

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="xing">
  <meta name="keywords" content="">
  
    <meta name="description" content="1.算法基础c++ &#x2F;java 1m大概可以进行10^9次运算 int 类型 -2^31~2^31-1   约&#x3D;10^9.33&#x3D;2*10^9 long long 类型 -2^63~2^63-1 约&#x3D;9.22×10^18&#x3D;10^19 1.位运算（不会改变原先的数）1.1按位与符号：	&amp;	  对应位都为一时得一  1.2按位或符号：    |">
<meta property="og:type" content="website">
<meta property="og:title" content="page.title">
<meta property="og:url" content="http://example.com/java%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E7%AE%97%E6%B3%95.html">
<meta property="og:site_name" content="xing的个人博客">
<meta property="og:description" content="1.算法基础c++ &#x2F;java 1m大概可以进行10^9次运算 int 类型 -2^31~2^31-1   约&#x3D;10^9.33&#x3D;2*10^9 long long 类型 -2^63~2^63-1 约&#x3D;9.22×10^18&#x3D;10^19 1.位运算（不会改变原先的数）1.1按位与符号：	&amp;	  对应位都为一时得一  1.2按位或符号：    |">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/%E7%AE%97%E6%B3%95.assets/image-20250318192505702.png">
<meta property="og:image" content="http://example.com/%E7%AE%97%E6%B3%95.assets/image-20250320194508711.png">
<meta property="og:image" content="http://example.com/%E7%AE%97%E6%B3%95.assets/image-20250409161439034.png">
<meta property="article:published_time" content="2025-05-24T07:50:11.100Z">
<meta property="article:modified_time" content="2025-05-24T07:50:11.100Z">
<meta property="article:author" content="xing">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/%E7%AE%97%E6%B3%95.assets/image-20250318192505702.png">
  
  
  
  <title>page.title - xing的个人博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />





<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="page.title"></span>
          
        </div>

        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      <div class="container nopadding-x-md">
        <div id="board"
          >
          
          <div class="container">
            <div class="row">
              <div class="col-12 col-md-10 m-auto">
                

<article class="page-content">
  <h1 id="1-算法基础"><a href="#1-算法基础" class="headerlink" title="1.算法基础"></a>1.算法基础</h1><p>c++ &#x2F;java 1m大概可以进行10^9次运算</p>
<p>int 类型 -2^31~2^31-1   约&#x3D;10^9.33&#x3D;2*10^9</p>
<p>long long 类型 -2^63~2^63-1 约&#x3D;9.22×10^18&#x3D;10^19</p>
<h2 id="1-位运算（不会改变原先的数）"><a href="#1-位运算（不会改变原先的数）" class="headerlink" title="1.位运算（不会改变原先的数）"></a>1.位运算（不会改变原先的数）</h2><h3 id="1-1按位与"><a href="#1-1按位与" class="headerlink" title="1.1按位与"></a>1.1按位与</h3><p>符号：	<code>&amp;</code>	</p>
<blockquote>
<p>对应位都为一时得一</p>
</blockquote>
<h3 id="1-2按位或"><a href="#1-2按位或" class="headerlink" title="1.2按位或"></a>1.2按位或</h3><p>符号：    <code>|</code></p>
<blockquote>
<p>对应位有一个为一得一</p>
</blockquote>
<h3 id="1-3按位异或"><a href="#1-3按位异或" class="headerlink" title="1.3按位异或"></a>1.3按位异或</h3><p>符号：   <code>^</code></p>
<blockquote>
<p>对应位不同时得一</p>
</blockquote>
<p>例：一组数中只有一个数只有一个，其余的数都有两个，找出这个数。</p>
<h3 id="1-4左移"><a href="#1-4左移" class="headerlink" title="1.4左移"></a>1.4左移</h3><p>符号：   <code>&lt;&lt;</code>  </p>
<blockquote>
<p>逻辑左移和算数左移无区别都是&lt;&lt;</p>
<p>左移一位相当于乘以二</p>
</blockquote>
<h3 id="1-5右移"><a href="#1-5右移" class="headerlink" title="1.5右移"></a>1.5右移</h3><p>符号：   <code>&gt;&gt;</code></p>
<blockquote>
<p>算数右移</p>
<p>右移一位相当于除以二</p>
<p>最左边的数补0或1，考虑符号位</p>
</blockquote>
<p>符号：<code>&gt;&gt;&gt;</code></p>
<blockquote>
<p>逻辑右移</p>
<p>不考虑符号位，统统补0</p>
</blockquote>
<h3 id="1-6注意点和应用实例"><a href="#1-6注意点和应用实例" class="headerlink" title="1.6注意点和应用实例"></a>1.6注意点和应用实例</h3><h4 id="1-6-1注意点"><a href="#1-6-1注意点" class="headerlink" title="1.6.1注意点"></a>1.6.1注意点</h4><p>在 C&#x2F;C++ 中，“a&gt;&gt; 1;” 和 “a &gt;&gt;&#x3D; 1;”</p>
<p>a^b;和a^b&#x3D;a;和a^b&#x3D;b,和a^b&#x3D;1 有以下区别：</p>
<p><strong>一、语法含义</strong></p>
<ol>
<li>a &gt;&gt; 1：<ul>
<li>这是一个表达式语句，它将变量 <code>a</code> 右移一位，但不会修改 <code>a</code> 的值。这个表达式的结果是 <code>a</code> 右移一位后的值，但这个结果通常不会被保存下来，除非它被赋值给另一个变量或者在其他表达式中使用。</li>
<li>例如：</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> b = a &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// b 为 4，a 仍然为 8</span><br></code></pre></td></tr></table></figure>



<ol start="2">
<li>a &gt;&gt;&#x3D; 1：</li>
</ol>
<ul>
<li>这是一个复合赋值语句，它将变量 <code>a</code> 右移一位，并将结果重新赋值给 <code>a</code>。也就是说，它会修改 <code>a</code> 的值。</li>
<li>例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">8</span>;<br>a &gt;&gt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// a 变为 4</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li>a^b：</li>
</ol>
<ul>
<li>这是一个表达式，计算 <code>a</code> 和 <code>b</code> 的按位异或结果。这个结果如果不被存储或使用，通常不会产生实际的影响。</li>
<li>例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> result = a ^ b;<br>std::cout &lt;&lt; result &lt;&lt; std::endl; <span class="hljs-comment">// 输出 6，5 的二进制为 101，3 的二进制为 011，按位异或结果为 110，即 6</span><br></code></pre></td></tr></table></figure>



<ol start="4">
<li>a^b &#x3D; a：</li>
</ol>
<ul>
<li>这是一个赋值语句，将 <code>a</code> 和 <code>b</code> 的按位异或结果重新赋值给 <code>a</code>。这会修改 <code>a</code> 的值，而 <code>b</code> 的值保持不变。</li>
<li>例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">3</span>;<br>a ^= b;<br>std::cout &lt;&lt; a &lt;&lt; std::endl; <span class="hljs-comment">// 输出 6，5 的二进制为 101，3 的二进制为 011，按位异或结果为 110，即 6</span><br></code></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><code>a^b</code>     <code>a&gt;&gt;1;</code> 只是计算按位异或结果&#x2F;右移 不修改任何变量的值。</li>
<li><code>a^b = a;</code>    <code>a&gt;&gt;=1</code>      修改 <code>a</code> 的值为 <code>a</code> 和 <code>b</code> 的按位异或结果&#x2F;a右移的结果。</li>
<li><code>a^b = b;</code> 和 <code>a^b = 1;</code> 都是错误的语法，会导致编译器报错。</li>
</ul>
<h4 id="1-6-2-应用实例"><a href="#1-6-2-应用实例" class="headerlink" title="1.6.2 应用实例"></a>1.6.2 应用实例</h4><p>位运算在算法中有很多高级应用，以下是一些例子：</p>
<p><strong>一、快速幂算法中的位运算应用</strong></p>
<ol>
<li>问题背景：<ul>
<li>快速幂算法用于高效地计算整数的幂次方，例如计算 ，其中 和 都是整数。传统的方法是通过多次乘法来计算幂次方，时间复杂度为 。快速幂算法可以将时间复杂度降低到 。</li>
</ul>
</li>
<li>位运算实现：<ul>
<li>快速幂算法利用了指数 的二进制表示。例如，如果 ，其二进制表示为 ，则 。</li>
<li>通过不断地将底数 平方，并根据指数 的二进制位决定是否将当前的结果累乘到最终结果中，可以高效地计算幂次方。</li>
<li>代码示例（C++）：</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fastPower</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (b &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) &#123;<br>            result *= a;<br>        &#125;<br>        a *= a;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>在这个例子中，使用位运算来检查指数 的最低位是否为 1，如果是，则将当前的底数累乘到结果中。然后将底数平方，并将指数右移一位，继续进行计算，直到指数为 0。</li>
</ul>
<p><strong>二、状态压缩动态规划中的位运算应用</strong></p>
<ol>
<li>问题背景：<ul>
<li>在某些动态规划问题中，状态可能非常多，使用传统的数组或矩阵来表示状态可能会导致内存占用过大。状态压缩动态规划利用位运算来表示状态，将状态压缩到一个整数中，从而节省内存空间。</li>
</ul>
</li>
<li>位运算实现：<ul>
<li>例如，在一个 的棋盘上放置若干个棋子，每个格子可以放置一个棋子或者为空。可以使用一个整数的各个位来表示棋盘上的状态，其中每一位对应一个格子，如果该位为 1 表示该格子上有棋子，否则表示为空。</li>
<li>通过位运算可以方便地进行状态转移和状态更新。例如，可以使用位运算来检查某个格子是否有棋子，或者将一个棋子放置到某个格子上。</li>
<li>代码示例（C++）</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">4</span>;<br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">1</span> &lt;&lt; N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countWays</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dp[state]!= <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> dp[state];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (state == (<span class="hljs-number">1</span> &lt;&lt; N) - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> dp[state] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> ways = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!(state &amp; (<span class="hljs-number">1</span> &lt;&lt; i))) &#123;<br>            ways += <span class="hljs-built_in">countWays</span>(state | (<span class="hljs-number">1</span> &lt;&lt; i));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[state] = ways;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>在这个例子中，使用状态压缩动态规划来计算在一个 的棋盘上放置棋子的不同方法数。状态用一个整数表示，每一位对应一个格子的状态。通过位运算来检查某个格子是否为空，并进行状态转移。</li>
</ul>
<p><strong>三、判断一个整数是否为 2 的幂次方</strong></p>
<ol>
<li><p>问题背景：</p>
<ul>
<li>给定一个整数，判断它是否为 2 的幂次方。例如，2、4、8、16 等都是 2 的幂次方，而 3、5、6、7 等不是。</li>
</ul>
</li>
<li><p>位运算实现</p>
<ul>
<li><p>如果一个整数是 2 的幂次方，那么它的二进制表示中只有一位是 1，其余位都是 0。可以利用这个性质，使用位运算来判断一个整数是否为 2 的幂次方。</p>
</li>
<li><p>代码示例（C++）：</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>在这个例子中，首先检查整数 是否大于 0，因为 0 不是 2 的幂次方。然后，使用位运算 <code>n &amp; (n - 1)</code> 来判断 的二进制表示中是否只有一位是 1。如果是，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<p><strong>四、计算两个整数的平均值（避免溢出）</strong></p>
<ol>
<li>问题背景：<ul>
<li>计算两个整数的平均值时，如果直接使用传统的算术平均公式 <code>(a + b) / 2</code>，可能会导致溢出，特别是当 和 都非常大时。</li>
</ul>
</li>
<li>位运算实现：<ul>
<li>可以使用位运算来避免溢出。计算两个整数的平均值可以通过先将两个数相加，然后右移一位来实现。</li>
<li>代码示例（C++）：</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">average</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (a &amp; b) + ((a ^ b) &gt;&gt; <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>在这个例子中，首先计算 <code>a</code> 和 <code>b</code> 的按位与 <code>a &amp; b</code>，这相当于计算了两个数的相同位部分。然后计算 <code>a</code> 和 <code>b</code> 的按位异或 <code>a ^ b</code>，并将其右移一位，这相当于计算了两个数的不同位部分的平均值。最后将两部分相加，得到两个数的平均值。</li>
</ul>
<h2 id="2-复杂度"><a href="#2-复杂度" class="headerlink" title="2.复杂度"></a>2.复杂度</h2><h1 id="2-基础模板"><a href="#2-基础模板" class="headerlink" title="2.基础模板"></a>2.基础模板</h1><h2 id="1-数组与链表"><a href="#1-数组与链表" class="headerlink" title="1.数组与链表"></a>1.数组与链表</h2><ul>
<li>学习内容：双指针（快慢指针、左右指针）、滑动窗口、前缀和、差分数组。</li>
<li>练习题：LeetCode 15（三数之和）、76（最小覆盖子串）、560（和为K的子数组）。</li>
</ul>
<blockquote>
<p>双指针-数组操作</p>
</blockquote>
<p>对撞双指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 对撞指针模板</span><br><span class="hljs-comment">// 示例问题：在有序数组中找到两个数，使它们的和等于目标值</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 左右指针分别指向数组的首尾</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> sum = nums[left] + nums[right];<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            <span class="hljs-keyword">return</span> &#123;left, right&#125;;  <span class="hljs-comment">// 找到满足条件的两个数，返回它们的下标</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>            left++;  <span class="hljs-comment">// 和小于目标值，左指针右移</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right--;  <span class="hljs-comment">// 和大于目标值，右指针左移</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;  <span class="hljs-comment">// 没有找到满足条件的两个数，返回空数组</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>滑动窗口（同向双指针）-维持一个满足条件的窗口常用于子串问题</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 滑动窗口模板</span><br><span class="hljs-comment">// 示例问题：在数组中找到满足特定条件的最短子数组</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">slidingWindow</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 左右指针，定义窗口边界</span><br>    <span class="hljs-type">int</span> ans = INT_MAX;  <span class="hljs-comment">// 存储结果，初始化为最大值</span><br>    <span class="hljs-comment">// 可根据具体问题添加额外的状态变量，例如窗口内元素的和、计数等</span><br>    <span class="hljs-type">int</span> windowSum = <span class="hljs-number">0</span>; <br><br>    <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>        <span class="hljs-comment">// 右指针右移，扩大窗口，并更新窗口状态</span><br>        windowSum += nums[right];<br><br>        <span class="hljs-comment">// 判断窗口是否满足条件，这里的条件可以根据具体问题修改</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-comment">/* 窗口满足条件 */</span> windowSum &gt;= target) &#123; <br>            <span class="hljs-comment">// 更新结果</span><br>            ans = std::<span class="hljs-built_in">min</span>(ans, right - left + <span class="hljs-number">1</span>); <br><br>            <span class="hljs-comment">// 左指针右移，缩小窗口，并更新窗口状态</span><br>            windowSum -= nums[left];<br>            left++;<br>        &#125;<br>        right++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans == INT_MAX ? <span class="hljs-number">0</span> : ans;<br>&#125;<br></code></pre></td></tr></table></figure>





<blockquote>
<p>前缀和与差分-对数组区间进行操作</p>
</blockquote>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250318192505702.png" srcset="/img/loading.gif" lazyload alt="image-20250318192505702"></p>
<blockquote>
<p>前缀和prefix：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">&gt;<span class="hljs-comment">// 计算前缀和数组</span><br>&gt;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prefixSum</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>   <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prefix</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 前缀和数组长度为 n+1，初始化为 0</span><br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>       prefix[i] = prefix[i - <span class="hljs-number">1</span>] + arr[i - <span class="hljs-number">1</span>];<br>   &#125;<br>   <span class="hljs-keyword">return</span> prefix;<br>&gt;&#125;<br><br>&gt;<span class="hljs-comment">// 计算区间 [left, right] 的和（闭区间，索引从 0 开始）</span><br>&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; prefix, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> prefix[right + <span class="hljs-number">1</span>] - prefix[left];<br>&gt;&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>注意数组区间：arr从1开始，求和区间【l,r】,对应prefix[r+1]-prefix[l]。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>差分diff:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++">&gt;<span class="hljs-comment">// 构建差分数组</span><br>&gt;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">buildDiff</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>   <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">diff</span><span class="hljs-params">(n)</span></span>;<br>   diff[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>       diff[i] = arr[i] - arr[i - <span class="hljs-number">1</span>];<br>   &#125;<br>   <span class="hljs-keyword">return</span> diff;<br>&gt;&#125;<br><br>&gt;<span class="hljs-comment">// 对区间 [left, right] 执行加 val 操作</span><br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateDiff</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; diff, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>   diff[left] += val;<br>   <span class="hljs-keyword">if</span> (right + <span class="hljs-number">1</span> &lt; diff.<span class="hljs-built_in">size</span>()) &#123;<br>       diff[right + <span class="hljs-number">1</span>] -= val;<br>   &#125;<br>&gt;&#125;<br><br>&gt;<span class="hljs-comment">// 根据差分数组还原原数组</span><br>&gt;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">restoreArray</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; diff)</span> </span>&#123;<br>   <span class="hljs-type">int</span> n = diff.<span class="hljs-built_in">size</span>();<br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(n)</span></span>;<br>   arr[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>];<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;=n; ++i) &#123;<br>       arr[i] = arr[i - <span class="hljs-number">1</span>] + diff[i<span class="hljs-number">-1</span>];<br>   &#125;<br>   <span class="hljs-keyword">return</span> arr;<br>&gt;&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>通常情况下对原数组进行差分，再对差分数组进行前缀和得到修改后的原数组，再对原数组进行前缀和</li>
</ul>
</blockquote>
<h2 id="2-栈与队列"><a href="#2-栈与队列" class="headerlink" title="2.栈与队列"></a>2.栈与队列</h2><ul>
<li>学习内容：单调栈、单调队列、优先队列（堆）。</li>
<li>练习题：LeetCode 84（柱状图最大矩形）、239（滑动窗口最大值）、215（数组中的第K大元素）。</li>
</ul>
<blockquote>
<p>单调栈联想：<img src="/%E7%AE%97%E6%B3%95.assets/image-20250320194508711.png" srcset="/img/loading.gif" lazyload alt="image-20250320194508711"></p>
<p>在一排高低不等的山中找到山与山的关系</p>
<p>排除无效元素，栈中存相邻元素上元素是第一个比下元素大&#x2F;小的元素</p>
</blockquote>
<h4 id="数据结构使用"><a href="#数据结构使用" class="headerlink" title="数据结构使用"></a>数据结构使用</h4><ul>
<li>栈（Stack）<ul>
<li>**C++**：使用 <code>std::stack</code>，操作方法有 <code>push</code>、<code>pop</code>、<code>top</code>、<code>empty</code> 等。</li>
<li><strong>Java</strong>：使用 <code>Stack</code> 类，操作方法有 <code>push</code>、<code>pop</code>、<code>peek</code>、<code>isEmpty</code> 等。</li>
</ul>
</li>
<li>队列（Queue）和双端队列（Deque）<ul>
<li>**C++**：使用 <code>std::queue</code> 和 <code>std::deque</code>，操作方法如 <code>push</code>、<code>pop</code>、<code>front</code>、<code>back</code> 等。</li>
<li><strong>Java</strong>：使用 <code>Queue</code> 接口的实现类（如 <code>LinkedList</code>）和 <code>Deque</code> 接口的实现类（如 <code>LinkedList</code>），操作方法有 <code>offer</code>、<code>poll</code>、<code>peek</code> 等。</li>
</ul>
</li>
<li>优先队列（堆）<ul>
<li>**C++**：使用 <code>std::priority_queue</code>，默认是大顶堆，可通过传入比较器实现小顶堆（如 <code>std::greater&lt;int&gt;</code>）。</li>
<li><strong>Java</strong>：使用 <code>PriorityQueue</code>，默认是小顶堆，可通过传入比较器实现大顶堆（如 <code>(a, b) -&gt; b - a</code>）。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-comment">// 单调栈模板</span><br><span class="hljs-comment">// 找出数组中每个元素右侧第一个比它大的元素的索引</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">monotonicStack</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>    std::stack&lt;<span class="hljs-type">int</span>&gt; st;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[st.<span class="hljs-built_in">top</span>()] &lt; nums[i]) &#123;<br>            result[st.<span class="hljs-built_in">top</span>()] = i;<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        st.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 单调队列模板</span><br><span class="hljs-comment">// 滑动窗口最大值</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">monotonicQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    std::deque&lt;<span class="hljs-type">int</span>&gt; dq;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-comment">// 移除不在窗口内的元素</span><br>        <span class="hljs-keyword">if</span> (!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; dq.<span class="hljs-built_in">front</span>() == i - k) &#123;<br>            dq.<span class="hljs-built_in">pop_front</span>();<br>        &#125;<br>        <span class="hljs-comment">// 保持队列单调递减</span><br>        <span class="hljs-keyword">while</span> (!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[dq.<span class="hljs-built_in">back</span>()] &lt; nums[i]) &#123;<br>            dq.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        dq.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-comment">// 当窗口形成后，记录最大值</span><br>        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(nums[dq.<span class="hljs-built_in">front</span>()]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 优先队列（堆）模板</span><br><span class="hljs-comment">// 找出数组中第 k 大的元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">priorityQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        pq.<span class="hljs-built_in">push</span>(num);<br>        <span class="hljs-keyword">if</span> (pq.<span class="hljs-built_in">size</span>() &gt; k) &#123;<br>            pq.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pq.<span class="hljs-built_in">top</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-comment">// 单调栈模板</span><br>    <span class="hljs-comment">// 找出数组中每个元素右侧第一个比它大的元素的索引</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] monotonicStack(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(result, -<span class="hljs-number">1</span>);<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i]) &#123;<br>                result[stack.pop()] = i;<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 单调队列模板</span><br>    <span class="hljs-comment">// 滑动窗口最大值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] monotonicQueue(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 移除不在窗口内的元素</span><br>            <span class="hljs-keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.peekFirst() == i - k) &#123;<br>                deque.pollFirst();<br>            &#125;<br>            <span class="hljs-comment">// 保持队列单调递减</span><br>            <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;<br>                deque.pollLast();<br>            &#125;<br>            deque.offerLast(i);<br>            <span class="hljs-comment">// 当窗口形成后，记录最大值</span><br>            <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) &#123;<br>                result[i - k + <span class="hljs-number">1</span>] = nums[deque.peekFirst()];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 优先队列（堆）模板</span><br>    <span class="hljs-comment">// 找出数组中第 k 大的元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">priorityQueue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            pq.offer(num);<br>            <span class="hljs-keyword">if</span> (pq.size() &gt; k) &#123;<br>                pq.poll();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pq.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>







<h1 id="3-递归与分治"><a href="#3-递归与分治" class="headerlink" title="3.递归与分治"></a>3.递归与分治</h1><h2 id="1-递归与分治"><a href="#1-递归与分治" class="headerlink" title="1.递归与分治"></a>1.递归与分治</h2><ul>
<li>学习内容：二分查找、归并排序、快速排序、汉诺塔问题。</li>
<li>练习题：LeetCode 50（Pow(x,n)）、169（多数元素）。</li>
</ul>
<blockquote>
<ul>
<li>二分查找(划分界限，红蓝区域思想)</li>
</ul>
<p><img src="/%E7%AE%97%E6%B3%95.assets/image-20250409161439034.png" srcset="/img/loading.gif" lazyload alt="image-20250409161439034"></p>
<blockquote>
<p>标准库中分别对应：</p>
<p>lower_bound()</p>
<p>lower_bound()-1</p>
<p>upper_bound()</p>
<p>upper_bound()-1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">&gt;<span class="hljs-comment">// 二分查找模板</span><br>&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>  <span class="hljs-type">int</span> left = <span class="hljs-number">-1</span>, right = nums.<span class="hljs-built_in">size</span>() ;<br>  <span class="hljs-keyword">while</span> (left+<span class="hljs-number">1</span>!=right) &#123;<br>      <span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<span class="hljs-comment">//int mid=(l+r)&gt;&gt;1;</span><br>      <span class="hljs-comment">//当r等于10^9 左右 溢出int时 开long long</span><br>      <span class="hljs-comment">//或者int mid = left + (right - left) // 2</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(nums[mid])) &#123;<br>          left = mid;<br>      &#125; <br>      <span class="hljs-keyword">else</span> right = mid;<br>  &#125;<br>   <span class="hljs-keyword">if</span>(符合的条件)<br>          <span class="hljs-keyword">return</span> l;<span class="hljs-comment">//return r</span><br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&gt;&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>mid = left + (right - left) // 2</code> 这一行代码避免了在计算中间索引时可能出现的溢出问题。</p>
</li>
<li><p>浮点数直接枚举100次二分，精度可以控制在1e-30以内</p>
</li>
</ul>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//while (left+1!=right)</span><br><span class="hljs-comment">//while(right-left&gt;1e-6) 自己控制j</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)<br></code></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>四舍五入保留小数操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> num = <span class="hljs-number">3.1415926</span>;<br>    <span class="hljs-comment">// 四舍五入保留 3 位小数</span><br>    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">3</span>) &lt;&lt; num &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> num = <span class="hljs-number">3.1415926</span>;<br>    <span class="hljs-comment">// 乘以 1000 以便对小数点后第 4 位进行四舍五入</span><br>    <span class="hljs-type">double</span> temp = num * <span class="hljs-number">1000</span>;<br>    <span class="hljs-comment">// 进行四舍五入</span><br>    <span class="hljs-type">int</span> rounded = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(temp + <span class="hljs-number">0.5</span>);<br>    <span class="hljs-comment">// 再除以 1000 得到保留 3 位小数的结果</span><br>    <span class="hljs-type">double</span> result = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(rounded) / <span class="hljs-number">1000</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;四舍五入保留 3 位小数后的结果: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="2-回溯算法"><a href="#2-回溯算法" class="headerlink" title="2.回溯算法"></a>2.回溯算法</h2><ul>
<li>学习内容：全排列、子集、组合、剪枝优化。</li>
<li>练习题：LeetCode 46（全排列）、78（子集）、39（组合总和）。</li>
</ul>
<h1 id="4-动态规划"><a href="#4-动态规划" class="headerlink" title="4.动态规划"></a>4.动态规划</h1><h2 id="1-线性DP"><a href="#1-线性DP" class="headerlink" title="1.线性DP"></a>1.线性DP</h2><ul>
<li>学习内容：斐波那契数列、最长递增子序列（LIS）、最长公共子序列（LCS）。</li>
<li>练习题：LeetCode 300（LIS）、1143（LCS）。</li>
</ul>
<h2 id="2-背包问题"><a href="#2-背包问题" class="headerlink" title="2.背包问题"></a>2.背包问题</h2><ul>
<li>学习内容：01背包、完全背包、多重背包。</li>
<li>练习题：蓝桥杯真题《砝码称重》、LeetCode 322（零钱兑换）。</li>
</ul>
<h2 id="3-区间DP与状态压缩"><a href="#3-区间DP与状态压缩" class="headerlink" title="3. 区间DP与状态压缩"></a>3. 区间DP与状态压缩</h2><ul>
<li>学习内容：矩阵链乘法、石子合并、状态压缩技巧（如TSP问题）。</li>
<li>练习题：LeetCode 312（戳气球）、蓝桥杯真题《能量项链》。</li>
</ul>
<h1 id="5-贪心与图论"><a href="#5-贪心与图论" class="headerlink" title="5.贪心与图论"></a>5.贪心与图论</h1><h2 id="1-贪心算法"><a href="#1-贪心算法" class="headerlink" title="1.贪心算法"></a>1.贪心算法</h2><ul>
<li>学习内容：区间调度、跳跃游戏、哈夫曼编码。</li>
<li>练习题：LeetCode 435（无重叠区间）、45（跳跃游戏II）。</li>
</ul>
<h2 id="2-图论"><a href="#2-图论" class="headerlink" title="2.图论"></a>2.图论</h2><ul>
<li>学习内容：DFS&#x2F;BFS遍历、最短路径（Dijkstra、Floyd）、最小生成树（Prim、Kruskal）。</li>
<li>练习题：LeetCode 743（网络延迟时间）、蓝桥杯真题《作物杂交》。</li>
</ul>
<blockquote>
<p>DFS（深度优先）-递归实现 -解决排列组合</p>
<ul>
<li>画递归搜索树</li>
<li>分别定义两个数组，一个数组用来存状态，一个数组用来存答案</li>
<li>递归调用自身函数以后恢复根结点状态。</li>
<li>定义结束返回条件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">&gt;~~~<br><br><br><br>&gt;DFS（深度优先） -利用栈实现<br><br></code></pre></td></tr></table></figure>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br><br><br><br><br><br><br>&gt;<span class="hljs-keyword">BFS（广度优先）- </span>利用队列实现<br><br></code></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><br><br><br><br><br><br><br><br><br><br><span class="hljs-section"># 6.高级数据结构</span><br><br><span class="hljs-section">## 1.并查集与字典树</span><br><br><span class="hljs-bullet">-</span> 学习内容：路径压缩、合并优化、Trie树实现。<br><span class="hljs-bullet">-</span> 练习题：LeetCode 547（省份数量）、208（实现Trie）。<br><br><br><br><span class="hljs-bullet">-</span> 字典序<br><br>&gt;字符串的字典序比较-<span class="hljs-code">`strcmp(str1,str2)`</span> str1&gt;str2 返回正数，等于返回0，小于返回负数<br><br></code></pre></td></tr></table></figure>
<p>abc&lt;abd  ASCII(d&gt;c)<br>adc&gt;abc  ASCII(d&gt;b)<br>123&gt;131<br>121&lt;123<br>213&gt;123<br>213&lt;223</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><br><br><br><span class="hljs-meta">## 2.线段树与树状数组</span><br><br>- 学习内容：区间查询、单点更新、差分思想。<br>- 练习题：LeetCode <span class="hljs-number">307</span>（区域和检索-数组可修改）。<br><br><br><br><span class="hljs-meta">## 3.字符串处理</span><br><br>- 学习内容：KMP算法、Manacher算法。<br>- 练习题：LeetCode <span class="hljs-number">28</span>（实现strStr()）、<span class="hljs-number">5</span>（最长回文子串）。<br><br><br><br><br><br><span class="hljs-meta"># 7.数学与模拟</span><br><br><span class="hljs-meta">## 1.数论与组合数学</span><br><br>- 学习内容：素数筛法、快速幂、排列组合公式。<br>- 练习题：蓝桥杯真题《等差数列》、LeetCode <span class="hljs-number">62</span>（不同路径）。<br><br><br><br><span class="hljs-meta">## 2.复杂模拟题</span><br><br>- 学习内容：大数运算、日期处理、状态机模型。<br>- 练习题：蓝桥杯真题《回文日期》、《成绩统计》。<br><br><br><br><br><br>**技巧工具**：预处理输入输出加速（C++的`ios::sync_with_stdio(<span class="hljs-literal">false</span>)`）、调试技巧。<br><br>- 求素数<br><br>~~~c++<br><span class="hljs-comment">//判断是否为素数 -只能被1和本身整除  1不是素数  </span><br>bool is_prim(<span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span>)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span>&lt;<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-keyword">sum</span>/i;i++)<span class="hljs-comment">//i&lt;=sqrt(sum)</span><br> &#123;<br> 	<span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span>%i==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <br></code></pre></td></tr></table></figure>
</blockquote>


  

</article>



              </div>
            </div>
          </div>
        </div>
      </div>
    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
