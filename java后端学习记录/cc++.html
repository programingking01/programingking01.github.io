

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="xing">
  <meta name="keywords" content="">
  
    <meta name="description" content="c&#x2F;c++数组1. C++ 中获取数组的长度在 C++ 里，获取数组长度的方法会因数组类型（普通数组、std::array、std::vector）而有所不同。 普通数组对于普通数组，可借助 sizeof 运算符来计算数组长度。sizeof 能返回数组所占的总字节数，用总字节数除以单个元素的字节数，就能得到数组的长度。 12345678#include &lt;iostream&gt;i">
<meta property="og:type" content="website">
<meta property="og:title" content="page.title">
<meta property="og:url" content="http://example.com/java%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/cc++.html">
<meta property="og:site_name" content="xing的个人博客">
<meta property="og:description" content="c&#x2F;c++数组1. C++ 中获取数组的长度在 C++ 里，获取数组长度的方法会因数组类型（普通数组、std::array、std::vector）而有所不同。 普通数组对于普通数组，可借助 sizeof 运算符来计算数组长度。sizeof 能返回数组所占的总字节数，用总字节数除以单个元素的字节数，就能得到数组的长度。 12345678#include &lt;iostream&gt;i">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-03-20T03:30:34.315Z">
<meta property="article:modified_time" content="2025-03-20T03:30:34.315Z">
<meta property="article:author" content="xing">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>page.title - xing的个人博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />





<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="page.title"></span>
          
        </div>

        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      <div class="container nopadding-x-md">
        <div id="board"
          >
          
          <div class="container">
            <div class="row">
              <div class="col-12 col-md-10 m-auto">
                

<article class="page-content">
  <h1 id="c-c"><a href="#c-c" class="headerlink" title="c&#x2F;c++"></a>c&#x2F;c++</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1-C-中获取数组的长度"><a href="#1-C-中获取数组的长度" class="headerlink" title="1. C++ 中获取数组的长度"></a>1. C++ 中获取数组的长度</h3><p>在 C++ 里，获取数组长度的方法会因数组类型（普通数组、<code>std::array</code>、<code>std::vector</code>）而有所不同。</p>
<h4 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h4><p>对于普通数组，可借助 <code>sizeof</code> 运算符来计算数组长度。<code>sizeof</code> 能返回数组所占的总字节数，用总字节数除以单个元素的字节数，就能得到数组的长度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> length = <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;数组长度: &quot;</span> &lt;&lt; length &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a><code>std::array</code></h4><p><code>std::array</code> 是 C++ 标准库提供的固定大小数组容器，它有 <code>size()</code> 成员函数可直接获取数组长度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::array&lt;<span class="hljs-type">int</span>, 5&gt; arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> length = arr.<span class="hljs-built_in">size</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;数组长度: &quot;</span> &lt;&lt; length &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="std-vector"><a href="#std-vector" class="headerlink" title="std::vector"></a><code>std::vector</code></h4><p><code>std::vector</code> 是动态数组容器，同样有 <code>size()</code> 成员函数来获取数组长度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> length = vec.<span class="hljs-built_in">size</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;数组长度: &quot;</span> &lt;&lt; length &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-C-数组和-Java-数组的区别"><a href="#2-C-数组和-Java-数组的区别" class="headerlink" title="2. C++ 数组和 Java 数组的区别"></a>2. C++ 数组和 Java 数组的区别</h3><h4 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h4><ul>
<li><p>C++</p>
<p>：</p>
<ul>
<li>普通数组声明时要指定大小，也能在声明时进行初始化。</li>
<li><code>std::array</code> 需指定大小和元素类型。</li>
<li><code>std::vector</code> 可动态调整大小，初始化方式多样。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 普通数组</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">// std::array</span><br>std::array&lt;<span class="hljs-type">int</span>, 5&gt; arr2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">// std::vector</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>Java</strong>：数组声明和初始化有多种方式，且数组大小可在运行时确定。- java中一切都是引用对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明并初始化数组</span><br><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">// 先声明，再分配空间</span><br><span class="hljs-type">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure>

<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><ul>
<li>**C++**：普通数组的内存分配在栈上，<code>std::vector</code> 和 <code>std::array</code> 的内存管理由标准库负责。若使用 <code>new</code> 动态分配数组，需用 <code>delete[]</code> 手动释放内存。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br><span class="hljs-comment">// 使用数组</span><br><span class="hljs-keyword">delete</span>[] arr; <span class="hljs-comment">// 手动释放内存</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>Java</strong>：数组内存分配在堆上，Java 的垃圾回收机制会自动管理内存，无需手动释放。</li>
</ul>
<h4 id="边界检查"><a href="#边界检查" class="headerlink" title="边界检查"></a>边界检查</h4><ul>
<li>**C++**：普通数组不会进行边界检查，访问越界可能导致未定义行为。<code>std::vector</code> 和 <code>std::array</code> 可使用 <code>at()</code> 方法进行边界检查，越界时会抛出 <code>std::out_of_range</code> 异常。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">try</span> &#123;<br>    std::cout &lt;&lt; vec.<span class="hljs-built_in">at</span>(<span class="hljs-number">5</span>) &lt;&lt; std::endl;<br>&#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::out_of_range&amp; e) &#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;越界访问: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>Java</strong>：数组会进行边界检查，访问越界会抛出 <code>ArrayIndexOutOfBoundsException</code> 异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">try</span> &#123;<br>    System.out.println(arr[<span class="hljs-number">5</span>]);<br>&#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;<br>    System.err.println(<span class="hljs-string">&quot;越界访问: &quot;</span> + e.getMessage());<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-C-字符串和-Java-字符串的区别"><a href="#3-C-字符串和-Java-字符串的区别" class="headerlink" title="3. C++ 字符串和 Java 字符串的区别"></a>3. C++ 字符串和 Java 字符串的区别</h3><h4 id="类型和表示"><a href="#类型和表示" class="headerlink" title="类型和表示"></a>类型和表示</h4><ul>
<li>**C++**：有 C 风格字符串（以 <code>&#39;\0&#39;</code> 结尾的字符数组）和 <code>std::string</code> 类。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C 风格字符串</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cstr = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-comment">// std::string</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br>std::string str = <span class="hljs-string">&quot;Hello&quot;</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>Java</strong>：字符串由 <code>String</code> 类表示，是不可变对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br></code></pre></td></tr></table></figure>

<h4 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h4><ul>
<li>**C++**：<code>std::string</code> 是可变的，可通过成员函数修改字符串内容。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string str = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    str += <span class="hljs-string">&quot; World&quot;</span>;<br>    std::cout &lt;&lt; str &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>Java</strong>：<code>String</code> 类是不可变的，若要修改字符串，可使用 <code>StringBuilder</code> 或 <code>StringBuffer</code> 类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>sb.append(<span class="hljs-string">&quot; World&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sb.toString();<br>System.out.println(str);<br></code></pre></td></tr></table></figure>

<h4 id="操作和方法"><a href="#操作和方法" class="headerlink" title="操作和方法"></a>操作和方法</h4><ul>
<li>**C++**：<code>std::string</code> 类提供了丰富的成员函数，如 <code>length()</code>、<code>substr()</code>、<code>find()</code> 等。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string str = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;字符串长度: &quot;</span> &lt;&lt; str.<span class="hljs-built_in">length</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>Java</strong>：<code>String</code> 类也有很多方法，如 <code>length()</code>、<code>substring()</code>、<code>indexOf()</code> 等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>System.out.println(<span class="hljs-string">&quot;字符串长度: &quot;</span> + str.length());<br></code></pre></td></tr></table></figure>



<h4 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h4><ul>
<li>**C++**：<code>std::string</code> 的内存管理由标准库负责，会自动处理内存分配和释放。</li>
<li><strong>Java</strong>：<code>String</code> 对象的内存由 Java 虚拟机的垃圾回收机制管理。</li>
</ul>
<h2 id="c-enum-枚举"><a href="#c-enum-枚举" class="headerlink" title="c enum(枚举)"></a>c enum(枚举)</h2><p>枚举是c语言的一种基本数据类型，用于定义一组具有离散值得常量，它可以让数据更简洁，更易读。枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性。</p>
<p>定义一个枚举类型，需要使用 <code>enum</code>关键字，后面跟着枚举类型的名称，以及用大括号 <strong>{}</strong> 括起来的一组枚举常量。每个枚举常量可以用一个标识符来表示，也可以为它们指定一个整数值，如果没有指定，那么默认从 <strong>0</strong> 开始递增。</p>
<p>枚举语法定义格式为：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">enum</span>　枚举名　&#123;枚举元素<span class="hljs-number">1</span>,枚举元素<span class="hljs-number">2</span>,……&#125;;<br></code></pre></td></tr></table></figure>

<p>接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MON 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TUe 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WED 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THU 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FRI 5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SAT 6</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SUN 7</span><br></code></pre></td></tr></table></figure>



<p>这个看起来代码量就比较多，接下来我们看看使用枚举的方式：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">enum DAY<br>&#123;<br>      <span class="hljs-attribute">MON</span>=1, TUE, WED, THU, FRI, SAT, SUN<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这样看起来是不是更简洁了。</p>
<p><strong>注意：</strong>第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。</p>
<h3 id="枚举变量的定义"><a href="#枚举变量的定义" class="headerlink" title="枚举变量的定义"></a>枚举变量的定义</h3><p>前面我们只是声明了枚举类型，接下来我们看看如何定义枚举变量。</p>
<p>我们可以通过以下三种方式来定义枚举变量</p>
<p><strong>1、先定义枚举类型，再定义枚举变量</strong></p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">enum <span class="hljs-built_in">DAY</span><br>&#123;<br>      MON=<span class="hljs-number">1</span>, TUE, WED, THU, FRI, SAT, SUN<br>&#125;;<br>enum <span class="hljs-built_in">DAY</span> <span class="hljs-built_in">day</span>;<br></code></pre></td></tr></table></figure>

<p><strong>2、定义枚举类型的同时定义枚举变量</strong></p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">enum <span class="hljs-built_in">DAY</span><br>&#123;<br>      MON=<span class="hljs-number">1</span>, TUE, WED, THU, FRI, SAT, SUN<br>&#125; <span class="hljs-built_in">day</span>;<br></code></pre></td></tr></table></figure>

<p><strong>3、省略枚举名称，直接定义枚举变量</strong></p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">enum</span><br>&#123;<br>      MON=<span class="hljs-number">1</span>, TUE, WED, THU, FRI, SAT, SUN<br>&#125; <span class="hljs-built_in">day</span>;<br></code></pre></td></tr></table></figure>



<p>一般直接用第三种</p>
<blockquote>
<p>在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 语言规范是没有办法遍历枚举类型的。</p>
<p>不过在一些特殊的情况下，枚举类型必须连续是可以实现有条件的遍历。</p>
</blockquote>
<p>以下实例使用 for 来遍历枚举的元素：</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>#include &lt;stdio.h&gt;  enum DAY {      MON&#x3D;1, TUE, WED, THU, FRI, SAT, SUN } day; int main() {    &#x2F;&#x2F; 遍历枚举元素    for (day &#x3D; MON; day &lt;&#x3D; SUN; day++) {        printf(“枚举元素：%d \n”, day);    } }</p>
<p>以上实例输出结果为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">枚举元素：1 <br>枚举元素：2 <br>枚举元素：3 <br>枚举元素：4 <br>枚举元素：5 <br>枚举元素：6 <br>枚举元素：7<br></code></pre></td></tr></table></figure>

<p>以下枚举类型不连续，这种枚举无法遍历。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">enum</span><br>&#123;<br>    ENUM_0,<br>    ENUM_10 = <span class="hljs-number">10</span>,<br>    ENUM_11<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>枚举在 switch 中的使用：</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">color</span> &#123; red=<span class="hljs-number">1</span>, green, blue &#125;;<br> <br>    <span class="hljs-keyword">enum</span>  <span class="hljs-title class_">color</span> favorite_color;<br> <br>    <span class="hljs-comment">/* 用户输入数字来选择颜色 */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入你喜欢的颜色: (1. red, 2. green, 3. blue): &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%u&quot;</span>, &amp;favorite_color);<br> <br>    <span class="hljs-comment">/* 输出结果 */</span><br>    <span class="hljs-keyword">switch</span> (favorite_color)<br>    &#123;<br>    <span class="hljs-keyword">case</span> red:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你喜欢的颜色是红色&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> green:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你喜欢的颜色是绿色&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> blue:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你喜欢的颜色是蓝色&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你没有选择你喜欢的颜色&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure>



<p>以上实例输出结果为：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs processing">请输入你喜欢的颜色: (<span class="hljs-number">1.</span> <span class="hljs-built_in">red</span>, <span class="hljs-number">2.</span> <span class="hljs-built_in">green</span>, <span class="hljs-number">3.</span> <span class="hljs-built_in">blue</span>): <span class="hljs-number">1</span><br>你喜欢的颜色是红色<br></code></pre></td></tr></table></figure>



<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>在 C 和 C++ 中，指针是一种非常强大但也相对复杂的概念。以下是对指针的详细解释：</p>
<h3 id="一、指针的概念"><a href="#一、指针的概念" class="headerlink" title="一、指针的概念"></a><strong>一、指针的概念</strong></h3><p>指针是一个变量，它存储的是另一个变量的内存地址。通过指针，可以间接访问和操作所指向的变量。</p>
<p>例如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> = <span class="hljs-number">10</span>; <br><span class="hljs-built_in">int</span> *ptr = &amp;<span class="hljs-built_in">num</span>;<br></code></pre></td></tr></table></figure>

<p>这里，<code>ptr</code>是一个指向<code>int</code>类型变量的指针，它存储了变量<code>num</code>的地址。</p>
<h3 id="二、指针的类型"><a href="#二、指针的类型" class="headerlink" title="二、指针的类型"></a><strong>二、指针的类型</strong></h3><p>指针的类型决定了它可以指向哪种类型的变量。例如，<code>int *</code>类型的指针只能指向<code>int</code>类型的变量，<code>char *</code>类型的指针只能指向<code>char</code>类型的变量等。</p>
<h3 id="三、指针的操作"><a href="#三、指针的操作" class="headerlink" title="三、指针的操作"></a><strong>三、指针的操作</strong></h3><ol>
<li>取地址（&amp;）运算符：用于获取变量的地址。例如，<code>&amp;num</code>返回变量<code>num</code>的地址。</li>
<li>解引用（*）运算符：用于访问指针所指向的变量。例如，<code>*ptr</code>表示访问指针<code>ptr</code>所指向的变量。</li>
<li>指针的赋值：可以将一个指针赋值给另一个同类型的指针。例如，<code>int *ptr2 = ptr;</code>。</li>
<li>指针的算术运算：可以对指针进行加法和减法运算。指针加上或减去一个整数，实际上是在内存中向前或向后移动相应数量的字节，具体移动的字节数取决于指针所指向的类型的大小。例如，如果<code>ptr</code>是一个指向<code>int</code>类型的指针，<code>ptr + 1</code>将指向内存中的下一个<code>int</code>类型的变量。</li>
</ol>
<h3 id="四、指针的作用"><a href="#四、指针的作用" class="headerlink" title="四、指针的作用"></a><strong>四、指针的作用</strong></h3><h4 id="4-1动态内存分配："><a href="#4-1动态内存分配：" class="headerlink" title="4.1动态内存分配："></a>4.1动态内存分配：</h4><p>通过指针，可以在程序运行时动态地分配内存。例如，使用<code>malloc</code>或<code>new</code>函数可以在堆上分配内存，并返回一个指向分配的内存的指针。</p>
<p>在 C 和 C++ 中，<code>malloc</code>和<code>new</code>确实可以在堆上分配内存并返回指向分配内存的指针。</p>
<h5 id="一、C-语言中的malloc"><a href="#一、C-语言中的malloc" class="headerlink" title="一、C 语言中的malloc"></a><strong>一、C 语言中的<code>malloc</code></strong></h5><ol>
<li><pre><code class="hljs">malloc
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>函数的原型是<br><br></code></pre></td></tr></table></figure>
void *malloc(size_t size)
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>，它接受一个参数，表示要分配的字节数，并返回一个指向分配的内存的指针，类型为<br><br></code></pre></td></tr></table></figure>
void *
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>   ，可以通过类型转换将其转换为任何所需的指针类型。<br><br>   - 例如：`<span class="hljs-type">int</span> *ptr = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));`，这里分配了足够存储一个整数的内存，并将指针转换为`<span class="hljs-type">int</span> *`类型。<br><br><span class="hljs-number">2.</span> 使用<br><br></code></pre></td></tr></table></figure>
malloc
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br>   分配的内存不会自动初始化。内存中的内容是未定义的，在使用之前可能需要进行初始化。<br><br><span class="hljs-bullet">   -</span> 例如：<span class="hljs-code">`*ptr = 10;`</span>，在使用指针之前，将整数 10 存储在分配的内存中。<br><br><span class="hljs-bullet">3.</span> 当不再需要使用由<br><br></code></pre></td></tr></table></figure>
malloc
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>分配的内存时，必须使用<br><br></code></pre></td></tr></table></figure>
free
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>   函数释放内存，以避免内存泄漏。<br><br>   - 例如：`free(ptr)<span class="hljs-comment">;`，释放之前分配的内存。</span><br><br><br><br>##### **二、C++ 中的`new`**<br><br><br><br><span class="hljs-number">1</span>. ```<br>   <span class="hljs-keyword">new</span><br></code></pre></td></tr></table></figure>

运算符有多种用法。可以使用

<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">new</span><br></code></pre></td></tr></table></figure>

来分配单个对象、数组或动态分配内存并调用构造函数进行初始化。

- 例如：`int *ptr = new int;`，分配一个整数的内存，并调用默认构造函数进行初始化（如果有）。也可以使用`new int(10);`来初始化分配的整数为 10。
- 对于数组：`int *arr = new int[5];`，分配一个包含 5 个整数的数组。
</code></pre>
</li>
<li><p>与</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">malloc</span><br></code></pre></td></tr></table></figure>

<p>不同，</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">new</span><br></code></pre></td></tr></table></figure>

<p>在分配内存时会根据对象的类型自动调用适当的构造函数进行初始化。如果对象有构造函数参数，可以在</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">new</span><br></code></pre></td></tr></table></figure>

<p>表达式中提供这些参数。</p>
<ul>
<li>例如：<code>class MyClass &#123; public: MyClass(int value) &#123; /*... */ &#125; &#125;; MyClass *obj = new MyClass(10);</code>，创建一个<code>MyClass</code>对象并初始化为值 10。</li>
</ul>
</li>
<li><p>当使用</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">new</span><br></code></pre></td></tr></table></figure>

<p>分配的对象不再需要时，应该使用</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">delete</span><br></code></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">delete</span>[]<br></code></pre></td></tr></table></figure>

<p>来释放内存，具体取决于分配的是单个对象还是数组。</p>
<ul>
<li>例如：<code>delete ptr;</code>释放单个对象的内存。<code>delete[] arr;</code>释放数组的内存</li>
</ul>
</li>
</ol>
<h4 id="4-2函数参数传递："><a href="#4-2函数参数传递：" class="headerlink" title="4.2函数参数传递："></a>4.2函数参数传递：</h4><p>指针可以作为函数的参数传递，这样可以在函数内部修改外部变量的值。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">(<span class="hljs-type">int</span> *num)</span> &#123;<br>    (*num)++;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br>    increment(&amp;n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, n); <span class="hljs-comment">// 输出 11</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="4-3数组和指针的关系："><a href="#4-3数组和指针的关系：" class="headerlink" title="4.3数组和指针的关系："></a>4.3数组和指针的关系：</h4><p>在 C 和 C++ 中，数组名实际上是一个指向数组第一个元素的指针。例如，对于数组<code>int arr[5]</code>，<code>arr</code>和<code>&amp;arr[0]</code>是等价的，都表示指向数组第一个元素的指针。可以使用指针来遍历数组。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> *ptr = arr;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *(ptr + i));<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="4-4数据结构："><a href="#4-4数据结构：" class="headerlink" title="4.4数据结构："></a>4.4数据结构：</h4><p>指针在实现各种数据结构（如链表、树、图等）中起着关键作用。通过指针，可以将不同的节点连接起来，构建复杂的数据结构。</p>
<h3 id="五、指针的注意事项"><a href="#五、指针的注意事项" class="headerlink" title="五、指针的注意事项"></a><strong>五、指针的注意事项</strong></h3><ol>
<li>空指针：指针可以被初始化为<code>NULL</code>（在 C++ 中是<code>nullptr</code>），表示它不指向任何有效的内存地址。在使用指针之前，应该检查它是否为<code>NULL</code>，以避免访问无效的内存地址。</li>
<li>内存泄漏：如果使用动态内存分配函数（如<code>malloc</code>或<code>new</code>）分配了内存，但在不再需要时没有释放，就会导致内存泄漏。应该在适当的时候使用<code>free</code>或<code>delete</code>函数释放动态分配的内存。</li>
<li>指针越界：访问指针所指向的内存范围之外的地址是危险的，可能会导致程序崩溃或产生不可预测的结果。在使用指针进行数组访问或其他操作时，要确保指针不越界。</li>
<li>指针的类型转换：在进行指针类型转换时要小心，确保转换是合法的并且不会导致错误的内存访问。</li>
</ol>
<p>指针是 C 和 C++ 中非常强大的工具，但也需要谨慎使用，以避免出现错误和安全问题。</p>
<h3 id="六-指针在-C-和-C-中有很多复杂的应用场景，以下是一些例子："><a href="#六-指针在-C-和-C-中有很多复杂的应用场景，以下是一些例子：" class="headerlink" title="六.指针在 C 和 C++ 中有很多复杂的应用场景，以下是一些例子："></a>六.指针在 C 和 C++ 中有很多复杂的应用场景，以下是一些例子：</h3><h4 id="一、指针与动态内存分配"><a href="#一、指针与动态内存分配" class="headerlink" title="一、指针与动态内存分配"></a><strong>一、指针与动态内存分配</strong></h4><ol>
<li><strong>动态数组</strong>：可以使用指针和动态内存分配来创建动态大小的数组。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Enter the size of the array: &quot;</span>;<br>std::cin &gt;&gt; n;<br><span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br><span class="hljs-comment">// 使用动态分配的数组</span><br><span class="hljs-keyword">delete</span>[] arr;<br></code></pre></td></tr></table></figure>



<ol start="2">
<li><strong>链表</strong>：链表是一种数据结构，其中每个节点包含一个值和一个指向下一个节点的指针。通过指针操作，可以方便地添加、删除和遍历链表节点。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    ListNode* next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">value</span>(val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(ListNode*&amp; head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    ListNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val);<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>        head = newNode;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ListNode* current = head;<br>        <span class="hljs-keyword">while</span> (current-&gt;next!= <span class="hljs-literal">nullptr</span>) &#123;<br>            current = current-&gt;next;<br>        &#125;<br>        current-&gt;next = newNode;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode* current = head;<br>    <span class="hljs-keyword">while</span> (current!= <span class="hljs-literal">nullptr</span>) &#123;<br>        std::cout &lt;&lt; current-&gt;value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        current = current-&gt;next;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ListNode* head = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-built_in">addNode</span>(head, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">addNode</span>(head, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">addNode</span>(head, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">printList</span>(head);<br>    <span class="hljs-comment">// 释放链表内存</span><br>    <span class="hljs-keyword">while</span> (head!= <span class="hljs-literal">nullptr</span>) &#123;<br>        ListNode* temp = head;<br>        head = head-&gt;next;<br>        <span class="hljs-keyword">delete</span> temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="二、指针与函数参数"><a href="#二、指针与函数参数" class="headerlink" title="二、指针与函数参数"></a><strong>二、指针与函数参数</strong></h4><ol>
<li><strong>传递指针以修改参数值</strong>：通过传递指针作为函数参数，可以在函数内部修改外部变量的值。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-type">int</span>* num)</span> </span>&#123;<br>    (*num)++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">increment</span>(&amp;value);<br>    std::cout &lt;&lt; value &lt;&lt; std::endl; <span class="hljs-comment">// 输出 11</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<ol start="2">
<li><strong>指针作为函数返回值</strong>：函数可以返回一个指针，指向动态分配的内存或某个特定的变量。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">createArray</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> </span>&#123;<br>    <span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>* myArray = <span class="hljs-built_in">createArray</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-comment">// 使用动态分配的数组</span><br>    <span class="hljs-keyword">delete</span>[] myArray;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li><p>在 C 和 C++ 中，<code>int *const a</code>、<code>const int *a</code>和<code>int const *a</code>这三种声明有不同的含义：</p>
<ol>
<li><pre><code class="hljs">int *const a
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><br>   ：<br><br>   - 这声明了一个指向整数的常量指针。<br>   - 意味着指针本身是常量，不能被重新赋值指向其他内存地址，但它所指向的整数可以被修改。<br>   - 例如：<br><br>```c++<br>     <span class="hljs-built_in">int</span> num1 = <span class="hljs-number">10</span>, num2 = <span class="hljs-number">20</span><span class="hljs-comment">;</span><br>     <span class="hljs-built_in">int</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">ptr</span> = &amp;num1<span class="hljs-comment">;</span><br>     // *<span class="hljs-built_in">ptr</span> = <span class="hljs-number">30</span><span class="hljs-comment">; // 可以修改所指向的整数的值</span><br>     // <span class="hljs-built_in">ptr</span> = &amp;num2<span class="hljs-comment">; // 错误，不能重新赋值指针</span><br></code></pre></td></tr></table></figure>

</code></pre>
</li>
<li><pre><code class="hljs">const int *a
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>和<br><br></code></pre></td></tr></table></figure>
int const *a
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><br>   ：这两种声明在语义上是完全相同的。<br><br>   - 这声明了一个指向常量整数的指针。<br>   - 意味着指针可以被重新赋值指向其他内存地址，但它所指向的整数不能被修改。<br>   - 例如：<br><br>```c++<br>     <span class="hljs-built_in">int</span> num1 = <span class="hljs-number">10</span>, num2 = <span class="hljs-number">20</span><span class="hljs-comment">;</span><br>     <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> *<span class="hljs-built_in">ptr</span> = &amp;num1<span class="hljs-comment">;</span><br>     // <span class="hljs-built_in">ptr</span> = &amp;num2<span class="hljs-comment">; // 可以重新赋值指针</span><br>     // *<span class="hljs-built_in">ptr</span> = <span class="hljs-number">30</span><span class="hljs-comment">; // 错误，不能修改所指向的整数的值</span><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
<h4 id="三、指针与多维数组"><a href="#三、指针与多维数组" class="headerlink" title="三、指针与多维数组"></a><strong>三、指针与多维数组</strong></h4><ol>
<li><strong>二维数组的指针表示</strong>：在 C 和 C++ 中，二维数组可以用指针的指针来表示。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>    &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;,<br>    &#123;<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;<br>&#125;;<br><span class="hljs-built_in">int</span>(*ptr)[<span class="hljs-number">4</span>] = arr;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++) &#123;<br>        std::cout &lt;&lt; (*ptr)[j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    ptr++;<br>    std::cout &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>



<ol start="2">
<li><strong>动态分配多维数组</strong>：可以使用指针和动态内存分配来创建动态大小的多维数组。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>** <span class="hljs-title">createDynamic2DArray</span><span class="hljs-params">(<span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols)</span> </span>&#123;<br>    <span class="hljs-type">int</span>** arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>*[rows];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[cols];<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteDynamic2DArray</span><span class="hljs-params">(<span class="hljs-type">int</span>** arr, <span class="hljs-type">int</span> rows)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        <span class="hljs-keyword">delete</span>[] arr[i];<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] arr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> rows = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> cols = <span class="hljs-number">4</span>;<br>    <span class="hljs-type">int</span>** myArray = <span class="hljs-built_in">createDynamic2DArray</span>(rows, cols);<br>    <span class="hljs-comment">// 使用动态分配的二维数组</span><br>    <span class="hljs-built_in">deleteDynamic2DArray</span>(myArray, rows);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="四、指针与字符串"><a href="#四、指针与字符串" class="headerlink" title="四、指针与字符串"></a><strong>四、指针与字符串</strong></h4><ol>
<li><strong>字符指针与字符串字面量</strong>：在 C 和 C++ 中，字符串字面量实际上是一个以空字符结尾的字符数组，并且可以用字符指针来指向它。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>std::cout &lt;&lt; str &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>



<ol start="2">
<li><strong>动态分配字符串</strong>：可以使用指针和动态内存分配来创建动态大小的字符串。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">readString</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Enter a string: &quot;</span>;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>    std::cin.<span class="hljs-built_in">getline</span>(buffer, <span class="hljs-number">100</span>);<br>    <span class="hljs-type">int</span> len = std::<span class="hljs-built_in">strlen</span>(buffer);<br>    <span class="hljs-type">char</span>* str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(str, buffer);<br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span>* myString = <span class="hljs-built_in">readString</span>();<br>    std::cout &lt;&lt; myString &lt;&lt; std::endl;<br>    <span class="hljs-keyword">delete</span>[] myString;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>指针的复杂应用需要谨慎处理，以避免内存泄漏、指针越界和其他错误。在使用指针时，要确保正确地管理内存，并遵循良好的编程实践。</p>
<h3 id="七-指针常见错误"><a href="#七-指针常见错误" class="headerlink" title="七.指针常见错误"></a>七.指针常见错误</h3><p>在 C 和 C++ 中使用指针时，容易出现以下一些常见错误：</p>
<h4 id="一、未初始化指针"><a href="#一、未初始化指针" class="headerlink" title="一、未初始化指针"></a><strong>一、未初始化指针</strong></h4><p>如果一个指针没有被初始化就被使用，它可能指向任意的内存地址，这会导致不可预测的行为甚至程序崩溃。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* ptr;<br>*ptr = <span class="hljs-number">10</span>; <span class="hljs-comment">// 错误，ptr 未初始化</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>未初始化的指针或者指向已经被释放内存的指针称为<code>野指针</code>，初始化指针赋值为空的指针为<code>空指针</code>，在 C 中，用 <code>NULL</code> 表示空指针，在 C++ 中，用 <code>nullptr</code> 表示空指针。</p>
</blockquote>
<h4 id="二、悬空指针"><a href="#二、悬空指针" class="headerlink" title="二、悬空指针"></a><strong>二、悬空指针</strong></h4><p>当一个指针所指向的内存被释放后，如果继续使用这个指针，就会产生悬空指针。这可能导致访问非法内存地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">delete</span>[] ptr;<br><span class="hljs-comment">// 以下代码可能导致错误，因为 ptr 成为悬空指针</span><br>std::cout &lt;&lt; *ptr;<br></code></pre></td></tr></table></figure>



<h4 id="三、内存泄漏"><a href="#三、内存泄漏" class="headerlink" title="三、内存泄漏"></a><strong>三、内存泄漏</strong></h4><p>如果动态分配了内存但没有在不再需要时释放，就会导致内存泄漏。随着程序的运行，可能会耗尽系统内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-comment">// 没有释放 ptr 所指向的内存</span><br></code></pre></td></tr></table></figure>



<h4 id="四、指针越界访问"><a href="#四、指针越界访问" class="headerlink" title="四、指针越界访问"></a><strong>四、指针越界访问</strong></h4><p>如果通过指针访问超出所指向的数组或内存范围的地址，可能会导致错误的结果或程序崩溃。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span>* ptr = arr;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123; <span class="hljs-comment">// 错误，i 可能超出数组范围</span><br>    std::cout &lt;&lt; ptr[i];<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="五、错误的指针类型转换"><a href="#五、错误的指针类型转换" class="headerlink" title="五、错误的指针类型转换"></a><strong>五、错误的指针类型转换</strong></h4><p>进行不恰当的指针类型转换可能导致错误的内存访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span>* ptr = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">double</span>*&gt;(&amp;num);<br><span class="hljs-comment">// 错误的类型转换，可能导致不可预测的结果</span><br>std::cout &lt;&lt; *ptr;<br></code></pre></td></tr></table></figure>



<h4 id="六、混淆指针和引用"><a href="#六、混淆指针和引用" class="headerlink" title="六、混淆指针和引用"></a><strong>六、混淆指针和引用</strong></h4><p>指针和引用在某些方面相似，但也有不同之处。混淆它们可能导致错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* ptr = &amp;num;<br><span class="hljs-type">int</span>&amp; ref = num;<br>*ptr = <span class="hljs-number">20</span>;<br>ref = <span class="hljs-number">30</span>;<br><span class="hljs-comment">// 可能错误地认为指针和引用完全相同的用法</span><br></code></pre></td></tr></table></figure>



<h4 id="七、忘记释放动态分配的内存（C-中使用new）"><a href="#七、忘记释放动态分配的内存（C-中使用new）" class="headerlink" title="七、忘记释放动态分配的内存（C++ 中使用new）"></a><strong>七、忘记释放动态分配的内存（C++ 中使用<code>new</code>）</strong></h4><p>在 C++ 中，如果使用<code>new</code>分配了内存，应该使用<code>delete</code>来释放。如果忘记释放，会导致内存泄漏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><span class="hljs-comment">// 没有释放 ptr 所指向的内存</span><br></code></pre></td></tr></table></figure>





<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="1-pair"><a href="#1-pair" class="headerlink" title="1.pair"></a><strong>1.pair</strong></h3><ul>
<li>在 C++ 中，<code>std::pair</code> 是一个模板类，它定义在 <code>&lt;utility&gt;</code> 头文件里，可将两个不同类型的值组合成一个单元。以下是关于 <code>std::pair</code> 的详细用法介绍：</li>
</ul>
<h4 id="1-定义和初始化"><a href="#1-定义和初始化" class="headerlink" title="1. 定义和初始化"></a>1. 定义和初始化</h4><ul>
<li><strong>默认初始化</strong>：创建一个 <code>pair</code> 对象，其成员会进行默认初始化。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; p1;  <span class="hljs-comment">// 默认初始化，p1.first 和 p1.second 是默认值</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p1: (&quot;</span> &lt;&lt; p1.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p1.second &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>使用构造函数初始化</strong>：可以使用构造函数为 <code>pair</code> 的两个成员赋值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>)</span></span>;  <span class="hljs-comment">// 使用构造函数初始化</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p2: (&quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p2.second &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>使用 <code>std::make_pair</code> 函数初始化</strong>：<code>std::make_pair</code> 是一个模板函数，能根据传入的参数自动推导 <code>pair</code> 的类型。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> p3 = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2.71</span>);  <span class="hljs-comment">// 使用 std::make_pair 初始化</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p3: (&quot;</span> &lt;&lt; p3.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p3.second &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-访问-pair-的成员"><a href="#2-访问-pair-的成员" class="headerlink" title="2. 访问 pair 的成员"></a>2. 访问 <code>pair</code> 的成员</h4><p><code>pair</code> 有两个公共成员 <code>first</code> 和 <code>second</code>，可通过它们来访问 <code>pair</code> 中的两个值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, std::string&gt; <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p4.first: &quot;</span> &lt;&lt; p4.first &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p4.second: &quot;</span> &lt;&lt; p4.second &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-修改-pair-的成员"><a href="#3-修改-pair-的成员" class="headerlink" title="3. 修改 pair 的成员"></a>3. 修改 <code>pair</code> 的成员</h4><p>可以直接对 <code>pair</code> 的 <code>first</code> 和 <code>second</code> 成员进行赋值操作来修改它们的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;a&#x27;</span>)</span></span>;<br>    p5.first = <span class="hljs-number">15</span>;<br>    p5.second = <span class="hljs-string">&#x27;b&#x27;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p5: (&quot;</span> &lt;&lt; p5.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p5.second &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-pair-的比较操作"><a href="#4-pair-的比较操作" class="headerlink" title="4. pair 的比较操作"></a>4. <code>pair</code> 的比较操作</h4><p><code>pair</code> 支持比较运算符（如 <code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code> 等），比较时先比较 <code>first</code> 成员，若相等再比较 <code>second</code> 成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p6</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p7</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p6 &lt; p7: &quot;</span> &lt;&lt; (p6 &lt; p7) &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 1（true）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-在容器中使用-pair"><a href="#5-在容器中使用-pair" class="headerlink" title="5. 在容器中使用 pair"></a>5. 在容器中使用 <code>pair</code></h4><p><code>pair</code> 常被用于容器中，例如 <code>std::map</code> 和 <code>std::unordered_map</code> 内部就使用 <code>pair</code> 来存储键值对。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, std::string&gt;&gt; vec;<br>    vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>));<br>    vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;two&quot;</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; p : vec) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; p.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="6-作为函数的返回值"><a href="#6-作为函数的返回值" class="headerlink" title="6. 作为函数的返回值"></a>6. 作为函数的返回值</h4><p><code>pair</code> 可以作为函数的返回值，这样函数就能同时返回两个不同类型的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">getValues</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">100</span>, <span class="hljs-number">3.14159</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">getValues</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Result: (&quot;</span> &lt;&lt; result.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; result.second &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>综上所述，<code>std::pair</code> 是一个非常实用的工具，能方便地将两个值组合在一起，在很多场景下都能发挥作用。</p>
<h3 id="2-vector-stack-map-queue"><a href="#2-vector-stack-map-queue" class="headerlink" title="2.vector\stack\map\queue"></a>2.vector\stack\map\queue</h3><h4 id="1-C-vector-与-Java-ArrayList"><a href="#1-C-vector-与-Java-ArrayList" class="headerlink" title="1. C++ vector 与 Java ArrayList"></a>1. C++ <code>vector</code> 与 Java <code>ArrayList</code></h4><ul>
<li><p><strong>功能</strong></p>
</li>
<li><p>**C++ <code>vector</code>**：是一个动态数组，支持随机访问，能在尾部高效地插入和删除元素。</p>
</li>
<li><p>**Java <code>ArrayList</code>**：同样是动态数组，支持随机访问，在尾部添加元素效率较高，但在中间插入或删除元素可能需要移动后续元素。</p>
</li>
<li><p><strong>方法和属性对比</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>功能</th>
<th>C++ <code>vector</code></th>
<th>Java <code>ArrayList</code></th>
</tr>
</thead>
<tbody><tr>
<td>初始化</td>
<td><code>std::vector&lt;int&gt; vec;</code></td>
<td><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code></td>
</tr>
<tr>
<td>添加元素</td>
<td><code>vec.push_back(1);</code></td>
<td><code>list.add(1);</code></td>
</tr>
<tr>
<td>访问元素</td>
<td><code>int val = vec[0];</code> 或 <code>int val = vec.at(0);</code></td>
<td><code>int val = list.get(0);</code></td>
</tr>
<tr>
<td>修改元素</td>
<td><code>vec[0] = 2;</code></td>
<td><code>list.set(0, 2);</code></td>
</tr>
<tr>
<td>获取大小</td>
<td><code>size_t size = vec.size();</code></td>
<td><code>int size = list.size();</code></td>
</tr>
<tr>
<td>检查是否为空</td>
<td><code>bool empty = vec.empty();</code></td>
<td><code>boolean empty = list.isEmpty();</code></td>
</tr>
<tr>
<td>删除元素</td>
<td><code>vec.pop_back();</code>（删除尾部元素） <code>vec.erase(vec.begin());</code>（删除指定位置元素）</td>
<td><code>list.remove(0);</code>（删除指定位置元素）</td>
</tr>
</tbody></table>
<h4 id="2-C-stack-与-Java-Stack"><a href="#2-C-stack-与-Java-Stack" class="headerlink" title="2. C++ stack 与 Java Stack"></a>2. C++ <code>stack</code> 与 Java <code>Stack</code></h4><ul>
<li><p>功能</p>
</li>
<li><p>**C++ <code>stack</code>**：是一种后进先出（LIFO）的数据结构，提供了基本的栈操作。</p>
</li>
<li><p>**Java <code>Stack</code>**：也是后进先出的数据结构，不过在 Java 中更推荐使用 <code>Deque</code> 接口的实现类（如 <code>ArrayDeque</code>）来模拟栈。</p>
</li>
<li><p>方法和属性对比</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>功能</th>
<th>C++ <code>stack</code></th>
<th>Java <code>Stack</code>（或 <code>ArrayDeque</code>）</th>
</tr>
</thead>
<tbody><tr>
<td>初始化</td>
<td><code>std::stack&lt;int&gt; st;</code></td>
<td><code>Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</code> 或 <code>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();</code></td>
</tr>
<tr>
<td>入栈</td>
<td><code>st.push(1);</code></td>
<td><code>stack.push(1);</code></td>
</tr>
<tr>
<td>出栈</td>
<td><code>st.pop();</code></td>
<td><code>stack.pop();</code></td>
</tr>
<tr>
<td>获取栈顶元素</td>
<td><code>int top = st.top();</code></td>
<td><code>int top = stack.peek();</code></td>
</tr>
<tr>
<td>检查是否为空</td>
<td><code>bool empty = st.empty();</code></td>
<td><code>boolean empty = stack.isEmpty();</code></td>
</tr>
<tr>
<td>获取栈的大小</td>
<td><code>size_t size = st.size();</code></td>
<td><code>int size = stack.size();</code></td>
</tr>
</tbody></table>
<h4 id="3-C-map-与-Java-TreeMap"><a href="#3-C-map-与-Java-TreeMap" class="headerlink" title="3. C++ map 与 Java TreeMap"></a>3. C++ <code>map</code> 与 Java <code>TreeMap</code></h4><ul>
<li><p>功能</p>
</li>
<li><p>**C++ <code>map</code>**：是基于红黑树实现的关联容器，存储键值对，键是唯一的，且元素会按照键的顺序自动排序。</p>
</li>
<li><p>**Java <code>TreeMap</code>**：同样基于红黑树实现，存储键值对，键唯一且按自然顺序或指定的比较器排序。</p>
</li>
<li><p>方法和属性对比</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>功能</th>
<th>C++ <code>map</code></th>
<th>Java <code>TreeMap</code></th>
</tr>
</thead>
<tbody><tr>
<td>初始化</td>
<td><code>std::map&lt;int, std::string&gt; myMap;</code></td>
<td><code>TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;();</code></td>
</tr>
<tr>
<td>插入元素</td>
<td><code>myMap[1] = &quot;one&quot;;</code> 或 <code>myMap.insert(&#123;1, &quot;one&quot;&#125;);</code></td>
<td><code>treeMap.put(1, &quot;one&quot;);</code></td>
</tr>
<tr>
<td>访问元素</td>
<td><code>std::string val = myMap[1];</code> 或 <code>auto it = myMap.find(1); if (it != myMap.end()) &#123; val = it-&gt;second; &#125;</code></td>
<td><code>String val = treeMap.get(1);</code></td>
</tr>
<tr>
<td>修改元素</td>
<td><code>myMap[1] = &quot;new one&quot;;</code></td>
<td><code>treeMap.put(1, &quot;new one&quot;);</code></td>
</tr>
<tr>
<td>删除元素</td>
<td><code>myMap.erase(1);</code></td>
<td><code>treeMap.remove(1);</code></td>
</tr>
<tr>
<td>检查键是否存在</td>
<td><code>auto it = myMap.find(1); bool exists = (it != myMap.end());</code></td>
<td><code>boolean exists = treeMap.containsKey(1);</code></td>
</tr>
<tr>
<td>获取大小</td>
<td><code>size_t size = myMap.size();</code></td>
<td><code>int size = treeMap.size();</code></td>
</tr>
</tbody></table>
<ul>
<li>遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//c++</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : myMap) &#123;<br>    std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java</span><br><span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : treeMap.entrySet()) &#123;<br>    System.out.println(entry.getKey() + <span class="hljs-string">&quot;: &quot;</span> + entry.getValue());<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="C-中的-queue-容器和-Java-中的-Queue-接口及其实现类"><a href="#C-中的-queue-容器和-Java-中的-Queue-接口及其实现类" class="headerlink" title="C++ 中的 queue 容器和 Java 中的 Queue 接口及其实现类"></a>C++ 中的 <code>queue</code> 容器和 Java 中的 <code>Queue</code> 接口及其实现类</h4><ul>
<li><p>功能</p>
</li>
<li><p>**C++ <code>queue</code>**：是一种先进先出（FIFO）的数据结构，它基于其他容器（默认是 <code>deque</code>）实现，提供了标准的队列操作。</p>
</li>
<li><p>**Java <code>Queue</code>**：是一个接口，<code>LinkedList</code> 是其常用的实现类，同样遵循先进先出原则，提供了队列的基本操作。</p>
</li>
<li><p>方法和属性对比</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>功能</th>
<th>C++ <code>queue</code></th>
<th>Java <code>Queue</code>（以 <code>LinkedList</code> 为例）</th>
</tr>
</thead>
<tbody><tr>
<td>初始化</td>
<td><code>std::queue&lt;int&gt; q;</code></td>
<td><code>Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</code></td>
</tr>
<tr>
<td>入队</td>
<td><code>q.push(1);</code></td>
<td><code>queue.add(1);</code> 或 <code>queue.offer(1);</code> <code>add()</code> 方法在队列满时会抛出异常，<code>offer()</code> 会返回 <code>false</code></td>
</tr>
<tr>
<td>出队</td>
<td><code>q.pop();</code></td>
<td><code>Integer removed = queue.remove();</code> 或 <code>Integer removed = queue.poll();</code> <code>remove()</code> 方法在队列为空时会抛出异常，<code>poll()</code> 会返回 <code>null</code></td>
</tr>
<tr>
<td>获取队首元素</td>
<td><code>int front = q.front();</code></td>
<td><code>Integer front = queue.element();</code> 或 <code>Integer front = queue.peek();</code> <code>element()</code> 方法在队列为空时会抛出异常，<code>peek()</code> 会返回 <code>null</code></td>
</tr>
<tr>
<td>检查是否为空</td>
<td><code>bool empty = q.empty();</code></td>
<td><code>boolean empty = queue.isEmpty();</code></td>
</tr>
<tr>
<td>获取队列大小</td>
<td><code>size_t size = q.size();</code></td>
<td><code>int size = queue.size();</code></td>
</tr>
</tbody></table>
<h3 id="map和unordered-map对比"><a href="#map和unordered-map对比" class="headerlink" title="map和unordered_map对比"></a>map和unordered_map对比</h3><p>在 C++ 中，<code>std::map</code> 和 <code>std::unordered_map</code> 都是常用的关联容器，但它们的实现和特性不同，因此适用场景也不同：</p>
<ol>
<li><p><strong><code>std::map</code></strong></p>
<ul>
<li><p><strong>实现</strong>：基于红黑树（一种平衡二叉搜索树），因此元素按键的 <strong>有序性</strong>（默认按升序）存储。</p>
</li>
<li><p>特性</p>
<p>：</p>
<ul>
<li>插入、删除、查找的时间复杂度为 (O(\log n))。</li>
<li>可以按键的顺序遍历元素（如使用迭代器从小到大访问）。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：需要元素有序、或需要范围查询（如查找某个区间内的所有键）时更适合。</p>
</li>
</ul>
</li>
<li><p><strong><code>std::unordered_map</code></strong></p>
<ul>
<li><p><strong>实现</strong>：基于哈希表，元素按键的哈希值存储，因此元素是 <strong>无序的</strong>。</p>
</li>
<li><p>特性</p>
<p>：</p>
<ul>
<li>插入、删除、查找的平均时间复杂度为 (O(1))（依赖哈希函数的质量和负载因子）。</li>
<li>不支持按键的顺序遍历。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：需要快速查找、插入和删除，且不关心元素顺序时更高效。</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>**<code>std::map</code>**：在需要有序性或范围操作时（如日志分析、统计排序后的结果）是首选。</li>
<li>**<code>std::unordered_map</code>**：在追求高性能的场景（如缓存、哈希表统计）中更常用，尤其是数据量较大时。</li>
</ul>
<h4 id="示例对比"><a href="#示例对比" class="headerlink" title="示例对比"></a>示例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用 std::map（有序）</span><br>    std::map&lt;<span class="hljs-type">int</span>, std::string&gt; orderedMap;<br>    orderedMap[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;apple&quot;</span>;<br>    orderedMap[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;banana&quot;</span>;<br>    orderedMap[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;orange&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;std::map (ordered): &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : orderedMap) &#123;<br>        std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 输出：1-&gt;banana 2-&gt;orange 3-&gt;apple</span><br><br>    <span class="hljs-comment">// 使用 std::unordered_map（无序）</span><br>    std::unordered_map&lt;<span class="hljs-type">int</span>, std::string&gt; unorderedMap;<br>    unorderedMap[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;apple&quot;</span>;<br>    unorderedMap[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;banana&quot;</span>;<br>    unorderedMap[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;orange&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\nstd::unordered_map (unordered): &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : unorderedMap) &#123;<br>        std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 输出顺序不固定，例如：3-&gt;apple 1-&gt;banana 2-&gt;orange</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>因此，两者是否 “常用” 取决于具体需求。如果需要有序性，<code>std::map</code> 更合适；如果追求速度且无需有序性，<code>std::unordered_map</code> 更优。</p>


  

</article>



              </div>
            </div>
          </div>
        </div>
      </div>
    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
