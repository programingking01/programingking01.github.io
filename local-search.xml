<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2025/07/02/%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><h3 id="1-力扣15-三数之和（数组：排序-双指针）"><a href="#1-力扣15-三数之和（数组：排序-双指针）" class="headerlink" title="1.力扣15.三数之和（数组：排序+双指针）"></a>1.力扣15.三数之和（数组：排序+双指针）</h3><p><img src="/.com//image-20250317153025675.png" alt="image-20250317153025675"></p><ul><li>思路：</li></ul><blockquote><p>根据题目分析，最终要得到三个数和为0的不重复集合，无关索引顺序，采用排序加双指针遍历</p><p><img src="/.com//image-20250317154933795.png" alt="image-20250317154933795"></p></blockquote><ul><li>代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>       <span class="hljs-comment">//排序**</span><br>       std::<span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>       vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>;k++)&#123;<br>        <span class="hljs-comment">//nums[k]大于0直接退出</span><br>        <span class="hljs-keyword">if</span>(nums[k]&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//nums[k]=nums[k-1]直接进入下次循环</span><br>        <span class="hljs-keyword">if</span>(k&gt;<span class="hljs-number">0</span>&amp;&amp;nums[k]==nums[k<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> i=k+<span class="hljs-number">1</span>,j=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br><span class="hljs-comment">//双指针内缩</span><br>        <span class="hljs-type">int</span> sum=nums[k]+nums[i]+nums[j];<br>        <span class="hljs-comment">//小于0,i++,同时排除相等的元素</span><br>        <span class="hljs-keyword">if</span>(sum&lt;<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">while</span>(i&lt;j&amp;&amp;nums[i]==nums[++i]);<br>        <span class="hljs-comment">//大于0;j--,同时排除相同的元素</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&gt;<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">while</span>(i&lt;j&amp;&amp;nums[j]==nums[--j]);<br>        <span class="hljs-comment">//等于0,加入集合,双指针内缩，并且排除相同的元素**</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            res.<span class="hljs-built_in">push_back</span>(&#123;nums[k],nums[i],nums[j]&#125;);<br>            <span class="hljs-keyword">while</span>(i&lt;j&amp;&amp;nums[i]==nums[++i]);<br>            <span class="hljs-keyword">while</span>(i&lt;j&amp;&amp;nums[j]==nums[--j]);<br>        &#125;<br>        &#125;  <br>       &#125;<br><span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 定义结果数组**</span><br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 排序</span><br>        Arrays.sort(nums);<br>        <span class="hljs-comment">// 定义k指针进入一层循环</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; nums.length - <span class="hljs-number">2</span>; k++) &#123;<br>            <span class="hljs-comment">// k指针特殊情况判定</span><br>            <span class="hljs-comment">// nums[k]&gt;0;break;</span><br>            <span class="hljs-keyword">if</span> (nums[k] &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 移动后和前面相等,continue进入下次循环</span><br>            <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; nums[k] == nums[k - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 定义i，j指针</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k + <span class="hljs-number">1</span>, j = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 进入双指针循环</span><br>            <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>                <span class="hljs-comment">// 判定数和是否为零</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[k] + nums[i] + nums[j];<br>                <span class="hljs-comment">// 大于0,双指针左缩</span><br>                <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[--j]);<br>                <span class="hljs-comment">// 小于0,双指针右缩</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[++i]);<br>                <span class="hljs-comment">// 等于0,加入集合,双指针内缩*</span><br>                <span class="hljs-keyword">else</span> &#123;<br>                    res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(nums[k], nums[i], nums[j])));<br>                    <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[--j]);<br>                    <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[++i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-力扣76-最小覆盖子串（滑动窗口-哈希表）"><a href="#2-力扣76-最小覆盖子串（滑动窗口-哈希表）" class="headerlink" title="2.力扣76.最小覆盖子串（滑动窗口+哈希表）"></a>2.力扣76.最小覆盖子串（滑动窗口+哈希表）</h3><p><img src="/.com//image-20250317162259737.png" alt="image-20250317162259737"></p><ul><li>思路</li></ul><blockquote><ul><li><p>统计字符需要出现次数：遍历t串并且，存入哈希表（need）键为字符，值为需要出现次数，同时使用一个变量needCount记录需要匹配的不同字符的数量</p></li><li><p>初始化窗口：使用两个指针 left 和 right 表示窗口的左右边界，初始时都指向字符串 s 的第一个字符。另外，使用一个哈希表 （window） 记录当前窗口中每个字符的出现频率。</p></li><li><p>扩大窗口：移动右指针 right，不断将新字符加入窗口，并更新 window 中该字符的频率。如果该字符在 need 中，并且 window 中该字符的频率等于 need 中该字符的频率，说明该字符已经匹配完成，将 valid 计数器加 1。</p></li><li><p>缩小窗口：当 valid 等于 needCount 时，说明当前窗口已经涵盖了 t 中的所有字符。此时，尝试移动左指针 left 缩小窗口，同时更新 window 中字符的频率。如果移除某个字符后，该字符在 window 中的频率小于 need 中该字符的频率，说明该字符不再匹配，将 valid 计数器减 1。</p></li><li><p>记录最小子串：在每次找到满足条件的窗口时，记录当前窗口的长度和起始位置，更新最小子串的长度和起始位置</p></li></ul></blockquote><ul><li>代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//c++</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-comment">//使用哈希表记录t串 ，并且初始化串匹配数</span><br>unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; need; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> a : t)&#123;<br>need[a]++;<br>&#125;<br><span class="hljs-type">int</span> needcount=need.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">//定义哈希表记录当前窗口字符串的出现次数，以及窗口指针 </span><br>unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; window;<br><span class="hljs-type">int</span> r=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> l=<span class="hljs-number">0</span>; <br><span class="hljs-comment">//定义有效匹配数</span><br><span class="hljs-type">int</span> vaild=<span class="hljs-number">0</span> ;<br><span class="hljs-comment">//定义子串的左右索引以及长度</span><br><span class="hljs-type">int</span> start=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> end=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> len=INT_MAX;  <br><span class="hljs-comment">//滑动窗口</span><br><span class="hljs-keyword">while</span>(r&lt;s.<span class="hljs-built_in">length</span>())&#123;<span class="hljs-comment">//右指针扩张 </span><br><span class="hljs-comment">//字符加入哈希表window并且值自增 </span><br><span class="hljs-type">char</span> c=s[r];<br>window[c]++;<br><span class="hljs-comment">//判断该字符是否存在于need，如果存在对比值，如果值相等，有效匹配数增加</span><br><span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(c)&amp;&amp;window[c]==need[c])&#123;<br>vaild++;<br>&#125;<br><span class="hljs-comment">//匹配数相等,记录子串详细 ，左指针收缩  </span><br><span class="hljs-keyword">while</span>(needcount==vaild)&#123;<br><span class="hljs-comment">//记录子串详细,len=0首次更新,长度比len小更新区间，以保证最小 </span><br><span class="hljs-keyword">if</span>(r-l&lt;len)&#123;<br>start=l;<br>    end=r;<br>    len=end-start;<br>&#125; <br><span class="hljs-comment">//左指针window值减1，并且判断need中是否存在，如果小于need中的值，则匹配数减1</span><br> <span class="hljs-type">char</span> d=s[l];<br> window[d]--;<br> <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(d)&amp;&amp;window[d]&lt;need[d])&#123;<br> vaild--;<br> &#125; <br> <span class="hljs-comment">//不存在则继续收缩 ,左指针移动 </span><br> l++;<br>&#125; <br><span class="hljs-comment">//右指针移动 </span><br>r++;<br>&#125; <br><span class="hljs-keyword">return</span> len==INT_MAX?<span class="hljs-string">&quot;&quot;</span>:s.<span class="hljs-built_in">substr</span>(start,end-start+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 向哈希表中添加字符并更新其出现次数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Mapstore</span><span class="hljs-params">(Map&lt;Character, Integer&gt; n, <span class="hljs-type">char</span> a)</span> &#123;<br>        n.put(a, n.getOrDefault(a, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 从哈希表中移除字符或更新其出现次数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Mapout</span><span class="hljs-params">(Map&lt;Character, Integer&gt; n, <span class="hljs-type">char</span> a)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> n.getOrDefault(a, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>) &#123;<br>            n.remove(a);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            n.put(a, count - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-comment">// 分别定义哈希表 need 记录 t 串字符出现的频率，minWindow 记录窗口中字符串出现的频率</span><br>        Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Character, Integer&gt; minWindow = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// need 遍历存储 t 串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> a : t.toCharArray()) &#123;<br>            Mapstore(need, a);<br>        &#125;<br>        <span class="hljs-comment">// 定义需要匹配次数，和现匹配次数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">needcount</span> <span class="hljs-operator">=</span> need.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 定义左右指针，子串索引，子串区间长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br><br>        <span class="hljs-comment">// 右窗口扩张</span><br>        <span class="hljs-keyword">while</span> (r &lt; s.length()) &#123;<br>            <span class="hljs-comment">// 加入窗口</span><br>            <span class="hljs-type">char</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> s.charAt(r);<br>            Mapstore(minWindow, a);<br>            <span class="hljs-comment">// 判断是否匹配，匹配成功 valid++</span><br>            <span class="hljs-keyword">if</span> (need.containsKey(a) &amp;&amp; need.get(a).equals(minWindow.get(a))) &#123;<br>                valid++;<br>            &#125;<br>            <span class="hljs-comment">// 左窗口收缩</span><br>            <span class="hljs-keyword">while</span> (needcount == valid) &#123;<br>                <span class="hljs-comment">// 更新窗口记录</span><br>                <span class="hljs-keyword">if</span> (len &gt; r - l + <span class="hljs-number">1</span>) &#123;<br>                    start = l;<br>                    len = r - l + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-comment">// 移出窗口</span><br>                <span class="hljs-type">char</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> s.charAt(l);<br>                Mapout(minWindow, b);<br>                <span class="hljs-comment">// 判断是否匹配，匹配失败 valid--</span><br>                <span class="hljs-keyword">if</span> (need.containsKey(b) <br>                    &amp;&amp; minWindow.getOrDefault(b, <span class="hljs-number">0</span>) &lt; need.get(b)) &#123;<br>                    valid--;<br>                &#125;<br>                l++;<br>            &#125;<br>            r++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len == Integer.MAX_VALUE ? <span class="hljs-string">&quot;&quot;</span> : s.substring(start, start + len);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>getOrDefault(键,默认值)</code> 方法是 <code>Map</code> 接口（包括 <code>HashMap</code>）的一个常用方法，其设计目的是为了简化 “获取键对应的值，若不存在则返回默认值” 的操作。</li></ul><h3 id="3-力扣560-和为k的子数组（前缀和）"><a href="#3-力扣560-和为k的子数组（前缀和）" class="headerlink" title="3.力扣560.和为k的子数组（前缀和）"></a>3.力扣560.和为k的子数组（前缀和）</h3><p><img src="/.com//image-20250318183653415.png" alt="image-20250318183653415"></p><ul><li>思路：</li></ul><blockquote><p>要知道子数组的和为k,可以利用前缀和求子数组的和，再通过双层for循环对比各个子数组的和是否为k</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//用前缀和求子数组的和</span><br>        <span class="hljs-comment">//设前缀和数组</span><br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prefix</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">//p1=0+a0,p2=p1+a1=a0+a1+0,   区间【l,r】=p[r+1]-p[l]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n+<span class="hljs-number">1</span>;++i) prefix[i]=prefix[i<span class="hljs-number">-1</span>]+nums[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-comment">//遍历子数组</span><br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>; r &lt; n; ++r) &#123;<br>            <span class="hljs-comment">// 内层循环遍历子数组的起始位置</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt;= r; ++l) &#123;<br>                <span class="hljs-comment">// 计算子数组 [l, r] 的和</span><br>                <span class="hljs-keyword">if</span> (prefix[r + <span class="hljs-number">1</span>] - prefix[l] == k) &#123;<br>                    count++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(List&lt;Integer&gt; nums,<span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-comment">//用前缀和求子数组的和</span><br>        <span class="hljs-comment">//设前缀和数组</span><br>        <span class="hljs-type">int</span> n=nums.size();<br>        List&lt;Integer&gt; prefix=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n+<span class="hljs-number">1</span>;++i) prefix[i]=prefix(i-<span class="hljs-number">1</span>)+nums[i-<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//遍历子数组</span><br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r=<span class="hljs-number">0</span>;r&lt;n;++r)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>;l&lt;=r;++l)&#123;<br>                <span class="hljs-keyword">if</span>(prefix[r+<span class="hljs-number">1</span>]-prefix[l]==k)count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-力扣84-柱状图最大的矩形（单调栈）"><a href="#4-力扣84-柱状图最大的矩形（单调栈）" class="headerlink" title="4.力扣84.柱状图最大的矩形（单调栈）"></a>4.力扣84.柱状图最大的矩形（单调栈）</h3><p><img src="/.com//image-20250319165230760.png" alt="image-20250319165230760"></p><ul><li>思考：</li></ul><blockquote><p>面积等于底乘高，暴力解法：遍历左右边界的所有情况，求最小高，同时底也就固定了为r-l+1，求最大面接</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//左右边界 ，从左往右扩散 </span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>      <span class="hljs-type">int</span> n=heights.<span class="hljs-built_in">size</span>() ;<br>      <span class="hljs-type">int</span> s=<span class="hljs-number">0</span>;<br>      <span class="hljs-comment">//左边界</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>;l&lt;n;l++)&#123;<br>  <span class="hljs-type">int</span> minh=INT_MAX;<br>  <span class="hljs-comment">//右边界</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r=l;r&lt;n;r++)&#123;<br>   <span class="hljs-comment">//求最小高</span><br>   minh=<span class="hljs-built_in">min</span>(minh,heights[r]); <br>   s=<span class="hljs-built_in">max</span>(s,minh*(r-l+<span class="hljs-number">1</span>));<br>  &#125; <br>  &#125; <br>  <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>存在超时问题；时间复杂度为O(n^2)</li></ul><blockquote><ul><li>优化</li></ul><p>使用栈和哨兵模式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 单调栈</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heights.size();<br>    <span class="hljs-comment">// 哨兵模式，在头部和尾部都添加 0  ***</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">v2</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)</span>;<br>    v2.insert(v2.begin() + <span class="hljs-number">1</span>, heights.begin(), heights.end());<br>    <span class="hljs-comment">// 栈</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化为 0</span><br>    <span class="hljs-comment">// 遍历数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">2</span>; i++) &#123;<br>        <span class="hljs-comment">// 栈内元素非空并且比栈顶元素小即出栈</span><br>        <span class="hljs-keyword">while</span> (!s.empty() &amp;&amp; v2[s.top()] &gt; v2[i]) &#123;<br>            <span class="hljs-comment">// 计算并且保留最大面积</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> v2[s.top()];<br>            s.pop();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> i - s.top() - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 修正宽度计算</span><br>            area = max(h * w, area);<br>        &#125;<br>        <span class="hljs-comment">// 比栈顶元素大，或者栈为空则入栈</span><br>        s.push(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> area;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-力扣456-132模式-单调栈"><a href="#5-力扣456-132模式-单调栈" class="headerlink" title="5.力扣456.132模式(单调栈)"></a>5.力扣456.132模式(单调栈)</h3><p><img src="/.com//image-20250320185338106.png" alt="image-20250320185338106"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find132pattern</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br> <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br> <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">3</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">// //暴力解法:i,j,k都枚举 </span><br><span class="hljs-comment">// for(int i=0;i&lt;n-2;i++)&#123;</span><br><span class="hljs-comment">// for(int j=i+1;j&lt;n-1;j++)&#123;</span><br><span class="hljs-comment">// for(int k=j+1;k&lt;n;k++)&#123;</span><br><span class="hljs-comment">// if(nums[i]&lt;nums[k]&amp;&amp;nums[k]&lt;nums[j])&#123;</span><br><span class="hljs-comment">// return true;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// &#125; </span><br><br><span class="hljs-comment">//优化解法：</span><br><span class="hljs-comment">//方法1：枚举j,记录左侧最小元素i，用有序容器 存放右侧所有元素，右侧查找比枚举元素大的元素k </span><br><span class="hljs-type">int</span> minleft=nums[<span class="hljs-number">0</span>];<br>multiset&lt;<span class="hljs-type">int</span>&gt; numsright;<span class="hljs-comment">//用有序集合记录右侧数据 </span><br><span class="hljs-comment">//加入右侧元素</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;i++)&#123;<br>numsright.<span class="hljs-built_in">insert</span>(nums[i]);<br>&#125; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-keyword">if</span>(nums[i]&gt;minleft)&#123;<br><span class="hljs-comment">//临时j确定，判断右侧是否有合法k***</span><br><span class="hljs-keyword">auto</span> it=numsright.<span class="hljs-built_in">upper_bound</span>(minleft);<span class="hljs-comment">//拿到第一个比左侧最小大的右侧元素 的迭代器</span><br><span class="hljs-keyword">if</span>(it!=numsright.<span class="hljs-built_in">end</span>()&amp;&amp;*it&lt;nums[i])<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125;<br><span class="hljs-comment">//对比枚举元素和最小左侧元素</span><br>minleft=<span class="hljs-built_in">min</span>(minleft,nums[i]);<br><span class="hljs-comment">//右侧元素缩小</span><br>numsright.<span class="hljs-built_in">erase</span>(numsright.<span class="hljs-built_in">find</span>(nums[i+<span class="hljs-number">1</span>])); <br>&#125;<br><br>    <br><span class="hljs-comment">//方法2：枚举i, 右向左遍历的单调栈，栈顶元素小于枚举元素出栈，元素i变成k,栈顶元素大于枚举元素入栈 确定j和i </span><br><span class="hljs-comment">//stack&lt;int&gt; s;</span><br><span class="hljs-comment">//int second=INT_MIN; </span><br><span class="hljs-comment">//for(int i=n-1;i&gt;=0;i--)&#123;</span><br><span class="hljs-comment">////出栈前，栈非空，把当前元素看作临时最大j </span><br><span class="hljs-comment">//while(!s.empty()&amp;&amp;nums[s.top()]&lt;nums[i])&#123;</span><br><span class="hljs-comment">////出栈 </span><br><span class="hljs-comment">////出栈元素设为临时最大k </span><br><span class="hljs-comment">//second=max(second,nums[s.top()]);</span><br><span class="hljs-comment">//s.pop();</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">////入栈，如果存在临时j说明i也成立 ,对比i和k如果i对应元素小于k ，返回true</span><br><span class="hljs-comment">//if(nums[i]&lt;second)&#123;</span><br><span class="hljs-comment">//return true;</span><br><span class="hljs-comment">//&#125; </span><br><span class="hljs-comment">//s.push(i);</span><br><span class="hljs-comment">//&#125;</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>    string str=<span class="hljs-built_in">find132pattern</span>(nums)?<span class="hljs-string">&quot;true&quot;</span>:<span class="hljs-string">&quot;false&quot;</span>;<br>    cout&lt;&lt;str&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-力扣239-滑动窗口最大值（单调队列）"><a href="#6-力扣239-滑动窗口最大值（单调队列）" class="headerlink" title="6.力扣239.滑动窗口最大值（单调队列）"></a>6.力扣239.滑动窗口最大值（单调队列）</h3><p><img src="/.com//image-20250320204743685.png" alt="image-20250320204743685"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//滑动窗口的最大值 </span><br><span class="hljs-comment">//暴力 -超时 </span><br><span class="hljs-comment">//vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="hljs-comment">//        int n=nums.size();</span><br><span class="hljs-comment">//        int l=0;</span><br><span class="hljs-comment">//        int r=k-1;</span><br><span class="hljs-comment">//        vector&lt;int&gt; m; </span><br><span class="hljs-comment">//       </span><br><span class="hljs-comment">//        while(r&lt;n)&#123;</span><br><span class="hljs-comment">//         int maxnum=INT_MIN;</span><br><span class="hljs-comment">//         //遍历窗口,得到最大值 </span><br><span class="hljs-comment">// for(int i=l;i&lt;k+l;i++)&#123;</span><br><span class="hljs-comment">// maxnum=max(maxnum,nums[i]);</span><br><span class="hljs-comment">// &#125; </span><br><span class="hljs-comment">// m.push_back(maxnum);</span><br><span class="hljs-comment">//        //窗口移动 </span><br><span class="hljs-comment">//        r++;</span><br><span class="hljs-comment">//l++; </span><br><span class="hljs-comment">//&#125; </span><br><span class="hljs-comment">//return m;</span><br><span class="hljs-comment">//    &#125;</span><br><br><span class="hljs-comment">//方法二： 使用先进先出的队列，1入队先入先出-2入队后入后出，如果2&gt;1,1为无用数据，直接出队 </span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; m; <br>       <span class="hljs-comment">//使用单调双端队列</span><br>   deque&lt;<span class="hljs-type">int</span>&gt; deque; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-comment">//移出不在窗口的元素</span><br>        <span class="hljs-keyword">if</span>(!deque.<span class="hljs-built_in">empty</span>()&amp;&amp;deque.<span class="hljs-built_in">front</span>()==i-k)&#123;<br>        deque.<span class="hljs-built_in">pop_front</span>();<br>&#125; <br><span class="hljs-comment">//保持队列单调 大的元素在队头，小的元素在队尾</span><br><span class="hljs-keyword">while</span>(!deque.<span class="hljs-built_in">empty</span>()&amp;&amp;nums[deque.<span class="hljs-built_in">back</span>()]&lt;nums[i])&#123;<br>deque.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br><span class="hljs-comment">//入队</span><br>deque.<span class="hljs-built_in">push_back</span>(i); <br><span class="hljs-comment">//当窗口形成以后每次都要记录最大元素即队头元素  </span><br><span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) m.<span class="hljs-built_in">push_back</span>(nums[deque.<span class="hljs-built_in">front</span>()]);<br>&#125;<br><span class="hljs-keyword">return</span> m;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="7-力扣215-数组中第k个最大元素（优先队列（堆）、快速排序查找）"><a href="#7-力扣215-数组中第k个最大元素（优先队列（堆）、快速排序查找）" class="headerlink" title="7.力扣215.数组中第k个最大元素（优先队列（堆）、快速排序查找）"></a>7.力扣215.数组中第k个最大元素（优先队列（堆）、快速排序查找）</h3><p><img src="/.com//image-20250320205019348.png" alt="image-20250320205019348"></p><h3 id="8-力扣42-接雨水（单调栈、双指针、动态规划）"><a href="#8-力扣42-接雨水（单调栈、双指针、动态规划）" class="headerlink" title="8.力扣42.接雨水（单调栈、双指针、动态规划）"></a>8.力扣42.接雨水（单调栈、双指针、动态规划）</h3><p><img src="/.com//image-20250329104324139.png" alt="image-20250329104324139"></p><ul><li>思路</li></ul><blockquote><p>局部分析：</p><p>区间内能接的雨水由左边最高和右边最高决定，左右最高较矮的一个乘区间长度-区间内的方块&#x3D;区间内能接的雨水</p><p>单调栈分析(横向填平)：</p><p>从低到高将栈顶元素填平</p><p>将栈顶元素用雨水填平，栈顶元素-1和枚举元素i中高度较小的来填平栈顶元素对应的横向面</p><p>双指针分析(单个元素)：</p><p>单个元素能接的雨水由左右最高元素决定，遍历过程分别记录左右最高元素，能接的雨水&#x3D;左右最高中较小的高度-自身高度</p><p>左右指针l,r分别在两侧往中间靠拢</p><p>当左边最大小于右边最大时计算左指针的雨水  rain+&#x3D;leftMax-height[l] 左指针右移</p><p>当右边最大小于左边最大时计算右指针的雨水  rain&#x3D;rightMax-height[r] 右指针左移 </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-comment">//接雨水 </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">////前缀和加单调栈 --暴力硬想无优化 </span><br><span class="hljs-comment">////想到求出每一个接水区间，求该区间的最大可容纳空间减去，该区间方块的空间，得到该区间的雨水空间 </span><br><span class="hljs-comment">//int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="hljs-comment">//    //求前缀和</span><br><span class="hljs-comment">//int n=height.size() ;</span><br><span class="hljs-comment">//vector&lt;int&gt;p(n+1,0);</span><br><span class="hljs-comment">//for(int i=1;i&lt;n+1;i++) p[i]=p[i-1]+height[i-1];</span><br><span class="hljs-comment">////正向单调栈求区间</span><br><span class="hljs-comment">//int l=INT_MIN; </span><br><span class="hljs-comment">//int r;</span><br><span class="hljs-comment">////雨水的值</span><br><span class="hljs-comment">//int rain=0; </span><br><span class="hljs-comment">//stack&lt;int&gt;s;</span><br><span class="hljs-comment">//for(int i=0;i&lt;n;i++)&#123;</span><br><span class="hljs-comment">////出栈</span><br><span class="hljs-comment">//while(!s.empty()&amp;&amp;height[s.top()]&lt;height[i])&#123;</span><br><span class="hljs-comment">////记录r,如果栈顶元素为最大l，进行计算雨水 </span><br><span class="hljs-comment">//r=i;</span><br><span class="hljs-comment">//int w=r-l-1;</span><br><span class="hljs-comment">//if(s.top()==l&amp;&amp;w&gt;0)&#123;</span><br><span class="hljs-comment">////区间值</span><br><span class="hljs-comment">//int sum=height[l]*w;</span><br><span class="hljs-comment">////前缀和</span><br><span class="hljs-comment">//int pre=p[r]-p[l+1]; </span><br><span class="hljs-comment">//rain+=(sum-pre);</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//s.pop();</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">////入栈记录最大l </span><br><span class="hljs-comment">// s.push(i);</span><br><span class="hljs-comment">//if(l==INT_MIN)&#123;</span><br><span class="hljs-comment">//l=i;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//else&#123;</span><br><span class="hljs-comment">//if(height[i]&gt;height[l])&#123;</span><br><span class="hljs-comment">//l=i;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//&#125; </span><br><span class="hljs-comment">//&#125; </span><br><span class="hljs-comment">////栈非空 ，出栈求空间 </span><br><span class="hljs-comment">//while(!s.empty())&#123;</span><br><span class="hljs-comment">////栈顶元素为r</span><br><span class="hljs-comment">//r=s.top();</span><br><span class="hljs-comment">////出栈 </span><br><span class="hljs-comment">//s.pop();</span><br><span class="hljs-comment">//if(s.empty()) break;</span><br><span class="hljs-comment">//// 栈顶元素为l</span><br><span class="hljs-comment">//l=s.top();</span><br><span class="hljs-comment">////计算</span><br><span class="hljs-comment">//int w=r-l-1;</span><br><span class="hljs-comment">//if(w&gt;0)&#123;</span><br><span class="hljs-comment">////区间值</span><br><span class="hljs-comment">//int sum=height[r]*w;</span><br><span class="hljs-comment">////前缀和</span><br><span class="hljs-comment">//int pre=p[r]-p[l+1]; </span><br><span class="hljs-comment">//rain+=(sum-pre);</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">////r=l </span><br><span class="hljs-comment">//r=l;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//        return rain;</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-comment">//时间复杂度O(N)  空间复杂度O(N) </span><br><br><br>  <br><span class="hljs-comment">//单调栈--每一次出栈进栈都传递有用信息 </span><br><span class="hljs-comment">//从低到高将栈顶元素横向用雨水填平 </span><br><span class="hljs-comment">//对于每个元素，当栈非空时，top元素可以容纳的雨水=top-1元素和i元素的其中较小者高度-top元素高度 * i到top-1元素间距</span><br><span class="hljs-comment">//int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="hljs-comment">//stack&lt;int&gt; s;</span><br><span class="hljs-comment">//int n=height.size();</span><br><span class="hljs-comment">//int rain=0;</span><br><span class="hljs-comment">//int h;</span><br><span class="hljs-comment">//int cur; </span><br><span class="hljs-comment">//for(int i=0;i&lt;n;i++)&#123;</span><br><span class="hljs-comment">//while(!s.empty()&amp;&amp;height[s.top()]&lt;height[i])&#123;</span><br><span class="hljs-comment">//cur=s.top();</span><br><span class="hljs-comment">////出栈 </span><br><span class="hljs-comment">//s.pop();</span><br><span class="hljs-comment">////出栈后栈内无元素则跳过</span><br><span class="hljs-comment">//if(s.empty())break;</span><br><span class="hljs-comment">////计算</span><br><span class="hljs-comment">//h=min(height[s.top()],height[i])-height[cur];</span><br><span class="hljs-comment">//rain+= h*(i-s.top()-1);</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//s.push(i);</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//    </span><br><span class="hljs-comment">//        return rain;</span><br><span class="hljs-comment">//    &#125;</span><br><br><span class="hljs-comment">//时间复杂度O(N)  空间复杂度O(N) </span><br><br><br><br><br><span class="hljs-comment">//双指针 </span><br><span class="hljs-comment">//维护左右两个指针往中间遍历l,r，条件(l&lt;r) </span><br><span class="hljs-comment">//分别记录左边最大和右边最大</span><br><span class="hljs-comment">//当左边最大小于右边最大时计算左指针的雨水  rain+=leftMax-height[l]  左指针右移</span><br><span class="hljs-comment">//当右边最大小于左边最大时计算右指针的雨水  rain=rightMax-height[r] 右指针左移</span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n=height.<span class="hljs-built_in">size</span>(); <br>    <span class="hljs-comment">//定义左右指针</span><br> <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>;<br> <span class="hljs-type">int</span> r=n<span class="hljs-number">-1</span>;<br> <span class="hljs-comment">//定义左右最大值</span><br> <span class="hljs-type">int</span> leftMax=INT_MIN;<br> <span class="hljs-type">int</span> rightMax=INT_MIN;<br> <span class="hljs-comment">//定义雨水量</span><br> <span class="hljs-type">int</span> rain=<span class="hljs-number">0</span>;<br> <span class="hljs-comment">//双指针遍历</span><br> <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>  leftMax=<span class="hljs-built_in">max</span>(leftMax,height[l]);<br>  rightMax=<span class="hljs-built_in">max</span>(rightMax,height[r]);<br> <span class="hljs-comment">//左最大小于右最大，计算左指针的雨水量，左指针右移， </span><br> <span class="hljs-keyword">if</span>(leftMax&lt;rightMax)&#123;<br> rain+=leftMax-height[l];<br> l++; <br> &#125; <br><span class="hljs-comment">//右最大小于左最大，计算右指针的雨水量，右指针左移， </span><br><span class="hljs-keyword">else</span>&#123;<br>rain+=rightMax-height[r];<br>r--;<br>&#125;<br> &#125;<br>        <span class="hljs-keyword">return</span> rain;<br>    &#125;<br>    <span class="hljs-comment">//时间复杂度O(N) 空间复杂度O(1) </span><br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;height=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span> s=<span class="hljs-built_in">trap</span>(height);<br>    cout&lt;&lt;s&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-蓝桥杯99-分巧克力（二分）"><a href="#9-蓝桥杯99-分巧克力（二分）" class="headerlink" title="9.蓝桥杯99.分巧克力（二分）"></a>9.蓝桥杯99.分巧克力（二分）</h3><p><img src="/.com//image-20250329131320469.png" alt="image-20250329131320469"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>; <br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> H[N]=&#123;<span class="hljs-number">0</span>&#125;; <br><span class="hljs-type">int</span> W[N]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">//判断边长为a时能否切出k份 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>sum+=(H[i]/a)*(W[i]/a);<br>&#125;<br><span class="hljs-keyword">if</span>(sum&gt;=k) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-comment">//输入</span><br>  cin&gt;&gt;n&gt;&gt;k;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>  cin&gt;&gt;H[i]&gt;&gt;W[i];<br>  &#125;<br>  <span class="hljs-comment">//分析</span><br>  <span class="hljs-comment">// 切边长为a的巧克力 可以切(H[i]/a)*(W[i]/a)  块 </span><br>  <span class="hljs-comment">// 边长范围[1,100000] </span><br>  <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> l=<span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> r=<span class="hljs-number">100000</span>;<br>  <span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br>  <span class="hljs-type">int</span> mid=l+(r-l)/<span class="hljs-number">2</span>;<br>  <span class="hljs-comment">//满足条件往右走,记录满足条件的边长 </span><br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))&#123;<br>  a=mid;<br>  l=mid+<span class="hljs-number">1</span>;<br>  &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//不，满足条件往左走 </span><br>  r=mid<span class="hljs-number">-1</span>; <br>  &#125; <br>  &#125;<br>  cout&lt;&lt;a;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/%E7%AE%97%E6%B3%95/"/>
    <url>/2025/07/02/%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-算法基础"><a href="#1-算法基础" class="headerlink" title="1.算法基础"></a>1.算法基础</h1><p>c++ &#x2F;java 1m大概可以进行10^9次运算</p><p>int 类型 -2^31~2^31-1   约&#x3D;10^9.33&#x3D;2*10^9</p><p>long long 类型 -2^63~2^63-1 约&#x3D;9.22×10^18&#x3D;10^19</p><h2 id="1-位运算（不会改变原先的数）"><a href="#1-位运算（不会改变原先的数）" class="headerlink" title="1.位运算（不会改变原先的数）"></a>1.位运算（不会改变原先的数）</h2><h3 id="1-1按位与"><a href="#1-1按位与" class="headerlink" title="1.1按位与"></a>1.1按位与</h3><p>符号：<code>&amp;</code></p><blockquote><p>对应位都为一时得一</p></blockquote><h3 id="1-2按位或"><a href="#1-2按位或" class="headerlink" title="1.2按位或"></a>1.2按位或</h3><p>符号：    <code>|</code></p><blockquote><p>对应位有一个为一得一</p></blockquote><h3 id="1-3按位异或"><a href="#1-3按位异或" class="headerlink" title="1.3按位异或"></a>1.3按位异或</h3><p>符号：   <code>^</code></p><blockquote><p>对应位不同时得一</p></blockquote><p>例：一组数中只有一个数只有一个，其余的数都有两个，找出这个数。</p><h3 id="1-4左移"><a href="#1-4左移" class="headerlink" title="1.4左移"></a>1.4左移</h3><p>符号：   <code>&lt;&lt;</code>  </p><blockquote><p>逻辑左移和算数左移无区别都是&lt;&lt;</p><p>左移一位相当于乘以二</p></blockquote><h3 id="1-5右移"><a href="#1-5右移" class="headerlink" title="1.5右移"></a>1.5右移</h3><p>符号：   <code>&gt;&gt;</code></p><blockquote><p>算数右移</p><p>右移一位相当于除以二</p><p>最左边的数补0或1，考虑符号位</p></blockquote><p>符号：<code>&gt;&gt;&gt;</code></p><blockquote><p>逻辑右移</p><p>不考虑符号位，统统补0</p></blockquote><h3 id="1-6注意点和应用实例"><a href="#1-6注意点和应用实例" class="headerlink" title="1.6注意点和应用实例"></a>1.6注意点和应用实例</h3><h4 id="1-6-1注意点"><a href="#1-6-1注意点" class="headerlink" title="1.6.1注意点"></a>1.6.1注意点</h4><p>在 C&#x2F;C++ 中，“a&gt;&gt; 1;” 和 “a &gt;&gt;&#x3D; 1;”</p><p>a^b;和a^b&#x3D;a;和a^b&#x3D;b,和a^b&#x3D;1 有以下区别：</p><p><strong>一、语法含义</strong></p><ol><li>a &gt;&gt; 1：<ul><li>这是一个表达式语句，它将变量 <code>a</code> 右移一位，但不会修改 <code>a</code> 的值。这个表达式的结果是 <code>a</code> 右移一位后的值，但这个结果通常不会被保存下来，除非它被赋值给另一个变量或者在其他表达式中使用。</li><li>例如：</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> b = a &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// b 为 4，a 仍然为 8</span><br></code></pre></td></tr></table></figure><ol start="2"><li>a &gt;&gt;&#x3D; 1：</li></ol><ul><li>这是一个复合赋值语句，它将变量 <code>a</code> 右移一位，并将结果重新赋值给 <code>a</code>。也就是说，它会修改 <code>a</code> 的值。</li><li>例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">8</span>;<br>a &gt;&gt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// a 变为 4</span><br></code></pre></td></tr></table></figure><ol start="3"><li>a^b：</li></ol><ul><li>这是一个表达式，计算 <code>a</code> 和 <code>b</code> 的按位异或结果。这个结果如果不被存储或使用，通常不会产生实际的影响。</li><li>例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> result = a ^ b;<br>std::cout &lt;&lt; result &lt;&lt; std::endl; <span class="hljs-comment">// 输出 6，5 的二进制为 101，3 的二进制为 011，按位异或结果为 110，即 6</span><br></code></pre></td></tr></table></figure><ol start="4"><li>a^b &#x3D; a：</li></ol><ul><li>这是一个赋值语句，将 <code>a</code> 和 <code>b</code> 的按位异或结果重新赋值给 <code>a</code>。这会修改 <code>a</code> 的值，而 <code>b</code> 的值保持不变。</li><li>例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">3</span>;<br>a ^= b;<br>std::cout &lt;&lt; a &lt;&lt; std::endl; <span class="hljs-comment">// 输出 6，5 的二进制为 101，3 的二进制为 011，按位异或结果为 110，即 6</span><br></code></pre></td></tr></table></figure><p>总结：</p><ul><li><code>a^b</code>     <code>a&gt;&gt;1;</code> 只是计算按位异或结果&#x2F;右移 不修改任何变量的值。</li><li><code>a^b = a;</code>    <code>a&gt;&gt;=1</code>      修改 <code>a</code> 的值为 <code>a</code> 和 <code>b</code> 的按位异或结果&#x2F;a右移的结果。</li><li><code>a^b = b;</code> 和 <code>a^b = 1;</code> 都是错误的语法，会导致编译器报错。</li></ul><h4 id="1-6-2-应用实例"><a href="#1-6-2-应用实例" class="headerlink" title="1.6.2 应用实例"></a>1.6.2 应用实例</h4><p>位运算在算法中有很多高级应用，以下是一些例子：</p><p><strong>一、快速幂算法中的位运算应用</strong></p><ol><li>问题背景：<ul><li>快速幂算法用于高效地计算整数的幂次方，例如计算 ，其中 和 都是整数。传统的方法是通过多次乘法来计算幂次方，时间复杂度为 。快速幂算法可以将时间复杂度降低到 。</li></ul></li><li>位运算实现：<ul><li>快速幂算法利用了指数 的二进制表示。例如，如果 ，其二进制表示为 ，则 。</li><li>通过不断地将底数 平方，并根据指数 的二进制位决定是否将当前的结果累乘到最终结果中，可以高效地计算幂次方。</li><li>代码示例（C++）：</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fastPower</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (b &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) &#123;<br>            result *= a;<br>        &#125;<br>        a *= a;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在这个例子中，使用位运算来检查指数 的最低位是否为 1，如果是，则将当前的底数累乘到结果中。然后将底数平方，并将指数右移一位，继续进行计算，直到指数为 0。</li></ul><p><strong>二、状态压缩动态规划中的位运算应用</strong></p><ol><li>问题背景：<ul><li>在某些动态规划问题中，状态可能非常多，使用传统的数组或矩阵来表示状态可能会导致内存占用过大。状态压缩动态规划利用位运算来表示状态，将状态压缩到一个整数中，从而节省内存空间。</li></ul></li><li>位运算实现：<ul><li>例如，在一个 的棋盘上放置若干个棋子，每个格子可以放置一个棋子或者为空。可以使用一个整数的各个位来表示棋盘上的状态，其中每一位对应一个格子，如果该位为 1 表示该格子上有棋子，否则表示为空。</li><li>通过位运算可以方便地进行状态转移和状态更新。例如，可以使用位运算来检查某个格子是否有棋子，或者将一个棋子放置到某个格子上。</li><li>代码示例（C++）</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">4</span>;<br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">1</span> &lt;&lt; N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countWays</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dp[state]!= <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> dp[state];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (state == (<span class="hljs-number">1</span> &lt;&lt; N) - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> dp[state] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> ways = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!(state &amp; (<span class="hljs-number">1</span> &lt;&lt; i))) &#123;<br>            ways += <span class="hljs-built_in">countWays</span>(state | (<span class="hljs-number">1</span> &lt;&lt; i));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[state] = ways;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在这个例子中，使用状态压缩动态规划来计算在一个 的棋盘上放置棋子的不同方法数。状态用一个整数表示，每一位对应一个格子的状态。通过位运算来检查某个格子是否为空，并进行状态转移。</li></ul><p><strong>三、判断一个整数是否为 2 的幂次方</strong></p><ol><li><p>问题背景：</p><ul><li>给定一个整数，判断它是否为 2 的幂次方。例如，2、4、8、16 等都是 2 的幂次方，而 3、5、6、7 等不是。</li></ul></li><li><p>位运算实现</p><ul><li><p>如果一个整数是 2 的幂次方，那么它的二进制表示中只有一位是 1，其余位都是 0。可以利用这个性质，使用位运算来判断一个整数是否为 2 的幂次方。</p></li><li><p>代码示例（C++）：</p></li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在这个例子中，首先检查整数 是否大于 0，因为 0 不是 2 的幂次方。然后，使用位运算 <code>n &amp; (n - 1)</code> 来判断 的二进制表示中是否只有一位是 1。如果是，则返回 <code>true</code>，否则返回 <code>false</code>。</li></ul><p><strong>四、计算两个整数的平均值（避免溢出）</strong></p><ol><li>问题背景：<ul><li>计算两个整数的平均值时，如果直接使用传统的算术平均公式 <code>(a + b) / 2</code>，可能会导致溢出，特别是当 和 都非常大时。</li></ul></li><li>位运算实现：<ul><li>可以使用位运算来避免溢出。计算两个整数的平均值可以通过先将两个数相加，然后右移一位来实现。</li><li>代码示例（C++）：</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">average</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (a &amp; b) + ((a ^ b) &gt;&gt; <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在这个例子中，首先计算 <code>a</code> 和 <code>b</code> 的按位与 <code>a &amp; b</code>，这相当于计算了两个数的相同位部分。然后计算 <code>a</code> 和 <code>b</code> 的按位异或 <code>a ^ b</code>，并将其右移一位，这相当于计算了两个数的不同位部分的平均值。最后将两部分相加，得到两个数的平均值。</li></ul><h2 id="2-复杂度"><a href="#2-复杂度" class="headerlink" title="2.复杂度"></a>2.复杂度</h2><h1 id="2-基础模板"><a href="#2-基础模板" class="headerlink" title="2.基础模板"></a>2.基础模板</h1><h2 id="1-数组与链表"><a href="#1-数组与链表" class="headerlink" title="1.数组与链表"></a>1.数组与链表</h2><ul><li>学习内容：双指针（快慢指针、左右指针）、滑动窗口、前缀和、差分数组。</li><li>练习题：LeetCode 15（三数之和）、76（最小覆盖子串）、560（和为K的子数组）。</li></ul><blockquote><p>双指针-数组操作</p></blockquote><p>对撞双指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 对撞指针模板</span><br><span class="hljs-comment">// 示例问题：在有序数组中找到两个数，使它们的和等于目标值</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 左右指针分别指向数组的首尾</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> sum = nums[left] + nums[right];<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            <span class="hljs-keyword">return</span> &#123;left, right&#125;;  <span class="hljs-comment">// 找到满足条件的两个数，返回它们的下标</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>            left++;  <span class="hljs-comment">// 和小于目标值，左指针右移</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right--;  <span class="hljs-comment">// 和大于目标值，右指针左移</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;  <span class="hljs-comment">// 没有找到满足条件的两个数，返回空数组</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>滑动窗口（同向双指针）-维持一个满足条件的窗口常用于子串问题</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 滑动窗口模板</span><br><span class="hljs-comment">// 示例问题：在数组中找到满足特定条件的最短子数组</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">slidingWindow</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 左右指针，定义窗口边界</span><br>    <span class="hljs-type">int</span> ans = INT_MAX;  <span class="hljs-comment">// 存储结果，初始化为最大值</span><br>    <span class="hljs-comment">// 可根据具体问题添加额外的状态变量，例如窗口内元素的和、计数等</span><br>    <span class="hljs-type">int</span> windowSum = <span class="hljs-number">0</span>; <br><br>    <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>        <span class="hljs-comment">// 右指针右移，扩大窗口，并更新窗口状态</span><br>        windowSum += nums[right];<br><br>        <span class="hljs-comment">// 判断窗口是否满足条件，这里的条件可以根据具体问题修改</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-comment">/* 窗口满足条件 */</span> windowSum &gt;= target) &#123; <br>            <span class="hljs-comment">// 更新结果</span><br>            ans = std::<span class="hljs-built_in">min</span>(ans, right - left + <span class="hljs-number">1</span>); <br><br>            <span class="hljs-comment">// 左指针右移，缩小窗口，并更新窗口状态</span><br>            windowSum -= nums[left];<br>            left++;<br>        &#125;<br>        right++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans == INT_MAX ? <span class="hljs-number">0</span> : ans;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>前缀和与差分-对数组区间进行操作</p></blockquote><p><img src="/.com//image-20250318192505702.png" alt="image-20250318192505702"></p><blockquote><p>前缀和prefix：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">&gt;<span class="hljs-comment">// 计算前缀和数组</span><br>&gt;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prefixSum</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>   <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prefix</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 前缀和数组长度为 n+1，初始化为 0</span><br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>       prefix[i] = prefix[i - <span class="hljs-number">1</span>] + arr[i - <span class="hljs-number">1</span>];<br>   &#125;<br>   <span class="hljs-keyword">return</span> prefix;<br>&gt;&#125;<br><br>&gt;<span class="hljs-comment">// 计算区间 [left, right] 的和（闭区间，索引从 0 开始）</span><br>&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; prefix, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> prefix[right + <span class="hljs-number">1</span>] - prefix[left];<br>&gt;&#125;<br></code></pre></td></tr></table></figure><ul><li>注意数组区间：arr从1开始，求和区间【l,r】,对应prefix[r+1]-prefix[l]。</li></ul></blockquote><blockquote><ul><li>差分diff:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++">&gt;<span class="hljs-comment">// 构建差分数组</span><br>&gt;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">buildDiff</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>   <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">diff</span><span class="hljs-params">(n)</span></span>;<br>   diff[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>       diff[i] = arr[i] - arr[i - <span class="hljs-number">1</span>];<br>   &#125;<br>   <span class="hljs-keyword">return</span> diff;<br>&gt;&#125;<br><br>&gt;<span class="hljs-comment">// 对区间 [left, right] 执行加 val 操作</span><br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateDiff</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; diff, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>   diff[left] += val;<br>   <span class="hljs-keyword">if</span> (right + <span class="hljs-number">1</span> &lt; diff.<span class="hljs-built_in">size</span>()) &#123;<br>       diff[right + <span class="hljs-number">1</span>] -= val;<br>   &#125;<br>&gt;&#125;<br><br>&gt;<span class="hljs-comment">// 根据差分数组还原原数组</span><br>&gt;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">restoreArray</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; diff)</span> </span>&#123;<br>   <span class="hljs-type">int</span> n = diff.<span class="hljs-built_in">size</span>();<br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(n)</span></span>;<br>   arr[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>];<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;=n; ++i) &#123;<br>       arr[i] = arr[i - <span class="hljs-number">1</span>] + diff[i<span class="hljs-number">-1</span>];<br>   &#125;<br>   <span class="hljs-keyword">return</span> arr;<br>&gt;&#125;<br></code></pre></td></tr></table></figure><ul><li>通常情况下对原数组进行差分，再对差分数组进行前缀和得到修改后的原数组，再对原数组进行前缀和</li></ul></blockquote><h2 id="2-栈与队列"><a href="#2-栈与队列" class="headerlink" title="2.栈与队列"></a>2.栈与队列</h2><ul><li>学习内容：单调栈、单调队列、优先队列（堆）。</li><li>练习题：LeetCode 84（柱状图最大矩形）、239（滑动窗口最大值）、215（数组中的第K大元素）。</li></ul><blockquote><p>单调栈联想：<img src="/.com//image-20250320194508711.png" alt="image-20250320194508711"></p><p>在一排高低不等的山中找到山与山的关系</p><p>排除无效元素，栈中存相邻元素上元素是第一个比下元素大&#x2F;小的元素</p></blockquote><h4 id="数据结构使用"><a href="#数据结构使用" class="headerlink" title="数据结构使用"></a>数据结构使用</h4><ul><li>栈（Stack）<ul><li>**C++**：使用 <code>std::stack</code>，操作方法有 <code>push</code>、<code>pop</code>、<code>top</code>、<code>empty</code> 等。</li><li><strong>Java</strong>：使用 <code>Stack</code> 类，操作方法有 <code>push</code>、<code>pop</code>、<code>peek</code>、<code>isEmpty</code> 等。</li></ul></li><li>队列（Queue）和双端队列（Deque）<ul><li>**C++**：使用 <code>std::queue</code> 和 <code>std::deque</code>，操作方法如 <code>push</code>、<code>pop</code>、<code>front</code>、<code>back</code> 等。</li><li><strong>Java</strong>：使用 <code>Queue</code> 接口的实现类（如 <code>LinkedList</code>）和 <code>Deque</code> 接口的实现类（如 <code>LinkedList</code>），操作方法有 <code>offer</code>、<code>poll</code>、<code>peek</code> 等。</li></ul></li><li>优先队列（堆）<ul><li>**C++**：使用 <code>std::priority_queue</code>，默认是大顶堆，可通过传入比较器实现小顶堆（如 <code>std::greater&lt;int&gt;</code>）。</li><li><strong>Java</strong>：使用 <code>PriorityQueue</code>，默认是小顶堆，可通过传入比较器实现大顶堆（如 <code>(a, b) -&gt; b - a</code>）。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-comment">// 单调栈模板</span><br><span class="hljs-comment">// 找出数组中每个元素右侧第一个比它大的元素的索引</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">monotonicStack</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>    std::stack&lt;<span class="hljs-type">int</span>&gt; st;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[st.<span class="hljs-built_in">top</span>()] &lt; nums[i]) &#123;<br>            result[st.<span class="hljs-built_in">top</span>()] = i;<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        st.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 单调队列模板</span><br><span class="hljs-comment">// 滑动窗口最大值</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">monotonicQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    std::deque&lt;<span class="hljs-type">int</span>&gt; dq;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-comment">// 移除不在窗口内的元素</span><br>        <span class="hljs-keyword">if</span> (!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; dq.<span class="hljs-built_in">front</span>() == i - k) &#123;<br>            dq.<span class="hljs-built_in">pop_front</span>();<br>        &#125;<br>        <span class="hljs-comment">// 保持队列单调递减</span><br>        <span class="hljs-keyword">while</span> (!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[dq.<span class="hljs-built_in">back</span>()] &lt; nums[i]) &#123;<br>            dq.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        dq.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-comment">// 当窗口形成后，记录最大值</span><br>        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(nums[dq.<span class="hljs-built_in">front</span>()]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 优先队列（堆）模板</span><br><span class="hljs-comment">// 找出数组中第 k 大的元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">priorityQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        pq.<span class="hljs-built_in">push</span>(num);<br>        <span class="hljs-keyword">if</span> (pq.<span class="hljs-built_in">size</span>() &gt; k) &#123;<br>            pq.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pq.<span class="hljs-built_in">top</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-comment">// 单调栈模板</span><br>    <span class="hljs-comment">// 找出数组中每个元素右侧第一个比它大的元素的索引</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] monotonicStack(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(result, -<span class="hljs-number">1</span>);<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i]) &#123;<br>                result[stack.pop()] = i;<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 单调队列模板</span><br>    <span class="hljs-comment">// 滑动窗口最大值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] monotonicQueue(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 移除不在窗口内的元素</span><br>            <span class="hljs-keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.peekFirst() == i - k) &#123;<br>                deque.pollFirst();<br>            &#125;<br>            <span class="hljs-comment">// 保持队列单调递减</span><br>            <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;<br>                deque.pollLast();<br>            &#125;<br>            deque.offerLast(i);<br>            <span class="hljs-comment">// 当窗口形成后，记录最大值</span><br>            <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) &#123;<br>                result[i - k + <span class="hljs-number">1</span>] = nums[deque.peekFirst()];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 优先队列（堆）模板</span><br>    <span class="hljs-comment">// 找出数组中第 k 大的元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">priorityQueue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            pq.offer(num);<br>            <span class="hljs-keyword">if</span> (pq.size() &gt; k) &#123;<br>                pq.poll();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pq.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-递归与分治"><a href="#3-递归与分治" class="headerlink" title="3.递归与分治"></a>3.递归与分治</h1><h2 id="1-递归与分治"><a href="#1-递归与分治" class="headerlink" title="1.递归与分治"></a>1.递归与分治</h2><ul><li>学习内容：二分查找、归并排序、快速排序、汉诺塔问题。</li><li>练习题：LeetCode 50（Pow(x,n)）、169（多数元素）。</li></ul><blockquote><ul><li>二分查找(划分界限，红蓝区域思想)</li></ul><p><img src="/.com//image-20250409161439034.png" alt="image-20250409161439034"></p><blockquote><p>标准库中分别对应：</p><p>lower_bound()</p><p>lower_bound()-1</p><p>upper_bound()</p><p>upper_bound()-1</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">&gt;<span class="hljs-comment">// 二分查找模板</span><br>&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>  <span class="hljs-type">int</span> left = <span class="hljs-number">-1</span>, right = nums.<span class="hljs-built_in">size</span>() ;<br>  <span class="hljs-keyword">while</span> (left+<span class="hljs-number">1</span>!=right) &#123;<br>      <span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<span class="hljs-comment">//int mid=(l+r)&gt;&gt;1;</span><br>      <span class="hljs-comment">//当r等于10^9 左右 溢出int时 开long long</span><br>      <span class="hljs-comment">//或者int mid = left + (right - left) // 2</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(nums[mid])) &#123;<br>          left = mid;<br>      &#125; <br>      <span class="hljs-keyword">else</span> right = mid;<br>  &#125;<br>   <span class="hljs-keyword">if</span>(符合的条件)<br>          <span class="hljs-keyword">return</span> l;<span class="hljs-comment">//return r</span><br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&gt;&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>mid = left + (right - left) // 2</code> 这一行代码避免了在计算中间索引时可能出现的溢出问题。</p></li><li><p>浮点数直接枚举100次二分，精度可以控制在1e-30以内</p></li></ul> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//while (left+1!=right)</span><br><span class="hljs-comment">//while(right-left&gt;1e-6) 自己控制j</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)<br></code></pre></td></tr></table></figure></blockquote><ul><li>四舍五入保留小数操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> num = <span class="hljs-number">3.1415926</span>;<br>    <span class="hljs-comment">// 四舍五入保留 3 位小数</span><br>    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">3</span>) &lt;&lt; num &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> num = <span class="hljs-number">3.1415926</span>;<br>    <span class="hljs-comment">// 乘以 1000 以便对小数点后第 4 位进行四舍五入</span><br>    <span class="hljs-type">double</span> temp = num * <span class="hljs-number">1000</span>;<br>    <span class="hljs-comment">// 进行四舍五入</span><br>    <span class="hljs-type">int</span> rounded = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(temp + <span class="hljs-number">0.5</span>);<br>    <span class="hljs-comment">// 再除以 1000 得到保留 3 位小数的结果</span><br>    <span class="hljs-type">double</span> result = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(rounded) / <span class="hljs-number">1000</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;四舍五入保留 3 位小数后的结果: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-回溯算法"><a href="#2-回溯算法" class="headerlink" title="2.回溯算法"></a>2.回溯算法</h2><ul><li>学习内容：全排列、子集、组合、剪枝优化。</li><li>练习题：LeetCode 46（全排列）、78（子集）、39（组合总和）。</li></ul><h1 id="4-动态规划"><a href="#4-动态规划" class="headerlink" title="4.动态规划"></a>4.动态规划</h1><h2 id="1-线性DP"><a href="#1-线性DP" class="headerlink" title="1.线性DP"></a>1.线性DP</h2><ul><li>学习内容：斐波那契数列、最长递增子序列（LIS）、最长公共子序列（LCS）。</li><li>练习题：LeetCode 300（LIS）、1143（LCS）。</li></ul><h2 id="2-背包问题"><a href="#2-背包问题" class="headerlink" title="2.背包问题"></a>2.背包问题</h2><ul><li>学习内容：01背包、完全背包、多重背包。</li><li>练习题：蓝桥杯真题《砝码称重》、LeetCode 322（零钱兑换）。</li></ul><h2 id="3-区间DP与状态压缩"><a href="#3-区间DP与状态压缩" class="headerlink" title="3. 区间DP与状态压缩"></a>3. 区间DP与状态压缩</h2><ul><li>学习内容：矩阵链乘法、石子合并、状态压缩技巧（如TSP问题）。</li><li>练习题：LeetCode 312（戳气球）、蓝桥杯真题《能量项链》。</li></ul><h1 id="5-贪心与图论"><a href="#5-贪心与图论" class="headerlink" title="5.贪心与图论"></a>5.贪心与图论</h1><h2 id="1-贪心算法"><a href="#1-贪心算法" class="headerlink" title="1.贪心算法"></a>1.贪心算法</h2><ul><li>学习内容：区间调度、跳跃游戏、哈夫曼编码。</li><li>练习题：LeetCode 435（无重叠区间）、45（跳跃游戏II）。</li></ul><h2 id="2-图论"><a href="#2-图论" class="headerlink" title="2.图论"></a>2.图论</h2><ul><li>学习内容：DFS&#x2F;BFS遍历、最短路径（Dijkstra、Floyd）、最小生成树（Prim、Kruskal）。</li><li>练习题：LeetCode 743（网络延迟时间）、蓝桥杯真题《作物杂交》。</li></ul><blockquote><p>DFS（深度优先）-递归实现 -解决排列组合</p><ul><li>画递归搜索树</li><li>分别定义两个数组，一个数组用来存状态，一个数组用来存答案</li><li>递归调用自身函数以后恢复根结点状态。</li><li>定义结束返回条件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">&gt;~~~<br><br><br><br>&gt;DFS（深度优先） -利用栈实现<br><br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br><br><br><br><br><br><br>&gt;<span class="hljs-keyword">BFS（广度优先）- </span>利用队列实现<br><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><br><br><br><br><br><br><br><br><br><br><span class="hljs-section"># 6.高级数据结构</span><br><br><span class="hljs-section">## 1.并查集与字典树</span><br><br><span class="hljs-bullet">-</span> 学习内容：路径压缩、合并优化、Trie树实现。<br><span class="hljs-bullet">-</span> 练习题：LeetCode 547（省份数量）、208（实现Trie）。<br><br><br><br><span class="hljs-bullet">-</span> 字典序<br><br>&gt;字符串的字典序比较-<span class="hljs-code">`strcmp(str1,str2)`</span> str1&gt;str2 返回正数，等于返回0，小于返回负数<br><br></code></pre></td></tr></table></figure><p>abc&lt;abd  ASCII(d&gt;c)<br>adc&gt;abc  ASCII(d&gt;b)<br>123&gt;131<br>121&lt;123<br>213&gt;123<br>213&lt;223</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><br><br><br><span class="hljs-meta">## 2.线段树与树状数组</span><br><br>- 学习内容：区间查询、单点更新、差分思想。<br>- 练习题：LeetCode <span class="hljs-number">307</span>（区域和检索-数组可修改）。<br><br><br><br><span class="hljs-meta">## 3.字符串处理</span><br><br>- 学习内容：KMP算法、Manacher算法。<br>- 练习题：LeetCode <span class="hljs-number">28</span>（实现strStr()）、<span class="hljs-number">5</span>（最长回文子串）。<br><br><br><br><br><br><span class="hljs-meta"># 7.数学与模拟</span><br><br><span class="hljs-meta">## 1.数论与组合数学</span><br><br>- 学习内容：素数筛法、快速幂、排列组合公式。<br>- 练习题：蓝桥杯真题《等差数列》、LeetCode <span class="hljs-number">62</span>（不同路径）。<br><br><br><br><span class="hljs-meta">## 2.复杂模拟题</span><br><br>- 学习内容：大数运算、日期处理、状态机模型。<br>- 练习题：蓝桥杯真题《回文日期》、《成绩统计》。<br><br><br><br><br><br>**技巧工具**：预处理输入输出加速（C++的`ios::sync_with_stdio(<span class="hljs-literal">false</span>)`）、调试技巧。<br><br>- 求素数<br><br>~~~c++<br><span class="hljs-comment">//判断是否为素数 -只能被1和本身整除  1不是素数  </span><br>bool is_prim(<span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span>)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span>&lt;<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-keyword">sum</span>/i;i++)<span class="hljs-comment">//i&lt;=sqrt(sum)</span><br> &#123;<br> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span>%i==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2025/07/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>[Toc]</p><h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="抽象数据结构ADT（abstract-data-type）"><a href="#抽象数据结构ADT（abstract-data-type）" class="headerlink" title="抽象数据结构ADT（abstract data type）"></a>抽象数据结构ADT（abstract data type）</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><h3 id="4-哈希表（散列表）"><a href="#4-哈希表（散列表）" class="headerlink" title="4.哈希表（散列表）"></a>4.哈希表（散列表）</h3><h4 id="4-1「哈希表-hash-table」，又称「散列表」，其通过建立键-key-与值-value-之间的映射，实现高效的元素查询。具体而言，我们向哈希表输入一个键-key-，则可以在-O-1-时间内获取对应的值-value-。"><a href="#4-1「哈希表-hash-table」，又称「散列表」，其通过建立键-key-与值-value-之间的映射，实现高效的元素查询。具体而言，我们向哈希表输入一个键-key-，则可以在-O-1-时间内获取对应的值-value-。" class="headerlink" title="4.1「哈希表 hash table」，又称「散列表」，其通过建立键 key 与值 value 之间的映射，实现高效的元素查询。具体而言，我们向哈希表输入一个键 key ，则可以在 O(1) 时间内获取对应的值 value 。"></a>4.1「哈希表 hash table」，又称「散列表」，其通过建立键 <code>key</code> 与值 <code>value</code> 之间的映射，实现高效的元素查询。具体而言，我们向哈希表输入一个键 <code>key</code> ，则可以在 <code>O(1)</code> 时间内获取对应的值 <code>value</code> 。</h4><p><img src="/.com//image-20250220203005747.png" alt="image-20250220203005747"></p><p>除哈希表外，数组和链表也可以实现查询功能，它们的效率对比如图 所示。</p><ul><li><strong>添加元素</strong>：仅需将元素添加至数组（链表）的尾部即可，使用 <code>O(1)</code>时间。</li><li><strong>查询元素</strong>：由于数组（链表）是乱序的，因此需要遍历其中的所有元素，使用 <code>O(n) </code>时间。</li><li><strong>删除元素</strong>：需要先查询到元素，再从数组（链表）中删除，使用 <code>O(n) </code>时间。</li></ul><p>表 4-1  元素查询效率对比</p><table><thead><tr><th align="left"></th><th align="left">数组</th><th align="left">链表</th><th align="left">哈希表</th></tr></thead><tbody><tr><td align="left">查找元素</td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left">O(1)</td></tr><tr><td align="left">添加元素</td><td align="left">O(1)</td><td align="left">O(1)</td><td align="left">O(1)</td></tr><tr><td align="left">删除元素</td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left">O(1)</td></tr></tbody></table><ul><li>hash_map</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">/初始化<br>unordered_map&lt;<span class="hljs-type">int</span>,String&gt;map;<span class="hljs-comment">//参数对应键和值（key,value)</span><br>/增<br>map[<span class="hljs-number">123</span>]=<span class="hljs-string">&quot;sda&quot;</span>;<br>map[<span class="hljs-number">124</span>]=<span class="hljs-string">&quot;daw&quot;</span>;<br>/查<br>String str=map[<span class="hljs-number">123</span>];<span class="hljs-comment">//输入键得到值</span><br>/删除<br>map.<span class="hljs-built_in">erase</span>(<span class="hljs-number">123</span>);<span class="hljs-comment">//输入键删除键值对</span><br><span class="hljs-comment">//遍历 key-&gt;value</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k: map)&#123;<br>    cout&lt;&lt;k.first&lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>&lt;&lt;k.second&lt;&lt;endl;  <br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> iter=map.<span class="hljs-built_in">begin</span>();iter!=map.<span class="hljs-built_in">end</span>();iter++)<span class="hljs-comment">//使用迭代器遍历</span><br>&#123;<br>    cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 初始化哈希表 */</span><br>Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><span class="hljs-comment">/* 添加操作 */</span><br><span class="hljs-comment">// 在哈希表中添加键值对 (key, value)</span><br>map.put(<span class="hljs-number">12836</span>, <span class="hljs-string">&quot;小哈&quot;</span>);<br>map.put(<span class="hljs-number">15937</span>, <span class="hljs-string">&quot;小啰&quot;</span>);<br>map.put(<span class="hljs-number">16750</span>, <span class="hljs-string">&quot;小算&quot;</span>);<br>map.put(<span class="hljs-number">13276</span>, <span class="hljs-string">&quot;小法&quot;</span>);<br>map.put(<span class="hljs-number">10583</span>, <span class="hljs-string">&quot;小鸭&quot;</span>);<br><br><span class="hljs-comment">/* 查询操作 */</span><br><span class="hljs-comment">// 向哈希表中输入键 key ，得到值 value</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> map.get(<span class="hljs-number">15937</span>);<br><br><span class="hljs-comment">/* 删除操作 */</span><br><span class="hljs-comment">// 在哈希表中删除键值对 (key, value)</span><br>map.remove(<span class="hljs-number">10583</span>);<br></code></pre></td></tr></table></figure><h4 id="4-2哈希表的简单实现-不考虑冲突情况下"><a href="#4-2哈希表的简单实现-不考虑冲突情况下" class="headerlink" title="4.2哈希表的简单实现&#x2F;&#x2F;不考虑冲突情况下"></a>4.2哈希表的简单实现&#x2F;&#x2F;不考虑冲突情况下</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTable</span>&#123;<br><span class="hljs-keyword">private</span>:<span class="hljs-type">int</span> size;<br>vector&lt;<span class="hljs-type">int</span>&gt;table;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hashfunction</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>&#123;<span class="hljs-keyword">return</span> key%size&#125;;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//初始化</span><br><span class="hljs-built_in">HashTable</span>(<span class="hljs-type">int</span> s):<span class="hljs-built_in">size</span>(s),<span class="hljs-built_in">table</span>(size,<span class="hljs-number">-1</span>)&#123;&#125;<br><span class="hljs-comment">//增</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>&#123;<br><span class="hljs-type">int</span> index=<span class="hljs-built_in">hashfunction</span>(key);<br>table[index]=key;<br>&#125;<br><span class="hljs-comment">//查</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>&#123;<br>cout&lt;&lt;table[<span class="hljs-built_in">hashfunction</span>(key)]&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//删</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>&#123;<br>table[<span class="hljs-built_in">hashfunction</span>(key)]=<span class="hljs-number">-1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/* 键值对 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> key;<br>    <span class="hljs-keyword">public</span> String val;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(<span class="hljs-type">int</span> key, String val)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 基于数组实现的哈希表 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayHashMap</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Pair&gt; buckets;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayHashMap</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 初始化数组，包含 100 个桶</span><br>        buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            buckets.add(<span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 哈希函数 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> key % <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br><br>    <span class="hljs-comment">/* 查询操作 */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> hashFunc(key);<br>        <span class="hljs-type">Pair</span> <span class="hljs-variable">pair</span> <span class="hljs-operator">=</span> buckets.get(index);<br>        <span class="hljs-keyword">if</span> (pair == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> pair.val;<br>    &#125;<br><br>    <span class="hljs-comment">/* 添加操作 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, String val)</span> &#123;<br>        <span class="hljs-type">Pair</span> <span class="hljs-variable">pair</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>(key, val);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> hashFunc(key);<br>        buckets.set(index, pair);<br>    &#125;<br><br>    <span class="hljs-comment">/* 删除操作 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> hashFunc(key);<br>        <span class="hljs-comment">// 置为 null ，代表删除</span><br>        buckets.set(index, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* 获取所有键值对 */</span><br>    <span class="hljs-keyword">public</span> List&lt;Pair&gt; <span class="hljs-title function_">pairSet</span><span class="hljs-params">()</span> &#123;<br>        List&lt;Pair&gt; pairSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Pair pair : buckets) &#123;<br>            <span class="hljs-keyword">if</span> (pair != <span class="hljs-literal">null</span>)<br>                pairSet.add(pair);<br>        &#125;<br>        <span class="hljs-keyword">return</span> pairSet;<br>    &#125;<br><br>    <span class="hljs-comment">/* 获取所有键 */</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">keySet</span><span class="hljs-params">()</span> &#123;<br>        List&lt;Integer&gt; keySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Pair pair : buckets) &#123;<br>            <span class="hljs-keyword">if</span> (pair != <span class="hljs-literal">null</span>)<br>                keySet.add(pair.key);<br>        &#125;<br>        <span class="hljs-keyword">return</span> keySet;<br>    &#125;<br><br>    <span class="hljs-comment">/* 获取所有值 */</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">valueSet</span><span class="hljs-params">()</span> &#123;<br>        List&lt;String&gt; valueSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Pair pair : buckets) &#123;<br>            <span class="hljs-keyword">if</span> (pair != <span class="hljs-literal">null</span>)<br>                valueSet.add(pair.val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> valueSet;<br>    &#125;<br><br>    <span class="hljs-comment">/* 打印哈希表 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (Pair kv : pairSet()) &#123;<br>            System.out.println(kv.key + <span class="hljs-string">&quot; -&gt; &quot;</span> + kv.val);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3哈希冲突"><a href="#4-3哈希冲突" class="headerlink" title="4.3哈希冲突"></a>4.3哈希冲突</h4><p><strong>通常情况下哈希函数的输入空间远大于输出空间</strong>，因此理论上哈希冲突是不可避免的。比如，输入空间为全体整数，输出空间为数组容量大小，则必然有多个整数映射至同一桶索引。</p><p>哈希冲突会导致查询结果错误，严重影响哈希表的可用性。为了解决该问题，每当遇到哈希冲突时，我们就进行哈希表扩容，直至冲突消失为止。此方法简单粗暴且有效，但效率太低，因为哈希表扩容需要进行大量的数据搬运与哈希值计算。为了提升效率，我们可以采用以下策略。</p><ol><li>改良哈希表数据结构，<strong>使得哈希表可以在出现哈希冲突时正常工作</strong>。</li><li>仅在必要时，即当哈希冲突比较严重时，才执行<strong>扩容操作</strong>。</li></ol><p>哈希表的结构改良方法主要包括“链式地址”和“开放寻址”。</p><p>负载因子：元素个数与桶数量的比值</p><ul><li>链式地址：每个桶存储一个链表，其中包含所有冲突元素。大大降低了查询效率，当链表很长时，查询效率由O(1)-&gt;O(n)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 链式地址哈希表 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-built_in">Pair</span>(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> v)&#123;<br>        key=k;<br>        value=v;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMapChaining</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> size;                       <span class="hljs-comment">// 键值对数量</span><br>    <span class="hljs-type">int</span> capacity;                   <span class="hljs-comment">// 哈希表容量</span><br>    <span class="hljs-type">double</span> loadThres;               <span class="hljs-comment">// 触发扩容的负载因子阈值</span><br>    <span class="hljs-type">int</span> extendRatio;                <span class="hljs-comment">// 扩容倍数</span><br>    vector&lt;vector&lt;Pair *&gt;&gt; buckets; <span class="hljs-comment">// 桶数组</span><br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/* 构造方法 */</span><br>    <span class="hljs-built_in">HashMapChaining</span>() : <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">capacity</span>(<span class="hljs-number">4</span>), <span class="hljs-built_in">loadThres</span>(<span class="hljs-number">2.0</span> / <span class="hljs-number">3.0</span>), <span class="hljs-built_in">extendRatio</span>(<span class="hljs-number">2</span>) &#123;<br>        buckets.<span class="hljs-built_in">resize</span>(capacity);<br>    &#125;<br><br>    <span class="hljs-comment">/* 析构方法 */</span><br>    ~<span class="hljs-built_in">HashMapChaining</span>() &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;bucket : buckets) &#123;<br>            <span class="hljs-keyword">for</span> (Pair *pair : bucket) &#123;<br>                <span class="hljs-comment">// 释放内存</span><br>                <span class="hljs-keyword">delete</span> pair;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 哈希函数 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hashFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key % capacity;<br>    &#125;<br><br>    <span class="hljs-comment">/* 负载因子 */</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">loadFactor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>)size / (<span class="hljs-type">double</span>)capacity;<br>    &#125;<br><br>    <span class="hljs-comment">/* 查询操作 */</span><br>    <span class="hljs-function">string <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> index = <span class="hljs-built_in">hashFunc</span>(key);<br>        <span class="hljs-comment">// 遍历桶，若找到 key ，则返回对应 val</span><br>        <span class="hljs-keyword">for</span> (Pair *pair : buckets[index]) &#123;<br>            <span class="hljs-keyword">if</span> (pair-&gt;key == key) &#123;<br>                <span class="hljs-keyword">return</span> pair-&gt;val;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 若未找到 key ，则返回空字符串</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 添加操作 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, string val)</span> </span>&#123;<br>        <span class="hljs-comment">// 当负载因子超过阈值时，执行扩容</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">loadFactor</span>() &gt; loadThres) &#123;<br>            <span class="hljs-built_in">extend</span>();<br>        &#125;<br>        <span class="hljs-type">int</span> index = <span class="hljs-built_in">hashFunc</span>(key);<br>        <span class="hljs-comment">// 遍历桶，若遇到指定 key ，则更新对应 val 并返回</span><br>        <span class="hljs-keyword">for</span> (Pair *pair : buckets[index]) &#123;<br>            <span class="hljs-keyword">if</span> (pair-&gt;key == key) &#123;<br>                pair-&gt;val = val;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 若无该 key ，则将键值对添加至尾部</span><br>        buckets[index].<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Pair</span>(key, val));<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">/* 删除操作 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> index = <span class="hljs-built_in">hashFunc</span>(key);<br>        <span class="hljs-keyword">auto</span> &amp;bucket = buckets[index];<br>        <span class="hljs-comment">// 遍历桶，从中删除键值对</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bucket.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (bucket[i]-&gt;key == key) &#123;<br>                Pair *tmp = bucket[i];<br>                bucket.<span class="hljs-built_in">erase</span>(bucket.<span class="hljs-built_in">begin</span>() + i); <span class="hljs-comment">// 从中删除键值对</span><br>                <span class="hljs-keyword">delete</span> tmp;                       <span class="hljs-comment">// 释放内存</span><br>                size--;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 扩容哈希表 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">extend</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 暂存原哈希表</span><br>        vector&lt;vector&lt;Pair *&gt;&gt; bucketsTmp = buckets;<br>        <span class="hljs-comment">// 初始化扩容后的新哈希表</span><br>        capacity *= extendRatio;<br>        buckets.<span class="hljs-built_in">clear</span>();<br>        buckets.<span class="hljs-built_in">resize</span>(capacity);<br>        size = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 将键值对从原哈希表搬运至新哈希表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;bucket : bucketsTmp) &#123;<br>            <span class="hljs-keyword">for</span> (Pair *pair : bucket) &#123;<br>                <span class="hljs-built_in">put</span>(pair-&gt;key, pair-&gt;val);<br>                <span class="hljs-comment">// 释放内存</span><br>                <span class="hljs-keyword">delete</span> pair;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 打印哈希表 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;bucket : buckets) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;[&quot;</span>;<br>            <span class="hljs-keyword">for</span> (Pair *pair : bucket) &#123;<br>                cout &lt;&lt; pair-&gt;key &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span> &lt;&lt; pair-&gt;val &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>            &#125;<br>            cout &lt;&lt; <span class="hljs-string">&quot;]\n&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/* 链式地址哈希表 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMapChaining</span> &#123;<br>    <span class="hljs-type">int</span> size; <span class="hljs-comment">// 键值对数量</span><br>    <span class="hljs-type">int</span> capacity; <span class="hljs-comment">// 哈希表容量</span><br>    <span class="hljs-type">double</span> loadThres; <span class="hljs-comment">// 触发扩容的负载因子阈值</span><br>    <span class="hljs-type">int</span> extendRatio; <span class="hljs-comment">// 扩容倍数</span><br>    List&lt;List&lt;Pair&gt;&gt; buckets; <span class="hljs-comment">// 桶数组</span><br><br>    <span class="hljs-comment">/* 构造方法 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMapChaining</span><span class="hljs-params">()</span> &#123;<br>        size = <span class="hljs-number">0</span>;<br>        capacity = <span class="hljs-number">4</span>;<br>        loadThres = <span class="hljs-number">2.0</span> / <span class="hljs-number">3.0</span>;<br>        extendRatio = <span class="hljs-number">2</span>;<br>        buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(capacity);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; capacity; i++) &#123;<br>            buckets.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 哈希函数 */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">hashFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">return</span> key % capacity;<br>    &#125;<br><br>    <span class="hljs-comment">/* 负载因子 */</span><br>    <span class="hljs-type">double</span> <span class="hljs-title function_">loadFactor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>) size / capacity;<br>    &#125;<br><br>    <span class="hljs-comment">/* 查询操作 */</span><br>    String <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> hashFunc(key);<br>        List&lt;Pair&gt; bucket = buckets.get(index);<br>        <span class="hljs-comment">// 遍历桶，若找到 key ，则返回对应 val</span><br>        <span class="hljs-keyword">for</span> (Pair pair : bucket) &#123;<br>            <span class="hljs-keyword">if</span> (pair.key == key) &#123;<br>                <span class="hljs-keyword">return</span> pair.val;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 若未找到 key ，则返回 null</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 添加操作 */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, String val)</span> &#123;<br>        <span class="hljs-comment">// 当负载因子超过阈值时，执行扩容</span><br>        <span class="hljs-keyword">if</span> (loadFactor() &gt; loadThres) &#123;<br>            extend();<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> hashFunc(key);<br>        List&lt;Pair&gt; bucket = buckets.get(index);<br>        <span class="hljs-comment">// 遍历桶，若遇到指定 key ，则更新对应 val 并返回</span><br>        <span class="hljs-keyword">for</span> (Pair pair : bucket) &#123;<br>            <span class="hljs-keyword">if</span> (pair.key == key) &#123;<br>                pair.val = val;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 若无该 key ，则将键值对添加至尾部</span><br>        <span class="hljs-type">Pair</span> <span class="hljs-variable">pair</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>(key, val);<br>        bucket.add(pair);<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">/* 删除操作 */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> hashFunc(key);<br>        List&lt;Pair&gt; bucket = buckets.get(index);<br>        <span class="hljs-comment">// 遍历桶，从中删除键值对</span><br>        <span class="hljs-keyword">for</span> (Pair pair : bucket) &#123;<br>            <span class="hljs-keyword">if</span> (pair.key == key) &#123;<br>                bucket.remove(pair);<br>                size--;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 扩容哈希表 */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">extend</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 暂存原哈希表</span><br>        List&lt;List&lt;Pair&gt;&gt; bucketsTmp = buckets;<br>        <span class="hljs-comment">// 初始化扩容后的新哈希表</span><br>        capacity *= extendRatio;<br>        buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(capacity);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; capacity; i++) &#123;<br>            buckets.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br>        size = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 将键值对从原哈希表搬运至新哈希表</span><br>        <span class="hljs-keyword">for</span> (List&lt;Pair&gt; bucket : bucketsTmp) &#123;<br>            <span class="hljs-keyword">for</span> (Pair pair : bucket) &#123;<br>                put(pair.key, pair.val);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 打印哈希表 */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (List&lt;Pair&gt; bucket : buckets) &#123;<br>            List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (Pair pair : bucket) &#123;<br>                res.add(pair.key + <span class="hljs-string">&quot; -&gt; &quot;</span> + pair.val);<br>            &#125;<br>            System.out.println(res);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>开放地址：不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突</p></li><li><ol><li>线性探测采用固定步长的线性搜索来进行探测，其操作方法与普通哈希表有所不同。</li></ol><ul><li><p><strong>插入元素</strong>：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为 1 ），直至找到空桶，将元素插入其中。</p></li><li><p><strong>查找元素</strong>：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 <code>value</code> 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 <code>None</code> 。</p></li><li><p>然而，<strong>线性探测容易产生“聚集现象”</strong>。具体来说，数组中连续被占用的位置越长，这些连续位置发生哈希冲突的可能性越大，从而进一步促使该位置的聚堆生长，形成恶性循环，最终导致增删查改操作效率劣化。</p><p>值得注意的是，<strong>我们不能在开放寻址哈希表中直接删除元素</strong>。这是因为删除元素会在数组内产生一个空桶 <code>None</code> ，而当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在</p><p>为了解决该问题，我们可以采用懒删除（lazy deletion）机制：它不直接从哈希表中移除元素，<strong>而是利用一个常量 <code>TOMBSTONE</code> 来标记这个桶</strong>。在该机制下，<code>None</code> 和 <code>TOMBSTONE</code> 都代表空桶，都可以放置键值对。但不同的是，线性探测到 <code>TOMBSTONE</code> 时应该继续遍历，因为其之下可能还存在键值对。</p><p>然而，<strong>懒删除可能会加速哈希表的性能退化</strong>。这是因为每次删除操作都会产生一个删除标记，随着 <code>TOMBSTONE</code> 的增加，搜索时间也会增加，因为线性探测可能需要跳过多个 <code>TOMBSTONE</code> 才能找到目标元素。</p><p>为此，考虑在线性探测中记录遇到的首个 <code>TOMBSTONE</code> 的索引，并将搜索到的目标元素与该 <code>TOMBSTONE</code> 交换位置。这样做的好处是当每次查询或添加元素时，元素会被移动至距离理想位置（探测起始点）更近的桶，从而优化查询效率。</p><p>以下代码实现了一个包含懒删除的开放寻址（线性探测）哈希表。为了更加充分地使用哈希表的空间，我们将哈希表看作一个“环形数组”，当越过数组尾部时，回到头部继续遍历。</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 开放寻址哈希表 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMapOpenAddressing</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> size;                             <span class="hljs-comment">// 键值对数量</span><br>    <span class="hljs-type">int</span> capacity = <span class="hljs-number">4</span>;                     <span class="hljs-comment">// 哈希表容量</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> loadThres = <span class="hljs-number">2.0</span> / <span class="hljs-number">3.0</span>;     <span class="hljs-comment">// 触发扩容的负载因子阈值</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> extendRatio = <span class="hljs-number">2</span>;            <span class="hljs-comment">// 扩容倍数</span><br>    vector&lt;Pair *&gt; buckets;               <span class="hljs-comment">// 桶数组</span><br>    Pair *TOMBSTONE = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Pair</span>(<span class="hljs-number">-1</span>, <span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-comment">// 删除标记</span><br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/* 构造方法 */</span><br>    <span class="hljs-built_in">HashMapOpenAddressing</span>() : <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">buckets</span>(capacity, <span class="hljs-literal">nullptr</span>) &#123;<br>    &#125;<br><br>    <span class="hljs-comment">/* 析构方法 */</span><br>    ~<span class="hljs-built_in">HashMapOpenAddressing</span>() &#123;<br>        <span class="hljs-keyword">for</span> (Pair *pair : buckets) &#123;<br>            <span class="hljs-keyword">if</span> (pair != <span class="hljs-literal">nullptr</span> &amp;&amp; pair != TOMBSTONE) &#123;<br>                <span class="hljs-keyword">delete</span> pair;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">delete</span> TOMBSTONE;<br>    &#125;<br><br>    <span class="hljs-comment">/* 哈希函数 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hashFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key % capacity;<br>    &#125;<br><br>    <span class="hljs-comment">/* 负载因子 */</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">loadFactor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>)size / capacity;<br>    &#125;<br><br>    <span class="hljs-comment">/* 搜索 key 对应的桶索引 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBucket</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> index = <span class="hljs-built_in">hashFunc</span>(key);<br>        <span class="hljs-type">int</span> firstTombstone = <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 线性探测，当遇到空桶时跳出</span><br>        <span class="hljs-keyword">while</span> (buckets[index] != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-comment">// 若遇到 key ，返回对应的桶索引</span><br>            <span class="hljs-keyword">if</span> (buckets[index]-&gt;key == key) &#123;<br>                <span class="hljs-comment">// 若之前遇到了删除标记，则将键值对移动至该索引处</span><br>                <span class="hljs-keyword">if</span> (firstTombstone != <span class="hljs-number">-1</span>) &#123;<br>                    buckets[firstTombstone] = buckets[index];<br>                    buckets[index] = TOMBSTONE;<br>                    <span class="hljs-keyword">return</span> firstTombstone; <span class="hljs-comment">// 返回移动后的桶索引</span><br>                &#125;<br>                <span class="hljs-keyword">return</span> index; <span class="hljs-comment">// 返回桶索引</span><br>            &#125;<br>            <span class="hljs-comment">// 记录遇到的首个删除标记</span><br>            <span class="hljs-keyword">if</span> (firstTombstone == <span class="hljs-number">-1</span> &amp;&amp; buckets[index] == TOMBSTONE) &#123;<br>                firstTombstone = index;<br>            &#125;<br>            <span class="hljs-comment">// 计算桶索引，越过尾部则返回头部</span><br>            index = (index + <span class="hljs-number">1</span>) % capacity;<br>        &#125;<br>        <span class="hljs-comment">// 若 key 不存在，则返回添加点的索引</span><br>        <span class="hljs-keyword">return</span> firstTombstone == <span class="hljs-number">-1</span> ? index : firstTombstone;<br>    &#125;<br><br>    <span class="hljs-comment">/* 查询操作 */</span><br>    <span class="hljs-function">string <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-comment">// 搜索 key 对应的桶索引</span><br>        <span class="hljs-type">int</span> index = <span class="hljs-built_in">findBucket</span>(key);<br>        <span class="hljs-comment">// 若找到键值对，则返回对应 val</span><br>        <span class="hljs-keyword">if</span> (buckets[index] != <span class="hljs-literal">nullptr</span> &amp;&amp; buckets[index] != TOMBSTONE) &#123;<br>            <span class="hljs-keyword">return</span> buckets[index]-&gt;val;<br>        &#125;<br>        <span class="hljs-comment">// 若键值对不存在，则返回空字符串</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 添加操作 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, string val)</span> </span>&#123;<br>        <span class="hljs-comment">// 当负载因子超过阈值时，执行扩容</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">loadFactor</span>() &gt; loadThres) &#123;<br>            <span class="hljs-built_in">extend</span>();<br>        &#125;<br>        <span class="hljs-comment">// 搜索 key 对应的桶索引</span><br>        <span class="hljs-type">int</span> index = <span class="hljs-built_in">findBucket</span>(key);<br>        <span class="hljs-comment">// 若找到键值对，则覆盖 val 并返回</span><br>        <span class="hljs-keyword">if</span> (buckets[index] != <span class="hljs-literal">nullptr</span> &amp;&amp; buckets[index] != TOMBSTONE) &#123;<br>            buckets[index]-&gt;val = val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 若键值对不存在，则添加该键值对</span><br>        buckets[index] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Pair</span>(key, val);<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">/* 删除操作 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-comment">// 搜索 key 对应的桶索引</span><br>        <span class="hljs-type">int</span> index = <span class="hljs-built_in">findBucket</span>(key);<br>        <span class="hljs-comment">// 若找到键值对，则用删除标记覆盖它</span><br>        <span class="hljs-keyword">if</span> (buckets[index] != <span class="hljs-literal">nullptr</span> &amp;&amp; buckets[index] != TOMBSTONE) &#123;<br>            <span class="hljs-keyword">delete</span> buckets[index];<br>            buckets[index] = TOMBSTONE;<br>            size--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 扩容哈希表 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">extend</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 暂存原哈希表</span><br>        vector&lt;Pair *&gt; bucketsTmp = buckets;<br>        <span class="hljs-comment">// 初始化扩容后的新哈希表</span><br>        capacity *= extendRatio;<br>        buckets = <span class="hljs-built_in">vector</span>&lt;Pair *&gt;(capacity, <span class="hljs-literal">nullptr</span>);<br>        size = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 将键值对从原哈希表搬运至新哈希表</span><br>        <span class="hljs-keyword">for</span> (Pair *pair : bucketsTmp) &#123;<br>            <span class="hljs-keyword">if</span> (pair != <span class="hljs-literal">nullptr</span> &amp;&amp; pair != TOMBSTONE) &#123;<br>                <span class="hljs-built_in">put</span>(pair-&gt;key, pair-&gt;val);<br>                <span class="hljs-keyword">delete</span> pair;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 打印哈希表 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Pair *pair : buckets) &#123;<br>            <span class="hljs-keyword">if</span> (pair == <span class="hljs-literal">nullptr</span>) &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;nullptr&quot;</span> &lt;&lt; endl;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pair == TOMBSTONE) &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;TOMBSTONE&quot;</span> &lt;&lt; endl;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cout &lt;&lt; pair-&gt;key &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span> &lt;&lt; pair-&gt;val &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><ol start="2"><li>平方探测</li></ol></li></ul><p>平方探测与线性探测类似，都是开放寻址的常见策略之一。当发生冲突时，平方探测不是简单地跳过一个固定的步数，而是跳过“探测次数的平方”的步数，即 1,4,9,… 步。</p><p>平方探测主要具有以下优势。</p><ul><li>平方探测通过跳过探测次数平方的距离，试图缓解线性探测的聚集效应。</li><li>平方探测会跳过更大的距离来寻找空位置，有助于数据分布得更加均匀。</li></ul><p>然而，平方探测并不是完美的。</p><ul><li><p>仍然存在聚集现象，即某些位置比其他位置更容易被占用。</p></li><li><p>由于平方的增长，平方探测可能不会探测整个哈希表，这意味着即使哈希表中有空桶，平方探测也可能无法访问到它。</p></li><li><ol start="3"><li>多次哈希</li></ol></li></ul><p>顾名思义，多次哈希方法使用多个哈希函数 f1(x)、f2(x)、f3(x)、… 进行探测。</p><ul><li><p><strong>插入元素</strong>：若哈希函数 f1(x) 出现冲突，则尝试 f2(x) ，以此类推，直到找到空位后插入元素。</p></li><li><p><strong>查找元素</strong>：在相同的哈希函数顺序下进行查找，直到找到目标元素时返回；若遇到空位或已尝试所有哈希函数，说明哈希表中不存在该元素，则返回 <code>None</code> 。</p></li></ul><p>与线性探测相比，多次哈希方法不易产生聚集，但多个哈希函数会带来额外的计算量。</p><ul><li>开放寻址（线性探测、平方探测和多次哈希）哈希表都存在“不能直接删除元素”的问题。</li></ul><h4 id="4-4-哈希算法"><a href="#4-4-哈希算法" class="headerlink" title="4.4.哈希算法"></a>4.4.哈希算法</h4><h3 id="5-树"><a href="#5-树" class="headerlink" title="5.树"></a>5.树</h3><h4 id="5-1树的定义与基本性质"><a href="#5-1树的定义与基本性质" class="headerlink" title="5.1树的定义与基本性质"></a>5.1树的定义与基本性质</h4><ul><li><p>空树–结点数为零的树</p></li><li><p>非空树的特性：</p><ol><li>有且只有一个根结点。</li><li>节点之间由边连接。</li><li>没有后继的结点叫“叶子结点”，有后继的结点叫“分支结点”。</li><li>除了根结点没有前驱以外，所有结点都有且只有一个前驱。</li></ol></li><li><p>树是一种递归定义的结构，任何一棵树都可以看做一个根结点和若干颗子树构成。</p></li><li><p>两个结点之间的路径和路径长度：</p></li></ul><ol><li>路径只能从上往下</li><li>路径长度为经过边的多少</li></ol><ul><li><p>结点、树的属性描述</p><ol><li><p>结点的层次（深度）–从上往下数  &#x2F;&#x2F; 默认从1开始数</p></li><li><p>结点的高度–从下往上数</p></li><li><p>树的高度（深度）–总共多少层</p></li><li><p><strong>结点的度</strong>–有几个孩子（分支）   </p><blockquote><p>非叶子结点的度&gt;0</p><p>叶子结点的度&#x3D;0</p></blockquote></li><li><p><strong>树的度</strong>–各结点的度的最大值</p></li></ol></li><li><p>有序树VS无序树——树中结点的各子树从左到右是否有序（由是否要反应结点左右位置的某些逻辑关系来选择）</p></li><li><p>森林：m棵互不相交的树的集合（m&gt;&#x3D;0）m&#x3D;0时为空森林。</p></li><li><p>树的常考性质</p></li></ul><blockquote><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">结点数=总度数<span class="hljs-string">+1</span>  //总度数为每个结点的度相加<br>度为m的树第i层最多有m^(i<span class="hljs-string">-1</span>)个结点（i&gt;=1）<br>m叉树第i层最多有m^(i<span class="hljs-string">-1</span>)个结点（i&gt;=1）<br>高度为h的m叉树结点最多有(m^h<span class="hljs-string">-1</span>)/(m<span class="hljs-string">-1</span>)个；最少有h+m<span class="hljs-string">-1</span>个<br>具有n个结点的m叉树的最小高度为logm【n<span class="hljs-string">+1</span>)<span class="hljs-string">-1</span>】<br></code></pre></td></tr></table></figure></blockquote><h4 id="5-2二叉树的定义与性质-binary-tree"><a href="#5-2二叉树的定义与性质-binary-tree" class="headerlink" title="5.2二叉树的定义与性质 binary tree"></a>5.2二叉树的定义与性质 binary tree</h4><h5 id="5-2-1二叉树"><a href="#5-2-1二叉树" class="headerlink" title="5.2.1二叉树"></a>5.2.1二叉树</h5><ul><li>二叉树是一种非线性数据结构，代表着祖先与后代之间的派生关系，体现着“一分为二”的分治逻辑。与链表类似，二叉树的基本单元是节点，每个节点包含：值、左子节点引用、右子节点引用。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*二叉树结点结构体*/</span> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span>&#123;<br>    <span class="hljs-type">int</span> val;<span class="hljs-comment">//结点值</span><br>    TreeNode*left;<span class="hljs-comment">//左子结点引用</span><br>    TreeNode*right;<span class="hljs-comment">//右子结点引用</span><br>   <span class="hljs-built_in">TreeNode</span>(intx):<span class="hljs-built_in">val</span>(x),<span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">ringt</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>每个节点都有两个引用（指针），分别指向「左子节点 left-child node」和「右子节点 right-child node」，该节点被称为这两个子节点的「父节点 parent node」。当给定一个二叉树的节点时，我们将该节点的左子节点及其以下节点形成的树称为该节点的「左子树 left subtree」，同理可得「右子树 right subtree」</li><li><strong>在二叉树中，除叶节点外，其他所有节点都包含子节点和非空子树</strong>。</li></ul><h5 id="5-2-2二叉树常见术语"><a href="#5-2-2二叉树常见术语" class="headerlink" title="5.2.2二叉树常见术语"></a>5.2.2二叉树常见术语</h5><ul><li><p>「根节点 root node」：位于二叉树顶层的节点，没有父节点。</p></li><li><p>「叶节点 leaf node」：没有子节点的节点，其两个指针均指向 None 。</p></li><li><p>「边 edge」：连接两个节点的线段，即节点引用（指针）。</p></li><li><p>节点所在的「层 level」：从顶至底递增，根节点所在层为 1 。</p></li><li><p>节点的「度 degree」：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。</p></li><li><p>二叉树的「高度 height」：从根节点到最远叶节点所经过的边的数量。</p></li><li><p>节点的「深度 depth」：从根节点到该节点所经过的边的数量。</p></li><li><p>节点的「高度 height」：从距离该节点最远的叶节点到该节点所经过的边的数量。</p></li></ul><blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Tip</span><br>请注意，我们通常将“高度”和“深度”定义为“走过边的数量”，但有些题目或教材可能会将其定义为“走过节点的数量”。在这种情况下，高度和深度都需要加 <span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure></blockquote><h5 id="5-2-3二叉树基本操作"><a href="#5-2-3二叉树基本操作" class="headerlink" title="5.2.3二叉树基本操作"></a>5.2.3二叉树基本操作</h5><ol><li><p>初始化二叉树</p><p>与链表类似，首先初始化结点，然后构建引用（指针）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 初始化二叉树 */</span><br><span class="hljs-comment">// 初始化节点</span><br>TreeNode* n1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">1</span>);<br>TreeNode* n2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">2</span>);<br>TreeNode* n3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">3</span>);<br>TreeNode* n4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">4</span>);<br>TreeNode* n5 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">5</span>);<br><span class="hljs-comment">// 构建引用指向（即指针）</span><br>n1-&gt;left = n2;<br>n1-&gt;right = n3;<br>n2-&gt;left = n4;<br>n2-&gt;right = n5;<br></code></pre></td></tr></table></figure></li><li><p>插入与删除</p><p>通过直接修该结点的指针实现</p></li></ol><h4 id="5-3二叉数遍历"><a href="#5-3二叉数遍历" class="headerlink" title="5.3二叉数遍历"></a>5.3二叉数遍历</h4><ul><li><p>层序遍历</p><ul><li><p>BFS(广度优先遍历)实现，借助队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; <span class="hljs-title function_">Bfs_tree</span><span class="hljs-params">(TreeNode root)</span>&#123;<br><span class="hljs-comment">//初始化队列并且根结点入队</span><br>Queue&lt;TreeNode&gt; queue=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>queue.add(root);<br><span class="hljs-comment">//初始化列表，用于存储遍历序列</span><br>List&lt;Integer&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">while</span>(！queue.isEmpty())&#123;<br>TreeNode node=queue.poll();<span class="hljs-comment">//出队</span><br>list.add(node.val);           <span class="hljs-comment">// 保存节点值</span><br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>)<br>            queue.offer(node.left);   <span class="hljs-comment">// 左子节点入队</span><br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>)<br>            queue.offer(node.right);  <span class="hljs-comment">// 右子节点入队</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>前、中、后序遍历</p><ul><li><p>DFS(深度优先)</p></li><li><pre><code class="hljs">//前序遍历,根左右void preOrder(TreeNode root)&#123;if(root==null)return;list.add(root.val);preOrder(root.left);preOrder(root.right);&#125;//中序遍历void inOrder(TreeNode root) &#123;    if (root == null)        return;    // 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树    inOrder(root.left);    list.add(root.val);    inOrder(root.right);&#125;/* 后序遍历 */void postOrder(TreeNode root) &#123;    if (root == null)        return;    // 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点    postOrder(root.left);    postOrder(root.right);    list.add(root.val);&#125;</code></pre></li><li></li></ul></li></ul><h4 id="5-4二叉树数组表示"><a href="#5-4二叉树数组表示" class="headerlink" title="5.4二叉树数组表示"></a>5.4二叉树数组表示</h4><h4 id="5-5二叉搜索树"><a href="#5-5二叉搜索树" class="headerlink" title="5.5二叉搜索树"></a>5.5二叉搜索树</h4><h4 id="5-5AVl树和红黑树"><a href="#5-5AVl树和红黑树" class="headerlink" title="5.5AVl树和红黑树"></a>5.5AVl树和红黑树</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2025/07/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE-%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/"/>
    <url>/2025/07/02/%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE-%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/</url>
    
    <content type="html"><![CDATA[<h1 id="外卖-take-out"><a href="#外卖-take-out" class="headerlink" title="外卖-take-out"></a>外卖-take-out</h1><h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><h2 id="1-架构和环境"><a href="#1-架构和环境" class="headerlink" title="1.架构和环境"></a>1.架构和环境</h2><h3 id="1-1技术架构"><a href="#1-1技术架构" class="headerlink" title="1.1技术架构"></a>1.1技术架构</h3><p><img src="/.com//image-20250329145750834.png" alt="image-20250329145750834"></p><h3 id="1-2项目模板导入和阅读"><a href="#1-2项目模板导入和阅读" class="headerlink" title="1.2项目模板导入和阅读"></a>1.2项目模板导入和阅读</h3><p><img src="/.com//image-20250329143602076.png" alt="image-20250329143602076"></p><p><img src="/.com//image-20250329143750224.png" alt="image-20250329143750224"></p><p><img src="/.com//image-20250329143804374.png" alt="image-20250329143804374"></p><p><img src="/.com//image-20250329143930566.png" alt="image-20250329143930566"></p><h3 id="1-3使用git远程版本控制"><a href="#1-3使用git远程版本控制" class="headerlink" title="1.3使用git远程版本控制"></a>1.3使用git远程版本控制</h3><p><img src="/.com//image-20250329144036317.png" alt="image-20250329144036317"></p><h3 id="1-4数据库引入"><a href="#1-4数据库引入" class="headerlink" title="1.4数据库引入"></a>1.4数据库引入</h3><p><img src="/.com//image-20250329193739368.png" alt="image-20250329193739368"></p><h3 id="1-5联调以及登录完善"><a href="#1-5联调以及登录完善" class="headerlink" title="1.5联调以及登录完善"></a>1.5联调以及登录完善</h3><p><img src="/.com//image-20250329193817922.png" alt="image-20250329193817922"></p><p><img src="/.com//image-20250329201632073.png" alt="image-20250329201632073"></p><p><img src="/.com//image-20250329201734103.png" alt="image-20250329201734103"></p><p><code>DigestUtils</code> 是 Spring 提供的工具类，封装了常见摘要算法操作。该方法将输入的密码字符串转换为字节数组，生成对应的 MD5 哈希值，并以十六进制字符串形式返回。</p><p>​</p><h3 id="1-6接口文档"><a href="#1-6接口文档" class="headerlink" title="1.6接口文档"></a>1.6接口文档</h3><h4 id="1-导入接口文档"><a href="#1-导入接口文档" class="headerlink" title="1.导入接口文档"></a>1.导入接口文档</h4><p>apifox或者postman导入接口文档</p><h4 id="2-Swagger"><a href="#2-Swagger" class="headerlink" title="2.Swagger"></a>2.<strong>Swagger</strong></h4><p><img src="/.com//image-20250329202615609.png" alt="image-20250329202615609"></p><p><img src="/.com//image-20250329202658718.png" alt="image-20250329202658718"></p><p><img src="/.com//image-20250329202822287.png" alt="image-20250329202822287"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">docket</span><span class="hljs-params">()</span>&#123;<br>Apilnfo apilnfo=newApilnfoBuilder()<br>.title(<span class="hljs-string">&quot;苍穹外卖项目接口文档&quot;</span>)<br>.version(<span class="hljs-string">&quot;2.0&quot;</span>)<br>.description(<span class="hljs-string">&quot;苍穹外卖项目接口文档&quot;</span>)<br>.build();<br>Docket docket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>.apilnfo(apilnfo)<br>.select()<br><span class="hljs-comment">//指定生成接口需要扫描的包</span><br>.apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.sky.controller&quot;</span>))<br>paths(PathSelectors.any())<br>build();<br><span class="hljs-keyword">return</span> docket;<br>&#125;<br><span class="hljs-comment">//WebMvcConfiguration配置类</span><br></code></pre></td></tr></table></figure><p><img src="/.com//image-20250329203038589.png" alt="image-20250329203038589"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*设置静态资源映射</span><br><span class="hljs-comment">*<span class="hljs-doctag">@param</span> registry</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span>&#123;<br>   log.info(<span class="hljs-string">&quot;开始设置静态资源映射..&quot;</span>);<br>registry.addResourceHandler(/doc.html<span class="hljs-string">&quot;).addResourceLocations(&quot;</span>classpath:/META-INF/resources/<span class="hljs-string">&quot;);</span><br><span class="hljs-string">registry.addResourceHandler(&quot;</span>/webjars<span class="hljs-comment">/**&quot;).addResourceLocations(classpath:/META-INF/resources/webjars/); </span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><p><img src="/.com//image-20250329203842827.png" alt="image-20250329203842827"></p><p><img src="/.com//image-20250329203924813.png" alt="image-20250329203924813"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(tags=&quot;员工登录接口&quot;)</span><br><span class="hljs-meta">@ApiModel(description = &quot;员工登录时传递的数据模型&quot;)</span><br><span class="hljs-meta">@ApiModelProperty(&quot;用户名&quot;)</span><br><span class="hljs-meta">@ApiOperation(value=&quot;员工登录&quot;)</span><br></code></pre></td></tr></table></figure><h4 id="3-双端接口文档改造"><a href="#3-双端接口文档改造" class="headerlink" title="3.双端接口文档改造"></a>3.双端接口文档改造</h4><ul><li><code>groupName</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Swagger配置</span><br><span class="hljs-comment">     * 通过knife4j生成接口文档</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">docket1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ApiInfo</span> <span class="hljs-variable">apiInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;苍穹外卖项目接口文档&quot;</span>)<br>                .version(<span class="hljs-string">&quot;2.0&quot;</span>)<br>                .description(<span class="hljs-string">&quot;苍穹外卖项目接口文档&quot;</span>)<br>                .build();<br>        <span class="hljs-type">Docket</span> <span class="hljs-variable">docket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .groupName(<span class="hljs-string">&quot;管理端接口&quot;</span>)<br>                .apiInfo(apiInfo)<br>                .select()<br>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.sky.controller.admin&quot;</span>))<br>                .paths(PathSelectors.any())<br>                .build();<br>        <span class="hljs-keyword">return</span> docket;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">docket2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ApiInfo</span> <span class="hljs-variable">apiInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;苍穹外卖项目接口文档&quot;</span>)<br>                .version(<span class="hljs-string">&quot;2.0&quot;</span>)<br>                .description(<span class="hljs-string">&quot;苍穹外卖项目接口文档&quot;</span>)<br>                .build();<br>        <span class="hljs-type">Docket</span> <span class="hljs-variable">docket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .groupName(<span class="hljs-string">&quot;用户端接口&quot;</span>)<br>                .apiInfo(apiInfo)<br>                .select()<br>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.sky.controller.user&quot;</span>))<br>                .paths(PathSelectors.any())<br>                .build();<br>        <span class="hljs-keyword">return</span> docket;<br>    &#125;<br><br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置Swagger静态资源映射</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> registry</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> &#123;<br>        registry.addResourceHandler(<span class="hljs-string">&quot;/doc.html&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;classpath:/META-INF/resources/&quot;</span>);<br>        registry.addResourceHandler(<span class="hljs-string">&quot;/webjars/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>openapi2</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.xiaoymin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>knife4j-openapi2-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>增强 UI：<code>http://localhost:8080/doc.html</code></p></li><li><p>原生 Swagger：<code>http://localhost:8080/swagger-ui/index.html</code></p></li><li><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">knife4j:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">setting:</span><br>    <span class="hljs-attr">language:</span> <span class="hljs-string">zh_cn</span>  <span class="hljs-comment"># 语言设置</span><br>    <span class="hljs-attr">enableSwaggerModels:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 启用Swagger Models功能</span><br>    <span class="hljs-attr">enableDocumentManage:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 启用文档管理功能</span><br>    <span class="hljs-attr">enableHost:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 是否显示Host信息</span><br>    <span class="hljs-attr">enableFilterMultipartApis:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 是否过滤Multipart类型的接口</span><br>  <span class="hljs-attr">openapi:</span><br>    <span class="hljs-attr">title:</span> <span class="hljs-string">&quot;项目API文档&quot;</span><br>    <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;详细描述项目接口信息&quot;</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-number">1.0</span><span class="hljs-number">.0</span><br>    <span class="hljs-attr">group:</span><br>       <span class="hljs-attr">user:</span><br>        <span class="hljs-attr">base-package:</span> <span class="hljs-string">com.xing.springboot.controller</span><br>        <span class="hljs-attr">title:</span> <span class="hljs-string">&quot;用户接口组&quot;</span><br>        <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;用户相关的API&quot;</span><br>      <span class="hljs-attr">admin:</span><br>        <span class="hljs-attr">base-package:</span> <span class="hljs-string">com.xing.springboot.admin.controller</span><br>        <span class="hljs-attr">title:</span> <span class="hljs-string">&quot;管理后台接口组&quot;</span><br>        <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;管理员专用接口&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>配置类注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.github.xiaoymin.knife4j.spring.annotations.EnableKnife4j;<br><span class="hljs-keyword">import</span> io.swagger.v3.oas.models.Components;<br><span class="hljs-keyword">import</span> io.swagger.v3.oas.models.OpenAPI;<br><span class="hljs-keyword">import</span> io.swagger.v3.oas.models.info.Contact;<br><span class="hljs-keyword">import</span> io.swagger.v3.oas.models.info.Info;<br><span class="hljs-keyword">import</span> io.swagger.v3.oas.models.info.License;<br><span class="hljs-keyword">import</span> io.swagger.v3.oas.models.servers.Server;<br><span class="hljs-keyword">import</span> org.springdoc.core.models.GroupedOpenApi;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableKnife4j</span>  <span class="hljs-comment">// 启用Knife4j增强功能</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> OpenAPI <span class="hljs-title function_">customOpenAPI</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenAPI</span>()<br>            .addServersItem(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>().url(<span class="hljs-string">&quot;/&quot;</span>))<br>            .info(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>()<br>                .title(<span class="hljs-string">&quot;项目API文档&quot;</span>)<br>                .description(<span class="hljs-string">&quot;详细描述项目接口信息&quot;</span>)<br>                .version(<span class="hljs-string">&quot;1.0.0&quot;</span>)<br>                .contact(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>()<br>                    .name(<span class="hljs-string">&quot;技术支持&quot;</span>)<br>                    .url(<span class="hljs-string">&quot;https://www.example.com/support&quot;</span>)<br>                    .email(<span class="hljs-string">&quot;support@example.com&quot;</span>))<br>                .license(<span class="hljs-keyword">new</span> <span class="hljs-title class_">License</span>()<br>                    .name(<span class="hljs-string">&quot;MIT License&quot;</span>)<br>                    .url(<span class="hljs-string">&quot;https://opensource.org/licenses/MIT&quot;</span>))<br>                .termsOfService(<span class="hljs-string">&quot;https://www.example.com&quot;</span>))<br>            .components(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Components</span>());<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> GroupedOpenApi <span class="hljs-title function_">defaultApi</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> GroupedOpenApi.builder()<br>            .group(<span class="hljs-string">&quot;default&quot;</span>)<br>            .pathsToMatch(<span class="hljs-string">&quot;/api/**&quot;</span>)<br>            .packagesToScan(<span class="hljs-string">&quot;com.xing.springboot.controller&quot;</span>)<br>            .build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> GroupedOpenApi <span class="hljs-title function_">adminApi</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> GroupedOpenApi.builder()<br>            .group(<span class="hljs-string">&quot;admin&quot;</span>)<br>            .pathsToMatch(<span class="hljs-string">&quot;/admin/**&quot;</span>)<br>            .packagesToScan(<span class="hljs-string">&quot;com.xing.springboot.admin.controller&quot;</span>)<br>            .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="管理端"><a href="#管理端" class="headerlink" title="管理端"></a>管理端</h2><h2 id="2-员工管理，分类管理"><a href="#2-员工管理，分类管理" class="headerlink" title="2.员工管理，分类管理"></a>2.员工管理，分类管理</h2><h3 id="2-1员工管理"><a href="#2-1员工管理" class="headerlink" title="2.1员工管理"></a>2.1员工管理</h3><h4 id="1-新增员工"><a href="#1-新增员工" class="headerlink" title="1.新增员工"></a>1.新增员工</h4><p><img src="/.com//image-20250330113154015.png" alt="image-20250330113154015"></p><p><img src="/.com//image-20250330113212417.png" alt="image-20250330113212417"></p><blockquote><ol><li><p>Coontroller层使用DTO接收数据</p></li><li><p>Service层将DTO转为实体类并且初始化数据传递给Mapper层，使用对象属性拷贝(前提是属性名一致)</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">//把employeeDTO中的属性拷贝到employee中（同名属性）</span><br>&gt;BeanUtils.copyProperties(employeeDTO,employee);<br>&gt;<span class="hljs-comment">//继续把其他属性初始化</span><br>&gt;<span class="hljs-comment">//手动使用setter</span><br>&gt;Employee employee=Employee.buildder()<br>   .status(status)<br>   .id(id) ...<br>   .build();<br></code></pre></td></tr></table></figure><ol start="3"><li>Mapper层插入数据</li><li>接口测试</li></ol></blockquote><p><img src="/.com//image-20250330115828189.png" alt="image-20250330115828189"></p><blockquote><ol><li>通过全局异常处理器捕获异常，返回异常信息</li><li>解析令牌时，设置ThreadLocal局部变量为id，在新增员工时初始化id,最后返回试图层时删除局部变量。（已有工具类在context包下）</li><li>push推送至仓库</li></ol></blockquote><h4 id="2-员工分页查询"><a href="#2-员工分页查询" class="headerlink" title="2.员工分页查询"></a>2.员工分页查询</h4><p><img src="/.com//image-20250330122453465.png" alt="image-20250330122453465"></p><p><img src="/.com//image-20250330122423034.png" alt="image-20250330122423034"></p><p><img src="/.com//image-20250330122612390.png" alt="image-20250330122612390"></p><p><img src="/.com//image-20250330122631173.png" alt="image-20250330122631173"></p><blockquote><ol><li>Controller层用DTO接收参数</li><li>Service层用PageHelper插件完成分页查询</li><li>Mapper层模糊查询</li><li>对比返回数据封装</li><li>接口测试</li></ol></blockquote><ul><li>发现问题</li></ul><blockquote><p>返回给前端的日期属性格式可读性差</p><p><img src="/.com//image-20250330135700359.png" alt="image-20250330135700359"></p><h3 id="常见的消息转换器"><a href="#常见的消息转换器" class="headerlink" title="常见的消息转换器"></a>常见的消息转换器</h3><p>Spring MVC 提供了多种内置的消息转换器，下面是一些常见的：</p><ul><li>**<code>StringHttpMessageConverter</code>**：用于处理 <code>String</code> 类型的数据，将请求体中的文本数据转换为 <code>String</code> 对象，或者将 <code>String</code> 对象转换为文本响应。</li><li>**<code>MappingJackson2HttpMessageConverter</code>**：用于处理 JSON 数据，依赖于 Jackson 库。它可以将请求体中的 JSON 数据转换为 Java 对象，也能将 Java 对象转换为 JSON 响应。</li><li>**<code>Jaxb2RootElementHttpMessageConverter</code>**：用于处理 XML 数据，依赖于 JAXB（Java Architecture for XML Binding）库。它可以将请求体中的 XML 数据转换为 Java 对象，也能将 Java 对象转换为 XML 响应。</li></ul><ol start="6"><li>push推送至仓库</li></ol></blockquote><h4 id="3-启用禁用员工账号"><a href="#3-启用禁用员工账号" class="headerlink" title="3.启用禁用员工账号"></a>3.启用禁用员工账号</h4><p><img src="/.com//image-20250330141107395.png" alt="image-20250330141107395"></p><ul><li><p>业务规则：</p><ul><li><p>可以对状态为“启用”的员工账号进行“禁用”操作</p></li><li><p>可以对状态为“禁用”的员工账号进行“启用”操作</p></li><li><p>状态为“禁用”的员工账号不能登录系统</p></li></ul></li></ul><blockquote><ol><li>Controller层查询方式接收id,路径方式接收status</li><li>Service层封装employee对象（builder）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> Employee.builder()<br>               .status(status)<br>               .id(id)<br>               .updateTime(LocalDateTime.now())<br>               .updateUser(BaseContext.getCurrentId())<br>               .build();<br></code></pre></td></tr></table></figure><ol start="3"><li><p>Mapper层编写动态update语句（全局可用）</p></li><li><p>测试接口</p></li><li><p>push推送至仓库</p></li></ol></blockquote><h4 id="4-编辑员工"><a href="#4-编辑员工" class="headerlink" title="4.编辑员工"></a>4.编辑员工</h4><p><img src="/.com//image-20250330143100056.png" alt="image-20250330143100056"></p><ul><li><p>编辑员工功能涉及到两个接口：</p><ul><li>根据id查询员工信息</li></ul><blockquote><p>Controller层路径方式接收id</p><p>Service层调用mapper层查询返回参数并且处理参数（Employee接收的话，设置密码字段***）返回给controller</p><p>最终返回回显信息（Employee或者EmployeeVO）</p></blockquote><ul><li>编辑员工信息</li></ul><blockquote><p>Controller层请求体接收EmployeeDTO</p><p>Service层把DTO属性拷贝到实体对象，设置更新时间和更新用户id,最后调用之前编写的通用修改Mapper接口</p></blockquote></li><li><p>功能测试</p></li><li><p>push推送至仓库</p></li></ul><h3 id="2-2分类管理"><a href="#2-2分类管理" class="headerlink" title="2.2分类管理"></a>2.2分类管理</h3><p><img src="/.com//image-20250330144818179.png" alt="image-20250330144818179"></p><ul><li><p>业务规则：</p><ul><li><p>分类名称必须是唯一的</p></li><li><p>分类按照类型可以分为菜品分类和套餐分类</p></li><li><p>新添加的分类状态默认为“禁用”</p></li></ul></li><li><p>接口实现（与员工管理类似）</p></li></ul><blockquote><ol><li>新增菜品分类</li><li>菜品分类分页查询</li><li>菜品分类启用禁用</li><li>编辑菜品分类</li></ol></blockquote><h3 id="2-3公共字段填充"><a href="#2-3公共字段填充" class="headerlink" title="2.3公共字段填充"></a>2.3公共字段填充</h3><p><img src="/.com//image-20250401143636654.png" alt="image-20250401143636654"></p><ul><li>在server模块分别创建自定义注解包和切面类包</li></ul><p><img src="/.com//image-20250401143714369.png" alt="image-20250401143714369"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoFillAspect</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    切入点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">autoFillPointCut</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-meta">@Before(&quot;autoFillPointCut()&quot;)</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">autoFill</span><span class="hljs-params">(JoinPoint joinPoint)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;开始公共字段自动填充&quot;</span>);<br>        <span class="hljs-comment">//获取注解的值判断操作类型</span><br>        MethodSignature signature= (MethodSignature)joinPoint.getSignature();<span class="hljs-comment">//方法前面对象</span><br>        AutoFill autoFill=signature.getMethod().getAnnotation(AutoFill.class);<span class="hljs-comment">//获得方法上的注解对象</span><br>        OperationType operationType=autoFill.value();<span class="hljs-comment">//获取操作类型</span><br>        <span class="hljs-comment">//拿到所有的的参数,约定实体类参数放在第一位</span><br>        Object[] args=joinPoint.getArgs();<br>        <span class="hljs-comment">//判断是否有参数</span><br>        <span class="hljs-keyword">if</span>(args==<span class="hljs-literal">null</span>||args.length==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//拿到参数对应的set方法进行赋值</span><br>        <span class="hljs-comment">//获取参数对象</span><br>        Object entity=args[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//赋值的数据</span><br>        LocalDateTime now=LocalDateTime.now();<br>        Long currentId= BaseContext.getCurrentId();<br>        <span class="hljs-comment">//根据不同的操作类型赋值</span><br>        <span class="hljs-keyword">if</span>(operationType==OperationType.INSERT)&#123;<br>            <span class="hljs-comment">//为四个字段赋值</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                Method setCreateTime=entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME,LocalDateTime.class);<br>                Method setUpdateTime=entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME,LocalDateTime.class);<br>                Method setCreateUser=entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER,Long.class);<br>                Method setUpdateUser=entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER,Long.class);<br>                <span class="hljs-comment">//通过反射为对象属性赋值</span><br>                setCreateTime.invoke(entity,now);<br>                setUpdateTime.invoke(entity,now);<br>                setCreateUser.invoke(entity,currentId);<br>                setUpdateUser.invoke(entity,currentId);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(operationType==OperationType.UPDATE)&#123;<br>            <span class="hljs-comment">//为两个字段赋值</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                Method setUpdateTime=entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME,LocalDateTime.class);<br>                Method setUpdateUser=entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER,Long.class);<br>                <span class="hljs-comment">//通过反射为对象属性赋值</span><br>                setUpdateTime.invoke(entity,now);<br>                setUpdateUser.invoke(entity,currentId);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-菜品管理"><a href="#3-菜品管理" class="headerlink" title="3.菜品管理"></a>3.菜品管理</h2><h3 id="3-1新增菜品"><a href="#3-1新增菜品" class="headerlink" title="3.1新增菜品"></a>3.1新增菜品</h3><p><img src="/.com//image-20250401143752497.png" alt="image-20250401143752497"></p><p><img src="/.com//image-20250401143803809.png" alt="image-20250401143803809"></p><h3 id="3-2菜品分页查询"><a href="#3-2菜品分页查询" class="headerlink" title="3.2菜品分页查询"></a>3.2菜品分页查询</h3><p><img src="/.com//image-20250401143957274.png" alt="image-20250401143957274"></p><p><img src="/.com//image-20250401144006606.png" alt="image-20250401144006606"></p><h3 id="3-3批量删除菜品"><a href="#3-3批量删除菜品" class="headerlink" title="3.3批量删除菜品"></a>3.3批量删除菜品</h3><p><img src="/.com//image-20250401144029936.png" alt="image-20250401144029936"></p><p><img src="/.com//image-20250401144042811.png" alt="image-20250401144042811"></p><p><img src="/.com//image-20250401144215728.png" alt="image-20250401144215728"></p><h3 id="3-4修改菜品"><a href="#3-4修改菜品" class="headerlink" title="3.4修改菜品"></a>3.4修改菜品</h3><h3 id="3-5菜品起售停售"><a href="#3-5菜品起售停售" class="headerlink" title="3.5菜品起售停售"></a>3.5菜品起售停售</h3><h2 id="4-套餐管理"><a href="#4-套餐管理" class="headerlink" title="4.套餐管理"></a>4.套餐管理</h2><ul><li>新增套餐</li><li>套餐分页查询</li><li>删除套餐</li><li>修改套餐</li><li>起售停售套餐</li></ul><h2 id="5-店铺营业状态设置"><a href="#5-店铺营业状态设置" class="headerlink" title="5.店铺营业状态设置"></a>5.店铺营业状态设置</h2><p><img src="/.com//image-20250402165143761.png" alt="image-20250402165143761"></p><p><img src="/.com//image-20250402165350874.png" alt="image-20250402165350874"></p><p><img src="/.com//image-20250402165503172.png" alt="image-20250402165503172"></p><blockquote><ul><li>管理端</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-meta">@Slf4j</span><br>&gt;<span class="hljs-meta">@RestController(&quot;adminShopController&quot;)</span><br>&gt;<span class="hljs-meta">@RequestMapping(&quot;/admin/shop&quot;)</span><br>&gt;<span class="hljs-meta">@Api(tags=&quot;店铺相关接口&quot;)</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShopController</span> &#123;<br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String KEY=<span class="hljs-string">&quot;SHOP_STATUS&quot;</span>;<br><br>&gt;<span class="hljs-meta">@Autowired</span><br>&gt;<span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 设置店铺营业状态</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> status</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@PutMapping(&quot;/&#123;status&#125;&quot;)</span><br>   <span class="hljs-meta">@ApiOperation(value=&quot;设置店铺营业状态&quot;)</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">setStatus</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer status)</span>&#123;<br>       log.info(<span class="hljs-string">&quot;设置店铺营业状态为&#123;&#125;&quot;</span>,status==<span class="hljs-number">1</span>?<span class="hljs-string">&quot;营业中&quot;</span>:<span class="hljs-string">&quot;打烊中&quot;</span>);<br>       <span class="hljs-type">ValueOperations</span> <span class="hljs-variable">valueOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue();<br>       valueOperations.set(KEY,status);<br>       <span class="hljs-keyword">return</span> Result.success();<br>   &#125;<br><br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 查询店铺的营业状态</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@GetMapping(&quot;/status&quot;)</span><br>   <span class="hljs-meta">@ApiOperation(value=&quot;管理端查询店铺的营业状态&quot;)</span><br>   <span class="hljs-keyword">public</span> Result&lt;Integer&gt; <span class="hljs-title function_">getStatus</span><span class="hljs-params">()</span>&#123;<br>       log.info(<span class="hljs-string">&quot;查询店铺的营业状态&quot;</span>);<br>       <span class="hljs-type">ValueOperations</span> <span class="hljs-variable">valueOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue();<br>       <span class="hljs-type">Integer</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> (Integer) valueOperations.get(KEY);<br>       <span class="hljs-keyword">return</span> Result.success(status);<br>   &#125;<br><br><br>&gt;&#125;<br></code></pre></td></tr></table></figure><ul><li>用户端</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-meta">@Slf4j</span><br>&gt;<span class="hljs-meta">@RestController(&quot;userShopController&quot;)</span><br>&gt;<span class="hljs-meta">@RequestMapping(&quot;/user/shop&quot;)</span><br>&gt;<span class="hljs-meta">@Api(tags = &quot;店铺相关接口&quot;)</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShopController</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SHOP_STATUS&quot;</span>;<br>   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 查询店铺的营业状态</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@GetMapping(&quot;/status&quot;)</span><br>   <span class="hljs-meta">@ApiOperation(value = &quot;用户端查询店铺的营业状态&quot;)</span><br>   <span class="hljs-keyword">public</span> Result&lt;Integer&gt; <span class="hljs-title function_">getStatus</span><span class="hljs-params">()</span> &#123;<br>       log.info(<span class="hljs-string">&quot;查询店铺的营业状态&quot;</span>);<br>       <span class="hljs-type">ValueOperations</span> <span class="hljs-variable">valueOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue();<br>       <span class="hljs-type">Integer</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> (Integer) valueOperations.get(KEY);<br>       <span class="hljs-keyword">return</span> Result.success(status);<br>   &#125;<br><br><br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="6-数据统计"><a href="#6-数据统计" class="headerlink" title="6.数据统计"></a>6.数据统计</h2><ul><li>前端基于Apache ECharts实现</li></ul><h3 id="1-营业额统计"><a href="#1-营业额统计" class="headerlink" title="1.营业额统计"></a>1.营业额统计</h3><p><img src="/.com//image-20250421201619654.png" alt="image-20250421201619654"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// TODO 待优化</span><br>   <span class="hljs-keyword">public</span> TurnoverReportVO <span class="hljs-title function_">getTurnOverStatistics</span><span class="hljs-params">(LocalDate begin, LocalDate end)</span> &#123;<br><br>       List&lt;LocalDate&gt; dataList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>       List&lt;BigDecimal&gt; turnoverList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>       <span class="hljs-comment">//赋值查询当天的营业额</span><br>       <span class="hljs-keyword">while</span>(!begin.isAfter(end))&#123;<br>           dataList.add(begin);<br>           LocalDateTime timest= begin.atStartOfDay();<br>           LocalDateTime timend=timest.plusDays(<span class="hljs-number">1</span>);<br>           <span class="hljs-comment">//查询checkout_time在timest和timend之间完成的订单的营业额之和</span><br>           <span class="hljs-comment">//select sum(amount) from orders  where checkout_time between timest and timend  and status=5</span><br>           BigDecimal amount=orderMapper.getAmountByDate(timest,timend);<br>           <span class="hljs-keyword">if</span>(amount!=<span class="hljs-literal">null</span>)&#123;<br>               turnoverList.add(amount);<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               turnoverList.add(BigDecimal.ZERO);<br>           &#125;<br>           begin=begin.plusDays(<span class="hljs-number">1</span>);<br>       &#125;<br><br>       <span class="hljs-comment">//转为JSON字符串</span><br>       String dataListStr= StringUtils.join(dataList,<span class="hljs-string">&quot;,&quot;</span>);<br>       String turnoverListStr=StringUtils.join(turnoverList,<span class="hljs-string">&quot;,&quot;</span>);<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TurnoverReportVO</span>(dataListStr,turnoverListStr);<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="2-用户统计"><a href="#2-用户统计" class="headerlink" title="2.用户统计"></a>2.用户统计</h3><p><img src="/.com//image-20250421213952378.png" alt="image-20250421213952378"></p><p><img src="/.com//image-20250421214031418.png" alt="image-20250421214031418"></p><h3 id="3-订单统计"><a href="#3-订单统计" class="headerlink" title="3.订单统计"></a>3.订单统计</h3><p><img src="/.com//image-20250421223147270.png" alt="image-20250421223147270"></p><p><img src="/.com//image-20250421223216523-17452459372291.png" alt="image-20250421223216523"></p><h3 id="4-销量排名统计"><a href="#4-销量排名统计" class="headerlink" title="4.销量排名统计"></a>4.销量排名统计</h3><p><img src="/.com//image-20250421233336252.png" alt="image-20250421233336252"></p><p><img src="/.com//image-20250421233405497.png" alt="image-20250421233405497"></p><h3 id="5-excel报表导出"><a href="#5-excel报表导出" class="headerlink" title="5.excel报表导出"></a>5.excel报表导出</h3><p><img src="/.com//image-20250422194408159.png" alt="image-20250422194408159"></p><p><img src="/.com//image-20250422194429813.png" alt="image-20250422194429813"></p><ul><li>入门案例</li></ul><blockquote><ul><li>写</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">//通过POI创建Excel文件并且写入文件内容</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception&#123;<br> <span class="hljs-comment">//创建文件</span><br>   XSSFWorkbook myExcel=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XSSFWorkbook</span>();<br> <span class="hljs-comment">//在Excel文件中创建一个Sheet页</span><br>   XSSFSheet sheet=myExcel.createsheet(<span class="hljs-string">&quot;Sheet1&quot;</span>);<br> <span class="hljs-comment">//在Sheet页中创建行对象，编号从0开始</span><br>   <span class="hljs-comment">//创建第二行</span><br>   XSSRow row=sheet.createRow(<span class="hljs-number">1</span>);<span class="hljs-comment">//第2行</span><br> <span class="hljs-comment">//在该行创建单元格对象,并且写入内容</span><br>   row.createCell(<span class="hljs-number">1</span>).setCellValue(<span class="hljs-string">&quot;姓名&quot;</span>);<span class="hljs-comment">//创建第2个单元格并且写入内容</span><br>   row.createCell(<span class="hljs-number">2</span>).setCellValue(<span class="hljs-string">&quot;城市&quot;</span>);<span class="hljs-comment">//第三个单元格</span><br>   <span class="hljs-comment">//创建第三行</span><br>    XSSRow row=sheet.createRow(<span class="hljs-number">2</span>);<span class="hljs-comment">//第3行</span><br>   row.createCell(<span class="hljs-number">1</span>).setCellValue(<span class="hljs-string">&quot;坤坤&quot;</span>);<span class="hljs-comment">//创建第2个单元格并且写入内容</span><br>   row.createCell(<span class="hljs-number">2</span>).setCellValue(<span class="hljs-string">&quot;鸡太美&quot;</span>);<span class="hljs-comment">//第三个单元格</span><br>   <span class="hljs-comment">//（当前在内存）写入磁盘文件-通过输出流</span><br>   FileOutputStream out=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:\\temporary_memory\\myExcel.xlsx&quot;</span>));<br>   myExcel.write(out);<br>   <span class="hljs-comment">//关闭资源</span><br>   out.close();<br>   myExcel.close();<br>&gt;&#125;<br></code></pre></td></tr></table></figure><ul><li>读</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Read</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception&#123;<br>&gt;FileInputStream input=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:\\temporary_memory\\myExcel.xlsx&quot;</span>))<br>   <span class="hljs-comment">//传入一个输入流来读取该输入流的内容</span><br>   XSSFWorkbook myExcel=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XSSFWorkbook</span>(input);<br>   <span class="hljs-comment">//读取Excel文件的第一个Sheet页</span><br>   XSSFSheet sheet=myExcel.getSheetAt(<span class="hljs-number">0</span>);<br>   <span class="hljs-comment">//获得最后一行的行号</span><br>   <span class="hljs-type">int</span> lastRowNum=sheet.getLastRowNum();<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=lastRowNum;i++)&#123;<span class="hljs-comment">//从第二行开始</span><br>       <span class="hljs-comment">//获取某一行</span><br>       XSSRow row=sheet.getRow(i);<br>       <span class="hljs-comment">//获得单元格对象</span><br>       String cellValue1=row.getCell(<span class="hljs-number">1</span>).getStringCellValue();<br>          String cellValue2=row.getCell(<span class="hljs-number">2</span>).getStringCellValue();<br>       System.out.println(cellValue1+<span class="hljs-string">&quot; &quot;</span>+cellValue2);<br>   &#125;<br>   <span class="hljs-comment">//关闭资源</span><br>   input.close(); <br>   myExcel.close();<br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><p><img src="/.com//image-20250422201238203.png" alt="image-20250422201238203"></p><p><img src="/.com//image-20250422201252345.png" alt="image-20250422201252345"></p><p><img src="/.com//image-20250422201529317.png" alt="image-20250422201529317"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 导出运营报表</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exportBusinessData</span><span class="hljs-params">(HttpServletResponse response)</span> &#123;<br>       <span class="hljs-comment">//1.查询数据库最近三十天的运营数据</span><br>       LocalDateTime begin=LocalDate.now().minusDays(<span class="hljs-number">30</span>).atStartOfDay();<br>       <span class="hljs-comment">//LocalDateTime begin1=LocalDateTime.of(LocalDate.now().minusDays(30), LocalTime.MIN);</span><br>       LocalDateTime end=LocalDate.now().atStartOfDay();<br>      <span class="hljs-comment">//LocalDateTime end1=LocalDateTime.of(LocalDate.now(),LocalTime.MIN);</span><br>       BusinessDataVO businessDataVO=workspaceService.getBusinessData(begin,end);<br><br>       <span class="hljs-comment">//2.通过POI写入Excel文件</span><br><br>       <span class="hljs-comment">//通过反射和类加载器获取模板文件的输r流</span><br>       InputStream in=<span class="hljs-built_in">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;template/运营数据报表模板.xlsx&quot;</span>);<br><br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">//基于模板文件创建一个新的Excel文件</span><br>           XSSFWorkbook excel=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XSSFWorkbook</span>(in);<br>           <span class="hljs-comment">//数据填充</span><br>           <span class="hljs-comment">//获取标签页和行,并且填充</span><br>           <span class="hljs-comment">//时间</span><br>           XSSFSheet sheet=excel.getSheet(<span class="hljs-string">&quot;Sheet1&quot;</span>);<br>           sheet.getRow(<span class="hljs-number">1</span>).getCell(<span class="hljs-number">1</span>).setCellValue(<span class="hljs-string">&quot;时间： &quot;</span>+begin+<span class="hljs-string">&quot; 至 &quot;</span>+end);<br>           <span class="hljs-comment">//概览数据</span><br>           <span class="hljs-comment">//第四行</span><br>           XSSFRow row=sheet.getRow(<span class="hljs-number">3</span>);<br>           row.getCell(<span class="hljs-number">2</span>).setCellValue(businessDataVO.getTurnover());<br>           row.getCell(<span class="hljs-number">4</span>).setCellValue(businessDataVO.getOrderCompletionRate());<br>           row.getCell(<span class="hljs-number">6</span>).setCellValue(businessDataVO.getNewUsers());<br>           <span class="hljs-comment">//第五行</span><br>           row=sheet.getRow(<span class="hljs-number">4</span>);<br>           row.getCell(<span class="hljs-number">2</span>).setCellValue(businessDataVO.getValidOrderCount());<br>           row.getCell(<span class="hljs-number">4</span>).setCellValue(businessDataVO.getUnitPrice());<br><br>           <span class="hljs-comment">//循环填充</span><br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">30</span>;i++)&#123;<br><br>               BusinessDataVO businessDataVO1=workspaceService.getBusinessData(begin,begin.plusDays(<span class="hljs-number">1</span>));<br>               <span class="hljs-comment">//从第八行开始填充</span><br>               <span class="hljs-type">XSSFRow</span> <span class="hljs-variable">row1</span> <span class="hljs-operator">=</span> sheet.getRow(<span class="hljs-number">7</span> + i);<br>               row1.getCell(<span class="hljs-number">1</span>).setCellValue(begin.toLocalDate().toString());<br>               row1.getCell(<span class="hljs-number">2</span>).setCellValue(businessDataVO1.getTurnover());<br>               row1.getCell(<span class="hljs-number">3</span>).setCellValue(businessDataVO1.getValidOrderCount());<br>               row1.getCell(<span class="hljs-number">4</span>).setCellValue(businessDataVO1.getOrderCompletionRate());<br>               row1.getCell(<span class="hljs-number">5</span>).setCellValue(businessDataVO1.getUnitPrice());<br>               row1.getCell(<span class="hljs-number">6</span>).setCellValue(businessDataVO1.getNewUsers());<br>               begin=begin.plusDays(<span class="hljs-number">1</span>);<br>           &#125;<br>           <span class="hljs-comment">//3.通过输出流将文件下载到客户端浏览器</span><br>           ServletOutputStream out= response.getOutputStream();<br>           excel.write(out);<br><br>       &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>           e.printStackTrace();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="6-工作台"><a href="#6-工作台" class="headerlink" title="6.工作台"></a>6.工作台</h2><p><img src="/.com//image-20250422191241564.png" alt="image-20250422191241564"></p><p><img src="/.com//image-20250422191611296.png" alt="image-20250422191611296"></p><h2 id="用户端"><a href="#用户端" class="headerlink" title="用户端"></a>用户端</h2><h2 id="1-微信登陆"><a href="#1-微信登陆" class="headerlink" title="1.微信登陆"></a>1.微信登陆</h2><ul><li>登录流程</li></ul><p><img src="/.com//image-20250415191931080.png" alt="image-20250415191931080"></p><p><img src="/.com//image-20250403163503313.png" alt="image-20250403163503313"></p><p><img src="/.com//image-20250403163538085.png" alt="image-20250403163538085"></p><p><img src="/.com//image-20250403163627912.png" alt="image-20250403163627912"></p><ul><li>整体流程：微信小程序登录申请code码，HttpClient发送请求到微信登录官方提供的接口获取到openid</li></ul><p><img src="/.com//image-20250403163855491.png" alt="image-20250403163855491"></p><p><img src="/.com//image-20250403163907748.png" alt="image-20250403163907748"></p><ul><li>创建拦截器，校验后续小程序的请求令牌</li></ul><blockquote><p>创建拦截器，进入前校验令牌，设置localthread变量</p><p>配置类注册拦截器（login，status以外需要拦截）</p></blockquote><blockquote><p>Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-meta">@RestController</span><br>&gt;<span class="hljs-meta">@RequestMapping(&quot;/user/user&quot;)</span><br>&gt;<span class="hljs-meta">@Api(tags=&quot;用户端用户相关接口&quot;)</span><br>&gt;<span class="hljs-meta">@Slf4j</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>&gt;<span class="hljs-meta">@Autowired</span><br>&gt;<span class="hljs-keyword">private</span> UserService userService;<br>&gt;<span class="hljs-meta">@Autowired</span><br>&gt;<span class="hljs-keyword">private</span> JwtProperties jwtProperties;<br><br>   <span class="hljs-meta">@ApiOperation(&quot;用户端登录操作&quot;)</span><br>   <span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span><br>   <span class="hljs-keyword">public</span> Result&lt;UserLoginVO&gt; <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> UserLoginDTO userLoginDTO)</span>&#123;<br>       log.info(<span class="hljs-string">&quot;用户端登录：&#123;&#125;&quot;</span>,userLoginDTO);<br>       <span class="hljs-comment">//继续调用Service进行登录-获取openid</span><br>       User user=userService.wxLogin(userLoginDTO);<br>       <span class="hljs-comment">//登录成功,创建JWT令牌并且封装</span><br>       Map&lt;String,Object&gt; claims=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>       claims.put(JwtClaimsConstant.USER_ID,user.getId());<br>       String token=JwtUtil.createJWT(jwtProperties.getUserSecretKey(), jwtProperties.getAdminTtl(),claims);<br><br>       UserLoginVO userLoginVO=UserLoginVO.builder()<br>               .id(user.getId())<br>               .openid(user.getOpenid())<br>               .token(token)<br>               .build();<br>       <span class="hljs-keyword">return</span> Result.success(userLoginVO);<br>   &#125;<br>   <br>&gt;&#125;<br><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>ServiceImpl  - 使用HttpClient模拟客户端发送请求获取openid</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> WeChatProperties weChatProperties;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String WX_LoginUrl=<span class="hljs-string">&quot;https://api.weixin.qq.com/sns/jscode2session&quot;</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户进行微信登录</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userLoginDTO</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>   <span class="hljs-keyword">public</span> User <span class="hljs-title function_">wxLogin</span><span class="hljs-params">(UserLoginDTO userLoginDTO)</span>&#123;<br>       String openid=getOpenid(userLoginDTO.getCode());<br>       <span class="hljs-comment">//判断openid是否为空，如果为空表示登录失败，抛出业务异常</span><br>       <span class="hljs-keyword">if</span>(openid==<span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginFailedException</span>(<span class="hljs-string">&quot;登录失败&quot;</span>);<br>       &#125;<br>       <span class="hljs-comment">//判断用户是否为新用户,如果是新用户，自动完成注册</span><br>       User user=userMapper.getByOpenid(openid);<br>       <span class="hljs-keyword">if</span>(user==<span class="hljs-literal">null</span>)&#123;<br>           user=User.builder()<br>                   .openid(openid)<br>                   .createTime(LocalDateTime.now())<br>                   .build();<br>           userMapper.insert(user);<br>       &#125;<br>       <span class="hljs-comment">//返回用户对象</span><br>       <span class="hljs-keyword">return</span> user;<br>   &#125;<br><br><br>   <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getOpenid</span><span class="hljs-params">(String code)</span>&#123;<br>       <span class="hljs-comment">//HttpClient发送请求调用微信接口服务获取openid</span><br>       Map&lt;String,String&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>       map.put(<span class="hljs-string">&quot;appid&quot;</span>,weChatProperties.getAppid());<br>       map.put(<span class="hljs-string">&quot;secret&quot;</span>,weChatProperties.getSecret());<br>       map.put(<span class="hljs-string">&quot;js_code&quot;</span>,code);<br>       map.put(<span class="hljs-string">&quot;grant_type&quot;</span>,<span class="hljs-string">&quot;authorization_code&quot;</span>);<br>       String json=HttpClientUtil.doGet(WX_LoginUrl,map);<br>       <span class="hljs-comment">//json字符串转JsonObject</span><br>       JSONObject jsonObject= JSON.parseObject(json);<br>       String openid=jsonObject.getString(<span class="hljs-string">&quot;openid&quot;</span>);<br>       <span class="hljs-keyword">return</span> openid;<br>   &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote><h2 id="2-商品浏览"><a href="#2-商品浏览" class="headerlink" title="2.商品浏览"></a>2.商品浏览</h2><p><img src="/.com//image-20250415212927359.png" alt="image-20250415212927359"></p><p><img src="/.com//image-20250415213059280.png" alt="image-20250415213059280"></p><h2 id="3-缓存菜品和套餐"><a href="#3-缓存菜品和套餐" class="headerlink" title="3.缓存菜品和套餐"></a>3.缓存菜品和套餐</h2><h3 id="1-缓存菜品"><a href="#1-缓存菜品" class="headerlink" title="1.缓存菜品"></a>1.缓存菜品</h3><p><img src="/.com//image-20250416201152802.png" alt="image-20250416201152802"></p><p>系统响应慢</p><p><img src="/.com//image-20250416201329928.png" alt="image-20250416201329928"></p><p><img src="/.com//image-20250416201605017.png" alt="image-20250416201605017"></p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-meta">@RestController(&quot;userDishController&quot;)</span><br>&gt;<span class="hljs-meta">@RequestMapping(&quot;/user/dish&quot;)</span><br>&gt;<span class="hljs-meta">@Slf4j</span><br>&gt;<span class="hljs-meta">@Api(tags = &quot;C端-菜品浏览接口&quot;)</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DishController</span> &#123;<br>   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> DishService dishService;<br>   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据分类id查询菜品</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> categoryId</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>   <span class="hljs-meta">@ApiOperation(&quot;根据分类id查询菜品&quot;)</span><br>   <span class="hljs-keyword">public</span> Result&lt;List&lt;DishVO&gt;&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Long categoryId)</span> &#123;<br>       log.info(<span class="hljs-string">&quot;查询分类id为&#123;&#125;下的菜品&quot;</span>,categoryId);<br>       <span class="hljs-comment">//构造redis中的key,规则：dish_分类id</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dish_&quot;</span> + categoryId;<br><br>       <span class="hljs-comment">//查询redis是否存在菜品数据</span><br><br>       List&lt;DishVO&gt; list = (List&lt;DishVO&gt;) redisTemplate.opsForValue().get(key);<br>       <span class="hljs-comment">//如果存在直接返回redis中的数据</span><br>       <span class="hljs-keyword">if</span> (list != <span class="hljs-literal">null</span> &amp;&amp; list.size() &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">return</span> Result.success(list);<br>       &#125;<br>       <span class="hljs-comment">//如果不存在，查询数据库，将查询的数据返回并且放入redis中</span><br>       <span class="hljs-type">Dish</span> <span class="hljs-variable">dish</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dish</span>();<br>       dish.setCategoryId(categoryId);<br>       dish.setStatus(StatusConstant.ENABLE);<span class="hljs-comment">//查询起售中的菜品</span><br>       list = dishService.listWithFlavor(dish);<br>       redisTemplate.opsForValue().set(key, list);<br>       <span class="hljs-keyword">return</span> Result.success(list);<br>   &#125;<br><br>&gt;&#125;<br><br></code></pre></td></tr></table></figure><p>未清理缓存–存在问题–”数据的不一致”</p><p><img src="/.com//image-20250416204853972.png" alt="image-20250416204853972"></p></blockquote><h3 id="2-缓存套餐"><a href="#2-缓存套餐" class="headerlink" title="2.缓存套餐"></a>2.缓存套餐</h3><p><img src="/.com//image-20250416213433448.png" alt="image-20250416213433448"></p><h2 id="4-购物车"><a href="#4-购物车" class="headerlink" title="4.购物车"></a>4.购物车</h2><h3 id="1-添加购物车"><a href="#1-添加购物车" class="headerlink" title="1.添加购物车"></a>1.添加购物车</h3><p><img src="/.com//image-20250416215115365.png" alt="image-20250416215115365"></p><p><img src="/.com//image-20250416215239482.png" alt="image-20250416215239482"></p><ul><li>设计冗余字段提高查询速度</li></ul><blockquote><p>实现逻辑：</p><ul><li><p>判断当前购物车是否已经存在（动态条件查询）</p></li><li><p>如果存在，只需要将数量加一</p></li><li><p>如果不存在，再插入一条购物车数据</p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加购物车</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> shoppingCartDTO</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addShoppingCart</span><span class="hljs-params">(ShoppingCartDTO shoppingCartDTO)</span> &#123;<br><span class="hljs-comment">//菜品id,套餐id,菜品口味</span><br>        <span class="hljs-comment">//拷贝属性</span><br>        <span class="hljs-type">ShoppingCart</span> <span class="hljs-variable">shoppingCart</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShoppingCart</span>();<br>        BeanUtils.copyProperties(shoppingCartDTO, shoppingCart);<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> BaseContext.getCurrentId();<br>        shoppingCart.setUserId(userId);<br>        List&lt;ShoppingCart&gt; shoppingCartList = shoppingCartMapper.list(shoppingCart);<br>        <span class="hljs-comment">//判断购物车是否存在</span><br>        <span class="hljs-keyword">if</span> (shoppingCartList != <span class="hljs-literal">null</span> &amp;&amp; shoppingCartList.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//如果存在(只有一条数据)，只需要将数量加一</span><br>            <span class="hljs-type">ShoppingCart</span> <span class="hljs-variable">cart</span> <span class="hljs-operator">=</span> shoppingCartList.get(<span class="hljs-number">0</span>);<br>            cart.setNumber(cart.getNumber() + <span class="hljs-number">1</span>);<span class="hljs-comment">//update shopping_cart set number=#&#123;number&#125; where id=?</span><br>            shoppingCartMapper.updateNumberById(cart);<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果不存在，再插入一条购物车数据</span><br>            <span class="hljs-comment">//完善购物车信息</span><br>            <span class="hljs-comment">//菜品还是套餐</span><br>            <span class="hljs-type">Long</span> <span class="hljs-variable">dishId</span> <span class="hljs-operator">=</span> shoppingCartDTO.getDishId();<br>            <span class="hljs-keyword">if</span> (dishId != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//本次添加的购物车为菜品-补充信息name,amount,number,image,createTime</span><br>                <span class="hljs-type">Dish</span> <span class="hljs-variable">dish</span> <span class="hljs-operator">=</span> dishMapper.getById(dishId);<br>                shoppingCart.setName(dish.getName());<br>                shoppingCart.setImage(dish.getImage());<br>                shoppingCart.setAmount(dish.getPrice());<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//添加的是套餐</span><br>                <span class="hljs-type">Long</span> <span class="hljs-variable">setmealId</span> <span class="hljs-operator">=</span> shoppingCartDTO.getSetmealId();<br>                <span class="hljs-type">Setmeal</span> <span class="hljs-variable">setmeal</span> <span class="hljs-operator">=</span> setmealMapper.getById(setmealId);<br>                shoppingCart.setName(setmeal.getName());<br>                shoppingCart.setImage(setmeal.getImage());<br>                shoppingCart.setAmount(setmeal.getPrice());<br>            &#125;<br>            shoppingCart.setNumber(<span class="hljs-number">1</span>);<br>            shoppingCart.setCreateTime(LocalDateTime.now());<br>            shoppingCartMapper.insert(shoppingCart);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2-查看购物车"><a href="#2-查看购物车" class="headerlink" title="2.查看购物车"></a>2.查看购物车</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 查看购物车</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> List&lt;ShoppingCart&gt; <span class="hljs-title function_">showShopingCart</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-comment">//获取userId,查看对应的购物车信息</span><br>       Long userId=BaseContext.getCurrentId();<br>       ShoppingCart shoppingCart=ShoppingCart.builder()<br>               .userId(userId)<br>               .build();<br>       List&lt;ShoppingCart&gt; list=shoppingCartMapper.list(shoppingCart);<br>       <span class="hljs-keyword">return</span> list;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="3-清空购物车"><a href="#3-清空购物车" class="headerlink" title="3.清空购物车"></a>3.清空购物车</h3><p><img src="/.com//image-20250418123345956.png" alt="image-20250418123345956"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 清空购物车</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanShoppingCart</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//获取当前的userId</span><br>        Long userId=BaseContext.getCurrentId();<br>        shoppingCartMapper.deleteByUserId(userId);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>购物车份量减一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     *份量减一</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">subShoppingCart</span><span class="hljs-params">(ShoppingCartDTO shoppingCartDTO)</span>&#123;<br>        <span class="hljs-comment">//拷贝属性</span><br>        <span class="hljs-type">ShoppingCart</span> <span class="hljs-variable">shoppingCart</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShoppingCart</span>();<br>        BeanUtils.copyProperties(shoppingCartDTO, shoppingCart);<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> BaseContext.getCurrentId();<br>        shoppingCart.setUserId(userId);<br>        List&lt;ShoppingCart&gt; shoppingCartList = shoppingCartMapper.list(shoppingCart);<br>        <span class="hljs-keyword">if</span> (shoppingCartList != <span class="hljs-literal">null</span> &amp;&amp; shoppingCartList.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//如果存在，只需要将数量减一</span><br>            <span class="hljs-type">ShoppingCart</span> <span class="hljs-variable">cart</span> <span class="hljs-operator">=</span> shoppingCartList.get(<span class="hljs-number">0</span>);<br>            cart.setNumber(cart.getNumber() -<span class="hljs-number">1</span>);<span class="hljs-comment">//update shopping_cart set number=#&#123;number&#125; where id=?</span><br>            shoppingCartMapper.updateNumberById(cart);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="5-用户下单和支付"><a href="#5-用户下单和支付" class="headerlink" title="5.用户下单和支付"></a>5.用户下单和支付</h2><h3 id="1-地址簿功能代码"><a href="#1-地址簿功能代码" class="headerlink" title="1.地址簿功能代码"></a>1.地址簿功能代码</h3><p><img src="/.com//image-20250418125752392.png" alt="image-20250418125752392"></p><h3 id="2-用户下单"><a href="#2-用户下单" class="headerlink" title="2.用户下单"></a>2.用户下单</h3><ul><li>表设计：一个订单表对应多个订单明细表</li></ul><p><img src="/.com//image-20250418201236284.png" alt="image-20250418201236284"></p><p><img src="/.com//image-20250418201346308.png" alt="image-20250418201346308"></p><ul><li>DTO和VO设计</li></ul><p><img src="/.com//image-20250418201433089.png" alt="image-20250418201433089"></p><p><img src="/.com//image-20250418201457699.png" alt="image-20250418201457699"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户下单</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ordersSubmitDTO</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Transactional(rollbackFor = &#123;Exception.class&#125;)</span><br>    <span class="hljs-keyword">public</span> OrderSubmitVO <span class="hljs-title function_">submit</span><span class="hljs-params">(OrdersSubmitDTO ordersSubmitDTO)</span> &#123;<br>        <span class="hljs-comment">//1.各种业务异常（地址簿为空，购物车数据异常）</span><br>        AddressBook addressBook=addressBookMapper.getById(ordersSubmitDTO.getAddressBookId());<br>        <span class="hljs-keyword">if</span>(addressBook==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddressBookBusinessException</span>(MessageConstant.ADDRESS_BOOK_IS_NULL);<br>        &#125;<br>        Long userId= BaseContext.getCurrentId();<br>        ShoppingCart shoppingCart=ShoppingCart.builder()<br>                .userId(userId)<br>                .build();<br>        List&lt;ShoppingCart&gt; list= shoppingCartMapper.list(shoppingCart);<br>        <span class="hljs-keyword">if</span>(list==<span class="hljs-literal">null</span>||list.size()==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShoppingCartBusinessException</span>(MessageConstant.SHOPPING_CART_IS_NULL);<br>        &#125;<br>        <span class="hljs-comment">//2.向订单表插入一条数据</span><br>        Orders orders=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Orders</span>();<br>        BeanUtils.copyProperties(ordersSubmitDTO,orders);<br>        orders.setOrderTime(LocalDateTime.now());<br>        orders.setPayStatus(Orders.UN_PAID);<span class="hljs-comment">//未支付</span><br>        orders.setStatus(Orders.PENDING_PAYMENT);<span class="hljs-comment">//待付款</span><br>        <span class="hljs-comment">//使用hutool工具包的雪花算法获取订单号</span><br>        <span class="hljs-comment">// 创建 Snowflake 实例</span><br>        <span class="hljs-type">Snowflake</span> <span class="hljs-variable">snowflake</span> <span class="hljs-operator">=</span> IdUtil.createSnowflake(<span class="hljs-number">1</span>,userId);<br>        <span class="hljs-comment">// 生成唯一 ID</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> snowflake.nextId();<br>        String orderNumber=orderId.toString();<br>        orders.setNumber(orderNumber);<span class="hljs-comment">//订单号</span><br>        orders.setPhone(addressBook.getPhone());<span class="hljs-comment">//手机号</span><br>        orders.setUserId(userId);<br><br>        orderMapper.insert(orders);<span class="hljs-comment">//返回主键值</span><br>        <span class="hljs-comment">//3.向订单明细表插入多条数据</span><br>        List&lt;OrderDetail&gt; orderDetailList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(ShoppingCart Cart :list)&#123;<br>            OrderDetail orderDetail=<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderDetail</span>();<span class="hljs-comment">//订单明细</span><br>            BeanUtils.copyProperties(Cart,orderDetail);<span class="hljs-comment">//拷贝属性</span><br>            orderDetail.setOrderId(orders.getId());<span class="hljs-comment">//设置当前的订单明细关联的订单id</span><br>            orderDetailList.add(orderDetail);<br>        &#125;<br>        <span class="hljs-comment">//批量插入</span><br>        orderDetailMapper.insertBatch(orderDetailList);<br><br>        <span class="hljs-comment">//4.清空购物车数据</span><br>        shoppingCartMapper.deleteByUserId(userId);<br><br>        <span class="hljs-comment">//5.封装VO结果</span><br>        OrderSubmitVO orderSubmitVO=OrderSubmitVO.builder()<br>                .id(orders.getId())<br>                .orderTime(orders.getOrderTime())<br>                .orderNumber(orders.getNumber())<br>                .orderAmount(orders.getAmount())<br>                .build();<br>        <span class="hljs-keyword">return</span> orderSubmitVO;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-订单支付-微信支付"><a href="#3-订单支付-微信支付" class="headerlink" title="3.订单支付-微信支付"></a>3.订单支付-微信支付</h3><p><img src="/.com//image-20250418214207711.png" alt="image-20250418214207711"></p><p>参考：<a href="https://pay.weixin.qq.com/static/product/product_index.shtml">https://pay.weixin.qq.com/static/product/product_index.shtml</a></p><p><img src="/.com//image-20250418214336219.png" alt="image-20250418214336219"></p><ul><li>预下单接口</li></ul><p><img src="/.com//image-20250418214801093.png" alt="image-20250418214801093"></p><ul><li>调用过程如何保证数据安全？</li></ul><p>两个密钥文件，商户私钥和微信支付平台证书</p><ul><li>微信后台如何调用到商户系统？</li></ul><p>内网穿透（分配临时的公网ip）</p><ul><li>微信支付的相关配置</li></ul><p><img src="/.com//image-20250418223842791.png" alt="image-20250418223842791"></p><blockquote><p>Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 订单支付</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> ordersPaymentDTO</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@PutMapping(&quot;/payment&quot;)</span><br>   <span class="hljs-meta">@ApiOperation(&quot;订单支付&quot;)</span><br>   <span class="hljs-keyword">public</span> Result&lt;OrderPaymentVO&gt; <span class="hljs-title function_">payment</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> OrdersPaymentDTO ordersPaymentDTO)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       log.info(<span class="hljs-string">&quot;订单支付：&#123;&#125;&quot;</span>, ordersPaymentDTO);<br>       <span class="hljs-type">OrderPaymentVO</span> <span class="hljs-variable">orderPaymentVO</span> <span class="hljs-operator">=</span> orderService.payment(ordersPaymentDTO);<br>       log.info(<span class="hljs-string">&quot;生成预支付交易单：&#123;&#125;&quot;</span>, orderPaymentVO);<br>       <span class="hljs-keyword">return</span> Result.success(orderPaymentVO);<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li>实现逻辑：</li><li>接收订单号和支付方式</li><li>调用Service层的payment接口</li></ul></blockquote><blockquote><p>ServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 订单支付</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> ordersPaymentDTO</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> OrderPaymentVO <span class="hljs-title function_">payment</span><span class="hljs-params">(OrdersPaymentDTO ordersPaymentDTO)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-comment">// 当前登录用户id</span><br>       <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> BaseContext.getCurrentId();<br>       <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.getById(userId);<br><br>       <span class="hljs-comment">//调用微信支付接口，生成预支付交易单</span><br>       <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> weChatPayUtil.pay(<br>               ordersPaymentDTO.getOrderNumber(), <span class="hljs-comment">//商户订单号</span><br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">0.01</span>), <span class="hljs-comment">//支付金额，单位 元</span><br>               <span class="hljs-string">&quot;苍穹外卖订单&quot;</span>, <span class="hljs-comment">//商品描述</span><br>               user.getOpenid() <span class="hljs-comment">//微信用户的openid</span><br>       );<br><br>       <span class="hljs-keyword">if</span> (jsonObject.getString(<span class="hljs-string">&quot;code&quot;</span>) != <span class="hljs-literal">null</span> &amp;&amp; jsonObject.getString(<span class="hljs-string">&quot;code&quot;</span>).equals(<span class="hljs-string">&quot;ORDERPAID&quot;</span>)) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderBusinessException</span>(<span class="hljs-string">&quot;该订单已支付&quot;</span>);<br>       &#125;<br><br>       <span class="hljs-type">OrderPaymentVO</span> <span class="hljs-variable">vo</span> <span class="hljs-operator">=</span> jsonObject.toJavaObject(OrderPaymentVO.class);<br>       vo.setPackageStr(jsonObject.getString(<span class="hljs-string">&quot;package&quot;</span>));<br><br>       <span class="hljs-keyword">return</span> vo;<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 支付成功，修改订单状态</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> outTradeNo</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paySuccess</span><span class="hljs-params">(String outTradeNo)</span> &#123;<br><br>       <span class="hljs-comment">// 根据订单号查询订单</span><br>       <span class="hljs-type">Orders</span> <span class="hljs-variable">ordersDB</span> <span class="hljs-operator">=</span> orderMapper.getByNumber(outTradeNo);<br><br>       <span class="hljs-comment">// 根据订单id更新订单的状态、支付方式、支付状态、结账时间</span><br>       <span class="hljs-type">Orders</span> <span class="hljs-variable">orders</span> <span class="hljs-operator">=</span> Orders.builder()<br>               .id(ordersDB.getId())<br>               .status(Orders.TO_BE_CONFIRMED)<br>               .payStatus(Orders.PAID)<br>               .checkoutTime(LocalDateTime.now())<br>               .build();<br><br>       orderMapper.update(orders);<br>   &#125;<br></code></pre></td></tr></table></figure><p>- </p></blockquote><blockquote><ul><li>微信支付工具类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">package</span> com.sky.utils;<br><br>&gt;<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br>&gt;<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONObject;<br>&gt;<span class="hljs-keyword">import</span> com.sky.properties.WeChatProperties;<br>&gt;<span class="hljs-keyword">import</span> com.wechat.pay.contrib.apache.httpclient.WechatPayHttpClientBuilder;<br>&gt;<span class="hljs-keyword">import</span> com.wechat.pay.contrib.apache.httpclient.util.PemUtil;<br>&gt;<span class="hljs-keyword">import</span> org.apache.commons.lang.RandomStringUtils;<br>&gt;<span class="hljs-keyword">import</span> org.apache.http.HttpHeaders;<br>&gt;<span class="hljs-keyword">import</span> org.apache.http.client.methods.CloseableHttpResponse;<br>&gt;<span class="hljs-keyword">import</span> org.apache.http.client.methods.HttpGet;<br>&gt;<span class="hljs-keyword">import</span> org.apache.http.client.methods.HttpPost;<br>&gt;<span class="hljs-keyword">import</span> org.apache.http.entity.ContentType;<br>&gt;<span class="hljs-keyword">import</span> org.apache.http.entity.StringEntity;<br>&gt;<span class="hljs-keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;<br>&gt;<span class="hljs-keyword">import</span> org.apache.http.util.EntityUtils;<br>&gt;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br>&gt;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br>&gt;<span class="hljs-keyword">import</span> java.io.File;<br>&gt;<span class="hljs-keyword">import</span> java.io.FileInputStream;<br>&gt;<span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br>&gt;<span class="hljs-keyword">import</span> java.math.BigDecimal;<br>&gt;<span class="hljs-keyword">import</span> java.security.PrivateKey;<br>&gt;<span class="hljs-keyword">import</span> java.security.Signature;<br>&gt;<span class="hljs-keyword">import</span> java.security.cert.X509Certificate;<br>&gt;<span class="hljs-keyword">import</span> java.util.ArrayList;<br>&gt;<span class="hljs-keyword">import</span> java.util.Arrays;<br>&gt;<span class="hljs-keyword">import</span> java.util.Base64;<br>&gt;<span class="hljs-keyword">import</span> java.util.List;<br><br>&gt;<span class="hljs-comment">/**</span><br><span class="hljs-comment">* 微信支付工具类</span><br><span class="hljs-comment">*/</span><br>&gt;<span class="hljs-meta">@Component</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeChatPayUtil</span> &#123;<br><br>   <span class="hljs-comment">//微信支付下单接口地址</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">JSAPI</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi&quot;</span>;<br><br>   <span class="hljs-comment">//申请退款接口地址</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">REFUNDS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://api.mch.weixin.qq.com/v3/refund/domestic/refunds&quot;</span>;<br><br>   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> WeChatProperties weChatProperties;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 获取调用微信接口的客户端工具对象</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> CloseableHttpClient <span class="hljs-title function_">getClient</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">PrivateKey</span> <span class="hljs-variable">merchantPrivateKey</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">//merchantPrivateKey商户API私钥，如何加载商户API私钥请看常见问题</span><br>           merchantPrivateKey = PemUtil.loadPrivateKey(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(weChatProperties.getPrivateKeyFilePath())));<br>           <span class="hljs-comment">//加载平台证书文件</span><br>           <span class="hljs-type">X509Certificate</span> <span class="hljs-variable">x509Certificate</span> <span class="hljs-operator">=</span> PemUtil.loadCertificate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(weChatProperties.getWeChatPayCertFilePath())));<br>           <span class="hljs-comment">//wechatPayCertificates微信支付平台证书列表。你也可以使用后面章节提到的“定时更新平台证书功能”，而不需要关心平台证书的来龙去脉</span><br>           List&lt;X509Certificate&gt; wechatPayCertificates = Arrays.asList(x509Certificate);<br><br>           <span class="hljs-type">WechatPayHttpClientBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> WechatPayHttpClientBuilder.create()<br>                   .withMerchant(weChatProperties.getMchid(), weChatProperties.getMchSerialNo(), merchantPrivateKey)<br>                   .withWechatPay(wechatPayCertificates);<br><br>           <span class="hljs-comment">// 通过WechatPayHttpClientBuilder构造的HttpClient，会自动的处理签名和验签</span><br>           <span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> builder.build();<br>           <span class="hljs-keyword">return</span> httpClient;<br>       &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>           e.printStackTrace();<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 发送post方式请求</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> url</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> body</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> String <span class="hljs-title function_">post</span><span class="hljs-params">(String url, String body)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> getClient();<br><br>       <span class="hljs-type">HttpPost</span> <span class="hljs-variable">httpPost</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpPost</span>(url);<br>       httpPost.addHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.toString());<br>       httpPost.addHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.toString());<br>       httpPost.addHeader(<span class="hljs-string">&quot;Wechatpay-Serial&quot;</span>, weChatProperties.getMchSerialNo());<br>       httpPost.setEntity(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEntity</span>(body, <span class="hljs-string">&quot;UTF-8&quot;</span>));<br><br>       <span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpClient.execute(httpPost);<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">bodyAsString</span> <span class="hljs-operator">=</span> EntityUtils.toString(response.getEntity());<br>           <span class="hljs-keyword">return</span> bodyAsString;<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           httpClient.close();<br>           response.close();<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 发送get方式请求</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> url</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(String url)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> getClient();<br><br>       <span class="hljs-type">HttpGet</span> <span class="hljs-variable">httpGet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(url);<br>       httpGet.addHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.toString());<br>       httpGet.addHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.toString());<br>       httpGet.addHeader(<span class="hljs-string">&quot;Wechatpay-Serial&quot;</span>, weChatProperties.getMchSerialNo());<br><br>       <span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpClient.execute(httpGet);<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">bodyAsString</span> <span class="hljs-operator">=</span> EntityUtils.toString(response.getEntity());<br>           <span class="hljs-keyword">return</span> bodyAsString;<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           httpClient.close();<br>           response.close();<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * jsapi下单</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> orderNum    商户订单号</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> total       总金额</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> description 商品描述</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> openid      微信用户的openid</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> String <span class="hljs-title function_">jsapi</span><span class="hljs-params">(String orderNum, BigDecimal total, String description, String openid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>       jsonObject.put(<span class="hljs-string">&quot;appid&quot;</span>, weChatProperties.getAppid());<br>       jsonObject.put(<span class="hljs-string">&quot;mchid&quot;</span>, weChatProperties.getMchid());<br>       jsonObject.put(<span class="hljs-string">&quot;description&quot;</span>, description);<br>       jsonObject.put(<span class="hljs-string">&quot;out_trade_no&quot;</span>, orderNum);<br>       jsonObject.put(<span class="hljs-string">&quot;notify_url&quot;</span>, weChatProperties.getNotifyUrl());<br><br>       <span class="hljs-type">JSONObject</span> <span class="hljs-variable">amount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>       amount.put(<span class="hljs-string">&quot;total&quot;</span>, total.multiply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">100</span>)).setScale(<span class="hljs-number">2</span>, BigDecimal.ROUND_HALF_UP).intValue());<br>       amount.put(<span class="hljs-string">&quot;currency&quot;</span>, <span class="hljs-string">&quot;CNY&quot;</span>);<br><br>       jsonObject.put(<span class="hljs-string">&quot;amount&quot;</span>, amount);<br><br>       <span class="hljs-type">JSONObject</span> <span class="hljs-variable">payer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>       payer.put(<span class="hljs-string">&quot;openid&quot;</span>, openid);<br><br>       jsonObject.put(<span class="hljs-string">&quot;payer&quot;</span>, payer);<br><br>       <span class="hljs-type">String</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> jsonObject.toJSONString();<br>       <span class="hljs-keyword">return</span> post(JSAPI, body);<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 小程序支付</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> orderNum    商户订单号</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> total       金额，单位 元</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> description 商品描述</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> openid      微信用户的openid</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> JSONObject <span class="hljs-title function_">pay</span><span class="hljs-params">(String orderNum, BigDecimal total, String description, String openid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-comment">//统一下单，生成预支付交易单</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">bodyAsString</span> <span class="hljs-operator">=</span> jsapi(orderNum, total, description, openid);<br>       <span class="hljs-comment">//解析返回结果</span><br>       <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> JSON.parseObject(bodyAsString);<br>       System.out.println(jsonObject);<br><br>       <span class="hljs-type">String</span> <span class="hljs-variable">prepayId</span> <span class="hljs-operator">=</span> jsonObject.getString(<span class="hljs-string">&quot;prepay_id&quot;</span>);<br>       <span class="hljs-keyword">if</span> (prepayId != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">timeStamp</span> <span class="hljs-operator">=</span> String.valueOf(System.currentTimeMillis() / <span class="hljs-number">1000</span>);<br>           <span class="hljs-type">String</span> <span class="hljs-variable">nonceStr</span> <span class="hljs-operator">=</span> RandomStringUtils.randomNumeric(<span class="hljs-number">32</span>);<br>           ArrayList&lt;Object&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>           list.add(weChatProperties.getAppid());<br>           list.add(timeStamp);<br>           list.add(nonceStr);<br>           list.add(<span class="hljs-string">&quot;prepay_id=&quot;</span> + prepayId);<br>           <span class="hljs-comment">//二次签名，调起支付需要重新签名</span><br>           <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>           <span class="hljs-keyword">for</span> (Object o : list) &#123;<br>               stringBuilder.append(o).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>           &#125;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">signMessage</span> <span class="hljs-operator">=</span> stringBuilder.toString();<br>           <span class="hljs-type">byte</span>[] message = signMessage.getBytes();<br><br>           <span class="hljs-type">Signature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> Signature.getInstance(<span class="hljs-string">&quot;SHA256withRSA&quot;</span>);<br>           signature.initSign(PemUtil.loadPrivateKey(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(weChatProperties.getPrivateKeyFilePath()))));<br>           signature.update(message);<br>           <span class="hljs-type">String</span> <span class="hljs-variable">packageSign</span> <span class="hljs-operator">=</span> Base64.getEncoder().encodeToString(signature.sign());<br><br>           <span class="hljs-comment">//构造数据给微信小程序，用于调起微信支付</span><br>           <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>           jo.put(<span class="hljs-string">&quot;timeStamp&quot;</span>, timeStamp);<br>           jo.put(<span class="hljs-string">&quot;nonceStr&quot;</span>, nonceStr);<br>           jo.put(<span class="hljs-string">&quot;package&quot;</span>, <span class="hljs-string">&quot;prepay_id=&quot;</span> + prepayId);<br>           jo.put(<span class="hljs-string">&quot;signType&quot;</span>, <span class="hljs-string">&quot;RSA&quot;</span>);<br>           jo.put(<span class="hljs-string">&quot;paySign&quot;</span>, packageSign);<br><br>           <span class="hljs-keyword">return</span> jo;<br>       &#125;<br>       <span class="hljs-keyword">return</span> jsonObject;<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 申请退款</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> outTradeNo    商户订单号</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> outRefundNo   商户退款单号</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> refund        退款金额</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> total         原订单金额</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">refund</span><span class="hljs-params">(String outTradeNo, String outRefundNo, BigDecimal refund, BigDecimal total)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>       jsonObject.put(<span class="hljs-string">&quot;out_trade_no&quot;</span>, outTradeNo);<br>       jsonObject.put(<span class="hljs-string">&quot;out_refund_no&quot;</span>, outRefundNo);<br><br>       <span class="hljs-type">JSONObject</span> <span class="hljs-variable">amount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>       amount.put(<span class="hljs-string">&quot;refund&quot;</span>, refund.multiply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">100</span>)).setScale(<span class="hljs-number">2</span>, BigDecimal.ROUND_HALF_UP).intValue());<br>       amount.put(<span class="hljs-string">&quot;total&quot;</span>, total.multiply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">100</span>)).setScale(<span class="hljs-number">2</span>, BigDecimal.ROUND_HALF_UP).intValue());<br>       amount.put(<span class="hljs-string">&quot;currency&quot;</span>, <span class="hljs-string">&quot;CNY&quot;</span>);<br><br>       jsonObject.put(<span class="hljs-string">&quot;amount&quot;</span>, amount);<br>       jsonObject.put(<span class="hljs-string">&quot;notify_url&quot;</span>, weChatProperties.getRefundNotifyUrl());<br><br>       <span class="hljs-type">String</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> jsonObject.toJSONString();<br><br>       <span class="hljs-comment">//调用申请退款接口</span><br>       <span class="hljs-keyword">return</span> post(REFUNDS, body);<br>   &#125;<br>&gt;&#125;<br><br></code></pre></td></tr></table></figure></blockquote><blockquote><ul><li>支付回调</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">package</span> com.sky.controller.notify;<br><br>&gt;<span class="hljs-keyword">import</span> com.alibaba.druid.support.json.JSONUtils;<br>&gt;<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br>&gt;<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONObject;<br>&gt;<span class="hljs-keyword">import</span> com.sky.properties.WeChatProperties;<br>&gt;<span class="hljs-keyword">import</span> com.sky.service.OrderService;<br>&gt;<span class="hljs-keyword">import</span> com.wechat.pay.contrib.apache.httpclient.util.AesUtil;<br>&gt;<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br>&gt;<span class="hljs-keyword">import</span> org.apache.http.entity.ContentType;<br>&gt;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br>&gt;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br>&gt;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br>&gt;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br>&gt;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br>&gt;<span class="hljs-keyword">import</span> java.io.BufferedReader;<br>&gt;<span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br>&gt;<span class="hljs-keyword">import</span> java.util.HashMap;<br><br>&gt;<span class="hljs-comment">/**</span><br><span class="hljs-comment">* 支付回调相关接口</span><br><span class="hljs-comment">*/</span><br>&gt;<span class="hljs-meta">@RestController</span><br>&gt;<span class="hljs-meta">@RequestMapping(&quot;/notify&quot;)</span><br>&gt;<span class="hljs-meta">@Slf4j</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PayNotifyController</span> &#123;<br>   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> OrderService orderService;<br>   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> WeChatProperties weChatProperties;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 支付成功回调</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@RequestMapping(&quot;/paySuccess&quot;)</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paySuccessNotify</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-comment">//读取数据</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> readData(request);<br>       log.info(<span class="hljs-string">&quot;支付成功回调：&#123;&#125;&quot;</span>, body);<br><br>       <span class="hljs-comment">//数据解密</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">plainText</span> <span class="hljs-operator">=</span> decryptData(body);<br>       log.info(<span class="hljs-string">&quot;解密后的文本：&#123;&#125;&quot;</span>, plainText);<br><br>       <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> JSON.parseObject(plainText);<br>       <span class="hljs-type">String</span> <span class="hljs-variable">outTradeNo</span> <span class="hljs-operator">=</span> jsonObject.getString(<span class="hljs-string">&quot;out_trade_no&quot;</span>);<span class="hljs-comment">//商户平台订单号</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">transactionId</span> <span class="hljs-operator">=</span> jsonObject.getString(<span class="hljs-string">&quot;transaction_id&quot;</span>);<span class="hljs-comment">//微信支付交易号</span><br><br>       log.info(<span class="hljs-string">&quot;商户平台订单号：&#123;&#125;&quot;</span>, outTradeNo);<br>       log.info(<span class="hljs-string">&quot;微信支付交易号：&#123;&#125;&quot;</span>, transactionId);<br><br>       <span class="hljs-comment">//业务处理，修改订单状态、来单提醒</span><br>       orderService.paySuccess(outTradeNo);<br><br>       <span class="hljs-comment">//给微信响应</span><br>       responseToWeixin(response);<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 读取数据</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> String <span class="hljs-title function_">readData</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> request.getReader();<br>       <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>       <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>       <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">if</span> (result.length() &gt; <span class="hljs-number">0</span>) &#123;<br>               result.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>           &#125;<br>           result.append(line);<br>       &#125;<br>       <span class="hljs-keyword">return</span> result.toString();<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 数据解密</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> body</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> String <span class="hljs-title function_">decryptData</span><span class="hljs-params">(String body)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-type">JSONObject</span> <span class="hljs-variable">resultObject</span> <span class="hljs-operator">=</span> JSON.parseObject(body);<br>       <span class="hljs-type">JSONObject</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> resultObject.getJSONObject(<span class="hljs-string">&quot;resource&quot;</span>);<br>       <span class="hljs-type">String</span> <span class="hljs-variable">ciphertext</span> <span class="hljs-operator">=</span> resource.getString(<span class="hljs-string">&quot;ciphertext&quot;</span>);<br>       <span class="hljs-type">String</span> <span class="hljs-variable">nonce</span> <span class="hljs-operator">=</span> resource.getString(<span class="hljs-string">&quot;nonce&quot;</span>);<br>       <span class="hljs-type">String</span> <span class="hljs-variable">associatedData</span> <span class="hljs-operator">=</span> resource.getString(<span class="hljs-string">&quot;associated_data&quot;</span>);<br><br>       <span class="hljs-type">AesUtil</span> <span class="hljs-variable">aesUtil</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AesUtil</span>(weChatProperties.getApiV3Key().getBytes(StandardCharsets.UTF_8));<br>       <span class="hljs-comment">//密文解密</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">plainText</span> <span class="hljs-operator">=</span> aesUtil.decryptToString(associatedData.getBytes(StandardCharsets.UTF_8),<br>               nonce.getBytes(StandardCharsets.UTF_8),<br>               ciphertext);<br><br>       <span class="hljs-keyword">return</span> plainText;<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 给微信响应</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">responseToWeixin</span><span class="hljs-params">(HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>       response.setStatus(<span class="hljs-number">200</span>);<br>       HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>       map.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-string">&quot;SUCCESS&quot;</span>);<br>       map.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;SUCCESS&quot;</span>);<br>       response.setHeader(<span class="hljs-string">&quot;Content-type&quot;</span>, ContentType.APPLICATION_JSON.toString());<br>       response.getOutputStream().write(JSONUtils.toJSONString(map).getBytes(StandardCharsets.UTF_8));<br>       response.flushBuffer();<br>   &#125;<br>&gt;&#125;<br><br></code></pre></td></tr></table></figure></blockquote><p>整体流程：</p><blockquote><p>小程序发起支付调用后端的payment接口，后端的payment服务层调用工具类的pay方法向微信官方后台发起JSAPI下单的POST请求，返回了一个预支付交易标识的字符串，进行签名和加密，最后返回给小程序，小程序进行解密后调起支付requestPayment接口让用户进行支付，支付完成后，微信后台返回支付结果参数给小程序，小程序显示结果。同时微信后台也会回调后端的接口，从而修改订单状态。</p></blockquote><h1 id="额外完善"><a href="#额外完善" class="headerlink" title="额外完善"></a>额外完善</h1><h2 id="1-订单管理"><a href="#1-订单管理" class="headerlink" title="1.订单管理"></a>1.订单管理</h2><p>用户端历史订单模块：</p><ul><li>查询历史订单</li><li>查询订单详情</li><li>取消订单</li><li>再来一单</li></ul><p>商家端订单管理模块：</p><ul><li>订单搜索</li><li>各个状态的订单数量统计</li><li>查询订单详情</li><li>接单</li><li>拒单</li><li>取消订单</li><li>派送订单</li><li>完成订单</li></ul><h2 id="2-订单状态"><a href="#2-订单状态" class="headerlink" title="2.订单状态"></a>2.订单状态</h2><p><img src="/.com//image-20250419164140986.png" alt="image-20250419164140986"></p><ul><li>超时订单的定时处理（支付超时和派送超时）-Spring Task</li><li>来单提醒 -WebSocket</li><li>客户催单提醒 -WebSocket</li></ul><h3 id="2-1-超时处理"><a href="#2-1-超时处理" class="headerlink" title="2.1.超时处理"></a>2.1.超时处理</h3><p><img src="/.com//image-20250419170715102.png" alt="image-20250419170715102"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderTask</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderMapper orderMapper;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理超时的订单的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Scheduled(cron = &quot;0 * * * * ?&quot;)</span><span class="hljs-comment">//每分钟触发一次</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processTimeoutOrder</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;定时处理超时订单&#123;&#125;&quot;</span>, LocalDateTime.now());<br><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> LocalDateTime.now().plusMinutes(-<span class="hljs-number">15</span>);<br>        <span class="hljs-comment">//select * from orders where status=? and order_time&lt; (当前时间-15分钟)</span><br>        List&lt;Orders&gt; ordersList = orderMapper.getByStatusAndOrderTimeLT(Orders.PENDING_PAYMENT, time);<br><br>        <span class="hljs-keyword">if</span> (ordersList != <span class="hljs-literal">null</span> &amp;&amp; ordersList.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (Orders orders : ordersList) &#123;<br>                orders.setStatus(Orders.CANCELLED);<span class="hljs-comment">//取消</span><br>                orders.setCancelReason(<span class="hljs-string">&quot;订单超时，自动取消&quot;</span>);<br>                orders.setCancelTime(LocalDateTime.now());<br>                orderMapper.update(orders);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Scheduled(cron = &quot;0 0 1 * * ?&quot;)</span> <span class="hljs-comment">//每天凌晨一点触发-处理昨天的订单</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processDeliveryOrder</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;定时处理处于派送中的订单&#123;&#125;&quot;</span>, LocalDateTime.now());<br>        LocalDateTime time=LocalDateTime.now().plusMinutes(-<span class="hljs-number">60</span>);<br><span class="hljs-comment">//select * from orders where status=? and order_time&lt; (当前时间-一个小时)</span><br>        List&lt;Orders&gt; ordersList = orderMapper.getByStatusAndOrderTimeLT(Orders.DELIVERY_IN_PROGRESS, time);<br><br>        <span class="hljs-keyword">if</span> (ordersList != <span class="hljs-literal">null</span> &amp;&amp; ordersList.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (Orders orders : ordersList) &#123;<br>                orders.setStatus(Orders.COMPLETED);<span class="hljs-comment">//取消</span><br>                orderMapper.update(orders);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-提醒处理"><a href="#2-2-提醒处理" class="headerlink" title="2.2.提醒处理"></a>2.2.提醒处理</h3><p><img src="/.com//image-20250421175625680.png" alt="image-20250421175625680"></p><p><img src="/.com//image-20250421175738972.png" alt="image-20250421175738972"></p><ul><li><p>来单提醒：小程序端用户支付完成后管理端播报来单提醒，即在微信支付的成功回调方法内调用的修改订单状态方法内实现来单消息的推送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> WebSocketServer webSocketServer;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paySuccess</span><span class="hljs-params">(String outTradeNo)</span> &#123;<br><br>        <span class="hljs-comment">// 根据订单号查询订单</span><br>        <span class="hljs-type">Orders</span> <span class="hljs-variable">ordersDB</span> <span class="hljs-operator">=</span> orderMapper.getByNumber(outTradeNo);<br><br>        <span class="hljs-comment">// 根据订单id更新订单的状态、支付方式、支付状态、结账时间</span><br>        <span class="hljs-type">Orders</span> <span class="hljs-variable">orders</span> <span class="hljs-operator">=</span> Orders.builder()<br>                .id(ordersDB.getId())<br>                .status(Orders.TO_BE_CONFIRMED)<br>                .payStatus(Orders.PAID)<br>                .checkoutTime(LocalDateTime.now())<br>                .build();<br><br>        <span class="hljs-comment">//WebSocket发送语言播报消息 type=1(来单提醒)，orderId订单id,content消息内容</span><br>        <span class="hljs-type">Map</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        session.put(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-number">1</span>);<br>        session.put(<span class="hljs-string">&quot;orderId&quot;</span>, ordersDB.getId());<br>        session.put(<span class="hljs-string">&quot;content&quot;</span>, <span class="hljs-string">&quot;您有新的订单！&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> JSON.toJSONString(session);<br>        webSocketServer.sendToAllClient(json);<br><br><br>        orderMapper.update(orders);<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>客户催单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 客户催单</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reminder</span><span class="hljs-params">(Long id)</span> &#123;<br>       Orders ordersDB=orderMapper.getById(id);<br>       <span class="hljs-comment">// 校验订单是否存在，并且状态为4</span><br>       <span class="hljs-keyword">if</span> (ordersDB == <span class="hljs-literal">null</span> ) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderBusinessException</span>(MessageConstant.ORDER_STATUS_ERROR);<br>       &#125;<br>       <span class="hljs-comment">//WebSocket发送语言播报消息 type=2(客户催单)，orderId订单id,content消息内容</span><br>       <span class="hljs-type">Map</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>  <br>       session.put(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-number">2</span>);<br>       session.put(<span class="hljs-string">&quot;orderId&quot;</span>, ordersDB.getId());<br>       session.put(<span class="hljs-string">&quot;content&quot;</span>, <span class="hljs-string">&quot;订单号：&quot;</span>+ordersDB.getNumber());<br>       <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> JSON.toJSONString(session);<br>       webSocketServer.sendToAllClient(json);<br>   &#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-百度地图"><a href="#3-百度地图" class="headerlink" title="3.百度地图"></a>3.百度地图</h2><p>优化用户下单功能，加入校验逻辑，如果用户的收货地址距离商家门店超出配送范围（配送范围为5公里内），则下单失败。</p><p>提示：</p><p>​1. 基于百度地图开放平台实现（<a href="https://lbsyun.baidu.com/%EF%BC%89">https://lbsyun.baidu.com/）</a></p><p>​2. 注册账号—&gt;创建应用获取AK(服务端应用)—&gt;调用接口</p><ol start="3"><li><p>相关接口</p><p><a href="https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding">https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding</a></p><p><a href="https://lbsyun.baidu.com/index.php?title=webapi/directionlite-v1">https://lbsyun.baidu.com/index.php?title=webapi/directionlite-v1</a></p></li><li><p>商家门店地址可以配置在配置文件中，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sky:</span><br>  <span class="hljs-attr">shop:</span><br>    <span class="hljs-attr">address:</span> <span class="hljs-string">北京市海淀区上地十街10号</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h3><p>注册账号：<a href="https://passport.baidu.com/v2/?reg&tt=1671699340600&overseas=&gid=CF954C2-A3D2-417F-9FE6-B0F249ED7E33&tpl=pp&u=https://lbsyun.baidu.com/index.php?title=%E9%A6%96%E9%A1%B5">https://passport.baidu.com/v2/?reg&amp;tt=1671699340600&amp;overseas=&amp;gid=CF954C2-A3D2-417F-9FE6-B0F249ED7E33&amp;tpl=pp&amp;u=https%3A%2F%2Flbsyun.baidu.com%2Findex.php%3Ftitle%3D%E9%A6%96%E9%A1%B5</a></p><p>登录百度地图开放平台：<a href="https://lbsyun.baidu.com/">https://lbsyun.baidu.com/</a></p><p>进入控制台，创建应用，获取AK：</p><p><img src="/.com//image-20221222170049729.png" alt="image-20221222170049729"></p><p><img src="/.com//image-20221222170256927.png" alt="image-20221222170256927"></p><p>相关接口:</p><p><a href="https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding">https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding</a></p><p><a href="https://lbsyun.baidu.com/index.php?title=webapi/directionlite-v1">https://lbsyun.baidu.com/index.php?title=webapi/directionlite-v1</a></p><h3 id="2-代码开发"><a href="#2-代码开发" class="headerlink" title="2. 代码开发"></a>2. 代码开发</h3><h4 id="2-1-application-yml"><a href="#2-1-application-yml" class="headerlink" title="2.1 application.yml"></a>2.1 application.yml</h4><p>配置外卖商家店铺地址和百度地图的AK：</p><p><img src="/.com//image-20221222170819582.png" alt="image-20221222170819582"></p><h4 id="2-2-OrderServiceImpl"><a href="#2-2-OrderServiceImpl" class="headerlink" title="2.2 OrderServiceImpl"></a>2.2 OrderServiceImpl</h4><p>改造OrderServiceImpl，注入上面的配置项：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;sky.shop.address&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String shopAddress;<br><br><span class="hljs-meta">@Value(&quot;$&#123;sky.baidu.ak&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String ak;<br></code></pre></td></tr></table></figure><p>在OrderServiceImpl中提供校验方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 检查客户的收货地址是否超出配送范围</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> address</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkOutOfRange</span><span class="hljs-params">(String address)</span> &#123;<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-string">&quot;address&quot;</span>,shopAddress);<br>        map.put(<span class="hljs-string">&quot;output&quot;</span>,<span class="hljs-string">&quot;json&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;ak&quot;</span>,ak);<br><br>        <span class="hljs-comment">//获取店铺的经纬度坐标</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">shopCoordinate</span> <span class="hljs-operator">=</span> HttpClientUtil.doGet(<span class="hljs-string">&quot;https://api.map.baidu.com/geocoding/v3&quot;</span>, map);<br><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> JSON.parseObject(shopCoordinate);<br>        <span class="hljs-keyword">if</span>(!jsonObject.getString(<span class="hljs-string">&quot;status&quot;</span>).equals(<span class="hljs-string">&quot;0&quot;</span>))&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderBusinessException</span>(<span class="hljs-string">&quot;店铺地址解析失败&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//数据解析</span><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">location</span> <span class="hljs-operator">=</span> jsonObject.getJSONObject(<span class="hljs-string">&quot;result&quot;</span>).getJSONObject(<span class="hljs-string">&quot;location&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">lat</span> <span class="hljs-operator">=</span> location.getString(<span class="hljs-string">&quot;lat&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">lng</span> <span class="hljs-operator">=</span> location.getString(<span class="hljs-string">&quot;lng&quot;</span>);<br>        <span class="hljs-comment">//店铺经纬度坐标</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">shopLngLat</span> <span class="hljs-operator">=</span> lat + <span class="hljs-string">&quot;,&quot;</span> + lng;<br><br>        map.put(<span class="hljs-string">&quot;address&quot;</span>,address);<br>        <span class="hljs-comment">//获取用户收货地址的经纬度坐标</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">userCoordinate</span> <span class="hljs-operator">=</span> HttpClientUtil.doGet(<span class="hljs-string">&quot;https://api.map.baidu.com/geocoding/v3&quot;</span>, map);<br><br>        jsonObject = JSON.parseObject(userCoordinate);<br>        <span class="hljs-keyword">if</span>(!jsonObject.getString(<span class="hljs-string">&quot;status&quot;</span>).equals(<span class="hljs-string">&quot;0&quot;</span>))&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderBusinessException</span>(<span class="hljs-string">&quot;收货地址解析失败&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//数据解析</span><br>        location = jsonObject.getJSONObject(<span class="hljs-string">&quot;result&quot;</span>).getJSONObject(<span class="hljs-string">&quot;location&quot;</span>);<br>        lat = location.getString(<span class="hljs-string">&quot;lat&quot;</span>);<br>        lng = location.getString(<span class="hljs-string">&quot;lng&quot;</span>);<br>        <span class="hljs-comment">//用户收货地址经纬度坐标</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">userLngLat</span> <span class="hljs-operator">=</span> lat + <span class="hljs-string">&quot;,&quot;</span> + lng;<br><br>        map.put(<span class="hljs-string">&quot;origin&quot;</span>,shopLngLat);<br>        map.put(<span class="hljs-string">&quot;destination&quot;</span>,userLngLat);<br>        map.put(<span class="hljs-string">&quot;steps_info&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>);<br><br>        <span class="hljs-comment">//路线规划</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> HttpClientUtil.doGet(<span class="hljs-string">&quot;https://api.map.baidu.com/directionlite/v1/driving&quot;</span>, map);<br><br>        jsonObject = JSON.parseObject(json);<br>        <span class="hljs-keyword">if</span>(!jsonObject.getString(<span class="hljs-string">&quot;status&quot;</span>).equals(<span class="hljs-string">&quot;0&quot;</span>))&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderBusinessException</span>(<span class="hljs-string">&quot;配送路线规划失败&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//数据解析</span><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jsonObject.getJSONObject(<span class="hljs-string">&quot;result&quot;</span>);<br>        <span class="hljs-type">JSONArray</span> <span class="hljs-variable">jsonArray</span> <span class="hljs-operator">=</span> (JSONArray) result.get(<span class="hljs-string">&quot;routes&quot;</span>);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> (Integer) ((JSONObject) jsonArray.get(<span class="hljs-number">0</span>)).get(<span class="hljs-string">&quot;distance&quot;</span>);<br><br>        <span class="hljs-keyword">if</span>(distance &gt; <span class="hljs-number">5000</span>)&#123;<br>            <span class="hljs-comment">//配送距离超过5000米</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderBusinessException</span>(<span class="hljs-string">&quot;超出配送范围&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在OrderServiceImpl的submitOrder方法中调用上面的校验方法：</p><p><img src="/.com//image-20221222171444981.png" alt="image-20221222171444981"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/%E7%AE%80%E5%8E%86%20-%20%E5%89%AF%E6%9C%AC/"/>
    <url>/2025/07/02/%E7%AE%80%E5%8E%86%20-%20%E5%89%AF%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="个人简历"><a href="#个人简历" class="headerlink" title="个人简历"></a>个人简历</h1><blockquote><p><span alt="icon">&#xe600;</span> <a href>胡亮星</a>&emsp;&emsp;<span alt="icon"> &#xe60f;</span> <code>13870818897</code>&emsp;&emsp; <span alt="icon">&#xe7ca;</span> <code>2963125082@qq.com</code>&emsp;&emsp; </p></blockquote><h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a><img alt="avatar" src="https://first-javaoss.oss-cn-beijing.aliyuncs.com/2025/06/220405217.jpg">个人信息</h2><ul><li>姓名：胡亮星                                                 性别：男</li><li>手机：13870818897                                   邮箱：<a href="mailto:&#50;&#x39;&#54;&#51;&#49;&#x32;&#53;&#x30;&#56;&#x32;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#109;">&#50;&#x39;&#54;&#51;&#49;&#x32;&#53;&#x30;&#56;&#x32;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#109;</a></li><li>年龄：20                                                         英语：四级</li><li>求职意向：Java后端开发                          年级：大三（准大四）</li></ul><h2 id="xe80c-教育经历"><a href="#xe80c-教育经历" class="headerlink" title="&#xe80c; 教育经历"></a>&#xe80c; 教育经历</h2><table><thead><tr><th align="left">学校</th><th>学历，专业</th><th align="center">时间</th><th>GPA</th></tr></thead><tbody><tr><td align="left">沈阳工业大学（一本）</td><td>本科，计算机科学与技术</td><td align="center">2022.09 - 2026.07</td><td>3.0&#x2F;4.0 (TOP 30%）</td></tr><tr><td align="left"></td><td></td><td align="center"></td><td></td></tr></tbody></table><h2 id="xecfa-专业技能"><a href="#xecfa-专业技能" class="headerlink" title="&#xecfa; 专业技能"></a>&#xecfa; 专业技能</h2><ul><li><strong>计算机基础</strong> ：了解掌握计算机网络、数据结构和算法、操作系统的基本知识。</li><li><strong>编程语言</strong>：熟练掌握Java 基础语法、熟悉面对对象、异常处理、集合类、常用工具类、反射与注解、以及多线程等基础内容。了解JVM内存空间、双亲委派机制、垃圾回收机制。</li><li><strong>开发工具</strong> ：熟练使用 Maven、Git、IDEA 、开发工具，了解Docker容器技术，Linux基础命令。熟悉Apifox、Postman、Swagger等接口测试工具，Jmeter压测工具。</li><li><strong>数据库</strong>：熟练掌握 MySQL、Redis使用及常见优化手段</li><li><strong>框架</strong> ：熟练掌握 Spring、Spring MVC、SpringBoot、MyBatis、了解微服务五大组件，分布式事务和服务保护，熟悉RabbitMQ的使用，掌握<strong>延迟队列、死信交换机</strong>等特性。</li><li><strong>前端</strong>：了解 HTML、CSS、Javascript、Vue 等前端技术。</li></ul><h2 id="xe635-项目经历"><a href="#xe635-项目经历" class="headerlink" title="&#xe635; 项目经历"></a>&#xe635; 项目经历</h2><div alt="entry-title">    <h3>云图片协作平台</h3>    <a href="https://gitee.com/programmingking01/yun-pictrure-backend">gitee.com/programmingking01/yun-pictrure-backend</a></div><p><strong>项目描述</strong>：云图片协作平台是一款支持多模态图片生成、多维度搜图、审核管理、空间分析及企业协同编辑的全栈图片</p><p>处理平台，涵盖AI扩图、颜色搜图、批量编辑等核心功能，满足用户高效图片管理与协作需求。</p><p><strong>技术栈：</strong>SpringBoot、WebSocket、COS、Mysql、Redis、MybatisPlus、CompletableFuture、阿里云百炼AI等。</p><p><strong>重点实现</strong>：</p><ul><li><p><strong>用户登录与权限管理</strong>：基于Redis实现<strong>分布式Session</strong>管理，保障用户登录态一致性；采用<strong>Sa-Token权限框架</strong>，基于RBAC模型实现多账号认证与权限控制，符合企业开发规范，权限校验耗时从120ms优化至30ms，拦截越权成功率100%。</p></li><li><p><strong>图片处理与性能优化</strong>：通<strong>过Redis+Caffeine多级缓存</strong>、<strong>Webp压缩</strong>、<strong>断点续传</strong>等技术优化图片加载、上传与查询性能；使用<strong>编程式管理事务类</strong>确保批量编辑的原子性，结合JUC工具包实现异步编程，万级图片更新速度提高69%。</p></li><li><p><strong>智能搜图与AI功能</strong>：调用<strong>Pexels API</strong>实现<strong>以图搜图</strong>，基于解析HEX色值，利用<strong>欧氏距离算法</strong>实现颜色搜图；封装阿里云百炼AI接口，通过<strong>异步任务编排</strong>实现AI扩图、文字生图等智能化功能。相似度匹配精度高达87%，搜索性能提高3倍。</p></li><li><p><strong>协作编辑与空间分析</strong>：基于<strong>WebSocket</strong>实现<strong>多人实时协作编辑</strong>，结合Redis与<strong>Disruptor环形队列</strong>优化消息异步处理；</p></li></ul><p><strong>项目成果</strong>：成功提交高并发、高性能的图片处理平台，支持大量图片处理请求，图片加载速度提升，AI功能响应时间缩短，提供高效的图片管理与协作解决方案。</p><div alt="entry-title">    <h3>商圈点评</h3>    <a href="https://gitee.com/programmingking01/hm-dianping">gitee.com/programmingking01/hm-dianping</a></div><p><strong>项目描述</strong>：商圈点评是模拟真实生活场景的本地生活服务类项目，旨在为用户提供商家信息查询、消费点评、团购秒杀等功能。</p><p><strong>技术栈</strong>：Spring Boot+Redis+MySQL+MyBatis Plus+Swagger+Redisson+Maven+Nginx</p><ul><li><strong>短信登录</strong>：使用 <strong>Redis</strong> 解决了在集群模式下的 Session共享问题,使用拦截器链实现用户的<strong>登录校验和权限刷新</strong>。</li><li><strong>商家查询缓存</strong>：使用 <strong>Redis +Caffeine多级缓存</strong>对高频访问的信息进行缓存，降低了数据库查询的压力,解决了<strong>缓存穿透、雪崩、击穿问题</strong>。</li><li><strong>团购秒杀</strong>：使用<strong>Lua脚本+Redis+阻塞队列</strong>方案对原来的<strong>基于setnx实现的分布式锁</strong>方案进行优化。实现<strong>团购秒杀</strong>，和<strong>限单</strong>功能。使用JMeter测试<strong>QPS</strong>提升 10 倍左右。</li><li><strong>探店点评</strong>：使用Redis的 <strong>ZSet <strong>数据结构实现了点评</strong>点赞排行榜</strong>功能。使用<strong>Set <strong>集合交集运算</strong>实现用户关注、共同关注</strong>功能。</li><li><strong>点评推送</strong>：设计<strong>Feed流推文算法</strong>实现关注用户的<strong>点评推送</strong>。</li><li><strong>用户签到打卡</strong>：使用Redis的<strong>BitMap结构</strong>实现用户的<strong>签到打卡</strong>功能。支持亿级用户签到记录存储</li></ul><p><strong>项目成果</strong>：并实现高并发商圈点评系统，通过 Redis 集群、Lua 脚本和分布式锁优化秒杀模块，QPS 提升 10 倍，支撑 5 万 + 并发用户；创新应用 ZSet&#x2F;Set&#x2F;BitMap 等数据结构解决排行榜、社交关系和签到功能，系统可用性达 99.95%，成本降低 40%。</p><h2 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h2><p>做事情认真努力、待人诚恳、积极乐观、勤奋好学、有拼搏精神。</p><p style="text-align: right;">感谢您花时间阅读我的简历，期待能与您共事！</p><div style="page-break-after: always;"></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/%E9%B8%BF%E8%92%99%E5%BC%80%E5%8F%91/"/>
    <url>/2025/07/02/%E9%B8%BF%E8%92%99%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="鸿蒙开发-DevEco"><a href="#鸿蒙开发-DevEco" class="headerlink" title="鸿蒙开发-DevEco"></a>鸿蒙开发-DevEco</h1><h1 id="1-ArkTs基础语法"><a href="#1-ArkTs基础语法" class="headerlink" title="1.ArkTs基础语法"></a>1.ArkTs基础语法</h1><ul><li><p>ArkTS是HarmonyOS优选的主力应用开发语言</p><ul><li>ArkTS围绕应用开发在TypeScript（简称TS）生态基础上做了进一步扩展，继承了TS的所有特性，是TS的超集。因此，在学习ArkTS语言之前，建议开发者具备TS语言开发能力</li></ul></li><li><p>ArkTS在TS的基础上能力扩展</p><ul><li>基本语法：ArkTS定义了声明式UI描述、自定义组件和动态扩展UI元素的能力，再配合ArkUI开发框架中的系统组件及其相关的事件方法、属性方法等共同构成了UI开发的主体。</li><li>状态管理：ArkTS提供了多维度的状态管理机制。在UI开发框架中，与UI相关联的数据可以在组件内使用，也可以在不同组件层级间传递，比如父子组件之间、爷孙组件之间，还可以在应用全局范围内传递或跨设备传递。另外，从数据的传递形式来看，可分为只读的单向传递和可变更的双向传递。开发者可以灵活的利用这些能力来实现数据和UI的联动。</li><li>渲染控制：ArkTS提供了渲染控制的能力。条件渲染可根据应用的不同状态，渲染对应状态下的UI内容。循环渲染可从数据源中迭代获取数据，并在每次迭代过程中创建相应的组件。数据懒加载从数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。</li></ul></li></ul><h2 id="1-基本数据类型和变量"><a href="#1-基本数据类型和变量" class="headerlink" title="1.基本数据类型和变量"></a>1.基本数据类型和变量</h2><h3 id="1-变量声明"><a href="#1-变量声明" class="headerlink" title="1.变量声明"></a>1.变量声明</h3><ul><li>打印控制台操作</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;msg&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li><p>常量和变量声明</p><ul><li><strong>let</strong>:块级作用域，可重新赋值</li><li><strong>const</strong>：块级作用域，不可重新赋值，指向对象时可修改内部属性</li><li><strong>var</strong>:函数作用全局作用域，可重新赋值</li></ul></li><li><p>三个变量声明的关键字的<strong>主要区别</strong>：</p></li><li><p><strong>变量声明提升</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//--------------- var -------------------</span><br><span class="hljs-comment">// 声明提升到此处（作用域顶部） var x;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">//输出undefined,而不是报错</span><br><span class="hljs-keyword">var</span> x=<span class="hljs-number">10</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">//输出10</span><br><span class="hljs-comment">//--------------- let/const -------------------</span><br><span class="hljs-comment">// 声明也提示到了此处（作用域顶部），但不会进行初始化 处于暂时性死区（TDZ）</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y); <span class="hljs-comment">//报错 ReferneceError Cannot access &#x27;y&#x27; before initialization</span><br><span class="hljs-keyword">let</span> y=<span class="hljs-number">10</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y); <span class="hljs-comment">//输出10</span><br></code></pre></td></tr></table></figure></li></ul><blockquote><ul><li><strong>var</strong>声明的变量会被提升（至作用域顶部）并初始化为undefined</li><li><strong>let</strong>和<strong>const</strong>声明的变量也会提升（至作用域顶部），但是不会被初始化</li></ul></blockquote><ul><li><strong>函数声明提升</strong></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//--------------- 函数 -------------------</span><br><span class="hljs-comment">//函数声明提升至此处</span><br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">//输出“Hello”</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>&#125;<span class="hljs-comment">//函数</span><br><span class="hljs-comment">//--------------- var函数表达式 -------------------</span><br><span class="hljs-comment">//变量声明提升至此处，但是不进行赋值 var bar; - undefined</span><br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">//报错 ：TypeError :bar is not function</span><br><br><span class="hljs-keyword">var</span> bar=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bar&quot;</span>);<br>&#125;;<span class="hljs-comment">//函数表达式</span><br></code></pre></td></tr></table></figure><blockquote><ul><li><strong>函数</strong>声明会被整个提升至作用域顶部</li><li><strong>var函数表达式</strong>只有变量会被提升，赋值操作不会被提升，初始化为**undefined **</li><li><strong>let&#x2F;const函数表达式</strong>变量也会被提升，但是处于暂时性死区（TDZ）中，无法访问</li></ul></blockquote><ul><li><strong>变量类型推断</strong></li></ul><blockquote><p><strong>类型推断（Type Inference）</strong> 是编译器自动推导变量类型的机制</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">10</span>;         <span class="hljs-comment">// 推断为 number</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;hello&quot;</span>;    <span class="hljs-comment">// 推断为 string</span><br><span class="hljs-keyword">let</span> bool = <span class="hljs-literal">true</span>;      <span class="hljs-comment">// 推断为 boolean</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];  <span class="hljs-comment">// 推断为 number[]</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="2-基本数据类型"><a href="#2-基本数据类型" class="headerlink" title="2.基本数据类型"></a>2.基本数据类型</h3><ul><li><strong>布尔类型</strong></li></ul><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">let</span> isDone: <span class="hljs-built_in">boolean</span>=<span class="hljs-literal">false</span>;<span class="hljs-comment">//默认</span><br><span class="hljs-keyword">let</span> isOn: <span class="hljs-built_in">boolean</span>=<span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><ul><li><strong>数字</strong><ul><li>TypeScript里的所有数字都是浮点数，这些浮点数的类型是 number。除了支持十进制，还支持二进制、八进制、十六进制。</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">decLiteral</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">2023</span>; <span class="hljs-comment">//十进制</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">binaryLiteral</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0b11111100111</span>; <span class="hljs-comment">//二进制 0b</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">octalLiteral</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0o3747</span>; <span class="hljs-comment">//八进制0o</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">hexLiteral</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0x7e7</span>; <span class="hljs-comment">//十六进制 0x</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(decLiteral)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(binaryLiteral)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(octalLiteral)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hexLiteral)<br></code></pre></td></tr></table></figure><ul><li><p><strong>字符串</strong></p><ul><li>使用 string表示文本数据类型， 可以使用双引号（ “）或单引号（’）表示字符串。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">myname</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;Jacky&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">sentence</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;I&#x27;m fine, thank you!&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myname,sentence)<br></code></pre></td></tr></table></figure></li><li><p><strong>数组</strong></p><ul><li>两种方式可以定义数组。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//--------------- 使用元素类型[] ----------------</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list)<br><span class="hljs-comment">//--------------- 使用数组泛型 Array&lt;元素类型&gt; ----------------</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list)<br></code></pre></td></tr></table></figure></li><li><p><strong>元组</strong></p><ul><li>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。</li><li>要求顺序类型一致</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//---------元组----------</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>];<br>x = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">10</span>]; <span class="hljs-comment">// OK</span><br>x = [<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;hello&#x27;</span>]; <span class="hljs-comment">// Error</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)<br><span class="hljs-comment">//-------元组混合数组--------</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: [<span class="hljs-built_in">string</span>[], <span class="hljs-built_in">number</span>];<br><span class="hljs-comment">// 合法赋值</span><br>x = [[<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>], <span class="hljs-number">100</span>];<br>x = [[], <span class="hljs-number">0</span>]; <span class="hljs-comment">// 空数组也符合 string[] 类型</span><br><span class="hljs-comment">// 错误示例：类型不匹配</span><br>x = [<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">100</span>]; <span class="hljs-comment">// 报错：Type &#x27;string&#x27; is not assignable to type &#x27;string[]&#x27;</span><br>x = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-number">100</span>];  <span class="hljs-comment">// 报错：Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;</span><br>x = [[<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>]];   <span class="hljs-comment">// 报错：元组需要 2 个元素</span><br></code></pre></td></tr></table></figure></li><li><p><strong>枚举</strong></p><ul><li>enum类型是对JavaScript标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字。</li><li>默认第一个元素为0，后续递增。可以初始化的时候给指定元素进行赋值，后续元素自动递增。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<span class="hljs-title class_">Red</span>, <span class="hljs-title class_">Green</span>, <span class="hljs-title class_">Blue</span>&#125;; <span class="hljs-comment">// 0,1,2</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Green</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c);<br></code></pre></td></tr></table></figure></li><li><p><strong>Unknown</strong></p><ul><li>用于在编程阶段还不清楚类型的变量指定一个类型，并且不希望类型检查器对这些值进行检查，而是直接让它们通过编译阶段的检查。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: <span class="hljs-built_in">unknown</span> = <span class="hljs-number">4</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(notSure) <span class="hljs-comment">//4</span><br>notSure = <span class="hljs-string">&#x27;maybe a string instead&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(notSure) <span class="hljs-comment">//maybe a string instead</span><br>notSure = <span class="hljs-literal">false</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(notSure) <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Void</strong></p><ul><li>当一个函数没有返回值时，定义函数返回值类型为 void。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This is function is void&#x27;</span>);<br>&#125;<br><span class="hljs-title function_">test</span>(); <span class="hljs-comment">//This is function is void</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Null 和 Undefined</strong></p><ul><li>TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null</li><li>声明为 <code>undefined</code> 或 <code>null</code> 类型的变量，<strong>只能赋值为自身类型的值</strong>（<code>undefined</code> 或 <code>null</code>）</li><li>默认<strong>非严格模式</strong>下，其他变量可以赋值为<code>undefined</code> 或 <code>null</code>，严格模式下无法进行赋值。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">u</span>: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">n</span>: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(u,n);<span class="hljs-comment">//undefined null</span><br></code></pre></td></tr></table></figure></li><li><p><strong>联合类型</strong></p><ul><li>联合类型（Union Types）表示取值可以为多种类型中的一种。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">myFavoriteNumber</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br>myFavoriteNumber = <span class="hljs-string">&#x27;seven&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myFavoriteNumber); <span class="hljs-comment">//seven string类型</span><br>myFavoriteNumber = <span class="hljs-number">7</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myFavoriteNumber); <span class="hljs-comment">//7 number类型</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-流程控制"><a href="#2-流程控制" class="headerlink" title="2.流程控制"></a>2.流程控制</h2><ul><li><strong>if…else</strong></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//-------- if-else--------</span><br><span class="hljs-keyword">var</span> <span class="hljs-attr">num</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">20</span>; <br><span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span>==<span class="hljs-number">0</span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;偶数&#x27;</span>); <br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;奇数&#x27;</span>); <br>&#125;<br><span class="hljs-comment">//--------if-else if-else -----------</span><br><span class="hljs-keyword">var</span> <span class="hljs-attr">num1</span>:<span class="hljs-built_in">number</span> = -<span class="hljs-number">50</span>;<br><span class="hljs-keyword">if</span>(num1 &gt; <span class="hljs-number">0</span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1+<span class="hljs-string">&#x27; 是正数&#x27;</span>); <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">0</span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1+<span class="hljs-string">&#x27; 是负数&#x27;</span>); <br>&#125; <span class="hljs-keyword">else</span> &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1+<span class="hljs-string">&#x27; 为0&#x27;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>switch…case</strong></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">grade</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;A&#x27;</span>; <br><span class="hljs-keyword">switch</span>(grade) &#123; <br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>: &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;优&#x27;</span>); <br>        <span class="hljs-keyword">break</span>; <br>    &#125; <br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>: &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;良&#x27;</span>); <br>        <span class="hljs-keyword">break</span>; <br>    &#125; <br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>: &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;及格&#x27;</span>); <br>        <span class="hljs-keyword">break</span>;    <br>    &#125; <br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>: &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;不及格&#x27;</span>); <br>        <span class="hljs-keyword">break</span>; <br>    &#125;  <br>    <span class="hljs-attr">default</span>: &#123; <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;非法输入&#x27;</span>); <br>        <span class="hljs-keyword">break</span>;              <br></code></pre></td></tr></table></figure><ul><li><strong>break</strong> :结束循环或分支</li><li><strong>continue</strong>:直接进入下次循环</li><li><strong>for&#x2F;while</strong>循环</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//----------- for ------------</span><br><span class="hljs-comment">// 遍历数组，类型自动推断</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">numbers</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numbers.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-comment">// i 类型为 number</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers[i]); <span class="hljs-comment">// 输出：1, 2, 3, 4, 5</span><br>&#125;<br><span class="hljs-comment">// 指定索引类型（可选）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> <span class="hljs-attr">i</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">// 0 到 9</span><br>&#125;<br><span class="hljs-comment">//----------- for...of 遍历可迭代对象------------</span><br><span class="hljs-comment">// 遍历数组</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">fruits</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fruit <span class="hljs-keyword">of</span> fruits) &#123;<br>  <span class="hljs-comment">// fruit 类型为 string</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruit.<span class="hljs-title function_">toUpperCase</span>()); <span class="hljs-comment">// APPLE, BANANA, ORANGE</span><br>&#125;<br><br><span class="hljs-comment">// 遍历字符串</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> char <span class="hljs-keyword">of</span> message) &#123;<br>  <span class="hljs-comment">// char 类型为 string（单个字符）</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(char); <span class="hljs-comment">// &quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 遍历 Map/Set</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">userMap</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Alice&quot;</span>], [<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Bob&quot;</span>]]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> userMap) &#123;<br>  <span class="hljs-comment">// key 类型为 number，value 类型为 string</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Key: <span class="hljs-subst">$&#123;key&#125;</span>, Value: <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>&#125;<br><span class="hljs-comment">//----------- while ------------</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">5</span>) &#123;<br>  <span class="hljs-comment">// count 类型为 number</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count); <span class="hljs-comment">// 0, 1, 2, 3, 4</span><br>  count++;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">i</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">// 10</span><br>  i += <span class="hljs-number">10</span>;<br>&#125; <span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">20</span>); <span class="hljs-comment">// 条件不满足，仅执行一次</span><br></code></pre></td></tr></table></figure><h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h2><ul><li>函数是一组共同执行一个任务的语句，函数声明要包括函数名称、返回类型和参数。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 有名函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x:<span class="hljs-built_in">number</span>, y:<span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><span class="hljs-comment">// 匿名函数</span><br><span class="hljs-keyword">let</span> myAdd = <span class="hljs-keyword">function</span> (<span class="hljs-params">x:<span class="hljs-built_in">number</span>, y:<span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>  &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">20</span>,<span class="hljs-number">30</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">myAdd</span>(<span class="hljs-number">20</span>,<span class="hljs-number">30</span>));<br></code></pre></td></tr></table></figure><ul><li>可选参数函数</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName?: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (lastName)<br>        <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> firstName;<br>&#125;<br><span class="hljs-keyword">let</span> result1 = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>);<br><span class="hljs-keyword">let</span> result2 = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Adams&#x27;</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result2);<br></code></pre></td></tr></table></figure><ul><li>剩余参数函数<ul><li>剩余参数会被当做个数不限的可选参数，可以一个都没有，同样也可以有任意个。 使用省略号（ …）进行定义。</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getEmployeeName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>[], ...restOfName: <span class="hljs-built_in">string</span>[]</span>) &#123;<br>  <span class="hljs-keyword">return</span> firstName.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27; &#x27;</span>)+ <span class="hljs-string">&#x27; &#x27;</span> + restOfName.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>    <span class="hljs-comment">//restOfName.join(&#x27; &#x27;) 将数组 [&#x27;Samuel&#x27;, &#x27;Lucas&#x27;, &#x27;MacKinzie&#x27;] 转换为字符串 &#x27;Samuel Lucas MacKinzie&#x27;。</span><br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span>[]=[<span class="hljs-string">&#x27;Joseph&#x27;</span>,<span class="hljs-string">&#x27;Lisa&#x27;</span>];<br><span class="hljs-keyword">let</span> employeeName = <span class="hljs-title function_">getEmployeeName</span>(firstName,<span class="hljs-string">&#x27;Joseph&#x27;</span>, <span class="hljs-string">&#x27;Samuel&#x27;</span>, <span class="hljs-string">&#x27;Lucas&#x27;</span>, <span class="hljs-string">&#x27;MacKinzie&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;最后的结果为:&#x27;</span>+employeeName);<span class="hljs-comment">//Joseph Lisa Joseph Samuel Lucas MacKinzie</span><br></code></pre></td></tr></table></figure><ul><li>箭头函数</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript">( [param1, parma2,…param n] )=&gt; &#123;<br>    <span class="hljs-comment">// 代码块</span><br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-title function_">arrowFun</span> = (<span class="hljs-params"> [param1, parma2,…param n] </span>)=&gt; &#123;<br>    <span class="hljs-comment">// 代码块</span><br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">anyway</span>:<span class="hljs-built_in">number</span>=<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;&#125;<br><span class="hljs-title function_">arrowFun</span>(param1, parma2,…param n);<br><span class="hljs-keyword">let</span> num=<span class="hljs-title function_">anyway</span>();<br><span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;Click Now&quot;</span>)<br>  .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;Button is click&quot;</span>)<br>  &#125;);<span class="hljs-comment">//传入箭头函数</span><br></code></pre></td></tr></table></figure><h2 id="4-接口-对象"><a href="#4-接口-对象" class="headerlink" title="4.接口&amp;对象"></a>4.接口&amp;对象</h2><h3 id="1-自定义类对象"><a href="#1-自定义类对象" class="headerlink" title="1.自定义类对象"></a>1.自定义类对象</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-comment">//构造器</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">getPersonInfo</span>(): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`My name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> and age is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>`</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>new对象和属性调用</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Jacky&#x27;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-attr">show</span>:<span class="hljs-built_in">string</span>=person1.<span class="hljs-title function_">getPersonInfo</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(show);<br></code></pre></td></tr></table></figure><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h3><ul><li><p>继承是子类继承父类的特征和行为，使子类具有父类相同的行为。TypeScript中允许使用继承来扩展现有的类，对应的关键字为extends。</p><ul><li>定义employee继承于person；比person新增一个属性department<br>通过super关键字实际上调用了person中的构造方法，初始化name和age，并在构造方法中初始化department，<br>employee有个公有方法，getemployeeinfo获取雇员的信息，其中调用getpersoninfo来获取雇员的姓名、年龄信息。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>   <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">getPersonInfo</span>(): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`My name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> and age is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>`</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">department</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span>, department: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name,age);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">department</span>=department;<br>  &#125;<br>    <span class="hljs-title function_">getemployeeinfo</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-attr">showResulet</span>: <span class="hljs-built_in">string</span> = <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">getPersonInfo</span>();<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(showResulet);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> emp = <span class="hljs-keyword">new</span> <span class="hljs-title function_">employee</span>(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;教学办&#x27;</span>);<br>emp.<span class="hljs-title function_">getemployeeinfo</span>();<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-可迭代对象"><a href="#3-可迭代对象" class="headerlink" title="3.可迭代对象"></a>3.可迭代对象</h3><ul><li>当一个对象实现了Symbol.iterator属性时，我们认为它是可迭代的。</li><li>内置类型如Array，Map，Set，String，Int32Array，Uint32Array等都具有可迭代性</li><li>使用for..of&#x2F;for…in遍历可迭代对象</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//-----------for...of-------------</span><br><span class="hljs-keyword">let</span> someArray = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-literal">false</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> someArray) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entry); <span class="hljs-comment">// 1, &quot;string&quot;, false</span><br>&#125;<br><span class="hljs-comment">//-----------for...in-------------</span><br><span class="hljs-keyword">let</span> someArray = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-literal">false</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">in</span> someArray) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entry); <span class="hljs-comment">// 1, &quot;string&quot;, false</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>for..of vs. for..in 语句</p><ul><li>for..of和for..in均可迭代一个列表，但是用于迭代的值却不同</li><li>for..in迭代的是对象的键&#x2F;数组索引，而for..of则迭代的是对象的值。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> list = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> list) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;,</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> list) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">// &quot;4&quot;, &quot;5&quot;, &quot;6&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>map语句</p><ul><li>每个元素都是由两个组成：key，value</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt;()<br>map1.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>)<br>map1.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">10</span>)<br>map1.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">15</span>)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> k <span class="hljs-keyword">of</span> map1)&#123;   <span class="hljs-comment">//k代表一个键值对数组 k[0]=key k[1]=value</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(k); <span class="hljs-comment">//[&quot;a&quot;,1] [&quot;b&quot;,10] [&quot;c&quot;,15]  </span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-接口-对象-1"><a href="#4-接口-对象-1" class="headerlink" title="4.接口-对象"></a>4.接口-对象</h3><p><img src="/.com//image-20250529173053441.png" alt="image-20250529173053441"></p><p><img src="/.com//image-20250529173216918.png" alt="image-20250529173216918"></p><h3 id="5-模块"><a href="#5-模块" class="headerlink" title="5.模块"></a>5.模块</h3><ul><li><p>随着应用越来越大，通常要将代码拆分成多个文件，即所谓的模块（module）。</p></li><li><p>模块可以相互加载，并可以使用特殊的指令 <strong>export</strong> 和 <strong>import</strong> 来交换功能，从另一个模块调用一个模块的函数。</p></li><li><p>两个模块之间的关系是通过在文件级别上使用  <strong>export</strong> 和 <strong>import</strong>  建立。</p></li><li><p>模块里面的变量、函数和类等在模块外部是不可见的，除非明确地使用 <strong>export</strong>导出。</p></li><li><p>必须通过 <strong>import</strong> 导入其他模块导出的变量、函数、类等。</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewsData</span> &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">content</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">source</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">title: <span class="hljs-built_in">string</span>, content: <span class="hljs-built_in">string</span>, source: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">content</span> = content;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">source</span> = source;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">NewsData</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./NewData&#x27;</span>;<span class="hljs-comment">//文件的相对路径</span><br><span class="hljs-keyword">let</span> newdata = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NewsData</span>(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>,<span class="hljs-string">&#x27;my name is haha&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newdata.<span class="hljs-property">title</span>);<br></code></pre></td></tr></table></figure><h1 id="2-界面开发ArkUI"><a href="#2-界面开发ArkUI" class="headerlink" title="2.界面开发ArkUI"></a>2.界面开发ArkUI</h1><h2 id="1-基础结构"><a href="#1-基础结构" class="headerlink" title="1.基础结构"></a>1.基础结构</h2><ul><li>程序结构</li></ul><p><img src="/.com//image-20250529174116347.png" alt="image-20250529174116347"></p><ul><li><p><strong>装饰器</strong></p><ul><li>用于装饰类、结构、方法以及变量，并赋予其特殊的含义。如上述示例中@Entry、@Component和@State都是装饰器，@Component表示自定义组件，@Entry表示该自定义组件为入口组件，@State表示组件中的状态变量，状态变量变化会触发UI刷新。</li></ul></li><li><p><strong>UI描述</strong></p><ul><li>以声明式的方式来描述UI的结构，例如build()方法中的代码块。</li></ul></li><li><p><strong>自定义组件</strong></p><ul><li>可复用的UI单元，可组合其他组件，如上述被@Component装饰的struct Hello。</li></ul></li><li><p><strong>系统组件</strong></p><ul><li>ArkUI框架中默认内置的基础和容器组件，可直接被开发者调用，比如示例中的Column、Text、Divider、Button</li></ul></li><li><p><strong>属性方法</strong></p><ul><li>组件可以通过链式调用配置多项属性，如fontSize()、width()、height()、backgroundColor()等。</li></ul></li><li><p><strong>事件方法</strong></p><ul><li>组件可以通过链式调用设置多个事件的响应逻辑，如跟随在Button后面的onClick()。</li></ul></li><li><p><strong>@Builder&#x2F;@BuilderParam</strong></p><ul><li>特殊的封装UI描述的方法，细粒度的封装和复用UI描述。</li></ul></li><li><p><strong>@Extend&#x2F;@Style</strong></p><ul><li>扩展内置组件和封装属性样式，更灵活地组合内置组件。</li></ul></li><li><p><strong>stateStyles</strong></p><ul><li>多态样式，可以依据组件的内部状态的不同，设置不同样式。</li></ul></li></ul><h2 id="2-声明式UI"><a href="#2-声明式UI" class="headerlink" title="2.声明式UI"></a>2.声明式UI</h2><ul><li><p>ArkTS以声明方式组合和扩展组件来描述应用程序的UI，同时还提供了基本的<strong>属性、事件和子组件配置</strong>方法，帮助开发者实现应用交互逻辑。</p></li><li><p><strong>创建组件</strong></p><ul><li>根据组件构造方法的不同，创建组件包含有参数和无参数两种方式。创建组件时不需要new运算符。</li></ul></li><li><p><strong>无参数构造</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">Column</span>() &#123;<br>  <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;item 1&#x27;</span>)<br>  <span class="hljs-title class_">Divider</span>()<br>  <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;item 2&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><img src="/.com//image-20250602112936940.png" alt="image-20250602112936940"></p><ul><li><p><strong>有参数构建</strong></p><ul><li>如果组件的接口定义包含构造参数，则在组件后面的“()”配置相应参数。</li></ul><blockquote><ul><li>Image组件的必选参数src</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&gt;<span class="hljs-title class_">Image</span>(<span class="hljs-string">&#x27;https://xyz/test.jpg&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>Text组件的非必选参数content。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&gt;<span class="hljs-comment">// string类型的参数</span><br>&gt;<span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;test&#x27;</span>)<br>&gt;<span class="hljs-comment">// $r形式引入应用资源，可应用于多语言场景</span><br>&gt;<span class="hljs-title class_">Text</span>($r(<span class="hljs-string">&#x27;app.string.title_value&#x27;</span>))<br>&gt;<span class="hljs-comment">// 无参数形式</span><br>&gt;<span class="hljs-title class_">Text</span>()<br></code></pre></td></tr></table></figure><ul><li>变量或表达式也可以用于参数赋值，其中表达式返回的结果类型必须满足参数类型要求。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&gt;<span class="hljs-title class_">Image</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">imagePath</span>)<br>&gt;<span class="hljs-title class_">Image</span>(<span class="hljs-string">&#x27;https://&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">imageUrl</span>)<br>&gt;<span class="hljs-title class_">Text</span>(<span class="hljs-string">`count: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.count&#125;</span>`</span>)<br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>配置属性</strong></p><ul><li>属性方法以“.”链式调用的方式配置系统组件的样式和其他属性，建议每个属性方法单独写一行。</li><li>除了直接传递常量参数外，还可以传递变量或表达式。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>  .<span class="hljs-title function_">fontSize</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>)<br><span class="hljs-title class_">Image</span>(<span class="hljs-string">&#x27;test.jpg&#x27;</span>)<br>  .<span class="hljs-title function_">width</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? <span class="hljs-number">100</span> : <span class="hljs-number">200</span>)    <br>  .<span class="hljs-title function_">height</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">offset</span> + <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><ul><li>对于系统组件，ArkUI还为其属性预定义了一些枚举类型供开发者调用，枚举类型可以作为参数传递，但必须满足参数类型要求。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>  .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">20</span>)<br>  .<span class="hljs-title function_">fontColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span>)<br>  .<span class="hljs-title function_">fontWeight</span>(<span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Bold</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>配置事件</strong></p><ul><li><p>事件方法以“.”链式调用的方式配置系统组件支持的事件，建议每个事件方法单独写一行。</p></li><li><p><strong>使用箭头函数配置组件的事件方法。</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;Click me&#x27;</span>)<br>  .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">myText</span> = <span class="hljs-string">&#x27;ArkUI&#x27;</span>;<br>  &#125;)<br></code></pre></td></tr></table></figure></li><li><p>使用<strong>匿名函数表达式</strong>配置组件的事件方法，要求使用bind，以确保函数体中的this指向当前组件。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;add counter&#x27;</span>)<br>  .<span class="hljs-title function_">onClick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">counter</span> += <span class="hljs-number">2</span>;<br>  &#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>))<br></code></pre></td></tr></table></figure></li><li><p>使用组件的<strong>成员函数</strong>配置组件的事件方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">myClickHandler</span>(): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">counter</span> += <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;add counter&#x27;</span>)<br>  .<span class="hljs-title function_">onClick</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">myClickHandler</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>))<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>配置子组件</strong></p><ul><li>如果组件支持子组件配置，则需在尾随闭包”{…}”中为组件添加子组件的UI描述。Column、Row、Stack、Grid、List等组件都是容器组件。</li><li>简单的Column组件配置子组件的示例。容器组件均支持子组件配置，可以实现相对复杂的多级嵌套</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">Column</span>() &#123;<br>  <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br>    .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">100</span>)<br>  <span class="hljs-title class_">Divider</span>()  <span class="hljs-comment">//分割线</span><br>  <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">myText</span>)<br>    .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">100</span>)<br>    .<span class="hljs-title function_">fontColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-基础组件"><a href="#3-基础组件" class="headerlink" title="3.基础组件"></a>3.基础组件</h2><ul><li><p><strong>基础组件Text</strong> -显示一段文本的组件。</p><blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">Text</span>(content?: <span class="hljs-built_in">string</span> | <span class="hljs-title class_">Resource</span>)<br></code></pre></td></tr></table></figure></blockquote><p><img src="/.com//image-20250602142749033.png" alt="image-20250602142749033"></p><p><img src="/.com//image-20250602142758768.png" alt="image-20250602142758768"></p><p><img src="/.com//image-20250602142805695.png" alt="image-20250602142805695"></p></li><li><p><strong>Text案例</strong>：</p></li></ul><p><img src="/.com//image-20250602143022870.png" alt="image-20250602143022870"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 文本对齐方式示例组件</span><br><span class="hljs-comment"> * 展示了鸿蒙ArkTS中Text组件的textAlign属性的三种对齐方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Entry</span><span class="hljs-comment">// 使用 @Entry 装饰器标识这是一个入口组件。</span><br><span class="hljs-meta">@Component</span><span class="hljs-comment">// 使用 @Component 装饰器定义一个新组件。</span><br>struct <span class="hljs-title class_">TextExample1</span> &#123; <span class="hljs-comment">// 定义名为 TextExample1 的结构体，代表这个组件。</span><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 定义 build 方法来构建UI。</span><br>    <span class="hljs-comment">// 创建垂直弹性布局容器</span><br>    <span class="hljs-title class_">Flex</span>(&#123;<span class="hljs-comment">// 创建一个弹性布局容器。</span><br>      <span class="hljs-attr">direction</span>: <span class="hljs-title class_">FlexDirection</span>.<span class="hljs-property">Column</span>,    <span class="hljs-comment">// 垂直方向排列子组件</span><br>      <span class="hljs-attr">alignItems</span>: <span class="hljs-title class_">ItemAlign</span>.<span class="hljs-property">Start</span>,        <span class="hljs-comment">// 子组件沿主轴(水平方向)左对齐</span><br>      <span class="hljs-attr">justifyContent</span>: <span class="hljs-title class_">FlexAlign</span>.<span class="hljs-property">SpaceBetween</span> <span class="hljs-comment">// 子组件在交叉轴(垂直方向)均匀分布</span><br>    &#125;) &#123;<br>      <span class="hljs-comment">// ====== 标题区域 ======</span><br>      <span class="hljs-comment">// 单行文本</span><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;textAlign&#x27;</span>)<br>        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">9</span>)<br>        .<span class="hljs-title function_">fontColor</span>(<span class="hljs-number">0xCCCCCC</span>) <span class="hljs-comment">// 浅灰色标题文字</span><br>      <br>      <span class="hljs-comment">// ====== 居中对齐文本示例 ======</span><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;TextAlign set to Center.&#x27;</span>)<br>        .<span class="hljs-title function_">textAlign</span>(<span class="hljs-title class_">TextAlign</span>.<span class="hljs-property">Center</span>)      <span class="hljs-comment">// 设置文本水平居中对齐</span><br>        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">12</span>)                     <span class="hljs-comment">// 字体大小12vp</span><br>        .<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">1</span> &#125;)             <span class="hljs-comment">// 添加1vp宽度的边框</span><br>        .<span class="hljs-title function_">padding</span>(<span class="hljs-number">10</span>)                      <span class="hljs-comment">// 内边距10vp</span><br>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)                    <span class="hljs-comment">// 宽度占满父容器</span><br>      <br>      <span class="hljs-comment">// ====== 起始对齐文本示例 ======</span><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;TextAlign set to Start.&#x27;</span>)<br>        .<span class="hljs-title function_">textAlign</span>(<span class="hljs-title class_">TextAlign</span>.<span class="hljs-property">Start</span>)       <span class="hljs-comment">// 设置文本与起始位置对齐(左侧对齐)</span><br>        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">12</span>)<br>        .<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">1</span> &#125;)<br>        .<span class="hljs-title function_">padding</span>(<span class="hljs-number">10</span>)<br>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>      <br>      <span class="hljs-comment">// ====== 结束对齐文本示例 ======</span><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;TextAlign set to End.&#x27;</span>)<br>        .<span class="hljs-title function_">textAlign</span>(<span class="hljs-title class_">TextAlign</span>.<span class="hljs-property">End</span>)         <span class="hljs-comment">// 设置文本与结束位置对齐(右侧对齐)</span><br>        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">12</span>)<br>        .<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">1</span> &#125;)<br>        .<span class="hljs-title function_">padding</span>(<span class="hljs-number">10</span>)<br>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>       <br>        <span class="hljs-comment">// ====== 标题区域 ======</span><br>         <span class="hljs-comment">// 文本超长时显示方式</span><br>   <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;TextOverflow+maxLines&#x27;</span>).<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">9</span>).<span class="hljs-title function_">fontColor</span>(<span class="hljs-number">0xCCCCCC</span>) <span class="hljs-comment">// 创建一个文本组件，说明接下来的文本溢出设置。</span><br>        <br>        <span class="hljs-comment">// ====== 文本溢出截断示例 ======</span><br>   <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;This is the setting of textOverflow to Clip text content This is the setting of textOverflow to None text content. This is the setting of textOverflow to Clip text content This is the setting of textOverflow to None text content.&#x27;</span>)<br>     .<span class="hljs-title function_">textOverflow</span>(&#123; <span class="hljs-attr">overflow</span>: <span class="hljs-title class_">TextOverflow</span>.<span class="hljs-property">Clip</span> &#125;) <span class="hljs-comment">// 设置文本溢出处理方式为直接剪裁</span><br>     .<span class="hljs-title function_">maxLines</span>(<span class="hljs-number">1</span>)                                  <span class="hljs-comment">// 限制最大显示行数为1行</span><br>     .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">12</span>)                                <span class="hljs-comment">// 字体大小12vp</span><br>     .<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">1</span> &#125;)                        <span class="hljs-comment">// 添加1vp宽度的边框用于视觉参考</span><br>     .<span class="hljs-title function_">padding</span>(<span class="hljs-number">10</span>)                                 <span class="hljs-comment">// 内边距10vp，防止文本紧贴边框</span><br>     .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)                               <span class="hljs-comment">// 占满父容器宽度，触发文本溢出条件</span><br>     .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-string">&#x27;#F5F5F5&#x27;</span>)                  <span class="hljs-comment">// 背景色便于观察文本区域</span><br>        <span class="hljs-comment">// ====== 文本溢出省略号示例 ======</span><br>   <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;This is set textOverflow to Ellipsis text content This is set textOverflow to Ellipsis text content.&#x27;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;\u200B&#x27;</span>))<br>     .<span class="hljs-title function_">textOverflow</span>(&#123; <span class="hljs-attr">overflow</span>: <span class="hljs-title class_">TextOverflow</span>.<span class="hljs-property">Ellipsis</span> &#125;) <span class="hljs-comment">// 设置文本溢出时显示省略号</span><br>     .<span class="hljs-title function_">maxLines</span>(<span class="hljs-number">1</span>)                                  <span class="hljs-comment">// 限制最大显示行数为1行</span><br>     .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">12</span>)                                <span class="hljs-comment">// 字体大小12vp</span><br>     .<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">1</span> &#125;)                        <span class="hljs-comment">// 添加边框便于观察文本区域</span><br>     .<span class="hljs-title function_">padding</span>(<span class="hljs-number">10</span>)                                 <span class="hljs-comment">// 内边距10vp</span><br>     .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)                               <span class="hljs-comment">// 占满父容器宽度，确保文本溢出</span><br><br><span class="hljs-comment">// ====== 行高设置示例标题 ======</span><br>   <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;lineHeight&#x27;</span>)<br>     .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">9</span>)<br>     .<span class="hljs-title function_">fontColor</span>(<span class="hljs-number">0xCCCCCC</span>)                         <span class="hljs-comment">// 浅灰色说明文字</span><br><br><span class="hljs-comment">// ====== 默认行高文本 ======</span><br>   <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;This is the text with the line height set. This is the text with the line height set.&#x27;</span>)<br>     .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">12</span>)                                <span class="hljs-comment">// 字体大小12vp</span><br>     .<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">1</span> &#125;)                        <span class="hljs-comment">// 添加边框对比行高效果</span><br>     .<span class="hljs-title function_">padding</span>(<span class="hljs-number">10</span>)                                 <span class="hljs-comment">// 内边距10vp</span><br>     .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)                               <span class="hljs-comment">// 统一宽度便于对比</span><br><br><span class="hljs-comment">// ====== 自定义行高文本 ======</span><br>   <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;This is the text with the line height set. This is the text with the line height set.&#x27;</span>)<br>     .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">12</span>)                                <span class="hljs-comment">// 字体大小12vp</span><br>     .<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">1</span> &#125;)                        <span class="hljs-comment">// 添加边框对比行高效果</span><br>     .<span class="hljs-title function_">padding</span>(<span class="hljs-number">10</span>)                                 <span class="hljs-comment">// 内边距10vp</span><br>     .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)                               <span class="hljs-comment">// 统一宽度便于对比</span><br>     .<span class="hljs-title function_">lineHeight</span>(<span class="hljs-number">20</span>)                              <span class="hljs-comment">// 设置行高为20vp，控制文本行间距</span><br>     .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-string">&#x27;#F5F5F5&#x27;</span>)                  <span class="hljs-comment">// 背景色便于观察文本区域</span><br>       &#125;.<span class="hljs-title function_">height</span>(<span class="hljs-number">600</span>)<br>        .<span class="hljs-title function_">width</span>(<span class="hljs-number">350</span>)<br>        .<span class="hljs-title function_">padding</span>(&#123; <span class="hljs-attr">left</span>: <span class="hljs-number">35</span>, <span class="hljs-attr">right</span>: <span class="hljs-number">35</span>, <span class="hljs-attr">top</span>: <span class="hljs-number">35</span> &#125;)  <span class="hljs-comment">// 设置容器的高度、宽度和内边距。</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>容器组件-Column</strong> -Column容器组件是沿垂直方向布局的容器。</p><blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&gt;<span class="hljs-title class_">Column</span>(value?: &#123;space?: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>&#125;)<br></code></pre></td></tr></table></figure></blockquote></li></ul><p><img src="/.com//image-20250602144550463.png" alt="image-20250602144550463"></p><p><img src="/.com//image-20250602144557742.png" alt="image-20250602144557742"></p><ul><li><strong>Column案例</strong>：</li></ul><p><img src="/.com//image-20250602144652933.png" alt="image-20250602144652933"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Entry</span> <span class="hljs-comment">// 使用 @Entry 装饰器标记当前组件为应用入口组件，每个应用必须有且仅有一个 @Entry 装饰的组件</span><br><span class="hljs-meta">@Component</span> <span class="hljs-comment">// 使用 @Component 装饰器定义一个自定义组件，可在其他组件中复用（此处为入口组件，无需复用但需定义）</span><br>struct <span class="hljs-title class_">ColumnExample</span> &#123; <span class="hljs-comment">// 定义组件名称为 ColumnExample 的结构体，结构体名称建议首字母大写，符合 PascalCase 命名规范</span><br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 每个组件必须实现 build() 方法，用于构建组件的 UI 结构</span><br>    <span class="hljs-comment">// ---------------------- 最外层 Column 容器 ----------------------</span><br>    <span class="hljs-title class_">Column</span>(&#123; <span class="hljs-attr">space</span>: <span class="hljs-number">5</span> &#125;) &#123; <span class="hljs-comment">// 创建 Column 垂直布局容器，space 属性设置子元素之间的垂直间距为 5vp（虚拟像素）</span><br>      <br>      <span class="hljs-comment">// ---------------------- space 属性演示区域 ----------------------</span><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;space&#x27;</span>) <span class="hljs-comment">// 创建文本组件，内容为 &#x27;space&#x27;，用于说明下方演示的属性功能</span><br>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>) <span class="hljs-comment">// 设置文本宽度占父容器的 90%，避免紧贴边缘</span><br>      <br>      <span class="hljs-comment">// 内部 Column 容器：演示 space 属性对子元素间距的影响</span><br>      <span class="hljs-title class_">Column</span>(&#123; <span class="hljs-attr">space</span>: <span class="hljs-number">5</span> &#125;) &#123; <span class="hljs-comment">// 子 Column 容器，再次设置 space: 5，确保子元素垂直间距为 5vp</span><br>        <br>        <span class="hljs-comment">// 第一个子 Column（浅蓝色背景）</span><br>        <span class="hljs-title class_">Column</span>() <span class="hljs-comment">// 空 Column 组件（无内容时会渲染为矩形块）</span><br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>) <span class="hljs-comment">// 宽度占满父容器（即内部 Column 的 100%）</span><br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">30</span>) <span class="hljs-comment">// 高度固定为 30vp</span><br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0xAFEEEE</span>) <span class="hljs-comment">// 背景色设置为浅蓝色（十六进制色值）</span><br>        <br>        <span class="hljs-comment">// 第二个子 Column（青色背景）</span><br>        <span class="hljs-title class_">Column</span>() <br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>) <br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">30</span>) <br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0x00FFFF</span>) <span class="hljs-comment">// 背景色设置为青色</span><br>      &#125;<br>      <span class="hljs-comment">// 内部 Column 容器的修饰属性</span><br>      .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>) <span class="hljs-comment">// 宽度占外层 Column 的 90%，与上方文本宽度一致</span><br>      .<span class="hljs-title function_">height</span>(<span class="hljs-number">100</span>) <span class="hljs-comment">// 固定高度为 100vp，方便观察边框范围</span><br>      .<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">1</span> &#125;) <span class="hljs-comment">// 添加 1vp 宽度的边框，用于可视化容器边界</span><br><br>      <span class="hljs-comment">// ---------------------- 水平对齐方式（alignItems）演示区域 ----------------------</span><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;alignItems(Start)&#x27;</span>) <span class="hljs-comment">// 说明文本：水平起始对齐（左对齐）</span><br>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>) <span class="hljs-comment">// 宽度占比 90%</span><br><br>      <span class="hljs-comment">// 演示水平左对齐的 Column 容器</span><br>      <span class="hljs-title class_">Column</span>() &#123; <span class="hljs-comment">// 子 Column 容器（未设置 space，默认间距为 0）</span><br>        <br>        <span class="hljs-comment">// 第一个子 Column（占父容器宽度的 50%，浅蓝色背景）</span><br>        <span class="hljs-title class_">Column</span>() <br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;50%&#x27;</span>) <span class="hljs-comment">// 宽度为父容器的 50%（即当前 Column 的 50%）</span><br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">30</span>) <br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0xAFEEEE</span>)<br>        <br>        <span class="hljs-comment">// 第二个子 Column（占父容器宽度的 50%，青色背景）</span><br>        <span class="hljs-title class_">Column</span>() <br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;50%&#x27;</span>) <br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">30</span>) <br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0x00FFFF</span>)<br>      &#125;<br>      <span class="hljs-comment">// 容器修饰属性：设置水平对齐方式为起始（左对齐）</span><br>      .<span class="hljs-title function_">alignItems</span>(<span class="hljs-title class_">HorizontalAlign</span>.<span class="hljs-property">Start</span>) <span class="hljs-comment">// 子元素在水平方向（主轴）左对齐</span><br>      .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>) <span class="hljs-comment">// 容器宽度占比 90%</span><br>      .<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">1</span> &#125;) <span class="hljs-comment">// 添加边框</span><br><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;alignItems(End)&#x27;</span>) <span class="hljs-comment">// 说明文本：水平结束对齐（右对齐）</span><br>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>)<br><br>      <span class="hljs-comment">// 演示水平右对齐的 Column 容器</span><br>      <span class="hljs-title class_">Column</span>() &#123; <br>        <span class="hljs-title class_">Column</span>() <br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;50%&#x27;</span>) <br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">30</span>) <br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0xAFEEEE</span>)<br>        <br>        <span class="hljs-title class_">Column</span>() <br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;50%&#x27;</span>) <br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">30</span>) <br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0x00FFFF</span>)<br>      &#125;<br>      .<span class="hljs-title function_">alignItems</span>(<span class="hljs-title class_">HorizontalAlign</span>.<span class="hljs-property">End</span>) <span class="hljs-comment">// 子元素在水平方向右对齐</span><br>      .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>) <br>      .<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">1</span> &#125;)<br><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;alignItems(Center)&#x27;</span>) <span class="hljs-comment">// 说明文本：水平居中对齐</span><br>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>)<br><br>      <span class="hljs-comment">// 演示水平居中对齐的 Column 容器</span><br>      <span class="hljs-title class_">Column</span>() &#123; <br>        <span class="hljs-title class_">Column</span>() <br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;50%&#x27;</span>) <br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">30</span>) <br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0xAFEEEE</span>)<br>        <br>        <span class="hljs-title class_">Column</span>() <br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;50%&#x27;</span>) <br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">30</span>) <br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0x00FFFF</span>)<br>      &#125;<br>      .<span class="hljs-title function_">alignItems</span>(<span class="hljs-title class_">HorizontalAlign</span>.<span class="hljs-property">Center</span>) <span class="hljs-comment">// 子元素在水平方向居中对齐</span><br>      .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>) <br>      .<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">1</span> &#125;)<br><br>      <span class="hljs-comment">// ---------------------- 垂直对齐方式（justifyContent）演示区域 ----------------------</span><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;justifyContent(Center)&#x27;</span>) <span class="hljs-comment">// 说明文本：垂直居中对齐</span><br>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>)<br><br>      <span class="hljs-comment">// 演示垂直居中对齐的 Column 容器（需设置容器高度以触发对齐）</span><br>      <span class="hljs-title class_">Column</span>() &#123; <br>        <span class="hljs-title class_">Column</span>() <br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>) <span class="hljs-comment">// 子元素宽度占父容器（当前 Column）的 90%</span><br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">30</span>) <br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0xAFEEEE</span>)<br>        <br>        <span class="hljs-title class_">Column</span>() <br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>) <br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">30</span>) <br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0x00FFFF</span>)<br>      &#125;<br>      .<span class="hljs-title function_">height</span>(<span class="hljs-number">100</span>) <span class="hljs-comment">// 容器高度固定为 100vp，子元素总高度为 60vp（30+30），剩余空间由 justifyContent 分配</span><br>      .<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">1</span> &#125;) <br>      .<span class="hljs-title function_">justifyContent</span>(<span class="hljs-title class_">FlexAlign</span>.<span class="hljs-property">Center</span>) <span class="hljs-comment">// 子元素在垂直方向（交叉轴）居中对齐，剩余空间均匀分布在上下方</span><br><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;justifyContent(End)&#x27;</span>) <span class="hljs-comment">// 说明文本：垂直结束对齐（底部对齐）</span><br>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>)<br><br>      <span class="hljs-comment">// 演示垂直结束对齐的 Column 容器</span><br>      <span class="hljs-title class_">Column</span>() &#123; <br>        <span class="hljs-title class_">Column</span>() <br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>) <br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">30</span>) <br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0xAFEEEE</span>)<br>        <br>        <span class="hljs-title class_">Column</span>() <br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>) <br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">30</span>) <br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0x00FFFF</span>)<br>      &#125;<br>      .<span class="hljs-title function_">height</span>(<span class="hljs-number">100</span>) <br>      .<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">1</span> &#125;) <br>      .<span class="hljs-title function_">justifyContent</span>(<span class="hljs-title class_">FlexAlign</span>.<span class="hljs-property">End</span>) <span class="hljs-comment">// 子元素在垂直方向底部对齐，剩余空间集中在容器顶部</span><br>      <br>    &#125;<br>    <span class="hljs-comment">// 最外层 Column 的修饰属性</span><br>    .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>) <span class="hljs-comment">// 宽度占满屏幕（父容器为窗口时）</span><br>    .<span class="hljs-title function_">padding</span>(&#123; <span class="hljs-attr">top</span>: <span class="hljs-number">5</span> &#125;) <span class="hljs-comment">// 顶部内边距 5vp，避免内容紧贴屏幕顶部</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>容器组件-Row</strong> -Row容器组件是沿水平方向布局容器。</li></ul><blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&gt;<span class="hljs-title class_">Row</span>(value?:&#123;space?: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> &#125;)<br></code></pre></td></tr></table></figure></blockquote><p><img src="/.com//image-20250602145710860.png" alt="image-20250602145710860"></p><p><img src="/.com//image-20250602145715463.png" alt="image-20250602145715463"></p><ul><li><strong>Row案例</strong>:</li></ul><p><img src="/.com//image-20250602145813153.png" alt="image-20250602145813153"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Entry</span> <span class="hljs-comment">// 使用@Entry装饰器标记为入口组件，每个应用必须有一个</span><br><span class="hljs-meta">@Component</span> <span class="hljs-comment">// 使用@Component装饰器定义自定义组件</span><br>struct <span class="hljs-title class_">RowExample</span> &#123; <span class="hljs-comment">// 定义组件名为RowExample的结构体</span><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 构建UI的核心方法</span><br>    <span class="hljs-title class_">Column</span>(&#123; <span class="hljs-attr">space</span>: <span class="hljs-number">5</span> &#125;) &#123; <span class="hljs-comment">// 创建垂直布局容器，子元素垂直间距5vp</span><br>      <br>      <span class="hljs-comment">// ---------------------- space属性演示 ----------------------</span><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;space&#x27;</span>) <span class="hljs-comment">// 说明文本：演示Row的space属性（水平间距）</span><br>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>) <span class="hljs-comment">// 宽度占父容器90%</span><br><br>      <span class="hljs-title class_">Row</span>(&#123; <span class="hljs-attr">space</span>: <span class="hljs-number">5</span> &#125;) &#123; <span class="hljs-comment">// 水平布局容器，子元素水平间距5vp</span><br>        <span class="hljs-title class_">Row</span>() <span class="hljs-comment">// 第一个子Row（浅蓝色背景）</span><br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;30%&#x27;</span>) <span class="hljs-comment">// 宽度占父Row的30%</span><br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">50</span>) <span class="hljs-comment">// 高度50vp</span><br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0xAFEEEE</span>) <span class="hljs-comment">// 浅蓝色背景色</span><br>        <br>        <span class="hljs-title class_">Row</span>() <span class="hljs-comment">// 第二个子Row（青色背景）</span><br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;30%&#x27;</span>)<br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">50</span>)<br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0x00FFFF</span>) <span class="hljs-comment">// 青色背景色</span><br>      &#125;<br>      .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>) <span class="hljs-comment">// 父Row宽度占90%</span><br>      .<span class="hljs-title function_">height</span>(<span class="hljs-number">107</span>) <span class="hljs-comment">// 固定高度便于观察边框</span><br>      .<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">1</span> &#125;) <span class="hljs-comment">// 添加1vp边框</span><br><br>      <span class="hljs-comment">// ---------------------- 垂直对齐方式（alignItems）演示 ----------------------</span><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;alignItems(Bottom)&#x27;</span>) <span class="hljs-comment">// 说明文本：垂直底部对齐</span><br>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>)<br><br>      <span class="hljs-title class_">Row</span>() &#123; <span class="hljs-comment">// 水平布局容器</span><br>        <span class="hljs-title class_">Row</span>() <span class="hljs-comment">// 子Row1</span><br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;30%&#x27;</span>)<br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">50</span>)<br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0xAFEEEE</span>)<br>        <br>        <span class="hljs-title class_">Row</span>() <span class="hljs-comment">// 子Row2</span><br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;30%&#x27;</span>)<br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">50</span>)<br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0x00FFFF</span>)<br>      &#125;<br>      .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>) <span class="hljs-comment">// 宽度90%</span><br>      .<span class="hljs-title function_">alignItems</span>(<span class="hljs-title class_">VerticalAlign</span>.<span class="hljs-property">Bottom</span>) <span class="hljs-comment">// 子元素垂直底部对齐</span><br>      .<span class="hljs-title function_">height</span>(<span class="hljs-string">&#x27;15%&#x27;</span>) <span class="hljs-comment">// 高度占父容器垂直空间的15%（需父容器有明确高度）</span><br>      .<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">1</span> &#125;) <span class="hljs-comment">// 边框</span><br><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;alignItems(Center)&#x27;</span>) <span class="hljs-comment">// 说明文本：垂直居中对齐</span><br>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>)<br><br>      <span class="hljs-title class_">Row</span>() &#123; <span class="hljs-comment">// 水平布局容器</span><br>        <span class="hljs-title class_">Row</span>()<br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;30%&#x27;</span>)<br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">50</span>)<br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0xAFEEEE</span>)<br>        <br>        <span class="hljs-title class_">Row</span>()<br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;30%&#x27;</span>)<br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">50</span>)<br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0x00FFFF</span>)<br>      &#125;<br>      .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>)<br>      .<span class="hljs-title function_">alignItems</span>(<span class="hljs-title class_">VerticalAlign</span>.<span class="hljs-property">Center</span>) <span class="hljs-comment">// 子元素垂直居中对齐</span><br>      .<span class="hljs-title function_">height</span>(<span class="hljs-string">&#x27;15%&#x27;</span>)<br>      .<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">1</span> &#125;)<br><br>      <span class="hljs-comment">// ---------------------- 水平对齐方式（justifyContent）演示 ----------------------</span><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;justifyContent(End)&#x27;</span>) <span class="hljs-comment">// 说明文本：水平结束对齐（右对齐）</span><br>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>)<br><br>      <span class="hljs-title class_">Row</span>() &#123; <span class="hljs-comment">// 水平布局容器</span><br>        <span class="hljs-title class_">Row</span>()<br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;30%&#x27;</span>)<br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">50</span>)<br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0xAFEEEE</span>)<br>        <br>        <span class="hljs-title class_">Row</span>()<br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;30%&#x27;</span>)<br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">50</span>)<br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0x00FFFF</span>)<br>      &#125;<br>      .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>) <span class="hljs-comment">// 宽度90%</span><br>      .<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">1</span> &#125;) <span class="hljs-comment">// 边框</span><br>      .<span class="hljs-title function_">justifyContent</span>(<span class="hljs-title class_">FlexAlign</span>.<span class="hljs-property">End</span>) <span class="hljs-comment">// 子元素水平右对齐（剩余空间在左侧）</span><br><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;justifyContent(Center)&#x27;</span>) <span class="hljs-comment">// 说明文本：水平居中对齐</span><br>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>)<br><br>      <span class="hljs-title class_">Row</span>() &#123; <span class="hljs-comment">// 水平布局容器</span><br>        <span class="hljs-title class_">Row</span>()<br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;30%&#x27;</span>)<br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">50</span>)<br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0xAFEEEE</span>)<br>        <br>        <span class="hljs-title class_">Row</span>()<br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;30%&#x27;</span>)<br>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">50</span>)<br>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0x00FFFF</span>)<br>      &#125;<br>      .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>)<br>      .<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">1</span> &#125;)<br>      .<span class="hljs-title function_">justifyContent</span>(<span class="hljs-title class_">FlexAlign</span>.<span class="hljs-property">Center</span>) <span class="hljs-comment">// 子元素水平居中对齐（剩余空间均匀分布两侧）</span><br><br>    &#125;<br>    .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>) <span class="hljs-comment">// 最外层Column宽度占满屏幕</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-自定义组件"><a href="#4-自定义组件" class="headerlink" title="4.自定义组件"></a>4.自定义组件</h2><p><img src="/.com//image-20250602150221614.png" alt="image-20250602150221614"></p><ul><li><strong>自定义组件案例</strong>：</li></ul><p><img src="/.com//image-20250602150401034.png" alt="image-20250602150401034"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 自定义组件：可复用的文本点击交互组件</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">HelloComponent</span> &#123;<br>  <span class="hljs-comment">// 声明状态变量：message 用于存储文本内容，@State 装饰器使UI响应数据变化</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Hello, World!&#x27;</span>; <br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 使用Row布局水平排列子组件</span><br>    <span class="hljs-title class_">Row</span>() &#123; <br>      <span class="hljs-comment">// 文本组件，显示message状态变量的值</span><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>) <br>        .<span class="hljs-title function_">height</span>(<span class="hljs-number">50</span>)        <span class="hljs-comment">// 固定高度50vp</span><br>        .<span class="hljs-title function_">width</span>(<span class="hljs-number">200</span>)        <span class="hljs-comment">// 固定宽度200vp</span><br>        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">30</span>)      <span class="hljs-comment">// 字体大小30vp</span><br>        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;   <span class="hljs-comment">// 点击事件处理函数</span><br>          <span class="hljs-comment">// 修改状态变量message的值，触发UI自动刷新</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;Hello, ArkUI!&#x27;</span>; <br>        &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 入口组件：应用的根组件</span><br><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">ParentComponent</span> &#123;<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 使用Column布局垂直排列子组件</span><br>    <span class="hljs-title class_">Column</span>() &#123; <br>      <span class="hljs-comment">// 标题文本</span><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;ArkUI message&#x27;</span>) <br>        .<span class="hljs-title function_">height</span>(<span class="hljs-number">100</span>)       <span class="hljs-comment">// 高度100vp</span><br>        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">50</span>)      <span class="hljs-comment">// 字体大小50vp</span><br>        .<span class="hljs-title function_">fontWeight</span>(<span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Bold</span>) <span class="hljs-comment">// 字体加粗</span><br><br>      <span class="hljs-comment">// 引用自定义组件HelloComponent，传递初始参数message=&quot;Hello, World!&quot;</span><br>      <span class="hljs-title class_">HelloComponent</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello, World!&#x27;</span> &#125;); <br><br>      <span class="hljs-comment">// 分隔线组件，用于视觉分隔</span><br>      <span class="hljs-title class_">Divider</span>() <br><br>      <span class="hljs-comment">// 再次引用HelloComponent，传递中文参数message=&quot;你好!&quot;</span><br>      <span class="hljs-title class_">HelloComponent</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;你好!&#x27;</span> &#125;); <br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/.com//image-20250602150437522.png" alt="image-20250602150437522"></p><p><img src="/.com//image-20250602150453679.png" alt="image-20250602150453679"></p><p><img src="/.com//image-20250602150507487.png" alt="image-20250602150507487"></p><p>所有声明在build()函数的语言，我们统称为UI描述，UI描述需要遵循以下规则</p><blockquote><p>@Entry装饰的自定义组件，其build()函数下的根节点唯一且必要，且必须为容器组件，其中ForEach禁止作为根节点。</p><p>@Component装饰的自定义组件，其build()函数下的根节点唯一且必要，可以为非容器组件，其中ForEach禁止作为根节点。</p><p>不允许声明本地变量 </p><p>不允许在UI描述里直接使用console.info，但允许在方法或者函数里使用</p><p>不允许创建本地的作用域</p><p>不允许switch语法，如果需要使用条件判断，请使用if。</p></blockquote><ul><li>案例</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">MainComponent</span> &#123;<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 根容器使用Row布局 -必须以容器组件为根结点</span><br>    <span class="hljs-title class_">Row</span>() &#123;<br>      <span class="hljs-comment">// 引入子组件</span><br>      <span class="hljs-title class_">ChildComponent</span>()<br>    &#125;<br>    .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)  <span class="hljs-comment">// 占满屏幕宽度</span><br>    .<span class="hljs-title function_">justifyContent</span>(<span class="hljs-title class_">FlexAlign</span>.<span class="hljs-property">Center</span>)  <span class="hljs-comment">// 子组件水平居中</span><br>  &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">ChildComponent</span> &#123;<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 直接使用Image组件作为根节点</span><br>    <span class="hljs-title class_">Image</span>($r(<span class="hljs-string">&#x27;app.media.test&#x27;</span>))<br>      .<span class="hljs-title function_">width</span>(<span class="hljs-number">300</span>)  <span class="hljs-comment">// 设置图片宽度</span><br>      .<span class="hljs-title function_">height</span>(<span class="hljs-number">200</span>) <span class="hljs-comment">// 设置图片高度</span><br>      .<span class="hljs-title function_">objectFit</span>(<span class="hljs-title class_">ImageFit</span>.<span class="hljs-property">Contain</span>)  <span class="hljs-comment">// 图片缩放模式</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//规则</span><br><span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 反例：不允许声明本地变量</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 反例：不允许console.info</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;print debug log&#x27;</span>);<br>&#125;<br><span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 反例：不允许本地作用域</span><br>  &#123;<br>    ...<br>  &#125;<br>&#125;<br><span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Column</span>() &#123;<br>    <span class="hljs-comment">// 反例：不允许使用switch语法</span><br>    <span class="hljs-keyword">switch</span> (expression) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;...&#x27;</span>)<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        <span class="hljs-title class_">Image</span>(<span class="hljs-string">&#x27;...&#x27;</span>)<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-attr">default</span>:<br>        <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;...&#x27;</span>)<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/.com//image-20250602150520193.png" alt="image-20250602150520193"></p><p><img src="/.com//image-20250602150613254.png" alt="image-20250602150613254"></p><p><img src="/.com//image-20250602150636130.png" alt="image-20250602150636130"></p><ul><li>自定义组件的参数规定案例：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">MyComponent</span> &#123;<br>  <span class="hljs-comment">// 组件私有属性：倒计时起始值</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">countDownFrom</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 组件私有属性：文本背景颜色</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">color</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Blue</span>;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 创建水平布局容器</span><br>    <span class="hljs-title class_">Row</span>() &#123;<br>      <span class="hljs-comment">// 创建文本组件</span><br>      <span class="hljs-title class_">Text</span>()<br>        .<span class="hljs-title function_">height</span>(<span class="hljs-number">50</span>)                <span class="hljs-comment">// 设置高度为50vp</span><br>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)             <span class="hljs-comment">// 设置宽度为父容器的100%</span><br>        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">30</span>)              <span class="hljs-comment">// 设置字体大小为30vp</span><br>        .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span>) <span class="hljs-comment">// 设置背景颜色为传入的color属性值</span><br>        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;           <span class="hljs-comment">// 绑定点击事件</span><br>          <span class="hljs-comment">// 点击事件处理函数（当前为空，可添加业务逻辑）</span><br>        &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">ParentComponent</span> &#123;<br>  <span class="hljs-comment">// 私有属性：颜色值</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">someColor</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span>;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 创建垂直布局容器</span><br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-comment">// 创建MyComponent实例并传递参数</span><br>      <span class="hljs-title class_">MyComponent</span>(&#123; <br>        <span class="hljs-attr">countDownFrom</span>: <span class="hljs-number">10</span>,        <span class="hljs-comment">// 初始化countDownFrom为10</span><br>        <span class="hljs-attr">color</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">someColor</span>     <span class="hljs-comment">// 传递颜色值</span><br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/.com//image-20250602150903628.png" alt="image-20250602150903628"></p><blockquote><p>传递参数修改颜色</p></blockquote><p><img src="/.com//image-20250602151602717.png" alt="image-20250602151602717"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">MyComponent2</span> &#123;<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 创建按钮组件，内容为&quot;Hello World&quot;</span><br>    <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;Hello World&quot;</span>)<br>     <br>  &#125;<br>&#125;<br><br><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">MyComponent</span> &#123;<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 创建水平布局容器</span><br>    <span class="hljs-title class_">Row</span>() &#123;<br>      <span class="hljs-comment">// 引入子组件MyComponent2</span><br>      <span class="hljs-title class_">MyComponent2</span>()<br>    &#125;<br>    .<span class="hljs-title function_">width</span>(<span class="hljs-number">200</span>)           <span class="hljs-comment">// 设置Row宽度为200vp</span><br>    .<span class="hljs-title function_">height</span>(<span class="hljs-number">300</span>)          <span class="hljs-comment">// 设置Row高度为300vp</span><br>    .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span>) <span class="hljs-comment">// 设置背景色为红色</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ArkUI给自定义组件设置样式时，相当于给MyComponent2套了一个不可见的容器组件。<br>而这些样式是设置在容器组件上的，而非直接设置给MyComponent2的Button组件。<br>通过渲染结果我们可以很清楚的看到，背景颜色红色并没有直接生效在Button上，而是生效在Button所处的开发者不可见的容器组件上。</p></blockquote><p><img src="/.com//image-20250602151851993.png" alt="image-20250602151851993"></p><p><img src="/.com//image-20250602151926517.png" alt="image-20250602151926517"></p><p><img src="/.com//image-20250602151953821.png" alt="image-20250602151953821"></p><p><img src="/.com//image-20250602152031365.png" alt="image-20250602152031365"></p><p><img src="/.com//image-20250602152108151.png" alt="image-20250602152108151"></p><ul><li><strong>当应用在后台启动时</strong>，此时应用进程并没有销毁，所以仅需要执行<strong>onPageShow</strong>。</li></ul><p><img src="/.com//image-20250602152238815.png" alt="image-20250602152238815"></p><p><img src="/.com//image-20250602152331168.png" alt="image-20250602152331168"></p><ul><li>展示<strong>生命周期的调用时机</strong>案例：</li></ul><p><img src="/.com//image-20250602152854186.png" alt="image-20250602152854186"></p><p><img src="/.com//image-20250602153618910.png" alt="image-20250602153618910"></p><blockquote><p>在resources&#x2F;base&#x2F;profile目录下的main_pages.json中配置 -实现路由</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&gt;<span class="hljs-punctuation">&#123;</span><br>&gt;<span class="hljs-attr">&quot;src&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>&gt;<span class="hljs-string">&quot;pages/Index&quot;</span><span class="hljs-punctuation">,</span><br>&gt;<span class="hljs-string">&quot;pages/Page2&quot;</span><br>&gt;<span class="hljs-punctuation">&#125;</span><br>&gt;<span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></blockquote><p><img src="/.com//image-20250602153658764.png" alt="image-20250602153658764"></p><p><img src="/.com//image-20250602153711059.png" alt="image-20250602153711059"></p><p><img src="/.com//image-20250602153720204.png" alt="image-20250602153720204"></p><ul><li><p><strong>@Builder装饰器 -自定义构建函数</strong>   -局部封装-无独立生命周期</p><ul><li>内部定义无需function</li></ul><p><img src="/.com//image-20250602161320920.png" alt="image-20250602161320920"></p><ul><li><p>按照值传递不会引起@Builder方法内的UI刷新。</p></li><li><pre><code class="typescript">@Builder function ABuilder(&#123; paramA1: string, paramB1 : string)&#123;...&#125;<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nim"><br>- 按引用传递参数时，传递的参数可为状态变量，且状态变量的改变会引起@<span class="hljs-type">Builder</span>方法内的<span class="hljs-type">UI</span>刷新。<span class="hljs-type">ArkUI</span>提供$$作为按引用传递参数的范式。<br><br>- ~~~typescript<br>  @<span class="hljs-type">Builder</span> function <span class="hljs-type">ABuilder</span>( $$ : &#123; paramA1: <span class="hljs-type">string</span>, paramB1 : <span class="hljs-type">string</span> &#125; )<span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure></code></pre></li><li><pre><code class="typescript">@Builder function ABuilder($$: &#123; paramA1: string &#125;) &#123;Row() &#123;Text(`UseStateVarByReference: $&#123;$$.paramA1&#125; `)     .margin(20)&#125;&#125;@Entry@Componentstruct Parent &#123;  @State label: string = &#39;Hello&#39;;  build() &#123;    Column() &#123;      Divider()            // 在Parent组件中调用ABuilder，将label引用传递给ABuilder      ABuilder(&#123;         text: this.label // 通过props传递数据      &#125;)            Button(&#39;Click me&#39;)        .onClick(() =&gt; &#123;          // 点击按钮后更新状态，触发UI刷新          this.label = &#39;ArkUI&#39;;        &#125;)    &#125;  &#125;&#125;</code></pre></li></ul></li></ul><h2 id="5-状态管理-装饰器"><a href="#5-状态管理-装饰器" class="headerlink" title="5.状态管理-装饰器"></a>5.状态管理-装饰器</h2><p><img src="/.com//image-20250602182216335.png" alt="image-20250602182216335"></p><p><img src="/.com//image-20250602182226616.png" alt="image-20250602182226616"></p><p><img src="/.com//image-20250602182239902.png" alt="image-20250602182239902"></p><p><img src="/.com//image-20250602182253645.png" alt="image-20250602182253645"></p><p><img src="/.com//image-20250602182316405.png" alt="image-20250602182316405"></p><ul><li><strong>@State装饰器</strong></li></ul><p><img src="/.com//image-20250602182332855.png" alt="image-20250602182332855"></p><p><img src="/.com//image-20250602182343017.png" alt="image-20250602182343017"></p><p><img src="/.com//image-20250602182513606.png" alt="image-20250602182513606"></p><p><img src="/.com//image-20250602182604125.png" alt="image-20250602182604125"></p><p><img src="/.com//image-20250602182622253.png" alt="image-20250602182622253"></p><ul><li>修改自定义类的属性时，使用**.**修改时，不会引起刷新，需要整个进行修改才会进行刷新。</li></ul><p><img src="/.com//image-20250602183113878.png" alt="image-20250602183113878"></p><ul><li><strong>@Prop装饰器</strong></li></ul><p><img src="/.com//image-20250602183155542.png" alt="image-20250602183155542"></p><p><img src="/.com//image-20250602183231473.png" alt="image-20250602183231473"></p><p><img src="/.com//image-20250602183239779.png" alt="image-20250602183239779"></p><p><img src="/.com//image-20250602183249468.png" alt="image-20250602183249468"></p><p><img src="/.com//image-20250602183258668.png" alt="image-20250602183258668"></p><p><img src="/.com//image-20250602183307893.png" alt="image-20250602183307893"></p><p><img src="/.com//image-20250602183317548.png" alt="image-20250602183317548"></p><p><img src="/.com//image-20250602183326990.png" alt="image-20250602183326990"></p><p><img src="/.com//image-20250602183337127.png" alt="image-20250602183337127"></p><p><img src="/.com//image-20250602183423412.png" alt="image-20250602183423412"></p><p><img src="/.com//image-20250602183436998.png" alt="image-20250602183436998"></p><p><img src="/.com//image-20250602183450331.png" alt="image-20250602183450331"></p><p><img src="/.com//image-20250602183511548.png" alt="image-20250602183511548"></p><p><img src="/.com//image-20250602183522453.png" alt="image-20250602183522453"></p><p><img src="/.com//image-20250602183548508.png" alt="image-20250602183548508"></p><p><img src="/.com//image-20250602183558252.png" alt="image-20250602183558252"></p><p><img src="/.com//image-20250602183606877.png" alt="image-20250602183606877"></p><p><img src="/.com//image-20250602183643894.png" alt="image-20250602183643894"></p><p><img src="/.com//image-20250602183716182.png" alt="image-20250602183716182"></p><p><img src="/.com//image-20250602183735963.png" alt="image-20250602183735963"></p><p><img src="/.com//image-20250602183751520.png" alt="image-20250602183751520"></p><p><img src="/.com//image-20250602183921275.png" alt="image-20250602183921275"></p><p><img src="/.com//image-20250602183938895.png" alt="image-20250602183938895"></p><p><img src="/.com//image-20250602183957575.png" alt="image-20250602183957575"></p><p><img src="/.com//image-20250602184009281.png" alt="image-20250602184009281"></p><ul><li><strong>@Link装饰器</strong></li></ul><p><img src="/.com//image-20250602184026232.png" alt="image-20250602184026232"></p><p><img src="/.com//image-20250602184045714.png" alt="image-20250602184045714"></p><p><img src="/.com//image-20250602184058548.png" alt="image-20250602184058548"></p><p><img src="/.com//image-20250602184108710.png" alt="image-20250602184108710"></p><p><img src="/.com//image-20250602184118746.png" alt="image-20250602184118746"></p><p><img src="/.com//image-20250602184135555.png" alt="image-20250602184135555"></p><p><img src="/.com//image-20250602184144704.png" alt="image-20250602184144704"></p><p><img src="/.com//image-20250602184158198.png" alt="image-20250602184158198"></p><p><img src="/.com//image-20250602184233058.png" alt="image-20250602184233058"></p><p><img src="/.com//image-20250602184257159.png" alt="image-20250602184257159"></p><p><img src="/.com//image-20250602184310184.png" alt="image-20250602184310184"></p><p><img src="/.com//image-20250602184326512.png" alt="image-20250602184326512"></p><h2 id="6-条件渲染"><a href="#6-条件渲染" class="headerlink" title="6.条件渲染"></a>6.条件渲染</h2><p><img src="/.com//image-20250602184344110.png" alt="image-20250602184344110"></p><p><img src="/.com//image-20250602184354641.png" alt="image-20250602184354641"></p><p><img src="/.com//image-20250602184417963.png" alt="image-20250602184417963"></p><p><img src="/.com//image-20250602184426643.png" alt="image-20250602184426643"></p><p><img src="/.com//image-20250602184436650.png" alt="image-20250602184436650"></p><p><img src="/.com//image-20250602184516661.png" alt="image-20250602184516661"></p><p><img src="/.com//image-20250602184545024.png" alt="image-20250602184545024"></p><p><img src="/.com//image-20250602184559398.png" alt="image-20250602184559398"></p><p><img src="/.com//image-20250602184631460.png" alt="image-20250602184631460"></p><p><img src="/.com//image-20250602184646097.png" alt="image-20250602184646097"></p><p><img src="/.com//image-20250602184659067.png" alt="image-20250602184659067"></p><p><img src="/.com//image-20250602184731929.png" alt="image-20250602184731929"></p><p><img src="/.com//image-20250602184746134.png" alt="image-20250602184746134"></p><p><img src="/.com//image-20250602184756985.png" alt="image-20250602184756985"></p><p><img src="/.com//image-20250602184805677.png" alt="image-20250602184805677"></p><p><img src="/.com//image-20250602184812838-17488612940631.png" alt="image-20250602184812838"></p><p><img src="/.com//image-20250602184827821.png" alt="image-20250602184827821"></p><p><img src="/.com//image-20250602184842631.png" alt="image-20250602184842631"></p><p><img src="/.com//image-20250602184904361.png" alt="image-20250602184904361"></p><p><img src="/.com//image-20250602184918715.png" alt="image-20250602184918715"></p><p><img src="/.com//image-20250602185105401.png" alt="image-20250602185105401"></p><p><img src="/.com//image-20250602185116303.png" alt="image-20250602185116303"></p><p><img src="/.com//image-20250602185133258.png" alt="image-20250602185133258"></p><p><img src="/.com//image-20250602185144484.png" alt="image-20250602185144484"></p><p><img src="/.com//image-20250602185154398.png" alt="image-20250602185154398"></p><p><img src="/.com//image-20250602185203664.png" alt="image-20250602185203664"></p><p><img src="/.com//image-20250602185232463.png" alt="image-20250602185232463"></p><p><img src="/.com//image-20250602185249447.png" alt="image-20250602185249447"></p><p><img src="/.com//image-20250602185302960.png" alt="image-20250602185302960"></p><p><img src="/.com//image-20250602185313940.png" alt="image-20250602185313940"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <url>/2025/07/02/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>分布式微服务</p><ul><li>Rpc远程调用</li><li>分布式基础</li><li>微服务Spring Cloud</li></ul><h1 id="1-分布式架构基础"><a href="#1-分布式架构基础" class="headerlink" title="1.分布式架构基础"></a>1.分布式架构基础</h1><h3 id="1-1分布式系统中的相关概念"><a href="#1-1分布式系统中的相关概念" class="headerlink" title="1.1分布式系统中的相关概念"></a>1.1分布式系统中的相关概念</h3><ul><li><p>集群：很多”人”一起，干一样的事</p><ul><li>一个业务模块，部署在多台服务器上</li></ul></li><li><p>分布式：很多”人”一起，干不一样的事，各司其职，合起来是一件大事。</p><ul><li>一个大的业务系统，拆分成多个小的模块，分别部署在不同的机器上。</li></ul></li><li><p>分布式和集群：</p><ul><li>高性能</li><li>高可用</li><li>可伸缩</li><li>高可扩展性</li></ul></li></ul><p><img src="/.com//image-20250425142826274.png" alt="image-20250425142826274"></p><p><img src="/.com//image-20250425143001622.png" alt="image-20250425143001622"></p><p><img src="/.com//image-20250425143238396.png" alt="image-20250425143238396"></p><p><img src="/.com//image-20250425143440871.png" alt="image-20250425143440871"></p><p><img src="/.com//image-20250425143636629.png" alt="image-20250425143636629"></p><p><img src="/.com//image-20250425143648568.png" alt="image-20250425143648568"></p><h1 id="2-Rpc远程调用"><a href="#2-Rpc远程调用" class="headerlink" title="2.Rpc远程调用"></a>2.Rpc远程调用</h1><h2 id="1-Rpc框架-Apache-Dubbo"><a href="#1-Rpc框架-Apache-Dubbo" class="headerlink" title="1.Rpc框架-Apache-Dubbo"></a>1.Rpc框架-Apache-Dubbo</h2><p><img src="/.com//image-20250425144050461.png" alt="image-20250425144050461"></p><h2 id="2-dubbo快速入门"><a href="#2-dubbo快速入门" class="headerlink" title="2.dubbo快速入门"></a>2.dubbo快速入门</h2><ul><li><p>引入dubbo依赖</p></li><li><p>安装zookeeper并启动 -默认端口2181  -用于完成注册registry</p></li><li><p>Registry实现</p></li></ul><p><img src="/.com//image-20250425144637193.png" alt="image-20250425144637193"></p><p><img src="/.com//image-20250425145450862.png" alt="image-20250425145450862"></p><ul><li>Service端注解**@Service(apache.dubbo下的Service注解)**注册到注册中心和Controller都进行Dubbo的地址配置</li><li>把Service端进行独立配置- 服务者</li><li>消费者<img src="/.com//image-20250425150659482.png" alt="image-20250425150659482"></li></ul><h2 id="3-Dubbo高级特性"><a href="#3-Dubbo高级特性" class="headerlink" title="3.Dubbo高级特性"></a>3.Dubbo高级特性</h2><h3 id="3-1-Monitor实现"><a href="#3-1-Monitor实现" class="headerlink" title="3.1.Monitor实现"></a>3.1.Monitor实现</h3><ul><li><p>下载Dubbo-admin管理平台（Spring+Vue实现）</p></li><li><p>配置文件配置注册Registry的路径</p></li><li><p>启动项目进行监听</p></li></ul><h3 id="3-2-高级特性"><a href="#3-2-高级特性" class="headerlink" title="3.2.高级特性"></a>3.2.高级特性</h3><p><img src="/.com//image-20250425172007959.png" alt="image-20250425172007959"></p><p><img src="/.com//image-20250425172106180.png" alt="image-20250425172106180"></p><p><img src="/.com//image-20250425172313481.png" alt="image-20250425172313481"></p><p><img src="/.com//image-20250425172442255.png" alt="image-20250425172442255"></p><ul><li>@Service(timeout&#x3D;”1000”,retries&#x3D;”2”)</li></ul><p><img src="/.com//image-20250425172639709.png" alt="image-20250425172639709"></p><ul><li>@Reference(version&#x3D;”1.0”)</li></ul><p><img src="/.com//image-20250425173050051.png" alt="image-20250425173050051"></p><ul><li>@Service(weight&#x3D;”100”)</li></ul><p><img src="/.com//image-20250425173858414.png" alt="image-20250425173858414"></p><p><img src="/.com//image-20250425174052888.png" alt="image-20250425174052888"></p><ul><li>@Reference(“mock&#x3D;force:return null”)</li></ul><h1 id="3-Spring-Cloud-微服务"><a href="#3-Spring-Cloud-微服务" class="headerlink" title="3.Spring Cloud-微服务"></a>3.Spring Cloud-微服务</h1><ul><li><p>微服务-解耦</p></li><li><p>微服务架构的4个核心问题</p><ul><li>服务很多，客户端如何访问？ API网关</li><li>服务之间如何通信？ Http&#x2F;RPC</li><li>如何管理服务？ 注册，监听</li><li>服务挂了怎么办？ 熔断机制-快速失败</li></ul></li><li><p>解决方案：</p><p>Spring Cloud 生态 </p><ul><li>Spring Cloud NetFlix 一站式解决 -已经停止更新和维护<ul><li>api网关，zuul组件</li><li>Feign  基于–HttpClient–  Http通信REST方式，同步，阻塞</li><li>服务注册发现 Eureka</li><li>熔断机制 Hystrix</li><li>…组件</li></ul></li><li>Apache Dubbo Zookeeper  半自动<ul><li>api网关，没有，找第三方组件</li><li>Dubbo(RPC框架)</li><li>Zookeeper注册</li><li>熔断机制 没有 借助 Hystrix</li><li>并不完善 需要借助第三方组件</li></ul></li><li>Spring Cloud Alibaba  一站式解决 更简单<ul><li>Spring Cloud Gateway-网关</li><li>Spring Cloud OpenFeign-远程调用</li><li>Spring Cloud Alibaba Nacos-注册，监听</li><li>Spring Cloud Alibaba Sentinel-熔断机制</li><li>Spring Cloud Alibaba Seata -分布式事务</li><li>Spring Boot -微服务单体</li></ul></li></ul></li><li><p>架构</p></li></ul><p><img src="/.com//image-20250425182057008.png" alt="image-20250425182057008"></p><h2 id="1-创建微服务项目"><a href="#1-创建微服务项目" class="headerlink" title="1.创建微服务项目"></a>1.创建微服务项目</h2><p><img src="/.com//image-20250425185949176.png" alt="image-20250425185949176"></p><h2 id="2-Nacos-注册、发现"><a href="#2-Nacos-注册、发现" class="headerlink" title="2.Nacos-注册、发现"></a>2.Nacos-注册、发现</h2><h3 id="1-注册中心"><a href="#1-注册中心" class="headerlink" title="1.注册中心"></a>1.注册中心</h3><h4 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h4><p><img src="/.com//image-20250425201322565.png" alt="image-20250425201322565"></p><ul><li>下载nacos2.4.3</li><li>启动命令：startup.cmd -m standalone</li><li>进入服务中心地址</li></ul><p><img src="/.com//image-20250425201754266.png" alt="image-20250425201754266"></p><p><img src="/.com//image-20250425210025524.png" alt="image-20250425210025524"></p><p><code>spring.cloud.nacos.server-addr=注册中心的地址</code></p><ul><li>若服务发现和配置管理使用同一个 Nacos 服务器，建议使用 <code>spring.cloud.nacos.server-addr</code> 进行全局配置，这样更为简洁。</li><li>若服务发现和配置管理需要使用不同的 Nacos 服务器，则应分别使用 <code>spring.cloud.nacos.discovery.server-addr</code> 和 <code>spring.cloud.nacos.config.server-addr</code> 来单独指定地址。</li></ul><p><img src="/.com//image-20250425210244012.png" alt="image-20250425210244012"></p><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p><img src="/.com//image-20250425204217125.png" alt="image-20250425204217125"></p><p><img src="/.com//image-20250522164827869.png" alt="image-20250522164827869"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscoveryTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> NacosServiceDiscovery nacosServiceDiscovery;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">discoveryClientTest</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span> (String service : discoveryClient.getServices()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;service= &quot;</span>+service);<span class="hljs-comment">//打印服务名称</span><br>            <span class="hljs-keyword">for</span> (ServiceInstance instance : discoveryClient.getInstances(service)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;ip: &quot;</span>+instance.getHost()+<span class="hljs-string">&quot;: &quot;</span>+<span class="hljs-string">&quot;port: &quot;</span>+instance.getPort());<span class="hljs-comment">//打印ip和端口</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">nacosServiceDiscovery</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NacosException &#123;<br>        <span class="hljs-keyword">for</span> (String service : nacosServiceDiscovery.getServices()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;service= &quot;</span>+service);<span class="hljs-comment">//打印服务名称</span><br>            <span class="hljs-keyword">for</span> (ServiceInstance instance : nacosServiceDiscovery.getInstances(service)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;ip: &quot;</span>+instance.getHost()+<span class="hljs-string">&quot;: &quot;</span>+<span class="hljs-string">&quot;port: &quot;</span>+instance.getPort());<span class="hljs-comment">//打印ip和端口</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注解：**@EnableDiscoveryClient**:开启<strong>服务发现</strong>，可以通过<strong>DiscoveryClient</strong>（所有的注册中心都可以用）和<strong>NacosServiceDiscovery</strong>（只有用Nacos可以用）获取服务的信息。</li><li>远程调用服务的第一步是<strong>服务发现</strong>。</li></ul><h4 id="服务之间远程调用-负载均衡"><a href="#服务之间远程调用-负载均衡" class="headerlink" title="服务之间远程调用-负载均衡"></a>服务之间远程调用-负载均衡</h4><p><img src="/.com//image-20250425210855095.png" alt="image-20250425210855095"></p><p><img src="/.com//image-20250425212848068.png" alt="image-20250425212848068"></p><ul><li><p>配置RestTemplate的Bean</p></li><li><p>基于<strong>LoadBanlancerClient</strong>的负载均衡</p><ul><li>引入<strong>spring-boot-starter-loadbanlancer</strong>依赖</li><li><strong>loadBanlancerClient.choose(“serviceId”)</strong>&#x2F;&#x2F;获取服务一个实例（遵循负载均衡规则-轮询）</li><li>再根据实例获取地址和端口编写url请求资源-<strong>restTemplate.getForObject(url,Object.calss)</strong></li></ul></li><li><p>基于注解**@LoadBanlanced**的负载均衡</p><ul><li>在<strong>RestTemplate</strong>的Bean配置类上添加**@LoadBanlanced**注解</li><li>无需获取实例直接用服务Id来代替 主机+端口号 发起**restTemplate.getForObject(url,Object.calss)**请求资源</li><li><img src="/.com//image-20250425214039517.png" alt="image-20250425214039517"></li></ul></li><li><p><strong>思考</strong>：注册中心宕机，远程调用还能成功吗？</p><ul><li>首次调用无法成功</li><li>后续调用存在缓存，缓存中有实例信息，能够根据该实例信息发送请求，远程调用成功。</li></ul></li></ul><h3 id="2-配置中心"><a href="#2-配置中心" class="headerlink" title="2.配置中心"></a>2.配置中心</h3><ul><li>统一管理所有微服务的配置</li></ul><p><img src="/.com//image-20250425214454137.png" alt="image-20250425214454137"></p><h4 id="导入的配置"><a href="#导入的配置" class="headerlink" title="导入的配置"></a>导入的配置</h4><p><img src="/.com//image-20250425214517824.png" alt="image-20250425214517824"></p><ul><li><p>配置导入nacos对应网址上编写的配置</p></li><li><p>引入了配置导入的依赖没有导入配置会报错，除非在配置文件中编写关闭配置导入的信息或者设置为可选</p><p><img src="/.com//image-20250425215330326.png" alt="image-20250425215330326"></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">//旧方式2020以前版本，且需要单独在bootstrap.yml中</span> <span class="hljs-string">引入配置中心的依赖nacos-config,instead：指定要导入的配置集 ID (Data ID)，需要替换为实际的配置集名称</span><br><span class="hljs-attr">spring.cloud.nacos.config.import</span>=<span class="hljs-string">optional:nacos:instead  //设置为可选</span><br><br><span class="hljs-attr">spring.cloud.nacos.config.import-check.enabled</span>=<span class="hljs-string">false</span><br> <span class="hljs-attr">//禁用导入检查设置为false可以避免在配置中心不可用时应用启动失败</span><br></code></pre></td></tr></table></figure><h4 id="旧方式完整配置："><a href="#旧方式完整配置：" class="headerlink" title="旧方式完整配置："></a><strong>旧方式完整配置</strong>：</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># bootstrap.yml（需单独文件）</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">order-service</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br>        <span class="hljs-attr">import:</span> <span class="hljs-string">optional:nacos:common-config,optional:nacos:$&#123;spring.application.name&#125;</span><br></code></pre></td></tr></table></figure><h4 id="新方式完整配置："><a href="#新方式完整配置：" class="headerlink" title="新方式完整配置："></a><strong>新方式完整配置</strong>：</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># application.yml（单文件）</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">order-service</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">config:</span><br>    <span class="hljs-attr">import:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">optional:nacos:common-config.yml</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">optional:nacos:$&#123;spring.application.name&#125;.yml</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="动态刷新"><a href="#动态刷新" class="headerlink" title="动态刷新"></a>动态刷新</h4><p><img src="/.com//image-20250426104158529.png" alt="image-20250426104158529"></p><ul><li><p>（1）使用注解**@Value(“${xx.xx}”)<strong>获取配置注解</strong>@RefreshScope**自动刷新配置-手动繁琐</p></li><li><p>（2）编写类来封装需要的配置，使用**@ConfigurationProperties（prefix&#x3D;”xx”）**批量配置绑定，实现自动刷新。导入封装类即可获取配置信息。</p></li><li><p>（3）使用Bean-**NacosConfigManager **</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosConfigListenerExample</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> NacosConfigManager nacosConfigManager;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NacosConfigListenerExample</span><span class="hljs-params">(NacosConfigManager nacosConfigManager)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nacosConfigManager = nacosConfigManager;<br>    &#125;<br><span class="hljs-comment">//监听配置变化的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addConfigListener</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取 ConfigService</span><br>            <span class="hljs-type">ConfigService</span> <span class="hljs-variable">configService</span> <span class="hljs-operator">=</span> nacosConfigManager.getConfigService();<br><br>            <span class="hljs-comment">// 配置的 Data ID</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">dataId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;example.properties&quot;</span>;<br>            <span class="hljs-comment">// 配置的 Group</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;DEFAULT_GROUP&quot;</span>;<br><br>            <span class="hljs-comment">// 添加配置监听器</span><br>            configService.addListener(dataId, group, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Listener</span>() &#123;<br>                <span class="hljs-comment">// 配置线程池</span><br>                <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">getExecutor</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-keyword">return</span> executor;<br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveConfigInfo</span><span class="hljs-params">(String configInfo)</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;配置发生变化，新的配置内容: &quot;</span> + configInfo);<br>                &#125;<br>            &#125;);<br><br>            <span class="hljs-comment">// 获取当前配置</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> configService.getConfig(dataId, group, <span class="hljs-number">5000</span>);<br>            System.out.println(<span class="hljs-string">&quot;当前配置内容: &quot;</span> + config);<br><br>        &#125; <span class="hljs-keyword">catch</span> (NacosException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>思考</strong>：Nacos中的数据集和appliaction.properties有相同的配置项，最终生效的是哪个？  -外部导入优先，先导入优先</p><ul><li>外部导入的优先级高于配置内编写的配置</li><li>外部导入多个配置有重复的情况下，先导入的优先级高</li><li>高优先级的配置（比如外部导入），以第一次声明的为准。</li></ul></li></ul><h4 id="数据隔离"><a href="#数据隔离" class="headerlink" title="数据隔离"></a>数据隔离</h4><p><img src="/.com//image-20250426111826596.png" alt="image-20250426111826596"></p><p><img src="/.com//image-20250426125746547.png" alt="image-20250426125746547"></p><ul><li><p>创建名称空间-Nacos上</p></li><li><p>创建数据集，同时分组，绑定命名空间</p></li><li><pre><code class="yml">server:  port: 8000spring:  profiles:    active: test  application:    name: service-order  cloud:    nacos:      server-addr: 127.0.0.1:8848      config:        import-check:          enabled: false        namespace: $&#123;spring.profiles.active:dev&#125;---spring:  config:    import:      - nacos:service-order.yml?group=order      - nacos:database.yml?group=order    activate:      on-profile: dev---spring:  config:    import:      - nacos:service-order.yml?group=order  activate:    on-profile: test<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><br><span class="hljs-comment">### 3.总结</span><br><br>![image-20250426133353032](分布式微服务.assets/image-20250426133353032.png)<br><br>- 负载均衡-<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>spring-cloud-starter-loadbanlancer<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>依赖<br>  - 若使用的是 Spring Cloud 2020.0 及以后版本，使用 OpenFeign 且服务存在多个实例时，需要引入 `spring-cloud-starter-loadbalancer` 来实现负载均衡；若使用的是旧版本，通常使用 `Ribbon` 来完成此功能。<br><br>~~~xml<br>  <span class="hljs-variable">&lt;dependency&gt;</span><br>            <span class="hljs-variable">&lt;groupId&gt;</span>org.springframework.cloud<span class="hljs-variable">&lt;/groupId&gt;</span><br>            <span class="hljs-variable">&lt;artifactId&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-variable">&lt;/artifactId&gt;</span><br>        <span class="hljs-variable">&lt;/dependency&gt;</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>配置</p></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 服务发现相关配置</span><br><span class="hljs-comment"># Nacos 服务发现服务器地址</span><br><span class="hljs-attr">spring.cloud.nacos.discovery.server-addr</span>=<span class="hljs-string">127.0.0.1:8848</span><br><span class="hljs-comment"># 服务名称，用于在 Nacos 中标识该服务</span><br><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">your-service-name</span><br><span class="hljs-comment"># 指定服务注册到 Nacos 的命名空间 ID</span><br><span class="hljs-attr">spring.cloud.nacos.discovery.namespace</span>=<span class="hljs-string">your-namespace-id</span><br><span class="hljs-comment"># 指定服务所属的集群名称</span><br><span class="hljs-attr">spring.cloud.nacos.discovery.cluster-name</span>=<span class="hljs-string">your-cluster-name</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 配置管理相关配置</span><br><span class="hljs-comment"># Nacos 配置中心服务器地址</span><br><span class="hljs-attr">spring.cloud.nacos.config.server-addr</span>=<span class="hljs-string">127.0.0.1:8848</span><br><span class="hljs-comment"># 配置文件的 Data ID，默认为 $&#123;spring.application.name&#125;.properties</span><br><span class="hljs-attr">spring.cloud.nacos.config.data-id</span>=<span class="hljs-string">your-data-id.properties</span><br><span class="hljs-comment"># 配置文件的 Group，默认为 DEFAULT_GROUP</span><br><span class="hljs-attr">spring.cloud.nacos.config.group</span>=<span class="hljs-string">your-group</span><br><span class="hljs-comment"># 配置文件的类型，支持 properties、yaml、json 等</span><br><span class="hljs-attr">spring.cloud.nacos.config.file-extension</span>=<span class="hljs-string">yaml</span><br><span class="hljs-comment"># 开启配置自动刷新功能</span><br><span class="hljs-attr">spring.cloud.nacos.config.refresh-enabled</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 其他配置</span><br><span class="hljs-comment"># Nacos 访问用户名</span><br><span class="hljs-attr">spring.cloud.nacos.username</span>=<span class="hljs-string">your-username</span><br><span class="hljs-comment"># Nacos 访问密码</span><br><span class="hljs-attr">spring.cloud.nacos.password</span>=<span class="hljs-string">your-password</span><br><span class="hljs-comment"># 配置 Nacos 客户端的日志级别 全限定com.alibaba.nacos.client下的所有l</span><br><span class="hljs-attr">logging.level.com.alibaba.nacos.client</span>=<span class="hljs-string">DEBUG</span><br></code></pre></td></tr></table></figure><h3 id="4-进阶-集群"><a href="#4-进阶-集群" class="headerlink" title="4.进阶-集群"></a>4.进阶-集群</h3><h2 id="3-OpenFeign-远程调用"><a href="#3-OpenFeign-远程调用" class="headerlink" title="3.OpenFeign-远程调用"></a>3.OpenFeign-远程调用</h2><h3 id="1-远程调用"><a href="#1-远程调用" class="headerlink" title="1.远程调用"></a>1.远程调用</h3><p><img src="/.com//image-20250426133816378.png" alt="image-20250426133816378"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--        远程调用--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--        当有多个实例时自动实现负载均衡--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/.com//image-20250426134338322.png" alt="image-20250426134338322"></p><ul><li><p>在启动类添加注解**@EnableFeignClients**&#x2F;&#x2F;开启远程调用客户端</p></li><li><p>**@FenignClient(value&#x3D;”注册的服务”,url&#x3D;”第三方url”，configuration&#x3D;”FeignConfig.class”) ** 如果调用注册的服务，会自动实现负载均衡。</p><ul><li>**<code>value</code>**：该参数用于指定远程服务的名称，它是 <code>@FeignClient</code> 注解的一个别名，等价于 <code>name</code> 参数。在使用服务注册与发现（如 Eureka、Nacos 等）的场景中，<code>value</code> 对应注册到服务注册中心的服务名。</li><li>**<code>url</code>**：当不使用服务注册与发现，而是直接指定远程服务的 URL 时，可以使用该参数访问第三方接口</li><li><strong><code>configuration</code> <strong>参数用于指定 Feign 客户端的自定义配置类。通过这个配置类，你能够对 Feign 客户端的行为进行定制，比如设置编码器、解码器、拦截器、日志级别等。但是</strong>配置文件的配置优先</strong>。</li><li><strong>扫描与代理生成</strong>：Spring 启动时，会扫描带有 <code>@FeignClient</code> 注解的接口。对于每个被注解的接口，Spring 会使用 JDK 动态代理或 CGLIB 代理为其生成代理对象。</li><li><strong>服务发现与调用</strong>：当调用 Feign 客户端接口的方法时，代理对象会根据 <code>@FeignClient</code> 注解中的 <code>value</code> 或 <code>url</code> 参数，结合服务注册与发现机制（如果使用），找到对应的远程服务地址。</li><li><strong>HTTP 请求发送</strong>：代理对象会根据接口方法上的 Spring MVC 注解（如 <code>@GetMapping</code>、<code>@PostMapping</code> 等）构建 HTTP 请求，并发送到远程服务。</li><li><strong>响应处理</strong>：接收到远程服务的响应后，代理对象会将响应数据转换为接口方法的返回类型，并返回给调用者。</li></ul></li><li><p>由<strong>LoadBanlancerClient</strong>自动实现<strong>负载均衡</strong>，只需导入依赖<strong>spring-cloud-starter-loadbalancer</strong></p></li><li><p>连接池 -默认实现没有连接池效率较低</p></li></ul><blockquote><p><img src="/.com//image-20250522213934794.png" alt="image-20250522213934794"></p><p><img src="/.com//image-20250522213952074.png" alt="image-20250522213952074"></p></blockquote><h3 id="2-日志"><a href="#2-日志" class="headerlink" title="2.日志"></a>2.日志</h3><p><img src="/.com//image-20250522215641381.png" alt="image-20250522215641381"></p><p><img src="/.com//image-20250426140836523.png" alt="image-20250426140836523"></p><ul><li><p>在配置类中注入<strong>Logger.Level</strong>组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultFeignConfig</span>&#123;<br><span class="hljs-meta">@Bean</span><br>Logger.Level <span class="hljs-title function_">feignLoggerLevel</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> Logger.Level.FULL;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/.com//image-20250522215909776.png" alt="image-20250522215909776"></p><p>也可以使用配置文件实现-配置文件优先</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 配置 Feign 客户端默认的日志级别为 FULL</span><br><span class="hljs-attr">spring.cloud.openfeign.client.config.default.logger-level</span>=<span class="hljs-string">FULL</span><br></code></pre></td></tr></table></figure></li><li><p>将OpenFeign接口所在的包&#x2F;类的日志级别调为<strong>debug</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">logging.level.com.example.feignclient</span>=<span class="hljs-string">DEBUG</span><br></code></pre></td></tr></table></figure></li><li><p>经过上述两部操作实现FULL级别后可以在控制台打印整个请求和响应的详细信息</p></li></ul><h3 id="3-超时控制"><a href="#3-超时控制" class="headerlink" title="3.超时控制"></a>3.超时控制</h3><p><img src="/.com//image-20250426141155814.png" alt="image-20250426141155814"></p><p><img src="/.com//image-20250426141559855.png" alt="image-20250426141559855"></p><ul><li><p>自定义配置，新建配置文件<strong>application-feign.yml</strong></p></li><li><p>在<strong>application.yml</strong>导入该配置文件<strong>spring.profiles.include: feign</strong></p></li><li><pre><code class="yml">spring:  cloud:    openfeign:      client:        config:#          默认配置  日志等级、连接时限、读取时限          default:            logger-level: full            connect-timeout: 3000            read-timeout: 5000#            精确配置          service-product:            logger-level: full            connect-timeout: 3000            read-timeout: 5000<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><br><br><br><br><br><span class="hljs-meta">### 4.重试机制</span><br><br>- 在 Spring Cloud OpenFeign 中，默认情况下是没有开启重试机制的。<br>- 不过，如果使用了 Spring Cloud LoadBalancer 进行负载均衡，Feign 会使用 `RetryableFeignBlockingLoadBalancerClient` 进行请求，并且会有一个简单的重试逻辑。<br>- 自定义 Retryer-注入容器中<br><br>~~~java<br><span class="hljs-keyword">import</span> feign.Retryer;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Retryer feignRetryer() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Retryer</span>.Default(<br>                <span class="hljs-number">100</span>, <span class="hljs-comment">// 初始重试间隔时间（毫秒）</span><br>                TimeUnit.SECONDS.toMillis(<span class="hljs-number">1</span>), <span class="hljs-comment">// 最大重试间隔时间（毫秒）</span><br>                <span class="hljs-number">5</span> <span class="hljs-comment">// 最大重试次数，每次等待的时间是之前的1.5倍，最大不超过1s,超过1s用1s</span><br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>也可以使用配置文件指定默认的Retryer</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 开启 Feign 客户端默认的自定义重试机制</span><br><span class="hljs-attr">spring.cloud.openfeign.client.config.service-product.retryer</span>=<span class="hljs-string">feign.Retryer.Default</span><br></code></pre></td></tr></table></figure><ul><li>配置文件优先</li></ul></li></ul><h3 id="5-拦截器"><a href="#5-拦截器" class="headerlink" title="5.拦截器"></a>5.拦截器</h3><p><img src="/.com//image-20250426145103511.png" alt="image-20250426145103511"></p><ul><li><p>请求拦截器 </p><ul><li>实现fegin下的RequestInterceptor接口</li><li>重写apply方法对RequestTemplate类进行操作</li><li>RequestTemplate类存放这次请求的参数</li></ul><p><img src="/.com//image-20250426170156530.png" alt="image-20250426170156530"></p><ul><li>注入容器全局生效，而配置文件编写可以针对不同的服务进行精确配置</li></ul></li><li><p>响应拦截器</p><ul><li>实现ResponseInterceptor接口</li><li>重写方法</li><li>设定参数</li></ul></li></ul><h3 id="6-Fallback兜底返回"><a href="#6-Fallback兜底返回" class="headerlink" title="6.Fallback兜底返回"></a>6.Fallback兜底返回</h3><p><img src="/.com//image-20250426151113581.png" alt="image-20250426151113581"></p><ul><li><p>兜底回调类是对应远程调用接口的实现类</p></li><li><p>远程调用类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;service-product&quot;,fallback = ProductFeignFallBack.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductFeign</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/product&quot;)</span><br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">getPro</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>兜底回调类 -兜底数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductFeignFallBack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProductFeign</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">getPro</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Product.builder()<br>                .name(<span class="hljs-string">&quot;王老吉&quot;</span>)<br>                .number(<span class="hljs-number">1</span>)<br>                .price(BigDecimal.valueOf(<span class="hljs-number">6</span>))<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>需要引入熔断机制Sentinel才能实现兜底回调</p><ul><li><p>引入依赖<strong>spring-cloud-starter-alibaba-sentinel</strong></p></li><li><p>配置文件开启</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">sentinel:</span><br><span class="hljs-comment">#    开启熔断</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="7-配置总结"><a href="#7-配置总结" class="headerlink" title="7.配置总结"></a>7.配置总结</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 开启 Feign 功能</span><br><span class="hljs-attr">spring.cloud.openfeign.enabled</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 配置 Feign 客户端默认的日志级别为 FULL</span><br><span class="hljs-attr">spring.cloud.openfeign.client.config.default.logger-level</span>=<span class="hljs-string">FULL</span><br><span class="hljs-comment"># 配置 Feign 客户端默认的连接超时时间为 3000 毫秒</span><br><span class="hljs-attr">spring.cloud.openfeign.client.config.default.connect-timeout</span>=<span class="hljs-string">3000</span><br><span class="hljs-comment"># 配置 Feign 客户端默认的读取超时时间为 5000 毫秒</span><br><span class="hljs-attr">spring.cloud.openfeign.client.config.default.read-timeout</span>=<span class="hljs-string">5000</span><br><span class="hljs-comment"># 开启 Feign 客户端默认的自定义重试机制</span><br><span class="hljs-attr">spring.cloud.openfeign.client.config.default.retryer</span>=<span class="hljs-string">feign.Retryer.Default</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 针对服务 service-product 的精确配置</span><br><span class="hljs-attr">spring.cloud.openfeign.client.config.service-product.logger-level</span>=<span class="hljs-string">FULL</span><br><span class="hljs-attr">spring.cloud.openfeign.client.config.service-product.connect-timeout</span>=<span class="hljs-string">3000</span><br><span class="hljs-attr">spring.cloud.openfeign.client.config.service-product.read-timeout</span>=<span class="hljs-string">5000</span><br><span class="hljs-attr">spring.cloud.openfeign.client.config.service-product.retryer</span>=<span class="hljs-string">feign.Retryer.Default</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 配置 Feign 客户端的日志级别 -包com.example.feignclient下的所有类的日志等级为DEBUG,打印在运行终端</span><br><span class="hljs-attr">logging.level.com.example.feignclient</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 开启 Feign 的 Hystrix服务保护（流量控制、熔断机制） 支持（Spring Cloud 2020.0 及以后版本默认不支持，需要额外配置）</span><br><span class="hljs-comment"># spring.cloud.openfeign.hystrix.enabled=true</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 开启 Feign 的 Sentinel 服务保护（流量控制、熔断机制）</span><br><span class="hljs-attr">feign.sentinel.enabled</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 配置 Feign 客户端的负载均衡策略（如果使用 spring-cloud-starter-loadbalancer）</span><br><span class="hljs-attr">spring.cloud.loadbalancer.retry.enabled</span>=<span class="hljs-string">false</span><br><span class="hljs-attr">spring.cloud.loadbalancer.ribbon.enabled</span>=<span class="hljs-string">false</span><br><span class="hljs-attr">spring.cloud.loadbalancer.strategy</span>=<span class="hljs-string">RandomLoadBalancer</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#开启连接池/需要引入Http相关依赖</span><br><span class="hljs-attr">feign.httpclient.enabled</span>=<span class="hljs-string">true  # 启用 Apache HttpClient</span><br><span class="hljs-attr">feign.httpclient.max-connections</span>=<span class="hljs-string">200   # 最大连接数</span><br><span class="hljs-attr">feign.httpclient.max-connections-per-route</span>=<span class="hljs-string">50  # 每个路由的最大连接数</span><br><br><span class="hljs-attr">feign.okhttp.enabled</span>=<span class="hljs-string">true # 启用 OKHttp</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 配置 Feign 的自定义拦截器-也可以通过配置文件注入Bean实现</span><br><span class="hljs-comment">#spring.cloud.openfeign.client.config.default.requestInterceptors=com.example.MyFeignInterceptor</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 配置 Feign 客户端默认的编码器为 SpringEncoder</span><br><span class="hljs-comment">#spring.cloud.openfeign.client.config.default.encoder=org.springframework.cloud.openfeign.support.SpringEncoder</span><br><span class="hljs-comment"># 配置 Feign 的错误解码器</span><br><span class="hljs-comment">#spring.cloud.openfeign.client.config.default.errorDecoder=com.example.MyErrorDecoder</span><br></code></pre></td></tr></table></figure><ul><li>配置文件优先级大于配置类</li></ul><h2 id="4-Sentinel-熔断"><a href="#4-Sentinel-熔断" class="headerlink" title="4.Sentinel-熔断"></a>4.Sentinel-熔断</h2><ul><li>服务保护<ul><li>限流</li><li>熔断降级</li></ul></li></ul><p><img src="/.com//image-20250427203326225.png" alt="image-20250427203326225"></p><p><img src="/.com//image-20250427203548437.png" alt="image-20250427203548437"></p><ul><li><strong>API接口</strong>和注解**@SentinelResource(value&#x3D;” “)**声明的均被看作资源</li></ul><p><img src="/.com//image-20250427203644243.png" alt="image-20250427203644243"></p><ul><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--        熔断机制--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure></li><li><p>服务中配置Sentinel</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <br>  <span class="hljs-attr">cloud:</span>  <br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br><span class="hljs-comment">#        sentinel服务地址</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span><br><span class="hljs-comment">#        提前加载</span><br>      <span class="hljs-attr">eager:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">sentinel:</span><br><span class="hljs-comment">#    开启熔断</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p><strong>启动Sentinel(默认在8080端口)</strong>: java -jar sentinel-dashboard-1.8.8.jar</p></li></ul><p> <img src="/.com//image-20250525212519461.png" alt="image-20250525212519461"></p><h3 id="1-异常处理"><a href="#1-异常处理" class="headerlink" title="1.异常处理"></a>1.异常处理</h3><p><img src="/.com//image-20250525213542866.png" alt="image-20250525213542866"></p><ul><li><p>Web接口Sentinel异常处理:编写异常处理器 <strong>implements BlockExceptionHandler</strong>，并且重写handle方法编写response</p></li><li><p><strong>@SentinelResource</strong>标注的资源Sentinel异常处理,通过指定<strong>blockHandler&#x2F;fallback</strong>方法 </p><ul><li>blockHandler(流控异常)回调方法中的异常参数为BlockException</li><li>fallback（流控+业务异常）回调方法中的异常参数为Throwable（任意异常）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SentinelResource(value = &quot;order-getPro&quot;,blockHandler = &quot;orderFallback&quot;)</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">order</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> productFeign.getPro();<br>   &#125;<br>  <br>   <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">orderFallback</span><span class="hljs-params">(BlockException e)</span>&#123;<br>       <span class="hljs-keyword">return</span> Product.builder()<br>               .name(<span class="hljs-string">&quot;未知&quot;</span>)<br>               .number(<span class="hljs-number">0</span>)<br>               .price(BigDecimal.valueOf(<span class="hljs-number">0</span>))<br>               .build();<br>   &#125;<br></code></pre></td></tr></table></figure></li><li><p>Sentinel会识别Feign调用的请求，如果对Feign调用的资源进行限流，出现异常时会调Feign客户端的fallback方法</p></li></ul><h3 id="2-流控规则"><a href="#2-流控规则" class="headerlink" title="2.流控规则"></a>2.流控规则</h3><p><img src="/.com//image-20250526155325605.png" alt="image-20250526155325605"></p><p>链路策略需要关闭上下文统一：spring.cloud.sentinel.web-context-unify&#x3D;false</p><p><img src="/.com//image-20250526160328789.png" alt="image-20250526160328789"></p><h3 id="3-熔断规则"><a href="#3-熔断规则" class="headerlink" title="3.熔断规则"></a>3.熔断规则</h3><p><img src="/.com//image-20250526160710335.png" alt="image-20250526160710335"></p><p><img src="/.com//image-20250526160816297.png" alt="image-20250526160816297"></p><ul><li><p>慢调用比例</p></li><li><p>异常比例</p></li><li><p>异常数</p></li></ul><p><img src="/.com//image-20250526161508116.png" alt="image-20250526161508116"></p><h3 id="4-热点规则"><a href="#4-热点规则" class="headerlink" title="4.热点规则"></a>4.热点规则</h3><ul><li>对资源的参数进行流控</li></ul><p><img src="/.com//image-20250526162451867.png" alt="image-20250526162451867"></p><ul><li>对Web请求无自动识别，需要自动创建埋点（@SentinelResource指定资源）</li></ul><h3 id="5-补充与总结"><a href="#5-补充与总结" class="headerlink" title="5.补充与总结"></a>5.补充与总结</h3><ul><li>授权规则</li><li>系统规则</li></ul><h2 id="5-GateWay-网关"><a href="#5-GateWay-网关" class="headerlink" title="5.GateWay-网关"></a>5.GateWay-网关</h2><p><img src="/.com//image-20250526164304862.png" alt="image-20250526164304862"></p><p><img src="/.com//image-20250526164522930.png" alt="image-20250526164522930"></p><ul><li>实现 路由代理+负载均衡 的功能</li></ul><h3 id="1-创建网关"><a href="#1-创建网关" class="headerlink" title="1.创建网关"></a>1.创建网关</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--        服务发现--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--        网关--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--        负载均衡--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>创建网关模块，引入网关和注册中心、负载均衡的依赖</li><li>注册到nacos</li><li>编写启动类（开启服务发现），配置端口</li></ul><h3 id="2-路由"><a href="#2-路由" class="headerlink" title="2.路由"></a>2.路由</h3><ul><li><p><strong>routes</strong></p></li><li><p>路由的规则默认从上到下，配置order（默认为0）,order越小优先级越高</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">order-route</span><br><span class="hljs-comment">#          请求路由</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://service-order</span><br><span class="hljs-comment">#          断言规则</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/api/order/**</span><br><span class="hljs-comment">#          优先级            </span><br>          <span class="hljs-attr">order:</span> <span class="hljs-number">1</span><br><span class="hljs-comment">#          过滤器</span><br>          <span class="hljs-attr">filters:</span> <br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">product-route</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://service-product</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/api/product/**</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-断言"><a href="#3-断言" class="headerlink" title="3.断言"></a>3.断言</h3><ul><li><strong>predicates</strong>,满足断言进行路由转发</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">order-route</span><br><span class="hljs-comment">#          请求路由</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://service-order</span><br><span class="hljs-comment">#          断言规则</span><br>          <span class="hljs-attr">predicates:</span><br><span class="hljs-comment">#            - Path=/api/order/**</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Path</span><br>              <span class="hljs-attr">args:</span><br><span class="hljs-comment">#                规则</span><br>                <span class="hljs-attr">patterns:</span> <span class="hljs-string">/api/order/**</span><br><span class="hljs-comment">#                兼容 /order/1/  /order/1  多/</span><br>                <span class="hljs-attr">matchTrailingSlash:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ul><li><p>两种写法-断言的定义：name+args的map表<img src="/.com//image-20250526174319811.png" alt="image-20250526174319811"></p></li><li><p>断言工厂-<strong>RoutePredicateFactory</strong></p></li></ul><p><img src="/.com//image-20250526174036649.png" alt="image-20250526174036649"></p><p><img src="/.com//image-20250526174209501.png" alt="image-20250526174209501"></p><ul><li><p><strong>自定义断言工厂</strong> ：自定义跳转到uri的规则</p><ul><li><p>继承<strong>AbstractRoutePredicateFactory</strong>并且通过泛型指定内部配置类</p></li><li><p>编写静态内部配置类 –》指定可以配置的参数</p></li><li><p>构造器传入配置类的class</p></li><li><p>重写<strong>shortcutFieldOrder</strong>方法指定属性顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">shortcutFieldOrder</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> Arrays.asList(key1,key2)&#125;<br></code></pre></td></tr></table></figure></li><li><p>重写apply方法编写断言规则算法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VipRoutePredicateFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRoutePredicateFactory</span>&lt;VipRoutePredicateFactory.Config&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">VipRoutePredicateFactory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(Config.class);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">shortcutFieldOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">&quot;param&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Predicate&lt;ServerWebExchange&gt; <span class="hljs-title function_">apply</span><span class="hljs-params">(Config config)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GatewayPredicate</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(ServerWebExchange serverWebExchange)</span> &#123;<br>                <span class="hljs-comment">//指定查询参数param的第一个值为value</span><br>                <span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> serverWebExchange.getRequest();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> request.getQueryParams().getFirst(config.param);<br>                <span class="hljs-keyword">return</span> StringUtils.hasText(first)&amp;&amp;first.equals(config.value);<br>            &#125;<br>        &#125;;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Validated</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-meta">@NotEmpty</span> String param;<br>        <span class="hljs-keyword">private</span> String value;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getParam</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.param;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> VipRoutePredicateFactory.Config <span class="hljs-title function_">setParam</span><span class="hljs-params">(String param)</span> &#123;<br>            <span class="hljs-built_in">this</span>.param = param;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> VipRoutePredicateFactory.Config <span class="hljs-title function_">setValue</span><span class="hljs-params">(String value)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value=value;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-过滤器"><a href="#4-过滤器" class="headerlink" title="4.过滤器"></a>4.过滤器</h3><p><img src="/.com//image-20250526201914937.png" alt="image-20250526201914937"></p><ul><li><p>路径重写过滤器</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">order-route</span><br><span class="hljs-comment">#          请求路由</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://service-order</span><br><span class="hljs-comment">#          断言规则</span><br>          <span class="hljs-attr">predicates:</span><br><span class="hljs-comment">#            - Path=/api/order/**</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Path</span><br>              <span class="hljs-attr">args:</span><br><span class="hljs-comment">#                规则</span><br>                <span class="hljs-attr">patterns:</span> <span class="hljs-string">/api/order/**</span><br><span class="hljs-comment">#                兼容 /order/1/  /order/1  多/</span><br>                <span class="hljs-attr">matchTrailingSlash:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-comment">#          优先级</span><br>          <span class="hljs-attr">order:</span> <span class="hljs-number">1</span><br>          <span class="hljs-comment">#          过滤器          </span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">RewritePath=/api/order/?(?&lt;segment&gt;.*),/$\&#123;segment&#125;</span><br>            <span class="hljs-comment">#/api/order/** -&gt;  uri/**</span><br></code></pre></td></tr></table></figure></li><li><p>默认filter -default-filters    -添加响应头</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">default-filters:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AddResponseHeader=X-Response,Blue</span><br></code></pre></td></tr></table></figure></li><li><p>**自定义全局Filter  -GlobalFilter  **</p><ul><li>实现GlobalFilter,Ordered接口</li><li>注入Bean</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RtGlobalFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-comment">//通过exchange拿到请求和恢复</span><br>        <span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> exchange.getRequest();<br>        <span class="hljs-type">ServerHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> exchange.getResponse();<br><br>        String uri=request.getURI().toString();<br>        <span class="hljs-type">long</span> start=System.currentTimeMillis();<br>        log.info(<span class="hljs-string">&quot;请求【&#123;&#125;】开始，时间：&#123;&#125;&quot;</span>,uri,start);<br>        <span class="hljs-comment">//以上是前置逻辑</span><br><br>        <span class="hljs-comment">//放行</span><br>        Mono&lt;Void&gt; filter = chain.filter(exchange)<br>                .doFinally((result)-&gt;&#123;<br>                    <span class="hljs-type">long</span> end=System.currentTimeMillis();<br>                    log.info(<span class="hljs-string">&quot;请求【&#123;&#125;】结束，结束时间：&#123;&#125;,耗时：&#123;&#125;&quot;</span>,uri,end,end-start);<br>                &#125;); <span class="hljs-comment">//后置逻辑</span><br><br>        <span class="hljs-keyword">return</span> filter;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p><strong>自定义过滤器</strong></p><p><img src="/.com//image-20250528104157331.png" alt="image-20250528104157331"></p><ul><li><p>自定义带参数的GatewayFilter</p></li><li><p>目的：添加响应头token</p></li><li><p>继承AbstractNameValueFilterFactory</p></li><li><p>重写apply方法返回一个GatewayFilter</p></li><li><p>注入Bean</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TokenGatewayFilterFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractNameValueGatewayFilterFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> GatewayFilter <span class="hljs-title function_">apply</span><span class="hljs-params">(NameValueConfig config)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GatewayFilter</span>()&#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>                <span class="hljs-comment">//响应之前添加token至响应头</span><br>               <span class="hljs-comment">//放行</span><br>                <span class="hljs-keyword">return</span> chain.filter(exchange).then(Mono.fromRunnable(()-&gt;&#123;<br>                    <span class="hljs-type">ServerHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> exchange.getResponse();<br>                    <span class="hljs-type">HttpHeaders</span> <span class="hljs-variable">headers</span> <span class="hljs-operator">=</span> response.getHeaders();<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> config.getValue();<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;uuid&quot;</span>.equalsIgnoreCase(value))&#123;<br>                        value= UUID.randomUUID().toString();<br>                        <span class="hljs-comment">//存入缓存中</span><br>                        <span class="hljs-comment">//。。。</span><br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;jwt&quot;</span>.equalsIgnoreCase(value)) &#123;<br>                        <span class="hljs-comment">//使用JWT令牌工具类生成Jwt令牌</span><br>                        value=<span class="hljs-string">&quot;...jwt令牌&quot;</span>;<br>                        <span class="hljs-comment">//存入缓存中</span><br>                        <span class="hljs-comment">//。。。</span><br>                    &#125;<br>                    headers.add(config.getName(),value);<br>                &#125;));<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="5-扩展与总结"><a href="#5-扩展与总结" class="headerlink" title="5.扩展与总结"></a>5.扩展与总结</h3><ul><li><p>跨域 </p><ul><li><p>springboot在controller上添加注解@CrossOrigin</p></li><li><p>配置filter，在响应头中添加允许跨域的请求</p></li><li><p>gateway的globalcros</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">globalcors:</span><br>        <span class="hljs-attr">cors-configurations:</span><br>        <span class="hljs-comment"># &#x27;[/**]&#x27;所有的请求</span><br>          <span class="hljs-string">&#x27;[/**]&#x27;</span><span class="hljs-string">:</span><br>            <span class="hljs-attr">allowed-origin-patterns:</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;*&#x27;</span><br>            <span class="hljs-attr">allowed-headers:</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;*&#x27;</span><br>            <span class="hljs-attr">allowed-methods:</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;*&#x27;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>微服务之间的调用不用通过网关 - Feign直接调用nacos上的服务</p></li><li><p>自定义断言和过滤器都是继承对应的抽象工厂类，然后注入Bean,通过内部的静态config类来实现参数。自定义的全局过滤器除外，全局过滤器实现GlobalFilter接口。</p></li></ul><h2 id="6-Seata-事务"><a href="#6-Seata-事务" class="headerlink" title="6.Seata -事务"></a>6.Seata -事务</h2><h3 id="1-seata引入和整合"><a href="#1-seata引入和整合" class="headerlink" title="1.seata引入和整合"></a>1.seata引入和整合</h3><p><img src="/.com//image-20250526215136112.png" alt="image-20250526215136112"></p><ul><li><p>分布式事务</p><ul><li>问题：部分回滚</li></ul><p><img src="/.com//image-20250526215215603.png" alt="image-20250526215215603"></p><ul><li>简单部署TC服务</li></ul></li><li><p>Seata依赖</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>引入seata依赖后，包含依赖的项目需要配置seata配置文件 (未整合nacos)</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">service</span> &#123;<br>    <span class="hljs-comment"># 事务服务组映射配置</span><br>    <span class="hljs-comment"># 将名为default_tx_group的事务服务组映射到名为default的服务端实例</span><br>    <span class="hljs-string">vgroupMapping.default_tx_group</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;default&quot;</span> <br>    <span class="hljs-comment"># 仅当registry.type为file时支持此配置，请不要设置多个地址</span><br>    <span class="hljs-comment"># 指定Seata服务端的地址列表，这里是本地地址127.0.0.1，端口8091</span><br>    <span class="hljs-string">default.grouplist</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;127.0.0.1:8091&quot;</span> <br>    <span class="hljs-comment"># 服务降级功能配置，当前不支持，这里设为关闭状态</span><br>    <span class="hljs-comment"># 若启用（设为true），在特定异常情况下可进行服务降级操作</span><br>    <span class="hljs-string">enableDegrade</span> <span class="hljs-string">=</span> <span class="hljs-literal">false</span> <br>    <span class="hljs-comment"># 禁用全局事务配置，当前设为不禁用</span><br>    <span class="hljs-comment"># 若设为true，则关闭应用内的分布式事务功能，事务按本地事务处理</span><br>    <span class="hljs-string">disableGlobalTransaction</span> <span class="hljs-string">=</span> <span class="hljs-literal">false</span> <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>事务控制</p><ul><li>分支事务：使用<strong>spring</strong>的**@Transactional**注解</li><li>全局事务：使用<strong>seata</strong>的**@GlobalTransactional**注解</li></ul></li><li><p>完整部署</p></li></ul><h3 id="2-二阶提交协议"><a href="#2-二阶提交协议" class="headerlink" title="2.二阶提交协议"></a>2.二阶提交协议</h3><ul><li><p><strong>Seata默认AT模式下</strong>：</p></li><li><p><strong>一阶段</strong>：<strong>事务注册与执行</strong></p><ul><li><strong>开启全局事务</strong>：<strong>TM</strong> 向 <strong>TC</strong> 发起请求开启一个全局事务，<strong>TC <strong>生成一个全局唯一的事务 ID（</strong>XID</strong>）并返回给 TM ，该 <strong>XID</strong> 会在整个分布式事务调用链路中传递。</li><li><strong>分支事务注册</strong>：<strong>RM</strong> 向 <strong>TC</strong> 注册分支事务，将本地事务<strong>BranchID</strong>与全局事务 <strong>XID</strong> 关联起来。</li><li><strong>分支事务执行与资源锁定</strong>：Seata会拦截“业务SQL”,首先解析SQL的语义，找到要更新的业务数据，在数据更新前，查询数据得到<strong>前镜像</strong>，<strong>获取本地锁（数据库行锁），本地事务执行-更新数据</strong>，得到<strong>后镜像</strong>，根据前后镜像生成undo_log,<strong>获取全局锁（提交资格）</strong>，提交<strong>本地事务（数据库事务提交：先提交redo，再持久化磁盘数据）和undo_log日志</strong>。释放本地锁资源。</li></ul></li><li><p><strong>二阶段</strong>：<strong>分支提交&#x2F;分支回滚</strong></p><ul><li><strong>分支提交</strong>：收到<strong>TC</strong>（分支事务全部成功）<strong>提交</strong>请求，给<strong>异步删除undo_log</strong>。</li><li><strong>分支回滚</strong>：收到<strong>TC回滚</strong>请求，找到<strong>undo_log记录</strong>（通过BranchID和XID）,数据校验-根据后镜像（不一致-被覆盖，则执行配置的相关策略），一致则进行<strong>回滚数据</strong>，最后删除undo_log，释放全局锁资源。</li></ul></li></ul><h3 id="3-四种事务模式"><a href="#3-四种事务模式" class="headerlink" title="3.四种事务模式"></a>3.四种事务模式</h3><h4 id="1-AT模式"><a href="#1-AT模式" class="headerlink" title="1.AT模式"></a>1.AT模式</h4><ul><li>默认的二阶段提交协议</li></ul><p><img src="/.com//image-20250528140303600.png" alt="image-20250528140303600">】</p><ul><li>存在<strong>脏数据</strong>问题</li></ul><h4 id="2-XA模式"><a href="#2-XA模式" class="headerlink" title="2.XA模式"></a>2.XA模式</h4><ul><li><p>和默认的二阶段提交协议有所不同</p><ul><li><img src="/.com//image-20250528135657128.png" alt="image-20250528135657128"></li><li>本地事务也在二阶段提交</li><li>高度占用锁资源</li></ul><p><img src="/.com//image-20250528135820802.png" alt="image-20250528135820802"></p><p><img src="/.com//image-20250528135905763.png" alt="image-20250528135905763"></p></li></ul><h4 id="3-TCC模式"><a href="#3-TCC模式" class="headerlink" title="3.TCC模式"></a>3.TCC模式</h4><ul><li>手动控制</li></ul><h4 id="4-Saga模式"><a href="#4-Saga模式" class="headerlink" title="4.Saga模式"></a>4.Saga模式</h4><ul><li>长事务模式</li></ul><h1 id="4-RabbitMQ"><a href="#4-RabbitMQ" class="headerlink" title="4.RabbitMQ"></a>4.RabbitMQ</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>RabbitMQ 是基于 AMQP 协议的开源消息代理软件，用于实现应用程序间的异步通信，能在分布式系统中可靠地传递消息，解耦应用组件，提升系统性能与可扩展性。</p><h2 id="2-核心概念"><a href="#2-核心概念" class="headerlink" title="2.核心概念"></a>2.核心概念</h2><h3 id="1-虚拟主机（Virtual-Host）"><a href="#1-虚拟主机（Virtual-Host）" class="headerlink" title="1.虚拟主机（Virtual Host）"></a>1.虚拟主机（Virtual Host）</h3><ul><li><strong>作用</strong>：相当于一个独立的 RabbitMQ 小型实例，实现数据隔离。不同虚拟主机有各自独立的队列、交换机等资源，可用于区分不同项目或环境。</li><li><strong>创建方式</strong>：可通过 RabbitMQ 管理控制台或命令行工具创建。</li></ul><h3 id="2-频道（Channel）"><a href="#2-频道（Channel）" class="headerlink" title="2.频道（Channel）"></a>2.频道（Channel）</h3><ul><li><strong>定义</strong>：是应用程序与 RabbitMQ 服务器通信的通道。一个 TCP 连接上可创建多个频道，避免频繁创建 TCP 连接，提升性能与资源利用率。</li></ul><h3 id="3-发布者（Publisher）、交换机（Exchange）、消费者（Consumer）、队列（Queue）"><a href="#3-发布者（Publisher）、交换机（Exchange）、消费者（Consumer）、队列（Queue）" class="headerlink" title="3.发布者（Publisher）、交换机（Exchange）、消费者（Consumer）、队列（Queue）"></a>3.发布者（Publisher）、交换机（Exchange）、消费者（Consumer）、队列（Queue）</h3><ul><li><strong>发布者</strong>：负责生成消息，并将消息发送到交换机。</li><li><strong>交换机</strong>：接收发布者消息，依据特定路由规则（取决于交换机类型）将消息转发到一个或多个队列。</li><li><strong>消费者</strong>：从队列中获取并处理消息。</li><li><strong>队列</strong>：用于存储消息，是消费者获取消息的地方。</li></ul><h2 id="3-Spring-AMQP"><a href="#3-Spring-AMQP" class="headerlink" title="3.Spring AMQP"></a>3.Spring AMQP</h2><h3 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h3><p>在<code>pom.xml</code>文件中添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-配置连接信息"><a href="#2-配置连接信息" class="headerlink" title="2.配置连接信息"></a>2.配置连接信息</h3><p>在<code>application.yml</code>中配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span> <span class="hljs-comment"># 你的虚拟机IP</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/hmall</span> <span class="hljs-comment"># 虚拟主机</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">hmall</span> <span class="hljs-comment"># 用户名</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123</span> <span class="hljs-comment"># 密码</span><br></code></pre></td></tr></table></figure><h3 id="3-发送消息-至队列"><a href="#3-发送消息-至队列" class="headerlink" title="3.发送消息 -至队列"></a>3.发送消息 -至队列</h3><p>注入<code>RabbitTemplate</code>发送消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageSender</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String queueName, String message)</span> &#123;<br>        rabbitTemplate.convertAndSend(queueName, message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-接收消息"><a href="#4-接收消息" class="headerlink" title="4.接收消息"></a>4.接收消息</h3><p>使用<code>@RabbitListener</code>注解监听队列消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageReceiver</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;yourQueueName&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Received: &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-Work-Queues-模式"><a href="#5-Work-Queues-模式" class="headerlink" title="5.Work Queues 模式"></a>5.Work Queues 模式</h3><h4 id="1-模式特点"><a href="#1-模式特点" class="headerlink" title="1 模式特点"></a>1 模式特点</h4><p>一个队列绑定多个消费者，消息以轮询的方式发送给消费者，实现一发多收。适用于将耗时任务分发给多个消费者处理的场景。</p><h4 id="2-能者多劳配置"><a href="#2-能者多劳配置" class="headerlink" title="2 能者多劳配置"></a>2 能者多劳配置</h4><p>通过配置<code>listener.simple.perfetch</code>属性，限制每个消费者预存取的消息数量，避免有的消费者任务积压，有的空闲，实现 “能者多劳”。例如在<code>application.yml</code>中配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">prefetch:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="4-交换机类型"><a href="#4-交换机类型" class="headerlink" title="4.交换机类型"></a>4.交换机类型</h2><h3 id="1-Fanout（广播交换机）"><a href="#1-Fanout（广播交换机）" class="headerlink" title="1.Fanout（广播交换机）"></a>1.Fanout（广播交换机）</h3><ul><li><p><strong>特点</strong>：将接收到的消息广播到所有与之绑定的队列，实现一对多消息分发。</p></li><li><p>使用示例</p><p>：</p><ul><li>声明交换机和队列：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.amqp.core.Binding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.BindingBuilder;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.FanoutExchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Queue;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title function_">fanoutExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FanoutExchange</span>(<span class="hljs-string">&quot;fanoutExchangeName&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">fanoutQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;fanoutQueueName&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">fanoutBinding</span><span class="hljs-params">(Queue fanoutQueue, FanoutExchange fanoutExchange)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(fanoutQueue).to(fanoutExchange);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>发送消息 -至交换机：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;fanoutExchangeName&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;广播消息内容&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="2-Direct（直连交换机）"><a href="#2-Direct（直连交换机）" class="headerlink" title="2.Direct（直连交换机）"></a>2.Direct（直连交换机）</h3><ul><li><p><strong>特点</strong>：交换机和队列绑定需指定<code>BindingKey</code>，发送消息时指定<code>routingKey</code>，消息会转发到<code>routingKey</code>与<code>BindingKey</code>匹配的队列。</p></li><li><p>使用示例</p><p>：</p><ul><li>声明交换机、队列并绑定：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.amqp.core.Binding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.BindingBuilder;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.DirectExchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Queue;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">directExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(<span class="hljs-string">&quot;directExchangeName&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">directQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;directQueueName&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">directBinding</span><span class="hljs-params">(Queue directQueue, DirectExchange directExchange)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(directQueue).to(directExchange).with(<span class="hljs-string">&quot;bindingKey&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>发送消息：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;directExchangeName&quot;</span>, <span class="hljs-string">&quot;bindingKey&quot;</span>, <span class="hljs-string">&quot;直连消息内容&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="3-Topic（主题交换机）"><a href="#3-Topic（主题交换机）" class="headerlink" title="3.Topic（主题交换机）"></a>3.Topic（主题交换机）</h3><ul><li><p><strong>特点</strong>：绑定队列时需指定<code>BindingKey</code>，支持通配符<code>#</code>（匹配 0 个或多个单词）和<code>*</code>（匹配一个单词）来模糊匹配发送消息时的<code>routingKey</code>。</p></li><li><p>使用示例</p><p>：</p><ul><li>声明交换机、队列并绑定：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.amqp.core.Binding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.BindingBuilder;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.TopicExchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Queue;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TopicExchange <span class="hljs-title function_">topicExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TopicExchange</span>(<span class="hljs-string">&quot;topicExchangeName&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">topicQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;topicQueueName&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">topicBinding</span><span class="hljs-params">(Queue topicQueue, TopicExchange topicExchange)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(topicQueue).to(topicExchange).with(<span class="hljs-string">&quot;topic.*&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>发送消息：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;topicExchangeName&quot;</span>, <span class="hljs-string">&quot;topic.message&quot;</span>, <span class="hljs-string">&quot;主题消息内容&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="5-交换机和队列声明与绑定实现方式"><a href="#5-交换机和队列声明与绑定实现方式" class="headerlink" title="5.交换机和队列声明与绑定实现方式"></a>5.交换机和队列声明与绑定实现方式</h2><h3 id="5-1-注解方式"><a href="#5-1-注解方式" class="headerlink" title="5.1 注解方式"></a>5.1 注解方式</h3><p>使用<code>@RabbitListener</code>结合<code>@QueueBinding</code>等注解实现交换机和队列的声明与绑定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.*;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">            value = @Queue(name = &quot;queueName&quot;),</span><br><span class="hljs-meta">            exchange = @Exchange(name = &quot;exchangeName&quot;, type = &quot;direct&quot;),</span><br><span class="hljs-meta">            key = &quot;routingKey&quot;</span><br><span class="hljs-meta">    ))</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Received: &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-Bean-方式"><a href="#5-2-Bean-方式" class="headerlink" title="5.2 Bean 方式"></a>5.2 Bean 方式</h3><p>通过代码创建 Exchange、Queue 对象并进行绑定，最后通过配置类将其注入到 Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.amqp.core.*;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;queueName&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">exchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(<span class="hljs-string">&quot;exchangeName&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding</span><span class="hljs-params">(Queue queue, DirectExchange exchange)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string">&quot;routingKey&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可使用对应的 Builder 来构造相关对象，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Queue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> QueueBuilder.durable(<span class="hljs-string">&quot;queueName&quot;</span>).build();<br><span class="hljs-type">DirectExchange</span> <span class="hljs-variable">exchange</span> <span class="hljs-operator">=</span> ExchangeBuilder.directExchange(<span class="hljs-string">&quot;exchangeName&quot;</span>).build();<br><span class="hljs-type">Binding</span> <span class="hljs-variable">binding</span> <span class="hljs-operator">=</span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string">&quot;routingKey&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="6-消息转换器"><a href="#6-消息转换器" class="headerlink" title="6.消息转换器"></a>6.消息转换器</h2><h3 id="1-JDK-默认转换器问题"><a href="#1-JDK-默认转换器问题" class="headerlink" title="1.JDK 默认转换器问题"></a>1.JDK 默认转换器问题</h3><p>JDK 默认的<code>SimpleMessageConverter</code>在处理复杂对象时存在类型丢失、可读性差、版本兼容性问题，仅支持<code>String</code>、<code>byte[]</code>、<code>Serializable</code>类型。</p><h3 id="2-自定义-JSON-消息转换器（使用-Jackson）"><a href="#2-自定义-JSON-消息转换器（使用-Jackson）" class="headerlink" title="2.自定义 JSON 消息转换器（使用 Jackson）"></a>2.自定义 JSON 消息转换器（使用 Jackson）</h3><ol><li><strong>添加依赖</strong>：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><strong>配置自定义转换器</strong>：</li></ol><p>配置消息转换器，在<code>publisher</code>和<code>consumer</code>两个服务的启动类中添加一个Bean即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title function_">messageConverter</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 1.定义消息转换器</span><br>    <span class="hljs-type">Jackson2JsonMessageConverter</span> <span class="hljs-variable">jackson2JsonMessageConverter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>    <span class="hljs-comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span><br>    jackson2JsonMessageConverter.setCreateMessageIds(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> jackson2JsonMessageConverter;<br>&#125;<br></code></pre></td></tr></table></figure><p>消息转换器中添加的messageId可以便于我们将来做幂等性判断（或者使用业务判断&#x2F;状态机实现幂等性）。</p><p>设置ID后，消息需要用Message接收</p><h2 id="6-消息可靠性"><a href="#6-消息可靠性" class="headerlink" title="6.消息可靠性"></a>6.消息可靠性</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/%E6%93%8D%E4%BD%9CExcel/"/>
    <url>/2025/07/02/%E6%93%8D%E4%BD%9CExcel/</url>
    
    <content type="html"><![CDATA[<h1 id="Excel操作"><a href="#Excel操作" class="headerlink" title="Excel操作"></a>Excel操作</h1><h2 id="1-Apache-POI"><a href="#1-Apache-POI" class="headerlink" title="1.Apache POI"></a>1.Apache POI</h2><p><img src="/.com//image-20250422194408159.png" alt="image-20250422194408159"></p><p><img src="/.com//image-20250422194429813.png" alt="image-20250422194429813"></p><ul><li>入门案例</li></ul><blockquote><ul><li>写</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">//通过POI创建Excel文件并且写入文件内容</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception&#123;<br><span class="hljs-comment">//创建文件</span><br>  XSSFWorkbook myExcel=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XSSFWorkbook</span>();<br><span class="hljs-comment">//在Excel文件中创建一个Sheet页</span><br>  XSSFSheet sheet=myExcel.createsheet(<span class="hljs-string">&quot;Sheet1&quot;</span>);<br><span class="hljs-comment">//在Sheet页中创建行对象，编号从0开始</span><br>  <span class="hljs-comment">//创建第二行</span><br>  XSSRow row=sheet.createRow(<span class="hljs-number">1</span>);<span class="hljs-comment">//第2行</span><br><span class="hljs-comment">//在该行创建单元格对象,并且写入内容</span><br>  row.createCell(<span class="hljs-number">1</span>).setCellValue(<span class="hljs-string">&quot;姓名&quot;</span>);<span class="hljs-comment">//创建第2个单元格并且写入内容</span><br>  row.createCell(<span class="hljs-number">2</span>).setCellValue(<span class="hljs-string">&quot;城市&quot;</span>);<span class="hljs-comment">//第三个单元格</span><br>  <span class="hljs-comment">//创建第三行</span><br>   XSSRow row=sheet.createRow(<span class="hljs-number">2</span>);<span class="hljs-comment">//第3行</span><br>  row.createCell(<span class="hljs-number">1</span>).setCellValue(<span class="hljs-string">&quot;坤坤&quot;</span>);<span class="hljs-comment">//创建第2个单元格并且写入内容</span><br>  row.createCell(<span class="hljs-number">2</span>).setCellValue(<span class="hljs-string">&quot;鸡太美&quot;</span>);<span class="hljs-comment">//第三个单元格</span><br>  <span class="hljs-comment">//（当前在内存）写入磁盘文件-通过输出流</span><br>  FileOutputStream out=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:\\temporary_memory\\myExcel.xlsx&quot;</span>));<br>  myExcel.write(out);<br>  <span class="hljs-comment">//关闭资源</span><br>  out.close();<br>  myExcel.close();<br>&gt;&#125;<br></code></pre></td></tr></table></figure><ul><li>读</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Read</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception&#123;<br>&gt;FileInputStream input=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:\\temporary_memory\\myExcel.xlsx&quot;</span>))<br>  <span class="hljs-comment">//传入一个输入流来读取该输入流的内容</span><br>  XSSFWorkbook myExcel=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XSSFWorkbook</span>(input);<br>  <span class="hljs-comment">//读取Excel文件的第一个Sheet页</span><br>  XSSFSheet sheet=myExcel.getSheetAt(<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">//获得最后一行的行号</span><br>  <span class="hljs-type">int</span> lastRowNum=sheet.getLastRowNum();<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=lastRowNum;i++)&#123;<span class="hljs-comment">//从第二行开始</span><br>      <span class="hljs-comment">//获取某一行</span><br>      XSSRow row=sheet.getRow(i);<br>      <span class="hljs-comment">//获得单元格对象</span><br>      String cellValue1=row.getCell(<span class="hljs-number">1</span>).getStringCellValue();<br>         String cellValue2=row.getCell(<span class="hljs-number">2</span>).getStringCellValue();<br>      System.out.println(cellValue1+<span class="hljs-string">&quot; &quot;</span>+cellValue2);<br>  &#125;<br>  <span class="hljs-comment">//关闭资源</span><br>  input.close(); <br>  myExcel.close();<br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><p><img src="/.com//image-20250422201238203.png" alt="image-20250422201238203"></p><p><img src="/.com//image-20250422201252345.png" alt="image-20250422201252345"></p><p><img src="/.com//image-20250422201529317.png" alt="image-20250422201529317"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 导出运营报表</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exportBusinessData</span><span class="hljs-params">(HttpServletResponse response)</span> &#123;<br>       <span class="hljs-comment">//1.查询数据库最近三十天的运营数据</span><br>       LocalDateTime begin=LocalDate.now().minusDays(<span class="hljs-number">30</span>).atStartOfDay();<br>       <span class="hljs-comment">//LocalDateTime begin1=LocalDateTime.of(LocalDate.now().minusDays(30), LocalTime.MIN);</span><br>       LocalDateTime end=LocalDate.now().atStartOfDay();<br>      <span class="hljs-comment">//LocalDateTime end1=LocalDateTime.of(LocalDate.now(),LocalTime.MIN);</span><br>       BusinessDataVO businessDataVO=workspaceService.getBusinessData(begin,end);<br><br>       <span class="hljs-comment">//2.通过POI写入Excel文件</span><br><br>       <span class="hljs-comment">//通过反射和类加载器获取模板文件的输出流</span><br>       InputStream in=<span class="hljs-built_in">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;template/运营数据报表模板.xlsx&quot;</span>);<br><br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">//基于模板文件创建一个新的Excel文件</span><br>           XSSFWorkbook excel=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XSSFWorkbook</span>(in);<br>           <span class="hljs-comment">//数据填充</span><br>           <span class="hljs-comment">//获取标签页和行,并且填充</span><br>           <span class="hljs-comment">//时间</span><br>           XSSFSheet sheet=excel.getSheet(<span class="hljs-string">&quot;Sheet1&quot;</span>);<br>           sheet.getRow(<span class="hljs-number">1</span>).getCell(<span class="hljs-number">1</span>).setCellValue(<span class="hljs-string">&quot;时间： &quot;</span>+begin+<span class="hljs-string">&quot; 至 &quot;</span>+end);<br>           <span class="hljs-comment">//概览数据</span><br>           <span class="hljs-comment">//第四行</span><br>           XSSFRow row=sheet.getRow(<span class="hljs-number">3</span>);<br>           row.getCell(<span class="hljs-number">2</span>).setCellValue(businessDataVO.getTurnover());<br>           row.getCell(<span class="hljs-number">4</span>).setCellValue(businessDataVO.getOrderCompletionRate());<br>           row.getCell(<span class="hljs-number">6</span>).setCellValue(businessDataVO.getNewUsers());<br>           <span class="hljs-comment">//第五行</span><br>           row=sheet.getRow(<span class="hljs-number">4</span>);<br>           row.getCell(<span class="hljs-number">2</span>).setCellValue(businessDataVO.getValidOrderCount());<br>           row.getCell(<span class="hljs-number">4</span>).setCellValue(businessDataVO.getUnitPrice());<br><br>           <span class="hljs-comment">//循环填充</span><br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">30</span>;i++)&#123;<br><br>               BusinessDataVO businessDataVO1=workspaceService.getBusinessData(begin,begin.plusDays(<span class="hljs-number">1</span>));<br>               <span class="hljs-comment">//从第八行开始填充</span><br>               <span class="hljs-type">XSSFRow</span> <span class="hljs-variable">row1</span> <span class="hljs-operator">=</span> sheet.getRow(<span class="hljs-number">7</span> + i);<br>               row1.getCell(<span class="hljs-number">1</span>).setCellValue(begin.toLocalDate().toString());<br>               row1.getCell(<span class="hljs-number">2</span>).setCellValue(businessDataVO1.getTurnover());<br>               row1.getCell(<span class="hljs-number">3</span>).setCellValue(businessDataVO1.getValidOrderCount());<br>               row1.getCell(<span class="hljs-number">4</span>).setCellValue(businessDataVO1.getOrderCompletionRate());<br>               row1.getCell(<span class="hljs-number">5</span>).setCellValue(businessDataVO1.getUnitPrice());<br>               row1.getCell(<span class="hljs-number">6</span>).setCellValue(businessDataVO1.getNewUsers());<br>               begin=begin.plusDays(<span class="hljs-number">1</span>);<br>           &#125;<br>           <span class="hljs-comment">//3.通过输出流将文件下载到客户端浏览器</span><br>           ServletOutputStream out= response.getOutputStream();<br>           excel.write(out);<br><br>       &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>           e.printStackTrace();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="2-EasyExcel"><a href="#2-EasyExcel" class="headerlink" title="2.EasyExcel"></a>2.EasyExcel</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/xml/"/>
    <url>/2025/07/02/xml/</url>
    
    <content type="html"><![CDATA[<h1 id="xml语法"><a href="#xml语法" class="headerlink" title="xml语法"></a>xml语法</h1><h3 id="1-文档声明"><a href="#1-文档声明" class="headerlink" title="1. 文档声明"></a>1. 文档声明</h3><ul><li>XML 文档通常以一个 XML 声明开始，它用来表明文档是 XML 类型，并指定版本和编码等信息。例如：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br></code></pre></td></tr></table></figure><ul><li>其中<code>version</code>属性指定 XML 的版本，目前最常用的是 1.0 版本。<code>encoding</code>属性指定文档使用的字符编码，<code>UTF - 8</code>是一种广泛使用的字符编码方式，可以表示多种语言的字符。</li></ul><h3 id="2-元素"><a href="#2-元素" class="headerlink" title="2. 元素"></a>2. 元素</h3><ul><li><p>元素定义</p><ul><li>XML 元素是由开始标签、结束标签和标签之间的内容组成。例如：<code>&lt;book&gt;这是一本书的内容&lt;/book&gt;</code>，其中<code>&lt;book&gt;</code>是开始标签，<code>&lt;/book&gt;</code>是结束标签，“这是一本书的内容” 是元素的内容。</li></ul></li><li><p>元素嵌套</p><ul><li>XML 元素可以嵌套，形成层次结构。例如：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">library</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>《平凡的世界》<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>路遥<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">library</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在这里，<code>&lt;library&gt;</code>元素包含<code>&lt;book&gt;</code>元素，<code>&lt;book&gt;</code>元素又包含<code>&lt;title&gt;</code>和<code>&lt;author&gt;</code>元素，这种嵌套结构可以很好地表示复杂的数据关系。</li></ul></li><li><p>空元素</p><ul><li>有些元素可能没有内容，这种元素称为空元素，可以使用一种简短的语法表示，即在开始标签的结尾处添加<code>/</code>。例如：<code>&lt;img src=&quot;image.jpg&quot;/&gt;</code>，这个<code>&lt;img&gt;</code>元素表示一个图像，它没有内部内容，通过<code>src</code>属性来指定图像的来源。</li></ul></li></ul><h3 id="3-属性"><a href="#3-属性" class="headerlink" title="3. 属性"></a>3. 属性</h3><ul><li>属性用于提供有关元素的额外信息，它位于元素的开始标签内部。例如：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">book</span> <span class="hljs-attr">category</span>=<span class="hljs-string">&quot;小说&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>《围城》<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>钱钟书<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>这里<code>&lt;book&gt;</code>元素有一个<code>category</code>属性，其值为 “小说”，用于描述这本书所属的类别。属性的值必须用引号（单引号或双引号）括起来。</li></ul><h3 id="4-注释"><a href="#4-注释" class="headerlink" title="4. 注释"></a>4. 注释</h3><ul><li>XML 中的注释与 HTML 类似，用于在文档中添加解释性的文本，注释内容不会被解析。注释的语法是<code>&lt;!-- 注释内容 --&gt;</code>。例如：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这是一个图书馆信息的XML文档 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">library</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 下面是书籍信息 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>《百年孤独》<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>加西亚·马尔克斯<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">library</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-CDATA-区"><a href="#5-CDATA-区" class="headerlink" title="5. CDATA 区"></a>5. CDATA 区</h3><ul><li>当 XML 文档中包含大量的文本内容，其中可能有一些字符会被 XML 解析器误解为标记符号（如<code>&lt;</code>、<code>&gt;</code>等）时，可以使用 CDATA 区来包含这些内容。CDATA 区的语法是<code>&lt;![CDATA[ 内容 ]]&gt;</code>。例如：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>&lt;![CDATA[这是一段包含 &lt; 符号的文本，在CDATA区内不会被误解。]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="6-DOM解析"><a href="#6-DOM解析" class="headerlink" title="6.DOM解析"></a>6.DOM解析</h2><ul><li>使用工具dom4j进行解析</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/Weixin/"/>
    <url>/2025/07/02/Weixin/</url>
    
    <content type="html"><![CDATA[<h1 id="微信小程序开发"><a href="#微信小程序开发" class="headerlink" title="微信小程序开发"></a>微信小程序开发</h1><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h1><p><img src="/.com//image-20250402190035085.png" alt="image-20250402190035085"></p><h1 id="2-开发"><a href="#2-开发" class="headerlink" title="2.开发"></a>2.开发</h1><p><img src="/.com//image-20250402202000786.png" alt="image-20250402202000786"></p><p><img src="/.com//image-20250402202133143.png" alt="image-20250402202133143"></p><h1 id="3-发布小程序"><a href="#3-发布小程序" class="headerlink" title="3.发布小程序"></a>3.发布小程序</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/Web%E5%89%8D%E7%AB%AF%E5%AE%9E%E6%88%98/"/>
    <url>/2025/07/02/Web%E5%89%8D%E7%AB%AF%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="web前端开发实战"><a href="#web前端开发实战" class="headerlink" title="web前端开发实战"></a>web前端开发实战</h1><h2 id="1-Tlias智能学习辅助系统-前端"><a href="#1-Tlias智能学习辅助系统-前端" class="headerlink" title="1.Tlias智能学习辅助系统-前端"></a>1.Tlias智能学习辅助系统-前端</h2><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h3><h3 id="2-整体布局"><a href="#2-整体布局" class="headerlink" title="2.整体布局"></a>2.整体布局</h3><h3 id="3-部门管理"><a href="#3-部门管理" class="headerlink" title="3.部门管理"></a>3.部门管理</h3><h4 id="1-部门列表查询"><a href="#1-部门列表查询" class="headerlink" title="1.部门列表查询"></a>1.部门列表查询</h4><p><img src="/.com//image-20250316134900547.png" alt="image-20250316134900547"></p><p><img src="/.com//image-20250316145738647.png" alt="image-20250316145738647"></p><p><img src="/.com//image-20250316150052011.png" alt="image-20250316150052011"></p><h4 id="2-删除部门"><a href="#2-删除部门" class="headerlink" title="2.删除部门"></a>2.删除部门</h4><p><img src="/.com//image-20250316174107302.png" alt="image-20250316174107302"></p><h4 id="3-新增部门"><a href="#3-新增部门" class="headerlink" title="3.新增部门"></a>3.新增部门</h4><p><img src="/.com//image-20250316153740633.png" alt="image-20250316153740633"></p><p><img src="/.com//image-20250316171822216.png" alt="image-20250316171822216"></p><ul><li>并且在下次打开表单时清空校验提示信息</li></ul><h4 id="4-修改部门"><a href="#4-修改部门" class="headerlink" title="4.修改部门"></a>4.修改部门</h4><h5 id="1-查询回显"><a href="#1-查询回显" class="headerlink" title="1.查询回显"></a>1.查询回显</h5><h5 id="2-修改"><a href="#2-修改" class="headerlink" title="2.修改"></a>2.修改</h5><h3 id="4-员工管理"><a href="#4-员工管理" class="headerlink" title="4.员工管理"></a>4.员工管理</h3><p><img src="/.com//image-20250316183109318.png" alt="image-20250316183109318"></p><ul><li>搜索栏：</li></ul><blockquote><p>封装搜索栏的数据</p><ul><li>使用watch侦听取到入职时间</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java">&gt;<span class="hljs-comment">//搜索表单对象</span><br>&gt;<span class="hljs-type">const</span> <span class="hljs-variable">searchEmp</span> <span class="hljs-operator">=</span> ref(&#123;<br> name: <span class="hljs-string">&quot;&quot;</span>,<br> gender: <span class="hljs-string">&quot;&quot;</span>,<br> date: [],<br> begin: <span class="hljs-string">&quot;&quot;</span>,<br> end: <span class="hljs-string">&quot;&quot;</span>,<br> pageSize: <span class="hljs-number">10</span>,<br> page: <span class="hljs-number">1</span>,<br>&gt;&#125;);<br><br>&gt;<span class="hljs-comment">//侦听date</span><br>&gt;watch(<br>searchEmp.value.date,<br> (newVal, oldVal) =&gt; &#123;<br>   newVal.length &gt; <span class="hljs-number">0</span><br>     ? (searchEmp.value.begin = newVal[<span class="hljs-number">0</span>])<br>     : (searchEmp.value.begin = <span class="hljs-string">&quot;&quot;</span>);<br>   newVal.length &gt; <span class="hljs-number">1</span><br>     ? (searchEmp.value.end = newVal[<span class="hljs-number">1</span>])<br>     : (searchEmp.value.end = <span class="hljs-string">&quot;&quot;</span>);<br> &#125;<br>&gt;);<br></code></pre></td></tr></table></figure></blockquote><ul><li>模板字符串查询</li></ul><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&gt;<span class="hljs-comment">//条件查询</span><br>&gt;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getAllStuApi</span>=(<span class="hljs-params">params</span>)=&gt;&#123;<br>   <span class="hljs-keyword">const</span> searchParams=<span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>();<br>   <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(params).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[key,value]</span>)=&gt;</span>&#123;<br>       <span class="hljs-keyword">if</span>(value!==<span class="hljs-literal">null</span>&amp;&amp;value!==<span class="hljs-literal">undefined</span>)<br>           searchParams.<span class="hljs-title function_">append</span>(key,value);<br>   &#125;)<br>&gt;<span class="hljs-keyword">return</span> request.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/students?<span class="hljs-subst">$&#123;searchParams.toString()&#125;</span>`</span>)<br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>URLSearchParams类规范、便捷，适合处理复杂参数，确保生成的 URL 中不会包含空值参数。</p></blockquote><blockquote><p>新增或修改的dialog表单排版</p><p>gutter：对应行之间的间隔</p><p>span:一行对应24，按列分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html">&gt;//第一行<br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">el-row</span> <span class="hljs-attr">:gutter</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br>&gt;//第一列<br>  <span class="hljs-tag">&lt;<span class="hljs-name">el-col</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;12&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span>&gt;</span>&quot;表单组件&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">el-col</span>&gt;</span><br>&gt;//第二列<br><span class="hljs-tag">&lt;<span class="hljs-name">el-col</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;12&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span>&gt;</span>&quot;表单组件&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">el-col</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">el-row</span>&gt;</span><br>&gt;//第二行<br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">el-row</span> <span class="hljs-attr">:gutter</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br>&gt;//第一列<br>  <span class="hljs-tag">&lt;<span class="hljs-name">el-col</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;12&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span>&gt;</span>&quot;表单组件&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">el-col</span>&gt;</span><br>&gt;//第二列<br><span class="hljs-tag">&lt;<span class="hljs-name">el-col</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;12&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span>&gt;</span>&quot;表单组件&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">el-col</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">el-row</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><ul><li>查询回显时下拉框的回显</li></ul><blockquote><p>先看准数据类型，再v-for循环遍历显示下拉框，绑定表单的对应项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&gt;<span class="hljs-comment">//定义元数据</span><br>&gt;<span class="hljs-keyword">const</span> degrees=<span class="hljs-title function_">ref</span>([<br>  &#123;<br>   <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;初中&quot;</span>,<br>   <span class="hljs-attr">value</span>:<span class="hljs-number">1</span><br>  &#125;,<br>  &#123;<br>   <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;高中&quot;</span>,<br>   <span class="hljs-attr">value</span>:<span class="hljs-number">2</span><br>  &#125;,&#123;<br>   <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;大专&quot;</span>,<br>   <span class="hljs-attr">value</span>:<span class="hljs-number">3</span><br>  &#125;,<br>  &#123;<br>   <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;本科&quot;</span>,<br>   <span class="hljs-attr">value</span>:<span class="hljs-number">4</span><br>  &#125;,<br>  &#123;<br>   <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;硕士&quot;</span>,<br>   <span class="hljs-attr">value</span>:<span class="hljs-number">5</span><br>  &#125;,<br>  &#123;<br>   <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;博士&quot;</span>,<br>   <span class="hljs-attr">value</span>:<span class="hljs-number">6</span><br>  &#125;<br>&gt;])<br>&gt;<span class="hljs-keyword">const</span> genderMap = &#123;<br> <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;男&#x27;</span>,<br> <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;女&#x27;</span><br>&gt;&#125;;<br><br>&gt;<span class="hljs-keyword">const</span> isCollegeMap = &#123;<br> <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;是学院生&#x27;</span>,<br> <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;不是学院生&#x27;</span><br>&gt;&#125;<br>&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;性别&quot;</span> <span class="hljs-attr">label-width</span>=<span class="hljs-string">&quot;80px&quot;</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">&quot;gender&quot;</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;<span class="hljs-name">el-select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;editStuList.gender&quot;</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">el-option</span></span></span><br><span class="hljs-tag"><span class="language-xml">         <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(label, value) in genderMap&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">         <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;value&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">         <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;Number(value)&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">         <span class="hljs-attr">:label</span>=<span class="hljs-string">&quot;label&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">       /&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">el-select</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;是否是学院生&quot;</span> <span class="hljs-attr">label-width</span>=<span class="hljs-string">&quot;120px&quot;</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">&quot;isCollege&quot;</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;<span class="hljs-name">el-select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;editStuList.isCollege&quot;</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">el-option</span></span></span><br><span class="hljs-tag"><span class="language-xml">         <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(label, value) in isCollegeMap&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">         <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;value&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">         <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;Number(value)&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">         <span class="hljs-attr">:label</span>=<span class="hljs-string">&quot;label&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">       /&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">el-select</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span></span><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;学位&quot;</span> <span class="hljs-attr">label-width</span>=<span class="hljs-string">&quot;80px&quot;</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">&quot;salary&quot;</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;<span class="hljs-name">el-select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;editStuList.degree&quot;</span>&gt;</span></span><br><span class="language-xml">           <span class="hljs-tag">&lt;<span class="hljs-name">el-option</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in degrees&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;item.value&quot;</span> <span class="hljs-attr">:label</span>=<span class="hljs-string">&quot;item.name&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.value&quot;</span> /&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;/<span class="hljs-name">el-select</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span></span><br></code></pre></td></tr></table></figure></blockquote><h3 id="5-登录"><a href="#5-登录" class="headerlink" title="5.登录"></a>5.登录</h3><ul><li>通用登录页面背景图设计CSS样式</li></ul><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css">&gt;<span class="hljs-selector-class">.container</span>&#123;<br>    <span class="hljs-comment">/*固定定位*/</span><br>   <span class="hljs-attribute">position</span>:fixed;<br>   <span class="hljs-attribute">top</span>=<span class="hljs-number">0</span>;<br>   <span class="hljs-attribute">left</span>=<span class="hljs-number">0</span>;<br>   <span class="hljs-attribute">right</span>=<span class="hljs-number">0</span>;<br>   <span class="hljs-attribute">bottom</span>=<span class="hljs-number">0</span>;<br> <span class="hljs-comment">/*设置背景图片 */</span><br>   <span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;背景图片路径&quot;</span>)<br>   background-repeat:no-repeat<span class="hljs-comment">/*不重复*/</span><br>   background-position:center<span class="hljs-comment">/*居中*/</span><br>   background-size:cover<span class="hljs-comment">/*覆盖z*/</span><br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><ul><li>登录页面跳转<ul><li>导入useRouter()方法，拿到router实例，调用push（’path‘）方法跳转页面</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-keyword">const</span> router=<span class="hljs-title function_">useRouter</span>();<span class="hljs-comment">//拿到router实例</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleLogin</span> = <span class="hljs-keyword">async</span>(<span class="hljs-params"></span>) =&gt; &#123;<br><span class="hljs-keyword">const</span> result=<span class="hljs-keyword">await</span> <span class="hljs-title function_">loginApi</span>(loginForm.<span class="hljs-property">value</span>);<br><br><span class="hljs-keyword">if</span>(result.<span class="hljs-property">code</span>)<span class="hljs-comment">//登录成功</span><br>&#123;<br>  <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">success</span>(<span class="hljs-string">&#x27;登录成功&#x27;</span>);<br>  <span class="hljs-comment">//页面跳转，接收令牌</span><br>router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(result.<span class="hljs-property">msg</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>登录接收令牌</li></ul><blockquote><p>localStorage-浏览器本地存储</p><p><img src="/.com//image-20250323144649180.png" alt="image-20250323144649180"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&gt;<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;loginUser&quot;</span>,<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(result.<span class="hljs-property">data</span>));<br></code></pre></td></tr></table></figure><p><img src="/.com//image-20250323145157508.png" alt="image-20250323145157508"></p><ul><li>携带令牌访问-axios请求拦截器</li></ul><p><img src="/.com//image-20250323152026092.png" alt="image-20250323152026092"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&gt;<span class="hljs-comment">//axios 请求拦截器-携带令牌访问</span><br>&gt;request.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>&gt;<span class="hljs-function">(<span class="hljs-params">config</span>)=&gt;</span>&#123;<span class="hljs-comment">//成功回调</span><br>&gt;<span class="hljs-keyword">const</span> loginUser=<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;loginUser&#x27;</span>));<br>&gt;<span class="hljs-keyword">if</span>(loginUser&amp;&amp;loginUser.<span class="hljs-property">token</span>)&#123;<br>   config.<span class="hljs-property">headers</span>.<span class="hljs-property">token</span>=loginUser.<span class="hljs-property">token</span>;<br>&gt;&#125;<br>&gt;<span class="hljs-keyword">return</span> config;<br>&gt;&#125;,<br>&gt;<span class="hljs-function">(<span class="hljs-params">error</span>)=&gt;</span>&#123;<br>&gt;<span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>&gt;&#125;<br>&gt;)<br></code></pre></td></tr></table></figure><ul><li>upload上传图片不是基于axios需要手动设置token</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&gt;<span class="hljs-comment">//文件上传token</span><br>&gt;<span class="hljs-keyword">const</span> token=<span class="hljs-title function_">ref</span>();<br>&gt;<span class="hljs-comment">//获取token</span><br>&gt;<span class="hljs-keyword">const</span> <span class="hljs-title function_">getToken</span>=(<span class="hljs-params"></span>)=&gt;&#123;<br> <span class="hljs-keyword">const</span> loginUser=<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;loginUser&quot;</span>));<br> <span class="hljs-keyword">if</span>(loginUser&amp;&amp;loginUser.<span class="hljs-property">token</span>)&#123;<br>   token.<span class="hljs-property">value</span>=loginUser.<span class="hljs-property">token</span>;<br> &#125;<br>&gt;&#125;<br>&gt;<span class="hljs-comment">//挂入钩子函数中</span><br></code></pre></td></tr></table></figure><ul><li>401未认证跳转至登录页面</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&gt;<span class="hljs-comment">//导入router实例使用push方法跳转页面,无需使用userRouter方法</span><br>&gt;<span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../router&quot;</span><br>&gt;<span class="hljs-comment">//axios 响应拦截器</span><br>&gt;request.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>   <span class="hljs-function">(<span class="hljs-params">response</span>)=&gt;</span>&#123;<span class="hljs-comment">//成功回调</span><br>   <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;    <br>   &#125;,<br>   <span class="hljs-function">(<span class="hljs-params">error</span>)=&gt;</span>&#123;<span class="hljs-comment">//失败回调，401--跳转登陆页面</span><br>       <span class="hljs-keyword">if</span>(error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span>===<span class="hljs-number">401</span>)&#123;<span class="hljs-comment">//===全等（包含类型）</span><br>       <span class="hljs-comment">//跳转到登陆页面</span><br>       <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;登录超时，请重新登录&#x27;</span>),<br>&gt;router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/login&#x27;</span>)<br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>           <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;接口访问异常&#x27;</span>)<br>       &#125;<br>&gt;<span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>   &#125;<br>&gt;)<br></code></pre></td></tr></table></figure></blockquote><h3 id="6-班级管理-学员管理"><a href="#6-班级管理-学员管理" class="headerlink" title="6.班级管理&#x2F;学员管理"></a>6.班级管理&#x2F;学员管理</h3><ul><li>多选删除的实现</li></ul><blockquote><ul><li>table加上selection的type，再实现handleSeletionChange方法即可</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&gt;<span class="hljs-comment">//删除学员</span><br>&gt;<span class="hljs-keyword">const</span> <span class="hljs-title function_">delStu</span>=<span class="hljs-keyword">async</span>(<span class="hljs-params">id</span>)=&gt;&#123;<br>&gt;<span class="hljs-keyword">const</span> res=<span class="hljs-keyword">await</span> <span class="hljs-title function_">delStuApi</span>(id);<br>&gt;<span class="hljs-keyword">if</span>(res.<span class="hljs-property">code</span>)&#123;<br> <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">success</span>(<span class="hljs-string">&quot;操作成功&quot;</span>)<br> <span class="hljs-title function_">search</span>();<br>&gt;&#125;<span class="hljs-keyword">else</span>&#123;<br> <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(res.<span class="hljs-property">msg</span>)<br>&gt;&#125;<br>&gt;&#125;<br>&gt;<span class="hljs-comment">//多选的实现</span><br>&gt;<span class="hljs-keyword">const</span> ids=<span class="hljs-title function_">ref</span>([])<br>&gt;<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSelectionChange</span>=(<span class="hljs-params">selection</span>)=&gt;&#123;<br>&gt;ids.<span class="hljs-property">value</span>=selection.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br> <span class="hljs-keyword">return</span> item.<span class="hljs-property">id</span><br>&gt;&#125;)<br>&gt;&#125;<br><br><br>&gt;<span class="hljs-comment">//批量删除学员</span><br>&gt;<span class="hljs-keyword">const</span> <span class="hljs-title function_">delStus</span>=<span class="hljs-keyword">async</span>(<span class="hljs-params"></span>)=&gt;&#123;<br>&gt;<span class="hljs-comment">//判断ids是否有值</span><br>&gt;<span class="hljs-keyword">if</span>(ids.<span class="hljs-property">value</span>&amp;&amp;ids.<span class="hljs-property">value</span>.<span class="hljs-property">length</span>&gt;<span class="hljs-number">0</span>)&#123;<br> <span class="hljs-title function_">delEmp</span>(ids.<span class="hljs-property">value</span>);<br>&gt;&#125;<span class="hljs-keyword">else</span>&#123;<br> <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;未选中&quot;</span>)<br>&gt;&#125;<br>&gt;&#125;<br></code></pre></td></tr></table></figure><ul><li>加上selection列和@selection-change方法绑定</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;large&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;delStus&quot;</span></span><br><span class="hljs-tag">       &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Minus</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span>批量删除&lt;/el-button<br>     &gt;<br><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">el-table</span> <span class="hljs-attr">:data</span>=<span class="hljs-string">&quot;stuList&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100%&quot;</span>  </span><br><span class="hljs-tag">     @<span class="hljs-attr">selection-change</span>=<span class="hljs-string">&quot;handleSelectionChange&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;selection&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;55&quot;</span> /&gt;</span><br>     ...<br>       <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;操作&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300px&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>=<span class="hljs-string">&quot;scope&quot;</span>&gt;</span><br>         <br>           <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;danger&quot;</span>  @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;delStu(scope.row.id)&quot;</span></span><br><span class="hljs-tag">             &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Delete</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span>删除&lt;/el-button<br>           &gt;<br>         <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">el-table</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="7-报表统计"><a href="#7-报表统计" class="headerlink" title="7.报表统计"></a>7.报表统计</h3><ul><li>使用Apache ECharts 显示报表统计信息</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/Web%E5%90%8E%E7%AB%AF%E5%AE%9E%E6%88%98/"/>
    <url>/2025/07/02/Web%E5%90%8E%E7%AB%AF%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Web后端开发实战"><a href="#Web后端开发实战" class="headerlink" title="Web后端开发实战"></a>Web后端开发实战</h1><h2 id="1-Tlias智能学习辅助系统-后端"><a href="#1-Tlias智能学习辅助系统-后端" class="headerlink" title="1.Tlias智能学习辅助系统-后端"></a>1.Tlias智能学习辅助系统-后端</h2><ul><li>后端技术</li></ul><p><img src="/.com//image-20250306175338956.png" alt="image-20250306175338956"></p><ul><li>需求</li></ul><p><img src="/.com//image-20250228153813425.png" alt="image-20250228153813425"></p><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h3><ul><li><p>前后端分离-接口文档</p></li><li><p>开发规范-Restful风格（REpresentational State Transfer 表述性状态转换），是一种软件架构风格</p><ul><li>描述功能模块通常使用复数形式（加s），表示此类资源，而非单个资源。如：users,books…</li><li>GET:查询</li><li>POST:新增</li><li>PUT:修改</li><li>DELETE:删除</li></ul></li></ul><p><img src="/.com//image-20250228155133465.png" alt="image-20250228155133465"></p><ul><li><p>开发规范- Apifox工具</p><p><img src="/.com//image-20250228161020984.png" alt="image-20250228161020984"></p></li><li><p>工程搭建</p><ol><li>创建 SpringBoot 工程，并引入 web 开发起步依赖、mybatis、mysql 驱动、lombok。</li><li>创建数据库表 dept（部门表）, 并在 application.yml 中配置数据库的基本信息。</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#配置数据库的连接信息</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/tlias</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">&#x27;052712&#x27;</span><br><br><br><span class="hljs-comment">#mybatis的相关配置</span><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-comment"># 配置日志实现</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br>    <span class="hljs-comment"># 配置mapper.xml文件位置</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mapper/*.xml</span><br></code></pre></td></tr></table></figure><ol start="3"><li>准备基础代码结构，并引入实体类 Dept 及统一的响应结果封装类 Result</li></ol></li></ul><p><img src="/.com//image-20250228200706298.png" alt="image-20250228200706298"></p><blockquote><p>建表、编写配置文件引入基本配置、编写实体类、项目分层、添加接口、类和注解</p><p>mapper(@Mapper,接口)、service(@Service,实现类)、controller(@RestController(@Controller,@ResponseBody),实体类)</p></blockquote><blockquote><p><strong>Result</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-meta">@Data</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> &#123;<br>   <span class="hljs-keyword">private</span> Integer code;<span class="hljs-comment">//响应码 1成功 0失败</span><br>   <span class="hljs-keyword">private</span> String msg;<span class="hljs-comment">//响应信息</span><br>   <span class="hljs-keyword">private</span> Object data;<span class="hljs-comment">//响应数据</span><br><br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">success</span><span class="hljs-params">()</span>&#123;<br>      Result result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>();<br>      result.code=<span class="hljs-number">1</span>;<br>      result.msg=<span class="hljs-string">&quot;sucess&quot;</span>;<br>      <span class="hljs-keyword">return</span> result;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">success</span><span class="hljs-params">(Object object)</span>&#123;<br>       Result result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>();<br>       result.code=<span class="hljs-number">1</span>;<br>       result.data=object;<br>       result.msg=<span class="hljs-string">&quot;sucess&quot;</span>;<br>       <span class="hljs-keyword">return</span> result;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">error</span><span class="hljs-params">(String msg)</span>&#123;<br>       Result result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>();<br>       result.code=<span class="hljs-number">0</span>;<br>       result.msg=msg;<br>       <span class="hljs-keyword">return</span> result;<br>   &#125;<br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="2-部门管理"><a href="#2-部门管理" class="headerlink" title="2.部门管理"></a>2.部门管理</h3><h4 id="1-查询部门"><a href="#1-查询部门" class="headerlink" title="1.查询部门"></a>1.查询部门</h4><ul><li>接口开发</li></ul><p><img src="/.com//image-20250228183821558.png" alt="image-20250228183821558"></p><ul><li>全部查询</li></ul><blockquote><p><strong>DeptController</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeptController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DeptService deptService;<br>    <span class="hljs-comment">//@RequestMapping(value = &quot;/depts&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-meta">@GetMapping(&quot;/depts&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">list</span><span class="hljs-params">()</span>&#123;<br>        List&lt;Dept&gt; list=deptService.findAll();<br>        System.out.println(<span class="hljs-string">&quot;查询全部的部门信息&quot;</span>);<br>        <span class="hljs-keyword">return</span> Result.success(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>DeptService</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-meta">@Service</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeptServiceimpImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DeptService</span> &#123;<br>   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> DeptMapper deptMapper;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> List&lt;Dept&gt; <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> deptMapper.findAll();<br>   &#125;<br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>DeptMapper</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-meta">@Mapper</span><span class="hljs-comment">//表示这是一个mybatis的mapper类</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DeptMapper</span> &#123;<br>      <span class="hljs-meta">@Select(&quot;select id,name,create_time,update_time from dept order by update_time desc&quot;)</span><br>   List&lt;Dept&gt; <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote><ul><li>根据id查询</li></ul><p><img src="/.com//image-20250301184544284.png" alt="image-20250301184544284"></p><blockquote><p>路径参数:通过请求URL直接传递参数，使用{…}来标识该路径参数，需要使用**@PathVariable**获取</p></blockquote><ul><li>前后端联调测试</li></ul><p><a href="https://pan.baidu.com/s/1pzty-fFmTECpw8U11mU2lA">前端资源</a></p><p>提取码：mlgb</p><p><img src="/.com//image-20250228204504212.png" alt="image-20250228204504212"></p><blockquote><p>前端资源文件放在html路径下</p></blockquote><p><img src="/.com//image-20250228204635036.png" alt="image-20250228204635036"></p><p>显示数据即联调成功</p><p><img src="/.com//image-20250228204440360.png" alt="image-20250228204440360"></p><blockquote><p>发现请求url并不是主机的tomcat服务器，那是如何获取数据的呢？</p><p>通过Nginx的反向代理</p><p><img src="/.com//image-20250228205601598.png" alt="image-20250228205601598"></p><p>查看Nginx的配置文件</p><p><img src="/.com//image-20250228205819280.png" alt="image-20250228205819280"></p></blockquote><p><img src="/.com//image-20250228205928495.png" alt="image-20250228205928495"></p><h4 id="2-删除部门"><a href="#2-删除部门" class="headerlink" title="2.删除部门"></a>2.删除部门</h4><ul><li><p>根据id删除部门</p><p><img src="/.com//image-20250301172419678-17408210611561.png" alt="image-20250301172419678"></p><blockquote><p><strong>DeptController</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DeleteMapping(&quot;/depts/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span>&#123;<br>        deptService.deleteById(id);<br>        System.out.println(<span class="hljs-string">&quot;删除部门的id为：&quot;</span>+id);<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>DeptService</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(Integer id)</span> &#123;<br>       deptMapper.deleteById(id);<br>   &#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>DeptMapper</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 按id删除部门</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Delete(&quot;delete from dept where id=#&#123;id&#125;&quot;)</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(Integer id)</span>;<br></code></pre></td></tr></table></figure></blockquote></li></ul><p>同样进行接口功能测试</p><h4 id="3-新增部门"><a href="#3-新增部门" class="headerlink" title="3.新增部门"></a>3.新增部门</h4><p><img src="/.com//image-20250301182514426.png" alt="image-20250301182514426"></p><ul><li>使用实体类来接收json格式的参数</li></ul><p><img src="/.com//image-20250301182648728.png" alt="image-20250301182648728"></p><ul><li><blockquote><p><strong>DeptController</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新增部门</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dept</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;/depts&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Dept dept)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;新增部门的信息为：&quot;</span>+dept);<br>deptService.add(dept);<br><span class="hljs-keyword">return</span> Result.success();<br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>DeptService</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Dept dept)</span> &#123;<br>      dept.setCreateTime(LocalDateTime.now());<br>      dept.setUpdateTime(LocalDateTime.now());<br>      deptMapper.add(dept);<br>  &#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>DeptMapper</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 插入新增部门</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-meta">@Insert(&quot;insert into dept(name,create_time,update_time) values(#&#123;name&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;)&quot;)</span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Dept dept)</span>;<br></code></pre></td></tr></table></figure></blockquote></li></ul><p>同样进行接口功能测试</p><h4 id="4-修改部门"><a href="#4-修改部门" class="headerlink" title="4.修改部门"></a>4.修改部门</h4><ul><li><p>修改时需要设置修改时间字段</p></li><li><blockquote><p><strong>DeptController</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据id更新部门数据</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@PutMapping</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Dept dept)</span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;修改部门的信息为：&quot;</span>+dept);<br>       deptService.update(dept);<br>       <span class="hljs-keyword">return</span> Result.success();<br>   &#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>DeptService</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Dept dept)</span> &#123;<br>     dept.setUpdateTime(LocalDateTime.now());<br>     deptMapper.update(dept);<br> &#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>DeptMapper</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 根据id修改部门</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@Update(&quot;update dept set name=#&#123;name&#125;,update_time=#&#123;updateTime&#125; where id=#&#123;id&#125;&quot;)</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Dept dept)</span>;<br><br></code></pre></td></tr></table></figure></blockquote></li></ul><p>同样进行接口功能测试</p><h4 id="5-添加日志"><a href="#5-添加日志" class="headerlink" title="5.添加日志"></a>5.添加日志</h4><ul><li>使用Lombok注解**@Slf4j**</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//System.out.println(&quot;查询部门的id为：&quot;+id);</span><br>        log.info(<span class="hljs-string">&quot;查询部门的id为：&#123;&#125;&quot;</span>, id);<br></code></pre></td></tr></table></figure><h3 id="3-员工管理"><a href="#3-员工管理" class="headerlink" title="3.员工管理"></a>3.员工管理</h3><h4 id="1-查询员工"><a href="#1-查询员工" class="headerlink" title="1.查询员工"></a>1.查询员工</h4><ul><li><p>需求</p><p><img src="/.com//image-20250301235202017-17408443454842.png" alt="image-20250301235202017"></p><ol><li>准备数据库表 emp、emp_expr。</li><li>准备实体类 Emp、EmpExpr。</li><li>准备三层架构的基本代码结构：EmpController、EmpService&#x2F;EmpServiceImpl、EmpMapper.</li><li>准备结果封装的实体类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分页结果封装类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageResult</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> Long total;<br>    <span class="hljs-keyword">private</span> List&lt;T&gt; rows;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>分页查询</p><p><img src="/.com//image-20250302003124238.png" alt="image-20250302003124238"></p><p><img src="/.com//image-20250302003141142.png" alt="image-20250302003141142"></p><p><img src="/.com//image-20250302003338846.png" alt="image-20250302003338846"></p><p><img src="/.com//image-20250302122550566.png" alt="image-20250302122550566"></p></li></ul><blockquote><ul><li>原始方式：</li></ul><blockquote><p>EmptController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"> &gt;<span class="hljs-comment">/**</span><br><span class="hljs-comment">* 分页查询员工信息</span><br><span class="hljs-comment">*/</span><br> &gt;<span class="hljs-meta">@GetMapping</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">list</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(defaultValue = &quot;1&quot;)</span> Integer page, <span class="hljs-meta">@RequestParam(defaultValue = &quot;10&quot;)</span> Integer pageSize)</span>&#123;<br>   PageResult&lt;Emp&gt; pageResult=empService.page(page,pageSize);<br>   log.info(<span class="hljs-string">&quot;分页查询：&#123;&#125;，&#123;&#125;&quot;</span>,page,pageSize);<br>   <span class="hljs-keyword">return</span> Result.success(pageResult);<br> &gt;&#125;<br></code></pre></td></tr></table></figure><p>EmpServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"> &gt;<span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> PageResult&lt;Emp&gt; <span class="hljs-title function_">page</span><span class="hljs-params">(Integer page, Integer pageSize)</span> &#123;<br> &gt;<span class="hljs-comment">//        if(page==null||page&lt;=0)&#123;</span><br> &gt;<span class="hljs-comment">//            page=1;</span><br> &gt;<span class="hljs-comment">//        &#125;</span><br> &gt;<span class="hljs-comment">//        if(pageSize==null||pageSize&lt;=0)&#123;</span><br> &gt;<span class="hljs-comment">//            pageSize=10;</span><br> &gt;<span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//调用mapper接口，查询总记录数</span><br>       <span class="hljs-type">Long</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> empMapper.count();<br>       Integer start=(page-<span class="hljs-number">1</span>)*pageSize;<br>       <span class="hljs-comment">//调用mapper接口，分页查询</span><br>       List&lt;Emp&gt; rows=empMapper.list(start,pageSize);<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageResult</span>&lt;Emp&gt;(total,rows);<br>   &#125;<br></code></pre></td></tr></table></figure><p>EmpMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"> &gt;<span class="hljs-comment">/**</span><br><span class="hljs-comment">* 查询总记录数</span><br><span class="hljs-comment">*/</span><br> &gt;<span class="hljs-meta">@Select(&quot;Select count(*) from emp e left join dept d on e.dept_id=d.id&quot;)</span><br> &gt;<span class="hljs-keyword">public</span> Long <span class="hljs-title function_">count</span><span class="hljs-params">()</span>;<br> &gt;<span class="hljs-comment">/**</span><br><span class="hljs-comment">* 分页查询</span><br><span class="hljs-comment">*/</span><br> &gt;<span class="hljs-meta">@Select(&quot;select e.*,d.name deptName from emp e left join dept d on e.dept_id = d.id order by e.update_time desc limit #&#123;start&#125;,#&#123;pageSize&#125;&quot;)</span><br> &gt;<span class="hljs-keyword">public</span> List&lt;Emp&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Integer start,Integer pageSize)</span>;<br></code></pre></td></tr></table></figure></blockquote><ul><li>PageHelper插件</li></ul><p> <img src="/.com//image-20250302132454820.png" alt="image-20250302132454820"></p><ul><li><blockquote><p>EmptController不变</p><p>EmpServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 使用PageHelper插件来进行分页查询</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> page</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> pageSize</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> PageResult&lt;Emp&gt; <span class="hljs-title function_">page</span><span class="hljs-params">(Integer page, Integer pageSize)</span> &#123;<br>&gt;<span class="hljs-comment">//设置分页参数</span><br>      PageHelper.startPage(page, pageSize);<br>&gt;<span class="hljs-comment">//调用查询方法</span><br>      List&lt;Emp&gt; empList = empMapper.list();<br>&gt;<span class="hljs-comment">//封装分页结果</span><br>      <span class="hljs-comment">//Page是PageHelper提供的分页对象，包含了分页信息，如总记录数、总页数等</span><br>      Page&lt;Emp&gt; p = (Page&lt;Emp&gt;) empList;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageResult</span>&lt;Emp&gt;(p.getTotal(),p.getResult());<br>  &#125;<br></code></pre></td></tr></table></figure><p>EmpMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">//使用PageHelper分页插件-无需考虑分页操作</span><br>  <span class="hljs-meta">@Select(&quot;select e.*,d.name deptName from emp e left join dept d on e.dept_id = d.id order by e.update_time desc&quot;)</span><br>  <span class="hljs-keyword">public</span> List&lt;Emp&gt; <span class="hljs-title function_">list</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure></blockquote></li></ul></blockquote><ul><li><p>条件查询</p><p><img src="/.com//image-20250302142223071.png" alt="image-20250302142223071"></p></li></ul><p><img src="/.com//image-20250302152210711.png" alt="image-20250302152210711"></p><blockquote><p>用xml编写动态sql</p><p><img src="/.com//image-20250302155536674.png" alt="image-20250302155536674"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml">&gt;<span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br>&gt;<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">       <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">       <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br>&gt;<span class="hljs-comment">&lt;!--对应mapper的全定向路径--&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.example.tliaswebmanagement.mapper.EmpMapper&quot;</span>&gt;</span><br>&gt;<span class="hljs-comment">&lt;!--定义对应方法的sql语句,id为方法名，resultType为返回类型的全定限名--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.example.tliaswebmanagement.pojo.Emp&quot;</span>&gt;</span><br>       select e.*, d.name deptName from emp e left join dept d on e.dept_id = d.id<br>       <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name !=null and name !=&#x27;&#x27;&quot;</span>&gt;</span><br>               e.name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>           <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender !=null &quot;</span>&gt;</span><br>               and e.gender = #&#123;gender&#125;<br>           <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin !=null and end != null&quot;</span>&gt;</span><br>               and e.entry_date between #&#123;begin&#125; and #&#123;end&#125;<br>           <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>       order by e.update_time desc<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>最终代码</p><p>EmpControl- 用对象封装请求头参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-meta">@GetMapping()</span><br>&gt;<span class="hljs-comment">//使用@RequestParam注解，设置默认值，如果没有传递page和pageSize参数，则使用默认值1和10</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">list</span><span class="hljs-params">(EmpQueryParam empQueryParam)</span>&#123;<br>   PageResult&lt;Emp&gt; pageResult=empService.page(empQueryParam);<br>   log.info(<span class="hljs-string">&quot;分页查询：&#123;&#125;&quot;</span>,empQueryParam);<br>   <span class="hljs-keyword">return</span> Result.success(pageResult);<br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>EmpService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> PageResult&lt;Emp&gt; <span class="hljs-title function_">page</span><span class="hljs-params">(EmpQueryParam empQueryParam)</span> &#123;<br>&gt;<span class="hljs-comment">//设置分页参数</span><br>       PageHelper.startPage(empQueryParam.getPage(), empQueryParam.getPageSize());<br>&gt;<span class="hljs-comment">//调用查询方法</span><br>       List&lt;Emp&gt; empList = empMapper.list(empQueryParam);<br>&gt;<span class="hljs-comment">//封装分页结果</span><br>       <span class="hljs-comment">//Page是PageHelper提供的分页对象，包含了分页信息，如总记录数、总页数等</span><br>       Page&lt;Emp&gt; p = (Page&lt;Emp&gt;) empList;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageResult</span>&lt;Emp&gt;(p.getTotal(),p.getResult());<br>   &#125;<br></code></pre></td></tr></table></figure><p>EmpMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">public</span> List&lt;Emp&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(EmpQueryParam empQueryParam)</span>;<br></code></pre></td></tr></table></figure></blockquote><h4 id="2-删除-批量删除员工"><a href="#2-删除-批量删除员工" class="headerlink" title="2.删除&#x2F;批量删除员工"></a>2.删除&#x2F;批量删除员工</h4><ul><li>根据id删除员工</li><li>前端传递对应的id</li><li>后端删除员工和其对应工作经历</li><li>后端无需返回信息</li></ul><p><img src="/.com//image-20250303161930170.png" alt="image-20250303161930170"></p><p><img src="/.com//image-20250303162030344.png" alt="image-20250303162030344"></p><blockquote><ul><li>EmpController</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 删除员工</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">////数组接收数组参数，路径变量接收</span><br><span class="hljs-comment">//@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-comment">//public Result delete(@PathVariable Integer[] ids)&#123;</span><br><span class="hljs-comment">//    empService.deleteById(ids);</span><br><span class="hljs-comment">//    log.info(&quot;删除id为&#123;&#125;的员工&quot;, Arrays.toString(ids));</span><br><span class="hljs-comment">//    return Result.success();</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//集合接收,前端以查询字符串形式传递</span><br><span class="hljs-meta">@DeleteMapping</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;ids&quot;)</span> List&lt;Integer&gt; ids)</span>&#123;<br>    empService.deleteById(ids);<br>    log.info(<span class="hljs-string">&quot;删除id为&#123;&#125;的员工&quot;</span>, ids);<br>    <span class="hljs-keyword">return</span> Result.success();<br>&#125;<br><span class="hljs-comment">//集合接收,前端以路径参数传递</span><br>    <span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String id)</span>&#123;<br>        List&lt;Integer&gt; ids = Arrays.stream(id.split(<span class="hljs-string">&quot;,&quot;</span>))<br>                .map(Integer::parseInt)<br>                .collect(Collectors.toList());<br>        empService.deleteById(ids);<br>        log.info(<span class="hljs-string">&quot;删除id为&#123;&#125;的员工&quot;</span>, ids);<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><ul><li>EmpServiceImpl</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-meta">@Override</span><br>   <span class="hljs-meta">@Transactional(rollbackFor = &#123;Exception.class&#125;)</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(List&lt;Integer&gt; ids)</span> &#123;<br>       <span class="hljs-comment">//删除员工基本信息</span><br>       empMapper.deleteById(ids);<br>       <span class="hljs-comment">//删除员工工作经历</span><br>       empExprMapper.deleteById(ids);<br>       <span class="hljs-comment">//根据id生成删除日志</span><br>       empLogService.deletelog(ids.stream().map(id -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmpLog</span>(<span class="hljs-literal">null</span>, LocalDateTime.now(), <span class="hljs-string">&quot;删除员工：&quot;</span> + id)).toList());<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li>多条sql操作用@Transactional(rollbackFor&#x3D;{Exception.class})来保证事务的原子性</li><li>EmpLogServiceImpl</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deletelog</span><span class="hljs-params">(List&lt;EmpLog&gt; empLog)</span> &#123;<br>       empLogMapper.deleteById(empLog);<br>   &#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><ul><li>EmpMapper</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteById&quot;</span>&gt;</span><br>       delete from emp where id in<br>       <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>           #&#123;id&#125;<br>       <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>EmpExprMapper</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;delete id=<span class="hljs-string">&quot;deleteById&quot;</span>&gt;<br>       delete from emp_expr where emp_id in<br>                            &lt;foreach collection=<span class="hljs-string">&quot;ids&quot;</span> item=<span class="hljs-string">&quot;id&quot;</span> separator=<span class="hljs-string">&quot;,&quot;</span> open=<span class="hljs-string">&quot;(&quot;</span> close=<span class="hljs-string">&quot;)&quot;</span>&gt;<br>                                #&#123;id&#125;<br>                            &lt;/foreach&gt;<br>   &lt;/delete&gt;<br></code></pre></td></tr></table></figure><ul><li>EmpLogMapper</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteById&quot;</span> &gt;</span><br>       insert into emp_log(operate_time, info)values<br>                                                  <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;empLog&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;e&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>                                                      (#&#123;e.operateTime&#125;,#&#123;e.info&#125;)<br>                                                  <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>动态sql用foreach标签遍历</li></ul></blockquote><h4 id="3-新增员工"><a href="#3-新增员工" class="headerlink" title="3.新增员工"></a>3.新增员工</h4><p><img src="/.com//image-20250302160741892.png" alt="image-20250302160741892"></p><p><img src="/.com//image-20250302161441952.png" alt="image-20250302161441952"></p><p><img src="/.com//image-20250302163740548.png" alt="image-20250302163740548"></p><blockquote><p>基于动态sql批量插入数据</p><p><img src="/.com//image-20250302164710502.png" alt="image-20250302164710502"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!--对应mapper的全定向路径--&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.example.tliaswebmanagement.mapper.EmpExprMapper&quot;</span>&gt;</span><br>&gt;<span class="hljs-comment">&lt;!--  批量保存员工工作经历--&gt;</span><br>&gt;<span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">&gt;foreach标签:</span><br><span class="hljs-comment">&gt;collection:指定一个集合或者数组，表示要遍历的集合或者数组</span><br><span class="hljs-comment">&gt;item:指定一个集合或者数组中的每一个元素，表示遍历的元素</span><br><span class="hljs-comment">&gt;separator:指定一个分隔符，表示集合或者数组中的元素之间要添加的分隔符</span><br><span class="hljs-comment">&gt;--&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertEmpExpr&quot;</span>&gt;</span><br>  insert into emp_expr(emp_id, begin, end, company, job)<br>  values<br>      <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;exprList&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;expr&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>          (#&#123;expr.empId&#125;,#&#123;expr.begin&#125;,#&#123;expr.end&#125;,#&#123;expr.company&#125;,#&#123;expr.job&#125;)<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>EmpController</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新增员工</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Emp emp)</span>&#123;<br><br>        log.info(<span class="hljs-string">&quot;新增员工:&#123;&#125;&quot;</span>,emp);<br>        empService.save(emp);<br>        <span class="hljs-keyword">return</span> Result.success();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>EmpServiceImpl</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(Emp emp)</span>&#123;<br>       <span class="hljs-comment">//1.保存员工基本信息</span><br>       emp.setCreateTime(LocalDateTime.now());<br>       emp.setUpdateTime(LocalDateTime.now());<br>       empMapper.insert(emp);<br>       <span class="hljs-comment">//2.批量保存员工工作经历信息</span><br>       List&lt;EmpExpr&gt; exprList = emp.getExprList();<br>       <span class="hljs-keyword">if</span>(!CollectionUtils.isEmpty(exprList))&#123;<br>           <span class="hljs-comment">//集合非空则批量保存</span><br>           <span class="hljs-comment">//遍历集合为empId赋值</span><br>           exprList.forEach(empExpr -&gt;&#123;<br>               empExpr.setEmpId(emp.getId());<br>           &#125;);<br>           empExprMapper.insertEmpExpr(exprList);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li>Mapper层</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//-EmpExprMapper</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">insertEmpExpr</span><span class="hljs-params">(List&lt;EmpExpr&gt; exprList)</span>;<br><br><span class="hljs-comment">//- EmpMapper</span><br><span class="hljs-meta">@Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)</span> <span class="hljs-comment">// useGeneratedKeys：开启自动回填 keyProperty：指定回填的属性名</span><br>    <span class="hljs-meta">@Insert(&quot;insert into emp (username, name, phone, job, salary, entry_date, image, create_time, update_time, dept_id) &quot; +</span><br><span class="hljs-meta">        &quot;values (#&#123;username&#125;,#&#123;name&#125;,#&#123;phone&#125;,#&#123;job&#125;,#&#123;salary&#125;,#&#123;entryDate&#125;,#&#123;image&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;,#&#123;deptId&#125;)&quot;)</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Emp emp)</span>;<br></code></pre></td></tr></table></figure></blockquote><ul><li><p>为新增员工这一操作添加日志</p><ul><li>插入日志表emp_log,实体类EmpLog,Mapper接口EmpLogMapper</li><li>在新增员工时记录日志</li><li><img src="/.com//image-20250302201818452.png" alt="image-20250302201818452"></li></ul></li><li><p>完成图片文件上传功能- 上传至阿里云OSS</p></li></ul><p><img src="/.com//image-20250302201818452.png" alt="image-20250302201818452"></p><p><img src="/.com//image-20250303140436161.png" alt="image-20250303140436161"></p><blockquote><p>前端提交图片至后端，后端将图片上传至阿里云OSS，并且返回图片的URL地址给前端，前端根据URL地址渲染显示图片。</p><ul><li>引入阿里云OSS文件上传的工具类（由官方的示例代码改造而来）</li><li>上传文件接口开发</li></ul></blockquote><p><strong>文件上传工具类AliyunOSSOperator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 阿里云OSS上传操作工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliyunOSSOperator</span> &#123;<br>    <span class="hljs-comment">// Endpoint以华东1（杭州）为例，其它Region请按实际情况填写。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">endpoint</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://oss-cn-beijing.aliyuncs.com&quot;</span>;<br>    <span class="hljs-comment">// 填写Bucket名称，例如examplebucket。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">bucketName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;first-javaoss&quot;</span>;<br>    <span class="hljs-comment">// 填写Bucket所在地域。以华东1（杭州）为例，Region填写为cn-hangzhou。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">region</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cn-beijing&quot;</span>;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] content, String originalFileName)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 从环境变量中获取访问凭证。运行本代码示例之前，请确保已设置环境变量OSS_ACCESS_KEY_ID和OSS_ACCESS_KEY_SECRET。</span><br>        <span class="hljs-type">EnvironmentVariableCredentialsProvider</span> <span class="hljs-variable">credentialsProvider</span> <span class="hljs-operator">=</span> CredentialsProviderFactory.newEnvironmentVariableCredentialsProvider();<br>        String dir= LocalDate.now().format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy/MM&quot;</span>));<br>        String newFileName=UUID.randomUUID()+originalFileName.substring(originalFileName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">objectName</span> <span class="hljs-operator">=</span> dir+<span class="hljs-string">&quot;/&quot;</span>+newFileName;<br><br>        <span class="hljs-comment">// 创建OSSClient实例。</span><br>        <span class="hljs-type">ClientBuilderConfiguration</span> <span class="hljs-variable">clientBuilderConfiguration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientBuilderConfiguration</span>();<br>        clientBuilderConfiguration.setSignatureVersion(SignVersion.V4);<br>        <span class="hljs-type">OSS</span> <span class="hljs-variable">ossClient</span> <span class="hljs-operator">=</span> OSSClientBuilder.create()<br>                .endpoint(endpoint)<br>                .credentialsProvider(credentialsProvider)<br>                .clientConfiguration(clientBuilderConfiguration)<br>                .region(region)<br>                .build();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 上传字节文件。</span><br>          ossClient.putObject(bucketName, objectName, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(content));<br>        &#125;  <span class="hljs-keyword">finally</span> &#123;<br>                ossClient.shutdown();<br>        &#125;<br>        String[] eStr=endpoint.split(<span class="hljs-string">&quot;//&quot;</span>);<br>        <span class="hljs-keyword">return</span> eStr[<span class="hljs-number">0</span>] + bucketName + <span class="hljs-string">&quot;.&quot;</span> + eStr[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;/&quot;</span> + objectName;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>UploadController控制层</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 文件上传到阿里云OSS</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> AliyunOSSOperator aliyunOSSOperator;<br><br><span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile file)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">byte</span>[] content = file.getBytes();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">originalFileName</span> <span class="hljs-operator">=</span> file.getOriginalFilename();<br>    log.info(<span class="hljs-string">&quot;文件上传：&#123;&#125;&quot;</span>, originalFileName);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">InfoMsg</span> <span class="hljs-operator">=</span> aliyunOSSOperator.upload(content, originalFileName);<br>    log.info(<span class="hljs-string">&quot;文件上传到阿里云OSS地址为:&#123;&#125;&quot;</span>, InfoMsg);<br>    <span class="hljs-keyword">return</span> Result.success(InfoMsg);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>优化</p><ul><li>将阿里云OSS的配置信息放到yml文件中</li></ul><p><img src="/.com//image-20250303151208888.png" alt="image-20250303151208888"></p><ul><li>进一步优化（参数多的情况）：将参数封装到实体类中，通过注解获取配置文件中参数的值，最后通过容器注入获取实体类。</li><li><img src="/.com//image-20250303155340027.png" alt="image-20250303155340027"></li></ul></li></ul><h4 id="4-修改员工"><a href="#4-修改员工" class="headerlink" title="4.修改员工"></a>4.修改员工</h4><p><img src="/.com//image-20250303174841960.png" alt="image-20250303174841960"></p><ul><li>查询回显- 根据id回传信息员工信息，员工经历信息</li></ul><p><img src="/.com//image-20250303193621213.png" alt="image-20250303193621213"></p><ul><li><p>修改数据</p><p>修改时需要设置修改时间字段</p></li></ul><p><img src="/.com//image-20250303202900997.png" alt="image-20250303202900997"></p><h3 id="4-报表统计"><a href="#4-报表统计" class="headerlink" title="4.报表统计"></a>4.报表统计</h3><h4 id="1-员工职位统计"><a href="#1-员工职位统计" class="headerlink" title="1.员工职位统计"></a>1.员工职位统计</h4><ul><li>柱状图</li></ul><p><img src="/.com//image-20250303230247302.png" alt="image-20250303230247302"></p><blockquote><p>生成图形报表</p><p>前端基于ECharts-图形报表组件库</p></blockquote><p><img src="/.com//image-20250303230710654.png" alt="image-20250303230710654"></p><p><img src="/.com//image-20250303232856934.png" alt="image-20250303232856934"></p><h4 id="2-员工性别统计"><a href="#2-员工性别统计" class="headerlink" title="2.员工性别统计"></a>2.员工性别统计</h4><ul><li>饼状图</li></ul><p><img src="/.com//image-20250304124227959.png" alt="image-20250304124227959"></p><h4 id="3-学院信息统计"><a href="#3-学院信息统计" class="headerlink" title="3.学院信息统计"></a>3.学院信息统计</h4><p><img src="/.com//image-20250304124610441.png" alt="image-20250304124610441"></p><ul><li>班级人数统计</li></ul><blockquote><p>返会班级名称以及班级对应的人数</p><p>name、num</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;msg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sucess&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;Java基础班&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;前端开发班&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;大数据分析班&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;Python开发班&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;Go语言班&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;嵌入式开发班&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;Java进阶班&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;前端进阶班&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;大数据高级班&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;Python高级班&quot;</span><br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;num&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-number">2</span><br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>学院学历统计</li></ul><blockquote><p>返回学历及其对应人数</p><p>degree、num</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;msg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sucess&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;num&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">19</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;degree&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;本科&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;num&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;degree&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;大专&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;num&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;degree&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;初中&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="5-登录认证"><a href="#5-登录认证" class="headerlink" title="5.登录认证"></a>5.登录认证</h3><h4 id="1-登录功能实现"><a href="#1-登录功能实现" class="headerlink" title="1.登录功能实现"></a>1.登录功能实现</h4><ul><li>本质：根据用户名和密码查询用户信息，判定，组装数据返回</li></ul><blockquote><ul><li>请求：</li></ul><p>请求方式- POST</p><p>请求体传递json格式的参数：用户名、密码</p><p>用员工类接收</p></blockquote><blockquote><ul><li>响应：</li></ul><p>员工的基本信息</p><p><img src="/.com//image-20250305113052606.png" alt="image-20250305113052606"></p><p>定义一个实体类来封装登录的结果</p></blockquote><ul><li>联调测试</li></ul><blockquote><p>在未登录的情况下，改变访问Url也可以进入页面访问后台资源</p></blockquote><p><img src="/.com//image-20250305120527143.png" alt="image-20250305120527143"></p><h4 id="2-登录校验"><a href="#2-登录校验" class="headerlink" title="2.登录校验"></a>2.登录校验</h4><ul><li><p>需求：用户登录成功后1，系统会自动下发JWT令牌，然后在后续的每次请求中，都需要在请求头携带令牌到服务端，请求头的名称为token，值为登录时下发的令牌，如果检测到用户未登录，则直接响应401状态码。</p></li><li><p>http协议是无状态的协议，后一次请求不携带前一次的信息</p></li></ul><p><img src="/.com//image-20250305121211497.png" alt="image-20250305121211497"></p><h5 id="1-会话技术"><a href="#1-会话技术" class="headerlink" title="1.会话技术"></a>1.会话技术</h5><ul><li>会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。</li><li>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。</li><li>会话跟踪方案：<ul><li>客户端会话跟踪技术：Cookie</li><li>服务端会话跟踪技术：Seesion</li><li>令牌技术</li></ul></li></ul><blockquote><ul><li>Cookie</li></ul><ol><li>创建与发送</li></ol><ul><li>当用户使用浏览器访问一个网站时，服务器可以通过 HTTP 响应头中的<code>Set-Cookie</code>字段来创建并发送 Cookie 给客户端浏览器。例如，服务器可能会发送这样的响应头：<code>Set-Cookie: username=JohnDoe; expires=Thu, 31 Dec 2025 23:59:59 GMT; path=/; domain=.example.com</code>，这就创建了一个名为<code>username</code>，值为<code>JohnDoe</code>的 Cookie，并指定了过期时间、路径和域名等属性。</li></ul><ol start="2"><li>存储</li></ol><ul><li>浏览器收到服务器发送的 Cookie 后，会根据 Cookie 的属性将其存储在本地。如果是会话 Cookie（没有设置<code>Expires</code>或<code>Max-Age</code>属性），则会存储在浏览器的内存中，当浏览器关闭时，这些 Cookie 会被删除。如果是持久化 Cookie（设置了<code>Expires</code>或<code>Max-Age</code>属性），则会被存储在用户的硬盘上，直到达到过期时间或被用户手动删除。</li></ul><ol start="3"><li>发送请求携带</li></ol><ul><li>当用户继续访问该网站的其他页面或再次发起对该网站的请求时，浏览器会自动在 HTTP 请求头中添加相应的 Cookie 信息。例如，请求头中可能会包含：<code>Cookie: username=JohnDoe</code>，将存储在本地的 Cookie 发送给服务器。</li></ul><ol start="4"><li>服务器读取与处理</li></ol><ul><li>服务器接收到客户端发送的请求后，会从请求头中读取 Cookie 信息，并根据 Cookie 中的数据来识别用户、记录用户的状态或提供个性化的服务等。比如，服务器可以根据<code>username</code>这个 Cookie 的值来判断用户的身份，为用户提供个性化的页面内容，或者根据用户之前的操作记录来继续处理相关业务逻辑。</li></ul><ol start="5"><li>更新与删除</li></ol><ul><li>服务器可以根据用户的操作或业务需求，通过再次发送<code>Set-Cookie</code>响应头来更新或删除 Cookie。如果要更新 Cookie 的值，只需发送一个同名的 Cookie，新的值会覆盖旧的值。如果要删除 Cookie，可以设置<code>Expires</code>属性为一个过去的时间，或者使用<code>Max-Age=0</code>，浏览器收到这样的 Cookie 后会将其删除。</li></ul><p><img src="/.com//image-20250305124301039.png" alt="image-20250305124301039"></p></blockquote><blockquote><ul><li>Session</li></ul><ol><li>会话创建</li></ol><ul><li>当用户首次访问 Web 应用时，服务器会为该用户创建一个唯一的 Session 对象，并为其分配一个唯一的 Session ID。这个 Session ID 通常是一个随机生成的字符串，用于标识该用户的会话。</li><li>服务器会在内存或其他存储介质（如数据库）中开辟一定的空间来存储与该 Session 相关的数据，例如用户的登录状态、购物车信息、浏览历史等。</li></ul><ol start="2"><li>Session ID 传递</li></ol><ul><li>服务器通过响应头中的<code>Set-Cookie</code>字段将 Session ID 发送给客户端浏览器，以 Cookie 的形式存储在客户端。例如，响应头中可能会包含<code>Set-Cookie: JSESSIONID=abcdefghijklmnopqrstuvwxyz; Path=/; HttpOnly</code>，这里的<code>JSESSIONID</code>就是 Session ID。</li><li>除了通过 Cookie 传递 Session ID，还可以通过 URL 重写的方式将 Session ID 附加在 URL 后面，例如<code>http://example.com/page.jsp;jsessionid=abcdefghijklmnopqrstuvwxyz</code>，但这种方式相对不安全，且可能会导致一些问题，如搜索引擎收录重复内容等。</li></ul><ol start="3"><li>客户端请求携带</li></ol><ul><li>当用户在同一浏览器中继续访问该 Web 应用的其他页面时，浏览器会自动在后续的 HTTP 请求头中携带包含 Session ID 的 Cookie。服务器接收到请求后，就可以从请求头的 Cookie 中获取 Session ID。</li><li>如果是通过 URL 重写传递 Session ID，客户端在发送请求时，URL 中会包含 Session ID，服务器从 URL 中解析出 Session ID。</li></ul><ol start="4"><li>服务器识别与处理</li></ol><ul><li>服务器根据接收到的 Session ID，在内存或存储介质中查找对应的 Session 对象。如果找到匹配的 Session 对象，服务器就可以获取该 Session 中存储的用户数据，根据这些数据来处理用户的请求，提供个性化的服务或进行业务逻辑处理。</li><li>例如，如果用户已经登录，服务器可以根据 Session 中存储的用户登录信息来显示用户的个人资料、授权用户访问特定的页面等；如果是购物车应用，服务器可以根据 Session 中存储的购物车商品信息来更新购物车、计算总价等。</li></ul><ol start="5"><li>会话管理与过期</li></ol><ul><li>服务器会对 Session 进行管理，包括设置 Session 的过期时间。如果用户在一定时间内没有进行任何操作，服务器会认为该 Session 已经过期，自动销毁该 Session 对象及其存储的数据。</li><li>用户也可以主动结束会话，例如点击 “退出登录” 按钮，服务器会收到相应的请求，然后销毁该用户的 Session，清除相关的用户数据。</li><li>服务器还可以根据业务需求对 Session 进行更新操作，例如更新用户的购物车内容、修改用户的登录状态等，将更新后的数据存储在 Session 中，以便后续请求使用。</li></ul><p><img src="/.com//image-20250305131206814.png" alt="image-20250305131206814"></p></blockquote><h5 id="2-JWT令牌"><a href="#2-JWT令牌" class="headerlink" title="2.JWT令牌"></a>2.JWT令牌</h5><ul><li>令牌技术<ul><li>生成令牌</li><li>传输令牌</li><li>验证令牌</li></ul></li></ul><p><img src="/.com//image-20250305131643188.png" alt="image-20250305131643188"></p><p><img src="/.com//image-20250305132359900.png" alt="image-20250305132359900"></p><p><img src="/.com//image-20250305132531924.png" alt="image-20250305132531924"></p><p><img src="/.com//image-20250305132554594.png" alt="image-20250305132554594"></p><ul><li><p>错输异常情况</p><p><img src="/.com//image-20250305143407019.png" alt="image-20250305143407019"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误写法：parseClaimsJwt</span><br>Jwts.parser().setSigningKey(SECRET).parseClaimsJwt(token.replace(TOKEN_PREFIX, <span class="hljs-string">&quot;&quot;</span>)).getBody();<br><br><span class="hljs-comment">// 正确写法：parseClaimsJws</span><br>Jwts.parser().setSigningKey(SECRET).parseClaimsJws(token.replace(TOKEN_PREFIX, <span class="hljs-string">&quot;&quot;</span>)).getBody();<br></code></pre></td></tr></table></figure></li></ul><p><img src="/.com//image-20250305143322536.png" alt="image-20250305143322536"></p><p><img src="/.com//image-20250305143336807.png" alt="image-20250305143336807"></p><p><img src="/.com//image-20250305143742385.png" alt="image-20250305143742385"></p><ul><li><p>创建令牌工具类，包含两个方法：生成令牌，解析令牌。</p></li><li><p>生成令牌传递给前端后，前端会以键值对的方式将令牌存储-Cookie,后续每次发送请求时会携带令牌。</p></li><li><p>后端令牌校验后后才允许访问资源</p></li></ul><blockquote><ul><li><strong>过滤器Filter</strong></li></ul><p><img src="/.com//image-20250305150447077.png" alt="image-20250305150447077"></p><p><img src="/.com//image-20250305150654940.png" alt="image-20250305150654940"></p><p><img src="/.com//image-20250305151912359.png" alt="image-20250305151912359"></p><p>登录和注册不需要校验令牌</p><p><img src="/.com//image-20250305152725057.png" alt="image-20250305152725057"></p><ul><li>过滤器执行流程</li></ul><p><img src="/.com//image-20250305155843359.png" alt="image-20250305155843359"></p><blockquote><p>执行放行之后会回到过滤器继续执行放行后的逻辑</p></blockquote><ul><li>过滤器链</li></ul><p><img src="/.com//image-20250305160726365.png" alt="image-20250305160726365"></p><blockquote><p>注解配置的Filter,优先级按照过滤器类名（字符串）的自然排序</p></blockquote></blockquote><blockquote><ul><li><strong>拦截器Interceptor</strong></li></ul><p><img src="/.com//image-20250305161239759.png" alt="image-20250305161239759"></p><p><img src="/.com//image-20250305161422280.png" alt="image-20250305161422280"></p><p>定义配置类-注册拦截器</p><p><img src="/.com//image-20250305161505705.png" alt="image-20250305161505705"></p><blockquote><p>创建配置类实现<strong>WebMvcConfigurer接口</strong>，注入拦截器Bean对象，重写<strong>addIntegerceptor</strong>方法，链式编程设置拦截路径和放行路径。</p></blockquote><p><img src="/.com//image-20250305163451303.png" alt="image-20250305163451303"></p><p><img src="/.com//image-20250305152725057.png" alt="image-20250305152725057"></p><ul><li>使用细节</li></ul><p><img src="/.com//image-20250305165104555.png" alt="image-20250305165104555"></p><blockquote><p>过滤器和拦截器同时存在- 过滤器先执行</p></blockquote><p><img src="/.com//image-20250305165436487.png" alt="image-20250305165436487"></p><p><img src="/.com//image-20250305165724655.png" alt="image-20250305165724655"></p></blockquote><h3 id="6-日志管理"><a href="#6-日志管理" class="headerlink" title="6.日志管理"></a>6.日志管理</h3><ul><li>基于切面类完成统一的增删改记录</li></ul><h3 id="7-班级、学员管理"><a href="#7-班级、学员管理" class="headerlink" title="7.班级、学员管理"></a>7.班级、学员管理</h3><ul><li>准备clazz、student表，并且插入数据</li><li><img src="/.com//image-20250304125030916.png" alt="image-20250304125030916"></li><li><img src="/.com//image-20250304125113830.png" alt="image-20250304125113830"></li><li>封装实体类</li></ul><h4 id="1-班级管理"><a href="#1-班级管理" class="headerlink" title="1.班级管理"></a>1.班级管理</h4><p><img src="/.com//image-20250304124455463.png" alt="image-20250304124455463"></p><ul><li>班级列表查询（分页）、删除班级、添加班级、修改班级</li></ul><h5 id="1-分页查询班级"><a href="#1-分页查询班级" class="headerlink" title="1.分页查询班级"></a>1.分页查询班级</h5><blockquote><ul><li>基本逻辑</li></ul><p>前端传递页码page、页展示数pageSize给后端 </p><p>后端返回总记录数total、以及该页的班级信息</p><ul><li>使用插件pageHelper</li></ul></blockquote><blockquote><ul><li>条件分页查询</li></ul><p>使用实体类封装请求参数</p><p>基于动态sql实现条件分页查询</p></blockquote><ul><li>前端参数</li></ul><p><img src="/.com//image-20250304143750501.png" alt="image-20250304143750501"></p><ul><li>后端返回的参数</li></ul><p><img src="/.com//image-20250304161548313.png" alt="image-20250304161548313"></p><p>状态由前端生成，后端需要返回开课和结课时间。</p><p>封装参数到实体类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 封装查询条件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClazzQueryParam</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//班级名称</span><br>    <span class="hljs-keyword">private</span> Integer page=<span class="hljs-number">1</span>;<span class="hljs-comment">//当前页码,默认为1</span><br>    <span class="hljs-keyword">private</span> Integer pageSize=<span class="hljs-number">10</span>;<span class="hljs-comment">//每页显示条数，默认为10</span><br>    <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span><br>    <span class="hljs-keyword">private</span> LocalDate begin;<span class="hljs-comment">//开始时间</span><br>    <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span><br>    <span class="hljs-keyword">private</span> LocalDate end;<span class="hljs-comment">//结束时间</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-删除班级"><a href="#2-删除班级" class="headerlink" title="2.删除班级"></a>2.删除班级</h5><blockquote><ul><li>基本逻辑</li></ul><p>根据前端传递的id,来删除对应的班级信息</p><ul><li>批量删除</li></ul><p>用数组或者集合接收前端的参数，Mapper层通过foreach动态删除班级信息</p></blockquote><h5 id="3-添加班级"><a href="#3-添加班级" class="headerlink" title="3.添加班级"></a>3.添加班级</h5><blockquote><ul><li>基本逻辑</li></ul><p>前端输入新建班级信息，后端接收并且加入数据库</p><p>用对象接收，服务层设置创建时间和更新时间属性</p></blockquote><h5 id="4-修改班级"><a href="#4-修改班级" class="headerlink" title="4.修改班级"></a>4.修改班级</h5><blockquote><ul><li>基本逻辑</li></ul><p>查询回显，前端点击编辑，根据id返回班级的基本信息</p><p>后端Service层重置更新时间，并且调用mapper层更新数据</p><p>之后前端再次分页查询展示修改后的数据</p></blockquote><h4 id="2-学员管理"><a href="#2-学员管理" class="headerlink" title="2.学员管理"></a>2.学员管理</h4><p><img src="/.com//image-20250304124535853.png" alt="image-20250304124535853"></p><ul><li>学员列表查询（分页）、删除学院、添加学员、修改学员、违纪处理</li></ul><h5 id="1-分页查询学员"><a href="#1-分页查询学员" class="headerlink" title="1.分页查询学员"></a>1.分页查询学员</h5><blockquote><ul><li>基本逻辑</li></ul><p>前端传递页码page、页展示数pageSize给后端 </p><p>后端返回总记录数total、以及该页的班级信息</p><ul><li>使用插件pageHelper</li></ul></blockquote><blockquote><ul><li>条件分页查询</li></ul><p>使用实体类封装请求参数</p><p>基于动态sql实现条件分页查询</p></blockquote><ul><li>前端参数</li></ul><p><img src="/.com//image-20250304160843861.png" alt="image-20250304160843861"></p><ul><li>后端返回的参数</li></ul><p><img src="/.com//image-20250304161517261.png" alt="image-20250304161517261"></p><h5 id="2-删除学员"><a href="#2-删除学员" class="headerlink" title="2.删除学员"></a>2.删除学员</h5><blockquote><ul><li>基本逻辑</li></ul><p>根据前端传递的id,来删除对应的班级信息</p><ul><li>批量删除</li></ul><p>用数组或者集合接收前端的参数，Mapper层通过foreach动态删除班级信息</p></blockquote><h5 id="3-添加学员"><a href="#3-添加学员" class="headerlink" title="3.添加学员"></a>3.添加学员</h5><blockquote><ul><li>基本逻辑</li></ul><p>前端输入新建学员信息，后端接收并且加入数据库</p><p>用对象接收，服务层设置创建时间和更新时间属性</p></blockquote><h5 id="4-修改学员"><a href="#4-修改学员" class="headerlink" title="4.修改学员"></a>4.修改学员</h5><blockquote><ul><li>基本逻辑</li></ul><p>查询回显，前端点击编辑，根据id返回班级的基本信息</p><p>后端Service层重置更新时间，并且调用mapper层更新数据</p><p>之后前端再次分页查询展示修改后的数据</p></blockquote><h5 id="5-学员违纪处理"><a href="#5-学员违纪处理" class="headerlink" title="5.学员违纪处理"></a>5.学员违纪处理</h5><blockquote><ul><li>基本逻辑</li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/Spring%20Task%E5%92%8CWebSocket/"/>
    <url>/2025/07/02/Spring%20Task%E5%92%8CWebSocket/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Task"><a href="#Spring-Task" class="headerlink" title="Spring Task"></a>Spring Task</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>![image-20250419164622847](Spring Task和WebSocket.assets&#x2F;image-20250419164622847.png)</p><p>![image-20250419164803474](Spring Task和WebSocket.assets&#x2F;image-20250419164803474.png)</p><h2 id="2-cron表达式"><a href="#2-cron表达式" class="headerlink" title="2.cron表达式"></a>2.cron表达式</h2><p>![image-20250419165147116](Spring Task和WebSocket.assets&#x2F;image-20250419165147116.png)</p><ul><li><p>可以使用在线生成器生成对应的cron表达式</p></li><li><p>*（星号）表示该字段的所有可能值。</p></li><li><p>&#x2F;（斜杠）表示间隔频率。如：0&#x2F;5表示从0开始每隔5个单位执行一次。</p></li><li><p>？（问号）表示不指定值，仅仅用于日和周，日为*周必须为？，反之依然</p></li></ul><h2 id="3-快速入门"><a href="#3-快速入门" class="headerlink" title="3.快速入门"></a>3.快速入门</h2><p>![image-20250419165621003](Spring Task和WebSocket.assets&#x2F;image-20250419165621003.png)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义的定时任务类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定时任务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Scheduled(cron = &quot;0/5 * * * * ?&quot;)</span><span class="hljs-comment">//秒 分 时 日 月 周 年(可选) 每隔5秒执行一次</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeTask</span><span class="hljs-params">()</span>&#123;<br>        log.info(<span class="hljs-string">&quot;定时任务开始执行：&#123;&#125;&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>订单超时的问题解决方案：<ul><li>方案一（定时任务框架-简单场景低要求）：使用定时任务轮询数据库，对状态进行更改  -延迟大</li><li>方案二（延迟队列-高并发、分布式）：消息队列的延迟队列，订单创建生产者发生消息，生产者延迟消费   -大量无效消息</li><li>方案三：使用第三方消息队列组件</li></ul></li></ul><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><h2 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1.介绍"></a>1.介绍</h2><ul><li>双向通信，全双工，长连接</li><li>与HTTP的关系：<ul><li>基于HTTP基础之上的，都是TCP</li><li>WebSOcket的连接需要通过一个握手（HTTP Upgrade请求），表明切换协议，服务器如果支持WebSocket，会返回一个HTTP 101 状态码，表示协议切换成功</li><li>握手完成后，HTTP协议的作用结束，通信会切换为WebSocket协议，双方可以开始全双工通信</li></ul></li><li>数据帧小，传输高效，无需像HTTP每次都携带完整的请求头</li></ul><p>![image-20250419173835335](Spring Task和WebSocket.assets&#x2F;image-20250419173835335.png)</p><p>![image-20250419174205653](Spring Task和WebSocket.assets&#x2F;image-20250419174205653.png)</p><ul><li><p>用于实时场景</p></li><li><p>和HTTP请求一样，前端和WebSocket服务器之间传输消息时，也可以通过JSON格式对数据进行序列化传输</p></li></ul><p>![image-20250630110121729](Spring Task和WebSocket.assets&#x2F;image-20250630110121729.png)</p><h2 id="2-入门案例"><a href="#2-入门案例" class="headerlink" title="2.入门案例"></a>2.入门案例</h2><p>![image-20250419174440454](Spring Task和WebSocket.assets&#x2F;image-20250419174440454.png)</p><blockquote><ul><li>maven坐标</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><ul><li>浏览器端html</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs html">&gt;<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>WebSocket Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;send()&quot;</span>&gt;</span>发送消息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;closeWebSocket()&quot;</span>&gt;</span>关闭连接<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-keyword">var</span> websocket = <span class="hljs-literal">null</span>;</span><br><span class="language-javascript">   <span class="hljs-keyword">var</span> clientId = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>().<span class="hljs-title function_">toString</span>(<span class="hljs-number">36</span>).<span class="hljs-title function_">substr</span>(<span class="hljs-number">2</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//判断当前浏览器是否支持WebSocket</span></span><br><span class="language-javascript">   <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;WebSocket&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-comment">//连接WebSocket节点</span></span><br><span class="language-javascript">       websocket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;ws://localhost:8080/ws/&quot;</span>+clientId);</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">   <span class="hljs-keyword">else</span>&#123;</span><br><span class="language-javascript">       <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Not support websocket&#x27;</span>)</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//连接发生错误的回调方法</span></span><br><span class="language-javascript">   websocket.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-title function_">setMessageInnerHTML</span>(<span class="hljs-string">&quot;error&quot;</span>);</span><br><span class="language-javascript">   &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//连接成功建立的回调方法</span></span><br><span class="language-javascript">   websocket.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-title function_">setMessageInnerHTML</span>(<span class="hljs-string">&quot;连接成功&quot;</span>);</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//接收到消息的回调方法</span></span><br><span class="language-javascript">   websocket.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-title function_">setMessageInnerHTML</span>(event.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//连接关闭的回调方法</span></span><br><span class="language-javascript">   websocket.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-title function_">setMessageInnerHTML</span>(<span class="hljs-string">&quot;close&quot;</span>);</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。</span></span><br><span class="language-javascript">   <span class="hljs-variable language_">window</span>.<span class="hljs-property">onbeforeunload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">       websocket.<span class="hljs-title function_">close</span>();</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//将消息显示在网页上</span></span><br><span class="language-javascript">   <span class="hljs-keyword">function</span> <span class="hljs-title function_">setMessageInnerHTML</span>(<span class="hljs-params">innerHTML</span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;message&#x27;</span>).<span class="hljs-property">innerHTML</span> += innerHTML + <span class="hljs-string">&#x27;&lt;br/&gt;&#x27;</span>;</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//发送消息</span></span><br><span class="language-javascript">   <span class="hljs-keyword">function</span> <span class="hljs-title function_">send</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-keyword">var</span> message = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;text&#x27;</span>).<span class="hljs-property">value</span>;</span><br><span class="language-javascript">       websocket.<span class="hljs-title function_">send</span>(message);</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//关闭连接</span></span><br><span class="language-javascript">   <span class="hljs-keyword">function</span> <span class="hljs-title function_">closeWebSocket</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">       websocket.<span class="hljs-title function_">close</span>();</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ul><li>ws协议</li></ul></blockquote><blockquote><ul><li>服务器端</li></ul><p>配置类注册WebSocket的Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">/**</span><br><span class="hljs-comment">* WebSocket配置类，用于注册WebSocket的Bean</span><br><span class="hljs-comment">*/</span><br>&gt;<span class="hljs-meta">@Configuration</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketConfiguration</span> &#123;<br><br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-keyword">public</span> ServerEndpointExporter <span class="hljs-title function_">serverEndpointExporter</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerEndpointExporter</span>();<br>   &#125;<br><br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>WebSocket服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">/**</span><br><span class="hljs-comment">* WebSocket服务</span><br><span class="hljs-comment">*/</span><br>&gt;<span class="hljs-meta">@Component</span><br>&gt;<span class="hljs-meta">@ServerEndpoint(&quot;/ws/&#123;sid&#125;&quot;)</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketServer</span> &#123;<br><br>   <span class="hljs-comment">//存放会话对象</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Session&gt; sessionMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 连接建立成功调用的方法</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@OnOpen</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onOpen</span><span class="hljs-params">(Session session, <span class="hljs-meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;客户端：&quot;</span> + sid + <span class="hljs-string">&quot;建立连接&quot;</span>);<br>       sessionMap.put(sid, session);<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 收到客户端消息后调用的方法</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> message 客户端发送过来的消息</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@OnMessage</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String message, <span class="hljs-meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;收到来自客户端：&quot;</span> + sid + <span class="hljs-string">&quot;的信息:&quot;</span> + message);<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 连接关闭调用的方法</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> sid</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@OnClose</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClose</span><span class="hljs-params">(<span class="hljs-meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;连接断开:&quot;</span> + sid);<br>       sessionMap.remove(sid);<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 群发</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> message</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendToAllClient</span><span class="hljs-params">(String message)</span> &#123;<br>       Collection&lt;Session&gt; sessions = sessionMap.values();<br>       <span class="hljs-keyword">for</span> (Session session : sessions) &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-comment">//服务器向客户端发送消息</span><br>               session.getBasicRemote().sendText(message);<br>           &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>               e.printStackTrace();<br>           &#125;<br>       &#125;<br>   &#125;<br><br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/Redis/"/>
    <url>/2025/07/02/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis非关系型数据库"><a href="#Redis非关系型数据库" class="headerlink" title="Redis非关系型数据库"></a>Redis非关系型数据库</h1><h1 id="1-Redis入门"><a href="#1-Redis入门" class="headerlink" title="1.Redis入门"></a>1.Redis入门</h1><ul><li><p><strong>Redis</strong>是一个基于内存的key-value结构数据库</p></li><li><p>基于内存存储，读写性能高</p></li><li><p>适合存储热点数据（热点商品、资讯、新闻）</p></li></ul><blockquote><ul><li><strong>redis启动</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;redis-server.exe redis.windows.conf <span class="hljs-comment">#启动redis(启动文件+配置文件)</span><br></code></pre></td></tr></table></figure><p>默认端口号6379</p></blockquote><blockquote><ul><li><strong>客户端连接redis服务</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;redis-cli.exe<br></code></pre></td></tr></table></figure><p>exit退出客户端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;redis-cli.exe -h localhost -p 6379<br>&gt;<span class="hljs-comment">#-h 指定连接的地址</span><br>&gt;<span class="hljs-comment">#-p 指定连接的端口</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><ul><li>设置密码</li></ul><p>配置文件redis.windows.conf 中 Ctrl+f搜索requirepass </p><p>（去除多余空格）把后面的内容替换为密码</p></blockquote><blockquote><ul><li>Redis的数据库</li></ul><p>Redis服务启动会自动创建16个数据库DB0-DB15</p><p>Redis启动默认使用DB0</p></blockquote><h1 id="2-Redis基础数据类型"><a href="#2-Redis基础数据类型" class="headerlink" title="2.Redis基础数据类型"></a>2.Redis基础数据类型</h1><p><img src="/.com//image-20250401231308537.png" alt="image-20250401231308537"></p><p><img src="/.com//image-20250401231616435.png" alt="image-20250401231616435"></p><h1 id="3-Redis常用命令"><a href="#3-Redis常用命令" class="headerlink" title="3.Redis常用命令"></a>3.Redis常用命令</h1><p><img src="/.com//image-20250401231907288.png" alt="image-20250401231907288"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">setnx key value  <span class="hljs-comment">#当key不存在时设置key的值成功返回1，失败返回0</span><br>setex key seconds(秒) value <span class="hljs-comment">#设置有存活时间的key</span><br>del key   <span class="hljs-comment">#删除 key 成功返回1，失败返回0</span><br>get key <span class="hljs-comment">#获取指定key的值</span><br></code></pre></td></tr></table></figure><p><img src="/.com//image-20250401232519315.png" alt="image-20250401232519315"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">hset key field value  <span class="hljs-comment">#key维护一个哈希表</span><br>hget key field      <span class="hljs-comment">#获取哈希表的对应键下的值</span><br>hdel key field    <span class="hljs-comment">#删除对应键值对</span><br>hkeys key    <span class="hljs-comment">#查看key维护的哈希表中所有的键</span><br>hvals key   <span class="hljs-comment">#查看key维护的哈希表中所有的值</span><br></code></pre></td></tr></table></figure><p><img src="/.com//image-20250402104503187.png" alt="image-20250402104503187"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 类似双端队列</span><br>lpush key value1 value2 .. <span class="hljs-comment">#从左侧插入value 返回队列长度</span><br>rpush key value1 value3 .. <span class="hljs-comment">#从右侧插入value 返回队列长度</span><br>lpop key <span class="hljs-comment">#移出最左侧的值同时返回这个value</span><br>rpop key <span class="hljs-comment">#移出最右侧的值同时返回这个value</span><br>lrange key start stop  <span class="hljs-comment">#获取列表区间(start,stop]</span><br>llen key <span class="hljs-comment">#获取列表长度</span><br>del key <span class="hljs-comment">#删除队列，成功返回1，失败返回0</span><br></code></pre></td></tr></table></figure><p><img src="/.com//image-20250402110651486.png" alt="image-20250402110651486"></p><p><img src="/.com//image-20250402111100351.png" alt="image-20250402111100351"></p><ul><li>ZRANGE key 0 -1 返回所有元素，这里的索引 0 代表有序集合中的第一个成员，索引 -1 代表最后一个成员</li><li>当在 <code>ZRANGE key 0 -1</code> 后面加上 <code>WITHSCORES</code> 参数后，除了返回有序集合中的成员，还会同时返回每个成员对应的分数。也就是说，结果会以 <code>成员1, 分数1, 成员2, 分数2, ...</code> 这样的形式呈现。</li><li><code>ZRANGE</code> 命令的基本语法是 <code>ZRANGE key start stop [WITHSCORES]</code>，当你执行 <code>ZRANGE key 0 -1</code> 或者 <code>ZRANGE key 0 -1 WITHSCORES</code> 时，返回的元素会按照分数从小到大的顺序排列。</li><li>如果你需要按照分数从大到小（降序）的顺序获取有序集合中的元素，可以使用 <code>ZREVRANGE</code> 命令。其语法为 <code>ZREVRANGE key start stop [WITHSCORES]</code>。</li></ul><p><img src="/.com//image-20250402111549122.png" alt="image-20250402111549122"></p><h1 id="4-Spring-Data-Redis"><a href="#4-Spring-Data-Redis" class="headerlink" title="4.Spring Data Redis"></a>4.Spring Data Redis</h1><h3 id="配置引入和初始化"><a href="#配置引入和初始化" class="headerlink" title="配置引入和初始化"></a>配置引入和初始化</h3><p><img src="/.com//image-20250402111855673.png" alt="image-20250402111855673"></p><p><img src="/.com//image-20250402111930307.png" alt="image-20250402111930307"></p><p><img src="/.com//image-20250402112000216.png" alt="image-20250402112000216"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        template.setConnectionFactory(redisConnectionFactory);<br>        template.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        template.setValueSerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        template.setHashKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        template.setHashValueSerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>RedisConnectionFactory</code> 是创建 <code>RedisConnection</code> 的工厂，通过 <code>RedisConnectionFactory</code> 可以获取 <code>RedisConnection</code> 实例，从而与 Redis 服务器进行交互。<code>RedisConnectionFactory</code> 负责连接的管理和配置，而 <code>RedisConnection</code> 负责具体的命令执行。</li><li>Redis 模板类<code>RedisTemplate</code>则在 <code>RedisConnectionFactory</code> 和 <code>RedisConnection</code> 的基础上，为开发者提供了方便、高效的操作接口，降低了使用 Redis 的难度。</li></ul><p><strong>为什么要设置序列化</strong></p><ul><li><p>在使用 Redis 存储数据时，Java 对象不能直接存储到 Redis 中，因为 Redis 是一个基于内存的键值对存储系统，它只能存储字节数组。所以在将 Java 对象存储到 Redis 之前，需要将其序列化为字节数组；从 Redis 中读取数据时，需要将字节数组反序列化为 Java 对象。</p></li><li><p>将 <code>RedisTemplate</code> 的键和值的序列化器都设置成了 <code>StringRedisSerializer</code>，目的是保证数据以字符串形式存储，方便阅读和调试。</p></li><li><p><code>JdkSerializationRedisSerializer</code> 虽然可以处理任意 Java 对象，但它的序列化结果通常比较大，并且序列化和反序列化的性能相对较低。而 <code>StringRedisSerializer</code> 只处理字符串，序列化和反序列化的速度非常快，对于存储简单的字符串类型的数据，使用 <code>StringRedisSerializer</code> 可以显著提高性能。</p></li></ul><h3 id="1-字符串类型（String）"><a href="#1-字符串类型（String）" class="headerlink" title="1. 字符串类型（String）"></a>1. 字符串类型（String）</h3><ul><li><p><strong>操作概述</strong>：字符串是 Redis 最基本的数据类型，可存储字符串、整数或浮点数。在 Spring Data Redis 里，借助 <code>ValueOperations</code> 进行操作。<code>ValueOperations valueOperations = redisTemplate.opsForValue();</code></p></li><li><p>常见操作及对应 Redis 命令</p><p>：</p><ul><li>**<code>set(key, value)</code>**：对应 Redis 的 <code>SET</code> 命令，用于设置指定键的值。</li><li>**<code>get(key)</code>**：对应 Redis 的 <code>GET</code> 命令，用于获取指定键的值。</li><li>**<code>set(key, value, timeout, unit)</code>**：对应 Redis 的 <code>SETEX</code> 命令，用于设置指定键的值并设置过期时间。</li><li>**<code>setIfAbsent(key, value)</code>**：对应 Redis 的 <code>SETNX</code> 命令，仅当键不存在时设置键的值。</li><li>**<code>delete(key)</code>**：对应 Redis 的 <code>DEL</code> 命令，用于删除指定键。</li><li><strong><code>increment(key)</code></strong> 方法对指定 <code>key</code> 的值进行自增操作，并返回自增后的结果。-原子性操作，多线程安全，对应 Redis 中的 <code>INCRBY</code> 命令。</li></ul></li></ul><h3 id="2-哈希类型（Hash）"><a href="#2-哈希类型（Hash）" class="headerlink" title="2. 哈希类型（Hash）"></a>2. 哈希类型（Hash）</h3><ul><li><p><strong>操作概述</strong>：哈希类型用于存储键值对的映射，适合存储对象。在 Spring Data Redis 中，通过 <code>HashOperations</code> 操作。</p><p><code>HashOperations hashOperations = redisTemplate.opsForHash();</code></p></li><li><p>常见操作及对应 Redis 命令 </p><p>：</p><ul><li>**<code>put(key, hashKey, value)</code>**：对应 Redis 的 <code>HSET</code> 命令，用于设置哈希表中指定字段的值。</li><li>**<code>get(key, hashKey)</code>**：对应 Redis 的 <code>HGET</code> 命令，用于获取哈希表中指定字段的值。</li><li>**<code>delete(key, hashKey)</code>**：对应 Redis 的 <code>HDEL</code> 命令，用于删除哈希表中指定字段。</li><li>**<code>keys(key)</code>**：对应 Redis 的 <code>HKEYS</code> 命令，用于获取哈希表中所有字段。</li><li>**<code>values(key)</code>**：对应 Redis 的 <code>HVALS</code> 命令，用于获取哈希表中所有值。</li></ul></li></ul><h3 id="3-列表类型（List）"><a href="#3-列表类型（List）" class="headerlink" title="3. 列表类型（List）"></a>3. 列表类型（List）</h3><ul><li><p><strong>操作概述</strong>：列表是一个有序的字符串列表，可在列表两端进行插入和删除操作。在 Spring Data Redis 中，使用 <code>ListOperations</code> 操作。<code>ListOperations listOperations = redisTemplate.opsForList();</code></p></li><li><p>常见操作及对应 Redis 命令</p><p>：</p><ul><li>**<code>leftPushAll(key, values)</code>**：对应 Redis 的 <code>LPUSH</code> 命令，用于将一个或多个值插入到列表头部。</li><li>**<code>leftPush(key, value)</code>**：对应 Redis 的 <code>LPUSH</code> 命令，用于将一个值插入到列表头部。</li><li>**<code>range(key, start, end)</code>**：对应 Redis 的 <code>LRANGE</code> 命令，用于获取列表中指定范围的元素。</li><li>**<code>rightPop(key)</code>**：对应 Redis 的 <code>RPOP</code> 命令，用于移除并获取列表的最后一个元素。</li><li>**<code>size(key)</code>**：对应 Redis 的 <code>LLEN</code> 命令，用于获取列表的长度。</li></ul></li></ul><h3 id="4-集合类型（Set）"><a href="#4-集合类型（Set）" class="headerlink" title="4. 集合类型（Set）"></a>4. 集合类型（Set）</h3><ul><li><p><strong>操作概述</strong>：集合是无序且唯一的字符串集合。在 Spring Data Redis 中，使用 <code>SetOperations</code> 操作。</p><p><code>SetOperations setOperations = redisTemplate.opsForSet();</code></p></li><li><p>常见操作及对应 Redis 命令</p><p>：</p><ul><li>**<code>add(key, values)</code>**：对应 Redis 的 <code>SADD</code> 命令，用于向集合中添加一个或多个成员。</li><li>**<code>members(key)</code>**：对应 Redis 的 <code>SMEMBERS</code> 命令，用于获取集合中的所有成员。</li><li>**<code>size(key)</code>**：对应 Redis 的 <code>SCARD</code> 命令，用于获取集合的成员数量。</li><li>**<code>intersect(key1, key2)</code>**：对应 Redis 的 <code>SINTER</code> 命令，用于获取多个集合的交集。</li><li>**<code>union(key1, key2)</code>**：对应 Redis 的 <code>SUNION</code> 命令，用于获取多个集合的并集。</li><li>**<code>remove(key, values)</code>**：对应 Redis 的 <code>SREM</code> 命令，用于移除集合中一个或多个成员。</li></ul></li></ul><h3 id="5-有序集合类型（ZSet）"><a href="#5-有序集合类型（ZSet）" class="headerlink" title="5. 有序集合类型（ZSet）"></a>5. 有序集合类型（ZSet）</h3><ul><li><p><strong>操作概述</strong>：有序集合和集合类似，不过每个成员都关联了一个分数，可根据分数进行排序。在 Spring Data Redis 中，使用 <code>ZSetOperations</code> 操作。<code>ZSetOperations zSetOperations = redisTemplate.opsForZSet();</code></p></li><li><p>常见操作及对应 Redis 命令</p><p>：</p><ul><li>**<code>add(key, value, score)</code>**：对应 Redis 的 <code>ZADD</code> 命令，用于向有序集合中添加一个成员并设置分数。</li><li>**<code>range(key, start, end)</code>**：对应 Redis 的 <code>ZRANGE</code> 命令，用于获取有序集合中指定范围的成员。</li><li>**<code>incrementScore(key, value, delta)</code>**：对应 Redis 的 <code>ZINCRBY</code> 命令，用于增加有序集合中成员的分数。</li><li>**<code>remove(key, values)</code>**：对应 Redis 的 <code>ZREM</code> 命令，用于移除有序集合中一个或多个成员。</li><li>**<code>range(key, start, end)</code>**：对应Redis的<code>ZRANGE</code>命令，按升序获取有序集合里指定范围的成员。结果按分数从小到大排列。</li><li><strong><code>reverseRange(key, start, end)</code></strong>:对应Redis的<code>ZREVRANGE</code>命令，按降序获取有序集合中指定范围的成员。结果按分数从大到小排列。</li><li><strong>索引0标识第一个，-1标识最后一个</strong></li><li>索引值为非负整数时，代表从有序集合开头计数的位置。例如，<code>range(key, 0, 2)</code> 会返回分数最小的前 3 个成员。</li><li>索引值为负数时，代表从有序集合末尾计数的位置。例如，<code>range(key, -3, -1)</code> 会返回分数最大的后 3 个成员。</li><li>若 <code>start</code> 索引大于 <code>end</code> 索引，或者 <code>start</code> 超出有序集合范围，会返回空集合</li></ul></li></ul><h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><ul><li><p><strong>操作概述</strong>：这些命令可对任意类型的键进行操作。</p><p><code>redisTemplate.</code></p></li><li><p>常见操作及对应 Redis 命令</p><p>：</p><ul><li>**<code>keys(pattern)</code>**：对应 Redis 的 <code>KEYS</code> 命令，用于查找所有符合给定模式的键。</li><li>**<code>hasKey(key)</code>**：对应 Redis 的 <code>EXISTS</code> 命令，用于检查给定键是否存在。</li><li>**<code>type(key)</code>**：对应 Redis 的 <code>TYPE</code> 命令，用于返回键所存储的值的类型。</li><li>**<code>delete(key)</code>**：对应 Redis 的 <code>DEL</code> 命令，用于删除指定键。</li></ul></li></ul><h1 id="5-Spring-Cache"><a href="#5-Spring-Cache" class="headerlink" title="5.Spring Cache"></a>5.Spring Cache</h1><p><img src="/.com//image-20250416210651552.png" alt="image-20250416210651552"></p><p><img src="/.com//image-20250416210813928.png" alt="image-20250416210813928"></p><p>Spring 表达式设置key</p><p><img src="/.com//image-20250416212101312.png" alt="image-20250416212101312"></p><ul><li>CachePut</li></ul><p><img src="/.com//image-20250416211844335.png" alt="image-20250416211844335"></p><ul><li>Cacheable</li></ul><p><img src="/.com//image-20250416212723196.png" alt="image-20250416212723196"></p><ul><li>CacheEvict</li></ul><p><img src="/.com//image-20250416213154004.png" alt="image-20250416213154004"></p><p><img src="/.com//image-20250416213309607.png" alt="image-20250416213309607"></p><p>设置allEntries&#x3D;true删除所用的缓存</p><h1 id="6-Redis进阶"><a href="#6-Redis进阶" class="headerlink" title="6.Redis进阶"></a>6.Redis进阶</h1><p><img src="/.com//image-20250424184204804.png" alt="image-20250424184204804"></p><p><img src="/.com//image-20250424184346571.png" alt="image-20250424184346571"></p><p><img src="/.com//image-20250424185144774.png" alt="image-20250424185144774"></p><h2 id="1-缓存更新策略"><a href="#1-缓存更新策略" class="headerlink" title="1.缓存更新策略"></a>1.缓存更新策略</h2><p><img src="/.com//image-20250424193522978.png" alt="image-20250424193522978"></p><p><img src="/.com//image-20250425140414841.png" alt="image-20250425140414841"></p><p><img src="/.com//image-20250428195050009.png" alt="image-20250428195050009"></p><p><img src="/.com//image-20250428195637484.png" alt="image-20250428195637484"></p><ul><li>总结：<ul><li>主动更新</li><li>先更新数据库，再删除缓存</li></ul></li></ul><h2 id="2-缓存穿透"><a href="#2-缓存穿透" class="headerlink" title="2.缓存穿透"></a>2.缓存穿透</h2><ul><li><p><strong>缓存穿透</strong>是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p><strong>解决方案</strong>：</p><ul><li><p><strong>缓存空对象</strong></p><ul><li><p><img src="/.com//image-20250428204922755.png" alt="image-20250428204922755"></p></li><li><p><strong>优点</strong>：简单、方便</p></li><li><p><strong>缺点</strong>：额外的内存消耗、可能造成短期的不一致</p></li></ul></li><li><p><strong>布隆过滤</strong></p><ul><li><img src="/.com//image-20250428205112400.png" alt="image-20250428205112400"></li><li><strong>优点</strong>：内存占用少，没有多余key</li><li><strong>缺点</strong>：实现复杂，存在误判问题。</li></ul></li></ul></li></ul><h2 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3.缓存雪崩"></a>3.缓存雪崩</h2><ul><li><strong>缓存雪崩</strong>是指同一时间大量的缓存key同时失效或者Redis服务宕机，导致<strong>大量的请求到达数据库</strong>，带来巨大的压力。</li></ul><p><img src="/.com//image-20250428211228045.png" alt="image-20250428211228045"></p><ul><li><p><strong>解决方案</strong></p><ul><li>给不同的key的TTL添加随机值</li><li>利用<strong>Redis集群</strong>提高服务的可用性-主从哨兵</li><li>给缓存业务添加限流策略</li><li>给业务添加多级缓存</li></ul></li></ul><h2 id="4-缓存击穿"><a href="#4-缓存击穿" class="headerlink" title="4.缓存击穿"></a>4.缓存击穿</h2><ul><li><p><strong>缓存击穿问题</strong>也叫热点Key问题，就是一个<strong>高并发访问</strong>并且<strong>缓存重建业务比较复杂</strong>的Key突然<strong>失效</strong>了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p></li><li><p><strong>解决方案</strong>：</p><ul><li><p>互斥锁</p><p><img src="/.com//image-20250428212337260.png" alt="image-20250428212337260"></p></li><li><p>逻辑过期</p><p><img src="/.com//image-20250428212547140.png" alt="image-20250428212547140"></p></li></ul></li></ul><p><img src="/.com//image-20250428212611784.png" alt="image-20250428212611784"></p><blockquote><ul><li>模拟互斥锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">//获取锁</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span>&#123;<br>       Boolean flag=redisTemplate.opsForValue().setIfAbsent(key,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-number">10</span>,TimeUnit.SECONDS);<br>       <span class="hljs-keyword">return</span> BooleanUtil.isTrue(flag);<span class="hljs-comment">//由于Boolean的自动装箱机制，null值会出现空指针异常</span><br>   &#125;<br><br>   <span class="hljs-comment">//释放锁</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span>&#123;<br>       redisTemplate.delete(key);<br>   &#125;<br></code></pre></td></tr></table></figure><p>setIfAbsent() -添加缓存（如果不存在） 返回1-成功，0-失败   redis使用互斥锁实现该机制 -setnx</p></blockquote><blockquote><ul><li>逻辑过期</li></ul><p>添加缓存时，额外添加过期时间字段。</p><p>无需处理<strong>缓存穿透</strong>（缓存未命中直接返回空值&#x2F;异常）</p><p>需要预存带有过期时间的热点数据</p><p>存在一段时间的不一致-创建新缓存来代替过期缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-meta">@Data</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisData</span> &#123;<br> <span class="hljs-keyword">private</span> LocalDateTime expireTime;<br> <span class="hljs-keyword">private</span> Object data;<br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="5-缓存工具封装"><a href="#5-缓存工具封装" class="headerlink" title="5.缓存工具封装"></a>5.缓存工具封装</h2><p><img src="/.com//image-20250429194840832.png" alt="image-20250429194840832"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheClient</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-comment">//直接存缓存-有真实的过期时间</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;<br>        redisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);<br>    &#125;<br><br>    <span class="hljs-comment">//封装-逻辑过期时间-存缓存</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWithLogicalExpire</span><span class="hljs-params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;<br>        <span class="hljs-comment">//封装</span><br>        <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisData</span>();<br>        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));<br>        redisData.setData(value);<br>        <span class="hljs-comment">//写入redis</span><br>        redisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));<br>    &#125;<br><br>    <span class="hljs-comment">//解决缓存穿透-get</span><br>    <span class="hljs-comment">//泛型，函数式编程</span><br>    <span class="hljs-comment">//调用案例Shop shop = cacheClient</span><br>    <span class="hljs-comment">//                .queryWithPassThrough(RedisConstants.CACHE_SHOP_KEY, id, Shop.class, this::getById, RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br>    <span class="hljs-keyword">public</span> &lt;R, ID&gt; R <span class="hljs-title function_">queryWithPassThrough</span><span class="hljs-params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyPrefix + id;<br>        <span class="hljs-comment">//从redis查询缓存</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> (String) redisTemplate.opsForValue().get(key);<br>        <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(json)) &#123;<span class="hljs-comment">//非空，且非空串-有效</span><br>            <span class="hljs-keyword">return</span> JSONUtil.toBean(json, type);<br>        &#125;<br>        <span class="hljs-comment">//不为null时-无效值-兜底数据-空值</span><br>        <span class="hljs-keyword">if</span> (json != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//返回错误信息</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//redis不存在-查询数据库</span><br>        <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> dbFallback.apply(id);<br>        <span class="hljs-comment">//数据库也不存在</span><br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//将空值写入redis</span><br>            redisTemplate.opsForValue().set(key, <span class="hljs-string">&quot; &quot;</span>, RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES);<br>            <span class="hljs-comment">//返回错误信息</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//数据库存在-写入缓存-返回数据</span><br>        <span class="hljs-built_in">this</span>.set(key, r, time, unit);<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-comment">//解决缓存击穿（热点击穿）-逻辑过期</span><br>    <span class="hljs-comment">//需要在测试类中提前放入</span><br>    <span class="hljs-keyword">public</span> &lt;R, ID&gt; R <span class="hljs-title function_">queryWithLogicalExpire</span><span class="hljs-params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyPrefix + id;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> (String) redisTemplate.opsForValue().get(key);<br>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(shopJson)) &#123;<span class="hljs-comment">//null/未初始化/“ ”</span><br>            <span class="hljs-comment">//未命中-返回</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//缓存命中-未过期，直接返回</span><br>        <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, RedisData.class);<br>        <span class="hljs-comment">//缓存的数据</span><br>        <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);<br>        <span class="hljs-keyword">if</span> (redisData.getExpireTime().isAfter(LocalDateTime.now())) &#123;<br>            <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        <span class="hljs-comment">//缓存命中-过期</span><br>        <span class="hljs-comment">//缓存重建</span><br>        <span class="hljs-comment">//获取锁</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> tryLock(key);<br>        <span class="hljs-comment">//获取锁成功-开启独立线程，实现缓存重建</span><br>        <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(lock)) &#123;<br>            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//创建缓存</span><br>                    <span class="hljs-type">R</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> dbFallback.apply(id);<br>                    <span class="hljs-built_in">this</span>.setWithLogicalExpire(key, r1, time, unit);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">//释放锁</span><br>                    unlock(RedisConstants.LOCK_SHOP_KEY + id);<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">//获取锁失败-直接返回过期数据兜底</span><br>        <span class="hljs-keyword">return</span> r;<br><br>    &#125;<br><br>    <span class="hljs-comment">//10个线程的线程池</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">CACHE_REBUILD_EXECUTOR</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-comment">//获取锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().setIfAbsent(key, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> BooleanUtil.isTrue(flag);<span class="hljs-comment">//由于Boolean的自动装箱机制，null值会出现空指针异常</span><br>    &#125;<br><br>    <span class="hljs-comment">//释放锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span> &#123;<br>        redisTemplate.delete(key);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><ul><li>注意：</li><li>泛型的使用</li><li>函数式参数的使用</li><li>线程池的使用</li></ul></blockquote><h2 id="6-Lua脚本实现原子性"><a href="#6-Lua脚本实现原子性" class="headerlink" title="6.Lua脚本实现原子性"></a>6.Lua脚本实现原子性</h2><p><img src="/.com//image-20250504134320454.png" alt="image-20250504134320454"></p><p><img src="/.com//image-20250504134713358.png" alt="image-20250504134713358"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- get key</span><br><span class="hljs-keyword">local</span> id=redis.call(<span class="hljs-string">&#x27;get&#x27;</span>,KEYS[<span class="hljs-number">1</span>])<br><br><span class="hljs-comment">-- 对比</span><br><span class="hljs-keyword">if</span>(id==ARGV[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 释放锁</span><br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="使用Java代码执行lua脚本"><a href="#使用Java代码执行lua脚本" class="headerlink" title="使用Java代码执行lua脚本"></a>使用Java代码执行lua脚本</h3><p><img src="/.com//image-20250504140223143.png" alt="image-20250504140223143"></p><p>核心改变：</p><blockquote><ul><li>引入脚本-编写脚本放置resource目录下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;<br>  <span class="hljs-keyword">static</span> &#123;<br>      UNLOCK_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>      UNLOCK_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;unlock.lua&quot;</span>));<br>      UNLOCK_SCRIPT.setResultType(Long.class);<br>  &#125;<br></code></pre></td></tr></table></figure><ul><li>执行脚本</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">//通过lua脚本来执行</span><br>      redisTemplate.execute(UNLOCK_SCRIPT, Collections.singletonList(KEY_PREFIX + name), ID_PREFIX + Thread.currentThread().getId());<br></code></pre></td></tr></table></figure></blockquote><h2 id="7-分布式锁-Redisson"><a href="#7-分布式锁-Redisson" class="headerlink" title="7.分布式锁-Redisson"></a>7.分布式锁-Redisson</h2><p><img src="/.com//image-20250504152117489.png" alt="image-20250504152117489"></p><p><strong><code>可重入锁（Reentrant Lock）</code></strong></p><ul><li><strong>原理</strong>：允许同一线程在持有锁的情况下多次获取锁，内部通过计数实现，每次加锁计数 +1 ，解锁计数 -1 ，计数为 0 时才真正释放锁。</li><li><strong>应用场景</strong>：一个方法调用另一个需要相同锁保护的方法时，避免线程自己阻塞自己。比如递归操作共享资源场景。</li></ul><p><strong><code>公平锁（Fair Lock）</code></strong></p><ul><li><strong>原理</strong>：按照请求锁的顺序，先来先得，保证锁分配的公平性。对比非公平锁，它减少了线程 “饥饿” 情况。</li><li><strong>应用场景</strong>：多个线程对资源访问需求相近，希望公平竞争资源的场景，如多个客户端公平获取数据库连接。</li></ul><p><strong><code>联锁（MultiLock）</code></strong></p><ul><li><strong>原理</strong>：将多个锁合并成一个锁，只有当所有子锁都成功获取时，联锁才获取成功；释放时也需释放所有子锁。</li><li><strong>应用场景</strong>：涉及多个不同资源，需要同时锁定以保证操作原子性的场景，比如同时操作多个不同 Redis 数据库中的数据。</li></ul><p><strong><code>红锁（RedLock）</code></strong></p><ul><li><strong>原理</strong>：基于多个 Redis 节点实现，通过在多个节点上获取锁，当在大多数节点（超过半数）成功获取锁时，认为获取到了红锁。</li><li><strong>应用场景</strong>：对可靠性要求极高，单个 Redis 节点故障也不希望锁机制失效的场景，如金融交易中的分布式事务场景。</li></ul><p><strong><code>读写锁（ReadWriteLock）</code></strong></p><ul><li><strong>原理</strong>：区分读操作和写操作，允许多个线程同时读，保证数据一致性；写操作时则独占锁，不允许其他线程读写。</li><li><strong>应用场景</strong>：读多写少的场景，如缓存系统，大量读请求同时进行，少量写请求更新缓存时需要独占。</li></ul><p><strong><code>信号量（Semaphore）</code></strong></p><ul><li><strong>原理</strong>：源自操作系统概念，通过控制信号量值来限制对资源的访问数量，获取信号量时值减 1 ，释放时值加 1 ，值为 0 时线程等待。</li><li><strong>应用场景</strong>：限制并发访问资源的线程数量，如限制数据库连接池同时使用的连接数。</li></ul><p><strong><code>可过期性信号量（PermitExpirableSemaphore）</code></strong></p><ul><li><strong>原理</strong>：在信号量基础上，为获取的许可（permit）设置过期时间，过期后自动释放，无需手动释放。</li><li><strong>应用场景</strong>：资源使用有时间限制的场景，如限时访问的共享资源。</li></ul><p><strong><code>闭锁（CountDownLatch）</code></strong></p><ul><li><strong>原理</strong>：通过计数器控制，初始设定计数，线程调用 <code>countDown()</code> 方法使计数减 1 ，计数为 0 时，等待的线程被释放继续执行。</li><li><strong>应用场景</strong>：多个线程完成各自任务后，再触发下一步操作的场景，如多个数据加载线程完成数据加载后，通知主线程进行数据处理。</li></ul><h3 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1.快速入门"></a>1.快速入门</h3><p><img src="/.com//image-20250504145123651.png" alt="image-20250504145123651"></p><p><img src="/.com//image-20250504145239043.png" alt="image-20250504145239043"></p><h3 id="2-可重入锁原理-解决重入，重试，超时释放"><a href="#2-可重入锁原理-解决重入，重试，超时释放" class="headerlink" title="2.可重入锁原理-解决重入，重试，超时释放"></a>2.可重入锁原理-解决重入，重试，超时释放</h3><ul><li><p><strong><code>可重入锁（Reentrant Lock）</code></strong></p></li><li><pre><code class="java"> //使用Redisson锁        RLock lock = redissonClient.getLock(&quot;lock:order:&quot; + userId);        boolean isLock=lock.tryLock();        if(isLock)&#123;            //获取锁失败，其他线程占用            return Result.fail(&quot;一个用户只能执行一次该业务&quot;);        &#125;        try &#123;//业务执行        &#125; finally &#123;            //释放锁            lock.unlock();        &#125;</code></pre></li><li><p>获取锁</p></li></ul><p><img src="/.com//image-20250504151322725.png" alt="image-20250504151322725"></p><ul><li>释放锁</li></ul><p><img src="/.com//image-20250504151501604.png" alt="image-20250504151501604"></p><p><img src="/.com//image-20250504174805232.png" alt="image-20250504174805232"></p><ul><li>看门狗机制实现定时任务持续更新有效期-》确保系统高可用，防止业务没有执行完毕锁超时释放。</li><li>集群模式下存在主从一致性问题</li></ul><h3 id="3-联锁（MultiLock）-解决主从一致性"><a href="#3-联锁（MultiLock）-解决主从一致性" class="headerlink" title="3.联锁（MultiLock）-解决主从一致性"></a>3.联锁（MultiLock）-解决主从一致性</h3><ul><li><p>主从模式</p><ul><li>主节点执行写</li><li>从节点执行读</li><li>主节点同步数据至从节点</li></ul></li><li><p>主节点宕机时，哨兵模式下从节点成为新的主节点。如果主从节点未能同步，此时锁在原先的主节点存在，而在新的主节点下不存在。</p><ul><li><p>此时其他线程也能获取锁，出现并发的安全问题</p><p><img src="/.com//image-20250504182353336.png" alt="image-20250504182353336"></p></li></ul></li><li><p>解决方法：</p><ul><li><p>获取锁的时候，向多个节点进行获取锁。</p><p><img src="/.com//image-20250504182530148.png" alt="image-20250504182530148"></p></li><li><p>创建联锁</p><p><img src="/.com//image-20250504182950695.png" alt="image-20250504182950695"></p></li></ul></li><li><p><img src="/.com//image-20250504183426117.png" alt="image-20250504183426117"></p></li></ul><h2 id="8-Redis消息队列"><a href="#8-Redis消息队列" class="headerlink" title="8.Redis消息队列"></a>8.Redis消息队列</h2><p><img src="/.com//image-20250505203035584.png" alt="image-20250505203035584"></p><ul><li><strong>List实现消息队列</strong></li></ul><p><img src="/.com//image-20250505203225971.png" alt="image-20250505203225971"></p><p><img src="/.com//image-20250505203456591.png" alt="image-20250505203456591"></p><ul><li><strong>PubSub实现消息队列</strong></li></ul><p><img src="/.com//image-20250505204206009.png" alt="image-20250505204206009"></p><p><img src="/.com//image-20250505204244428.png" alt="image-20250505204244428"></p><ul><li><strong>Stream实现消息队列</strong></li></ul><p><img src="/.com//image-20250505204654318.png" alt="image-20250505204654318"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Markdown语法</title>
    <link href="/2025/07/02/markdown/"/>
    <url>/2025/07/02/markdown/</url>
    
    <content type="html"><![CDATA[<h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h2><p>#加空格<br>几个井号表示几级标题</p><p>”# 一级标题“或者ctrl+1</p><p>”## 二级标题“或者ctrl+2</p><p>”### 三级标题“或者ctrl+3</p><h2 id="2-代码块"><a href="#2-代码块" class="headerlink" title="2.代码块"></a>2.代码块</h2><p>“~~~”加代码语言</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-段落"><a href="#3-段落" class="headerlink" title="3.段落"></a>3.段落</h2><p>enter大段</p><p>shift+enter小换行</p><p>大</p><p>大</p><p>小<br>小</p><h2 id="4-链接"><a href="#4-链接" class="headerlink" title="4.链接"></a>4.链接</h2><p>在Markdown中，可以使用以下语法来创建链接：</p><p>4.1. 行内链接：使用方括号和圆括号来创建行内链接。方括号中放置链接文本，圆括号中放置链接地址。例如：<a href="https://www.markdownguide.org/">Markdown Guide</a></p><p>4.2. 引用链接：可以先在文档的其他地方定义链接的名称和地址，然后在需要使用的地方引用。示例如下：</p>   <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less">这是一个<span class="hljs-selector-attr">[示例链接]</span><span class="hljs-selector-attr">[1]</span>。<br><br><span class="hljs-selector-attr">[1]</span>: <span class="hljs-selector-tag">https</span>:<span class="hljs-comment">//www.example.com</span><br><br></code></pre></td></tr></table></figure><p> 这是一个<a href="https://www.example.com/">示例</a>。</p><p>4.3. 自动链接：可以直接使用尖括号来创建自动链接，例如：<a href="https://www.example.com/">https://www.example.com</a></p><p>这些是创建链接的基本语法，你可以根据需要选择合适的方式来创建链接。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;https:<span class="hljs-comment">//www.example.com&gt;</span><br><span class="hljs-string">[哔哩]</span>（https:<span class="hljs-comment">//www.bilibili.com/）</span><br></code></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/">哔哩</a><br><a href="https://www.markdownguide.org/">Markdown Guide</a></p><h2 id="5-引用"><a href="#5-引用" class="headerlink" title="5.引用"></a>5.引用</h2><p>在Markdown中，你可以使用大于符号（&gt;）来创建引用。例如：</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">这是一个引用的文本。</span><br></code></pre></td></tr></table></figure><p>在渲染后，上面的文本将显示为引用样式：</p><blockquote><p>这是一个引用的文本。</p></blockquote><p>你还可以嵌套引用，例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby">&gt; 这是一个引用的文本。<br><span class="hljs-meta prompt_">&gt;&gt;</span> 这是嵌套在引用中的文本。<br></code></pre></td></tr></table></figure><p>在渲染后，上面的文本将显示为：</p><blockquote><p>这是一个引用的文本。</p><blockquote><p>这是嵌套在引用中的文本。</p></blockquote></blockquote><p>通过使用大于符号，你可以很容易地在Markdown中创建引用文本。</p><h2 id="6-粗体和斜体"><a href="#6-粗体和斜体" class="headerlink" title="6.粗体和斜体"></a>6.粗体和斜体</h2><p>在Markdown中，你可以使用星号（*）或下划线（_）来创建粗体和斜体文本。<br>一对表示斜体，两对表示粗体，三对表示粗斜体<br>要创建粗体文本，你可以使用两个星号或下划线，例如：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**这是粗体文本**</span><br><span class="hljs-emphasis">__这也是粗体文本__</span><br></code></pre></td></tr></table></figure><p>在渲染后，上面的文本将显示为粗体样式：</p><p><strong>这是粗体文本</strong><br><strong>这也是粗体文本</strong></p><p>要创建斜体文本，你可以使用一个星号或下划线，例如：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">*这是斜体文本*</span><br><span class="hljs-emphasis">_这也是斜体文本_</span><br></code></pre></td></tr></table></figure><p>在渲染后，上面的文本将显示为斜体样式：</p><p><em>这是斜体文本</em><br><em>这也是斜体文本</em></p><p>你还可以同时使用两个星号和下划线来创建粗斜体文本，例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">**<span class="hljs-emphasis">*这是粗斜体文本*</span>**</span><br><span class="hljs-strong">__<span class="hljs-emphasis">_这也是粗斜体文本_</span>__</span><br></code></pre></td></tr></table></figure><p>在渲染后，上面的文本将显示为粗斜体样式：</p><p><em><strong>这是粗斜体文本</strong></em><br><em><strong>这也是粗斜体文本</strong></em></p><h2 id="7-插入图片"><a href="#7-插入图片" class="headerlink" title="7.插入图片"></a>7.插入图片</h2><p>在Markdown中，你可以使用以下语法来插入图片：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">!<span class="hljs-selector-attr">[图片描述]</span>(图片链接)<br></code></pre></td></tr></table></figure><p>其中，图片描述是显示在图片无法加载时的替代文本，图片链接是图片的URL或者相对路径。</p><p>例如，如果你有一张名为 “example.jpg” 的图片，并且它位于与Markdown文件相同的目录下，你可以这样插入图片：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">!<span class="hljs-selector-attr">[示例图片]</span>(example.jpg)<br></code></pre></td></tr></table></figure><p>如果图片不在同一目录下，你可以使用相对路径或者绝对路径来引用图片。如果图片在网上，你也可以使用图片的URL来插入图片。</p><p>示例：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less">!<span class="hljs-selector-attr">[示例图片]</span>(<span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.example.com/images/example.jpg)</span><br></code></pre></td></tr></table></figure><p>以上是基本的图片插入语法，你可以根据需要来插入不同的图片。</p><p><img src="/.com//背景图片\wallpaper.jpg" alt="桌面图片"></p><p><img src="/.com//image-20231117160856264.png" alt="image-20231117160856264"></p><h2 id="8-列表"><a href="#8-列表" class="headerlink" title="8.列表"></a>8.列表</h2><ol><li><p>无序列表</p><p>：用</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-</span><br></code></pre></td></tr></table></figure><p>、</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">*</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-addition">+</span><br></code></pre></td></tr></table></figure><p>开头。</p><ul><li><code>- 列表项 1</code></li><li><code>- 列表项 2</code></li><li><code>- 列表项 3</code></li></ul></li><li><p>有序列表</p><p>：用数字加</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">.<br></code></pre></td></tr></table></figure><p>开头。</p><ul><li><code>1. 列表项 1</code></li><li><code>2. 列表项 2</code></li><li><code>3. 列表项 3</code></li></ul></li></ol><h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><p>在 Markdown（MD）中可以使用表格语法来创建简单的表格，以下是基本的语法格式：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> 列标题 1 </span>|<span class="hljs-string"> 列标题 2 </span>|<span class="hljs-string"> 列标题 3 </span>|<br>|<span class="hljs-string"> -------- </span>|<span class="hljs-string"> -------- </span>|<span class="hljs-string"> -------- </span>|<br>|<span class="hljs-string"> 内容 1   </span>|<span class="hljs-string"> 内容 2   </span>|<span class="hljs-string"> 内容 3   </span>|<br>|<span class="hljs-string"> 内容 4   </span>|<span class="hljs-string"> 内容 5   </span>|<span class="hljs-string"> 内容 6   </span>|<br><br></code></pre></td></tr></table></figure><table><thead><tr><th>列标题 1</th><th>列标题 2</th><th>列标题 3</th></tr></thead><tbody><tr><td>内容 1</td><td>内容 2</td><td>内容 3</td></tr><tr><td>内容 4</td><td>内容 5</td><td>内容 6</td></tr></tbody></table><p>例如，创建一个学生信息表可以这样写：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> 学号    </span>|<span class="hljs-string"> 姓名 </span>|<span class="hljs-string"> 年龄 </span>|<br>|<span class="hljs-string"> ------- </span>|<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ---- </span>|<br>|<span class="hljs-string"> 2024001 </span>|<span class="hljs-string"> 张三 </span>|<span class="hljs-string"> 18   </span>|<br>|<span class="hljs-string"> 2024002 </span>|<span class="hljs-string"> 李四 </span>|<span class="hljs-string"> 19   </span>|<br></code></pre></td></tr></table></figure><table><thead><tr><th>学号</th><th>姓名</th><th>年龄</th></tr></thead><tbody><tr><td>2024001</td><td>张三</td><td>18</td></tr><tr><td>2024002</td><td>李四</td><td>19</td></tr></tbody></table><p>在 Markdown 中创建的表格比较简单，主要用于文档中的展示，不能像数据库中的表那样进行复杂的查询和操作。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/Linux%E7%B3%BB%E7%BB%9F/"/>
    <url>/2025/07/02/Linux%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a><code>Linux</code></h1><h2 id="虚拟机配置"><a href="#虚拟机配置" class="headerlink" title="虚拟机配置"></a>虚拟机配置</h2><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p><img src="/.com//image-20250323184852335.png" alt="image-20250323184852335"></p><blockquote><p>子网ip设置为:192.168.100.0</p><p>查看ip地址的命令：ip addr</p><p>启动&#x2F;停止&#x2F;重启 Linux系统：init 0:关闭  。init 6:重启</p></blockquote><h3 id="远程连接ssh-免密登录"><a href="#远程连接ssh-免密登录" class="headerlink" title="远程连接ssh-免密登录"></a>远程连接ssh-免密登录</h3><h4 id="1-Linux-开启-SSH-远程服务"><a href="#1-Linux-开启-SSH-远程服务" class="headerlink" title="1. Linux 开启 SSH 远程服务"></a>1. Linux 开启 SSH 远程服务</h4><ul><li><p>检查 SSH 服务状态</p><p>：</p><p>打开 Linux 终端，执行命令（以 Ubuntu 为例）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl status sshd  <span class="hljs-comment"># 查看 SSH 服务状态  </span><br></code></pre></td></tr></table></figure><p>若未安装，先安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update &amp;&amp; sudo apt install openssh-server  <span class="hljs-comment"># Debian/Ubuntu 系  </span><br>sudo yum install openssh-server  <span class="hljs-comment"># CentOS/RHEL 系  </span><br></code></pre></td></tr></table></figure></li><li><p>启动并设置开机自启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start sshd  <span class="hljs-comment"># 启动服务  </span><br>sudo systemctl <span class="hljs-built_in">enable</span> sshd  <span class="hljs-comment"># 设置开机自启 </span><br></code></pre></td></tr></table></figure><ul><li>修改 SSH 的配置文件 &#x2F;etc&#x2F;ssh&#x2F;sshd_config，将其中的 PubkeyAuthentication 参数设置为 yes，以开启公钥认证功能。</li></ul></li></ul><h4 id="2-Windows-生成密钥对"><a href="#2-Windows-生成密钥对" class="headerlink" title="2. Windows 生成密钥对"></a>2. Windows 生成密钥对</h4><p>在打开的终端中，执行以下命令来生成 SSH 密钥对，并使用邮箱作为注释信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">&quot;your_email@example.com&quot;</span><br></code></pre></td></tr></table></figure><ul><li><p><code>-t rsa</code>：指定密钥类型为 RSA，这是目前较为常用的 SSH 密钥类型。</p></li><li><p><code>-b 4096</code>：设置密钥的位数为 4096，位数越高，密钥越安全。</p></li><li><p><code>-C &quot;your_email@example.com&quot;</code>：为生成的密钥添加注释信息，通常使用你的邮箱地址，这样在管理多个密钥时可以方便识别。</p></li><li><p>执行上述命令后，会有以下提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Enter file in which to save the key (C:\Users\YourUsername/.ssh/id_rsa):<br></code></pre></td></tr></table></figure><p>如果你想使用默认路径和文件名，直接按下回车键即可。若要自定义保存路径和文件名，可以输入相应的路径和文件名。</p><p>接着，会提示你设置一个密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Enter passphrase (empty for no passphrase):<br></code></pre></td></tr></table></figure><p>如果你希望在使用密钥时无需输入密码（即实现真正的免密登录），可以直接按下回车键；若要为密钥设置额外的安全保护，可输入一个强密码，然后再次确认密码。</p><p>完成上述步骤后，SSH 密钥对就会生成。默认情况下，私钥文件名为 <code>id_rsa</code>，公钥文件名为 <code>id_rsa.pub</code>，它们位于 <code>C:\Users\YourUsername\.ssh</code> 目录下（<code>YourUsername</code> 是你的 Windows 用户名）。</p></li></ul><h4 id="3-Linux-保存-Windows-的公钥"><a href="#3-Linux-保存-Windows-的公钥" class="headerlink" title="3. Linux 保存 Windows 的公钥"></a>3. Linux 保存 Windows 的公钥</h4><p>将生成的公钥复制到你要连接的 Linux 系统的 <code>~/.ssh/authorized_keys</code> 文件中，以实现免密登录。</p><h4 id="4-VS-Code-配置远程连接"><a href="#4-VS-Code-配置远程连接" class="headerlink" title="4. VS Code 配置远程连接"></a>4. VS Code 配置远程连接</h4><ul><li><p>安装 <strong>Remote - SSH</strong> 扩展，按下 <code>Ctrl+Shift+P</code>，输入 <strong>Remote-SSH: Connect to Host</strong> → 选择 **Configure SSH Hosts…**。</p></li><li><p>编辑C:\Users\username.ssh\config</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Host Linux_别名（如 MyLinux）  <br>    HostName Linux 的 IP 地址  <br>    User Linux 用户名  <br>    IdentityFile C:\Users\你的用户名\.ssh\id_rsa  # 指向 Windows 私钥  <br></code></pre></td></tr></table></figure><p>在Linux中输入以下命令查看ip</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip addr <br><span class="hljs-comment">#或者 </span><br>ifconfig <span class="hljs-comment">#查看ip</span><br></code></pre></td></tr></table></figure></li><li><p>再次执行 <strong>Remote-SSH: Connect to Host</strong>，选择配置的主机，即可免密连接 Linux。</p></li></ul><p>通过以上流程，Windows 作为客户端发起连接，Linux 作为服务端接收连接，密钥认证实现免密登录。</p><h4 id="5-finalshell-配置远程连接"><a href="#5-finalshell-配置远程连接" class="headerlink" title="5. finalshell 配置远程连接"></a>5. finalshell 配置远程连接</h4><blockquote><p>直接根据Linux的IP、登录用户的用户名和密码进行连接</p></blockquote><h2 id="1-linux的目录结构"><a href="#1-linux的目录结构" class="headerlink" title="1.linux的目录结构"></a>1.<code>linux</code>的目录结构</h2><h3 id="1-1目录结构"><a href="#1-1目录结构" class="headerlink" title="1.1目录结构"></a>1.1目录结构</h3><blockquote><p><code>linux</code>的目录结构是一个树型结构</p><p><code>Windows</code>系统可以拥有多个盘符，如C盘、D盘、E盘</p><p><code>linux</code>没有盘符这个概念，只有一个根目录<code>/</code>，所有文件都在它下面</p></blockquote><p><img src="/.com//image-20250323210453283.png" alt="image-20250323210453283"></p><h3 id="1-2Linux路径的描述方式"><a href="#1-2Linux路径的描述方式" class="headerlink" title="1.2Linux路径的描述方式"></a>1.2Linux路径的描述方式</h3><blockquote><p>在Linux系统中，路径之间的层级关系，使用：&#x2F;来表示</p><p>在Windows系统中，路径之间的层级关系，使用：\来表示</p></blockquote><p><strong>win</strong>: D:\data\work\hello.txt</p><p><strong>Linux</strong>: &#x2F;use&#x2F;local&#x2F;hello.txt</p><h2 id="2-linux命令基础"><a href="#2-linux命令基础" class="headerlink" title="2.linux命令基础"></a>2.<code>linux</code>命令基础</h2><blockquote><p>无论是什么命令，用于什么用途，在Linux中，命令有其通用的格式：</p><p><code>command [-options] [parameter]</code></p><p><strong>command</strong> :命令本身</p><p><strong>-option</strong> :可选，非必选，命令的一些选项，控制命令的行为细节</p><p><strong>parameter</strong> :可选，非必选，命令的参数，多数用于命令的指向目标等</p></blockquote><p>【】表示可选的意思</p><h3 id="2-1-什么是命令、命令行"><a href="#2-1-什么是命令、命令行" class="headerlink" title="2.1 什么是命令、命令行"></a>2.1 什么是命令、命令行</h3><ul><li>命令：Linux操作指令，是系统内置的程序，可以以字符化的形式去使用</li><li>命令行：即Linux终端，可以提供字符化的操作液面供命令执行</li></ul><h3 id="2-2Linux命令的通用格式"><a href="#2-2Linux命令的通用格式" class="headerlink" title="2.2Linux命令的通用格式"></a>2.2Linux命令的通用格式</h3><p><code>command [-options] [parameter]</code></p><ul><li>命令本体</li><li>可选选项，控制命令的行为细节</li><li>可选参数，控制命令的指向目标</li><li>不使用如何命令默认路径在home下，&#x2F;home&#x2F;用户名，第一个&#x2F;表示根目录下。实例：&#x2F;home&#x2F;xing</li></ul><h2 id="3-常用基本命令"><a href="#3-常用基本命令" class="headerlink" title="3.常用基本命令"></a>3.常用基本命令</h2><blockquote><p>ls命令的作用是列出目录下的的内容，语法细节如下：</p></blockquote><p><code>ls [-a -l -h] [linux路径]</code></p><ul><li>-a -l -h 是可选的选项</li><li>Linux路径是此命令可选的参数</li></ul><p>当不使用选项和参数，直接使用ls命令本体，表示：以平铺形式列出当前工作目录下的内容</p><blockquote><p>Linux的命令行终端，在启动的时候，默认会加载：</p><ul><li>默认当前登录用户的home用户作为当前工作目录，所以ls命令列出的是home目录的内容</li><li>home目录：每个Linux操作用户在Linux系统的个人账户目录，路径在：&#x2F;home&#x2F;用户名<ul><li>如用户为xing，其home目录是：&#x2F;home&#x2F;xing     (Windows也有)</li></ul></li></ul></blockquote><p><img src="/.com//image-20240918182529465-17266551323782.png" alt="image-20240918182529465"></p><h3 id="3-1-ls命令的参数和选项（可缩写成l"><a href="#3-1-ls命令的参数和选项（可缩写成l" class="headerlink" title="3.1 ls命令的参数和选项（可缩写成l)"></a>3.1 ls命令的参数和选项（可缩写成l)</h3><blockquote><p>ls &#x2F;   :展示根目录下的内容</p><ul><li>-a :表示all，列出全部文件包括隐藏文件（以<code>.</code>开头的文件表示的是Linux系统中的隐藏文件&#x2F;文件夹）只有通过-a才可以看到</li><li>-l :以列表形式展示</li><li>-h :表示以易于阅读的形式（如K、M、G），列出文件的大小（必须搭配-l一起使用单独使用没有作用）</li></ul></blockquote><p>混合使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l -a<br><span class="hljs-built_in">ls</span> -al<br><span class="hljs-built_in">ls</span> -la<br><span class="hljs-built_in">ls</span> -hla<br><span class="hljs-built_in">ls</span> -alh /  <span class="hljs-comment">#(指定根目录)</span><br>l<br>ll  <span class="hljs-comment">#ls -l</span><br></code></pre></td></tr></table></figure><h3 id="3-2-cd-pwd-命令"><a href="#3-2-cd-pwd-命令" class="headerlink" title="3.2 -cd  -pwd  命令"></a>3.2 -cd  -pwd  命令</h3><h4 id="3-2-1-cd-切换工作目录（change-directory"><a href="#3-2-1-cd-切换工作目录（change-directory" class="headerlink" title="3.2.1 cd 切换工作目录（change directory)"></a>3.2.1 cd 切换工作目录（change directory)</h4><blockquote><p>语法：<code>cd [linux路径]</code></p><ul><li>cd命令无需选项，只有参数，表示要切换到那个目录下</li><li>cd命令直接执行，不写参数，表示回到用户的home目录</li></ul></blockquote><h4 id="3-2-2-pwd-查看当前工作目录-Print-Work-Directory"><a href="#3-2-2-pwd-查看当前工作目录-Print-Work-Directory" class="headerlink" title="3.2.2 pwd 查看当前工作目录(Print Work Directory)"></a>3.2.2 pwd 查看当前工作目录(Print Work Directory)</h4><blockquote><p>语法：pwd</p><ul><li>pwd命令，无选项，无参数，直接输入pwd即可</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">相对路径和绝对路径<br>绝对路径：<span class="hljs-built_in">cd</span>/home/xing/Desktop<br>以根目录为起点，以/开头<br>相对路径：<span class="hljs-built_in">cd</span> Desktop<br>以当前目录为起点，无需/开头<br>默认home目录下<br><span class="hljs-built_in">cd</span>/home/xing/Desktop<br><span class="hljs-built_in">cd</span> Desktop<br><span class="hljs-built_in">cd</span> ./Desktop<br><span class="hljs-built_in">cd</span> ~/Desktop<br>效果一样<br></code></pre></td></tr></table></figure><p><strong>特殊的路径表达符</strong> </p><ul><li><code>.</code> 表示当前目录，比如cd .&#x2F;Desktop表示切换到当前目录下的Desktop目录内，和cd Desktop效果一样</li><li><code>..</code> 表示上一级目录，比如：cd .. 即可切换到上一级目录，cd ..&#x2F;..切换到上二级的目录</li><li><code>~</code> 表示home目录，cd ~切换到home路径，和cd不加东西效果一样，cd ~&#x2F;Desktop,切换到home内的Desktop目录</li></ul><h3 id="3-3-who命令"><a href="#3-3-who命令" class="headerlink" title="3.3-who命令"></a>3.3-who命令</h3><blockquote><p>显示当前用户，无选项，无参数</p></blockquote><h2 id="4-创建目录命令mkdir"><a href="#4-创建目录命令mkdir" class="headerlink" title="4.创建目录命令mkdir"></a>4.创建目录命令mkdir</h2><blockquote><p>通过mkdir命令可以创建新的目录（文件夹）</p><p>（Make Directory）</p><p>语法：mkdir [-p] Linux路径</p><ul><li>参数必填，表示Linux路径，即要创建的文件夹得路径，绝对路径和相对路径都可以</li><li>-p选项可选，表示自动创建不存在得父目录，适用于创建连续多层级的目录</li></ul></blockquote><h3 id="4-1参数"><a href="#4-1参数" class="headerlink" title="4.1参数"></a>4.1参数</h3><p><img src="/.com//image-20240919155442212-17267324844911.png" alt="image-20240919155442212"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//默认在home目录下</span><br>mkdir itpro_king   <br>mkdir ./itpro_king  <span class="hljs-comment">//两个都是在当前目录下创建文件夹，以相对路径创建</span><br>mkdir /home/xing/itpro_king/test1<br><span class="hljs-comment">//绝对路径下创建</span><br>mkdir ../test3   <span class="hljs-comment">//在上级目录下创建</span><br>mkdir ~/itpro_king/test4   <span class="hljs-comment">//~表示到home目录</span><br><br></code></pre></td></tr></table></figure><h3 id="4-2选项"><a href="#4-2选项" class="headerlink" title="4.2选项"></a>4.2选项</h3><blockquote><p>如果想要一次性创建多个层级的目录，如下图</p></blockquote><p><img src="/.com//image-20240919160602497-17267331639402.png" alt="image-20240919160602497"></p><ul><li>报错因为上级目录emoji不存在，所以无法创建</li><li>可以通过<code>-p</code>选项，将一整个链路都创建</li></ul><p><img src="/.com//image-20240919160947971-17267333894143.png" alt="image-20240919160947971"></p><ul><li><code>注意</code>：创建文件夹需要修改权限，mkdir在home目录内使用无阻碍，在home目录外涉及权限问题，不授权的情况下无法成功</li></ul><h2 id="5-文件操作命令"><a href="#5-文件操作命令" class="headerlink" title="5.文件操作命令"></a>5.文件操作命令</h2><h3 id="5-1创建、查看（touch、cat、more）"><a href="#5-1创建、查看（touch、cat、more）" class="headerlink" title="5.1创建、查看（touch、cat、more）"></a>5.1创建、查看（touch、cat、more）</h3><ol><li><strong>touch&#96;创建文件</strong></li></ol><ul><li>语法：<code>touch Linux路径</code></li><li>touch命令无选项，参数必填，表示要创建的文件路径，相对、绝对、特殊路径符均可以使用</li></ul><p><img src="/.com//image-20240919162814570-17267344958104.png" alt="image-20240919162814570"></p><p><code>注意</code>：区分文件和文件夹（目录），蓝色的为文件夹，白色的为文件,也可以通过查看目录下文件的详细信息来区分，<code>ls -l</code></p><p><img src="/.com//image-20240919163150273-17267347119015.png" alt="image-20240919163150273"></p><blockquote><p>第一列信息表示权限信息，其中第一个字母为d表示为文件夹，-表示文件。</p></blockquote><ol start="2"><li><strong>cat查看文件内容</strong>- 适用于小文件</li></ol><ul><li>准备好文件内容，可以通过cat查看文件内容</li><li>语法：<code>cat [-n] Linux路径</code></li><li>选项：-n 显示行数</li><li>参数，相对绝对特殊路径符都可以</li></ul><p><img src="/.com//image-20240919164422523-17267354636766.png" alt="image-20240919164422523"></p><ol start="3"><li><p><strong>more命令查看文件内容</strong>-适用于大文件</p><ul><li>more也可以查看文件内容，和cat有略微不同</li></ul><blockquote><ul><li>cat直接将内容全部显示出来</li><li>more支持翻页，如果文件内容过多，可以一页页的展示</li></ul></blockquote><ul><li>语法：<code>more Linux路径</code></li><li>无选项，只有必填参数，相对绝对特殊路径符都可以</li></ul><p>Linux系统内置一个文件，路径为：&#x2F;etc&#x2F;services,可以通过more查看</p><blockquote><ul><li>查看过程中通过空格翻页，b回页</li><li>通过q退出查看</li></ul></blockquote></li><li><p><strong>head命令查看文件头部</strong></p></li></ol><ul><li>head -[n] fileName</li><li>查看文件头部的n行内容</li></ul><ol start="5"><li><strong>tail命名查看文件的尾部</strong></li></ol><ul><li>tail -[nf] fileName</li><li>-n:查看文件尾部的n行内容</li><li>-f:实时刷新文件尾部的内容，可用于动态日志文件查看</li></ul><h3 id="5-2复制、移动、删除（cp、mv、rm）"><a href="#5-2复制、移动、删除（cp、mv、rm）" class="headerlink" title="5.2复制、移动、删除（cp、mv、rm）"></a>5.2复制、移动、删除（cp、mv、rm）</h3><ol><li><strong>cp命令复制文件文件夹</strong></li></ol><p>cp命令可以用于复制文件\文件夹，cp命令来自英文单词：copy</p><ul><li>语法：<code>cp [-r] 参数1 参数2</code></li><li><code>-r选项</code>：可选，用于复制文件夹使用，表示递归return</li><li><code>参数1</code>，Linux路径，表示被复制的文件或文件夹</li><li><code>参数2</code>，Linux路径，表示要复制去的地方</li></ul><p><img src="/.com//image-20240919170148574-17267365101457.png" alt="image-20240919170148574"></p><ol start="2"><li><strong>mv移动文件或文件夹</strong></li></ol><p>mv命令可以用于移动文件、文件夹，来自单词：move</p><ul><li>语法：<code>mv 参数1 参数2</code></li><li>无选项</li><li>参数1，Linux路径，表示被移动的文件或文件夹</li><li>参数2，Linux路径，表示要移动去的目录，如果目标目录不存在，则进行<strong>重命名</strong></li></ul><p><img src="/.com//image-20240919170703419-17267368244238.png" alt="image-20240919170703419"></p><ol start="3"><li><strong>rm删除文件或文件夹</strong></li></ol><p>rm命令可以删除文件、文件夹，来自单词：remove</p><ul><li>语法：<code>rm [-r -f] 参数1 参数2 ... 参数N </code></li><li><code>-r选项</code>：和cp命令一样，-r选项用于删除文件夹</li><li><code>-f选项</code>：表示force，强制删除（不会弹出提示确认消息）<ul><li>普通用户删除内容不会弹出提示，只有root管理员用户删除内容会有提示，所以一般用户用不到-f选项</li></ul></li><li>参数1、参数2…参数N表示要删除的文件或者文件夹路径，按照空格隔开</li></ul><p><img src="/.com//image-20240919171916791-17267375582759.png" alt="image-20240919171916791"></p><blockquote><p><code>通配符</code></p><ul><li>符号*表示通配符，即匹配任意内容（包含空），示例：<ul><li>test*,表示匹配任何以test开头的内容</li><li>*test，表示匹配任何以test结尾的内容</li><li>*test *，表示匹配任何包含test的内容</li></ul></li></ul></blockquote><p><img src="/.com//image-20240919172837778-172673811893810.png" alt="image-20240919172837778"></p><p><code>注意</code>：</p><p>用mkdir创建的是文件夹（目录）rm或者rm -f都无法删除，必须用-r选项。</p><blockquote><p>演示强制删除，-f选项</p></blockquote><h3 id="5-3-打包压缩tar"><a href="#5-3-打包压缩tar" class="headerlink" title="5.3.打包压缩tar"></a>5.3.打包压缩tar</h3><ul><li><strong>tar</strong></li></ul><p><img src="/.com//image-20250323212055102.png" alt="image-20250323212055102"></p><p><img src="/.com//image-20250323212150407.png" alt="image-20250323212150407"></p><h3 id="5-4查找文件find-grep"><a href="#5-4查找文件find-grep" class="headerlink" title="5.4查找文件find&#x2F;grep"></a>5.4查找文件find&#x2F;grep</h3><p><img src="/.com//image-20250323212703953.png" alt="image-20250323212703953"></p><p><img src="/.com//image-20250323212806520.png" alt="image-20250323212806520"></p><h2 id="7-vim编辑器"><a href="#7-vim编辑器" class="headerlink" title="7.vim编辑器"></a>7.vim编辑器</h2><p>vi -文件路径   打开</p><p><img src="/.com//image-20250323212533720.png" alt="image-20250323212533720"></p><p>编辑模式：i；a;o</p><p>移动：hjkl:左下上右   可加数字移动n个</p><p>行：</p><ul><li><p>光标到屏幕的上H,中M,下L,第一个字符</p></li><li><p>光标到文本的最后一行：G；第一个字符</p></li><li><p>n+G:光标到文本的第n行的第一个字符</p></li><li><p>gg-&gt;1G</p></li><li><p>n+回车：下移n行</p></li></ul><p>列：</p><ul><li><p>n+空格 ：右移n个</p></li><li><p>0：到该列的第一个字符</p></li><li><p>＄：到该列的最后一个字符</p></li></ul><p>删除：</p><ul><li>X:光标所在往前删  可以加数字  删n个</li><li>x：光标所在往后删  可以加数字  删n个</li><li>d+0:删到这一行的第一个</li><li>d+$:删到这一行的最后一个</li><li>d+G:删到文本最后一行</li><li>d+1G:删到第一行   ：同理d+nG</li></ul><p>复制：</p><ul><li>yy复制这一行</li><li>y+光标移动  ：类似删除</li></ul><p>粘贴：</p><ul><li>P</li></ul><p>复原：u</p><p>反复原：ctrl+r</p><p>重复：.</p><h2 id="8-shell脚本编程"><a href="#8-shell脚本编程" class="headerlink" title="8.shell脚本编程"></a>8.shell脚本编程</h2><ul><li><p>#！是一个指定解释器标记，告诉系统这个脚本要用什么解释器来执行，即哪一种shell</p></li><li><pre><code class="shell">#!/bin/shellecho &quot;Hellow World !&quot;<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stata"><br>### 运行<span class="hljs-keyword">shell</span>脚本有两种方法<br><br>- 1. 作为可执行程序<br><br>- ~~~<span class="hljs-keyword">shell</span><br>  chmod +x ./<span class="hljs-keyword">test</span>.<span class="hljs-keyword">sh</span>  #使脚本具有执行权限 ./<span class="hljs-keyword">test</span>.<span class="hljs-keyword">sh</span>让系统就在当前目录找此文件<br>  ./<span class="hljs-keyword">test</span>.<span class="hljs-keyword">sh</span> #执行脚本<br></code></pre></td></tr></table></figure>- 2. 作为解释器参数  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">/bin/<span class="hljs-keyword">sh</span> <span class="hljs-keyword">test</span>.<span class="hljs-keyword">sh</span>   #直接运行解释器，参数是<span class="hljs-keyword">shell</span>脚本的文件名<br></code></pre></td></tr></table></figure>  - 该方式不需要在第一行写指定解释器标志### shell变量- 定义变量时，变量名不加美元符号$(php语言中变量需要)- ~~~shell  your_name=&quot;zhuzhuxia&quot;  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br>- 注意：变量和等号之间不能有空格；只包含字母，数字，下划线；不能以数字开头；避免使用关键字；使用大写字母表示常量<br><br>- ~~~shell<br>  <span class="hljs-attribute">var_1</span>=<span class="hljs-string">&quot;123&quot;</span><br>  <span class="hljs-attribute">Var_2</span>=<span class="hljs-string">&quot;214&quot;</span><br></code></pre></td></tr></table></figure>- 除了显示的直接赋值，还可以用语句给变量赋值- ~~~shell  for file in $(ls /etc）   #将/etc下目录的文件名循环出来  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>- <span class="hljs-comment">#### 使用变量</span><br><br>- ~~~shell<br>  <span class="hljs-comment">#! /bin/bash</span><br>  your_name=<span class="hljs-string">&quot;zhuzhuxia&quot;</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$your_name</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;your_name&#125;</span>//推荐<br></code></pre></td></tr></table></figure>- ### 只读变量- 使用readonly命令可以将变量定义为只读变量，只读变量的值不能被改变- ~~~shell  #！/bin/b  my_name=&quot;zhuzhuxia&quot;  readonly my_name  my_name=&quot;chaorenqiang&quot;  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>- 结果：/bin/sh: NAME: This variable is <span class="hljs-built_in">read</span> only.<br><br>- <span class="hljs-comment">### 删除变量</span><br><br>- 使用<span class="hljs-built_in">unset</span> 命令可以删除变量<br><br>- ~~~bash<br>  <span class="hljs-built_in">unset</span> variable_name<br></code></pre></td></tr></table></figure>- unset不能删除只读变量- ### 不同类型的变量- ~~~bash  #字符串  my_string=&quot;Hellow,world!&quot;#在shell中变量通常被视为字符串，你可以使用单引号和双引号来定义  #整数变量  可以使用declare或typeset命令来声明整数变量  declare -i my_integer=42  #数组变量  my_arry=(1 2 3 4 5 6)  #或者关联数组  declare -A associative_array  associative_arry[&quot;name&quot;]=&quot;Jhon&quot;  associative_arry[&quot;age&quot;]=30  #环境变量  echo $PATH   #包含了操作系统可执行文件的路径  your_name=&quot;runoob&quot;  str=&quot;Hello, I know you are \&quot;$your_name\&quot;! \n&quot;  echo -e $str  #-e 实现转义  #Hello, I know you are &quot;runoob&quot;!   # 使用双引号拼接  双引号可以有变量也可以有转义字符  greeting=&quot;hello, &quot;$your_name&quot; !&quot;  greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;  echo $greeting  $greeting_1    # 使用单引号拼接  单引号不拼接的话不能放变量  greeting_2=&#39;hello, &#39;$your_name&#39; !&#39;  greeting_3=&#39;hello, $&#123;your_name&#125; !&#39;  echo $greeting_2  $greeting_3    #hello, runoob ! hello, runoob !  #hello, runoob ! hello, $&#123;your_name&#125; !  <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>  <br><br>​    <br><br><br><br><br><br><br><br>## <span class="hljs-number">9</span>.Linux软件安装<br><br>- CentOS<br><br>![image-<span class="hljs-number">20250323221818298</span>](Linux系统.assets/image-<span class="hljs-number">20250323221818298</span>.png)<br><br>![image-<span class="hljs-number">20250323223804993</span>](Linux系统.assets/image-<span class="hljs-number">20250323223804993</span>.png)<br><br>![image-<span class="hljs-number">20250324143126426</span>](Linux系统.assets/image-<span class="hljs-number">20250324143126426</span>.png)<br><br>![image-<span class="hljs-number">20250323225534167</span>](Linux系统.assets/image-<span class="hljs-number">20250323225534167</span>.png)<br><br><br><br><br><br>- Ubuntu<br><br>以下是在虚拟机 Ubuntu <span class="hljs-number">22.04</span> 上安装 MySQL、JDK、Nginx 并配置环境，以及检查安装是否成功的详细步骤：<br><br>### 安装 MySQL<br><br>#### 步骤<br><br><span class="hljs-number">1</span>. **更新系统包列表**：<br><br>```bash<br>sudo apt update<br>```<br><br><span class="hljs-number">1</span>. **安装 MySQL 服务器**：<br><br>```bash<br>sudo apt install mysql-server<br>```<br><br><span class="hljs-number">1</span>. **启动 MySQL 服务并设置开机自启**：<br><br>```bash<br>sudo systemctl start mysql<br>sudo systemctl enable mysql<br>```<br><br><span class="hljs-number">1</span>. **运行安全脚本**：<br><br>```bash<br>sudo mysql_secure_installation<br>```<br><br>按照提示设置密码、移除匿名用户、禁止远程 root 登录等。<br><br>#### 检查安装是否成功<br><br>```bash<br>sudo systemctl status mysql<br>```<br><br>若显示 `active (running)`，则表示 MySQL 服务已成功启动。也可以使用以下命令登录 MySQL：<br><br>```bash<br>sudo mysql -u root -p<br>```<br><br>输入之前设置的密码，若能成功登录，说明 MySQL 安装和配置成功。<br><br><br><br><br><br>### MySQL远程<br><br>在 MySQL 中授权远程访问通常需要在数据库中创建具有远程访问权限的用户，并配置防火墙允许 MySQL 端口（默认是 <span class="hljs-number">3306</span>）的流量通过。下面以 MySQL <span class="hljs-number">8</span>.x 版本为例，详细介绍具体操作步骤：<br><br>#### <span class="hljs-number">1</span>. 登录 MySQL<br><br>在服务器上打开终端，使用具有足够权限的用户（如 `root`）登录 MySQL：<br><br>```bash<br>sudo mysql -u root -p<br>```<br><br>输入密码后回车，进入 MySQL 命令行界面。<br><br>#### <span class="hljs-number">2</span>. 创建用于远程访问的用户<br><br>在 MySQL 命令行中执行以下命令创建一个新用户，这里以用户名为 `remote_user`，密码为 `your_password` 为例：<br><br>```sql<br>CREATE USER &#x27;remote_user&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;your_password&#x27;<span class="hljs-comment">;</span><br>```<br><br>- `&#x27;remote_user&#x27;` 是新创建的用户名，你可以根据实际情况修改。<br>- `&#x27;%&#x27;` 表示该用户可以从任何 IP 地址远程连接到 MySQL 服务器。如果想限制特定的 IP 地址访问，可以将 `%` 替换为具体的 IP 地址，如 `&#x27;<span class="hljs-number">192.168</span>.<span class="hljs-number">1.100</span>&#x27;`。<br>- `&#x27;your_password&#x27;` 是用户的密码，你需要设置一个安全且容易记住的密码。<br><br>#### <span class="hljs-number">3</span>. 授予用户权限<br><br>授予新用户所需的权限，这里以授予所有数据库的所有权限为例：<br><br>```sql<br>GRANT ALL PRIVILEGES ON *.* TO &#x27;remote_user&#x27;@&#x27;%&#x27;<span class="hljs-comment">;</span><br>```<br><br>- `*.*` 表示所有数据库的所有表。如果你只想授予用户对特定数据库的权限，可以将 `*.*` 替换为具体的数据库名和表名，如 `testdb.*` 表示 `testdb` 数据库中的所有表。<br><br>刷新权限表，使新的权限设置生效：<br><br>```sql<br>FLUSH PRIVILEGES<span class="hljs-comment">;</span><br>```<br><br>#### <span class="hljs-number">4</span>. 配置防火墙（可选）<br><br>如果服务器启用了防火墙（如 `iptables` 或 `firewalld`），需要开放 MySQL 的默认端口 <span class="hljs-number">3306</span> 以允许远程访问。<br><br>##### 使用 `firewalld`（适用于 CentOS <span class="hljs-number">7</span> 及以上版本）<br><br>执行以下命令开放 <span class="hljs-number">3306</span> 端口：<br><br>```bash<br>sudo firewall-cmd --zone=public --add-port=<span class="hljs-number">3306</span>/tcp --permanent<br>```<br><br>重新加载防火墙规则：<br><br>```bash<br>sudo firewall-cmd --reload<br>```<br><br>##### 使用 `iptables`（适用于 Ubuntu 等系统）<br><br>执行以下命令开放 <span class="hljs-number">3306</span> 端口：<br><br>```bash<br>sudo iptables -A INPUT -p tcp --dport <span class="hljs-number">3306</span> -j ACCEPT<br>```<br><br>保存规则（不同系统保存方式可能不同），例如在 Ubuntu 上可以使用以下命令保存：<br><br>```bash<br>sudo apt-get install iptables-persistent<br>sudo netfilter-persistent save<br>```<br><br>#### <span class="hljs-number">5</span>. 检查 MySQL 配置文件（可选）<br><br>在某些情况下，你可能需要检查 MySQL 的配置文件 `my.cnf` 或 `mysqld.cnf`，确保 MySQL 监听的是所有可用的 IP 地址。找到 `bind-address` 配置项，将其值设置为 `0.<span class="hljs-number">0.0</span>.<span class="hljs-number">0</span>`：<br><br>~~~bash<br>sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf<br></code></pre></td></tr></table></figure></code></pre></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">bind-address = 0.0.0.0<br></code></pre></td></tr></table></figure><p>修改完成后，重启 MySQL 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart mysql<br></code></pre></td></tr></table></figure><h4 id="6-测试远程连接"><a href="#6-测试远程连接" class="headerlink" title="6. 测试远程连接"></a>6. 测试远程连接</h4><p>在另一台机器上，使用 MySQL 客户端工具（如 <code>mysql</code> 命令行工具或 Navicat 等图形化工具）尝试连接到 MySQL 服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -h your_server_ip -u remote_user -p<br></code></pre></td></tr></table></figure><ul><li><code>your_server_ip</code> 是 MySQL 服务器的 IP 地址。</li><li><code>remote_user</code> 是前面创建的用于远程访问的用户名。<br>输入密码后，如果能成功连接到 MySQL 服务器，说明远程访问授权配置成功。</li></ul><p>通过以上步骤，你就可以为 MySQL 服务器配置远程访问权限。需要注意的是，为了安全起见，应尽量限制允许远程访问的 IP 地址范围，并使用强密码。</p><h3 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li><strong>更新系统包列表</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br></code></pre></td></tr></table></figure><ol><li><strong>安装 OpenJDK 17（这里以 OpenJDK 17 为例）</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install openjdk-17-jdk<br></code></pre></td></tr></table></figure><p>也可以自行下载解压，如何在配置环境变量</p><ol><li><strong>配置环境变量</strong>：<br>编辑 <code>/etc/profile</code> 文件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nano /etc/profile<br></code></pre></td></tr></table></figure><p>在文件末尾添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">JAVA_HOME=&quot;/usr/lib/jvm/java-17-openjdk-amd64&quot;<br>PATH=&quot;$PATH:$JAVA_HOME/bin&quot;<br></code></pre></td></tr></table></figure><p>保存并退出文件，然后使环境变量生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><h4 id="检查安装是否成功"><a href="#检查安装是否成功" class="headerlink" title="检查安装是否成功"></a>检查安装是否成功</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -version<br>javac -version<br></code></pre></td></tr></table></figure><p>若能正确显示 Java 版本信息，说明 JDK 安装和配置成功。</p><h3 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><h4 id="方式1："><a href="#方式1：" class="headerlink" title="方式1："></a>方式1：</h4><ol><li><strong>更新系统包列表</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br></code></pre></td></tr></table></figure><ol><li><strong>安装 Nginx</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install nginx<br></code></pre></td></tr></table></figure><ol><li><strong>启动 Nginx 服务并设置开机自启</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start nginx<br>sudo systemctl <span class="hljs-built_in">enable</span> nginx<br></code></pre></td></tr></table></figure><h4 id="检查安装是否成功-1"><a href="#检查安装是否成功-1" class="headerlink" title="检查安装是否成功"></a>检查安装是否成功</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl status nginx<br></code></pre></td></tr></table></figure><p>若显示 <code>active (running)</code>，则表示 Nginx 服务已成功启动。在浏览器中输入虚拟机的 IP 地址，若能看到 Nginx 的欢迎页面，说明 Nginx 安装和配置成功。</p><ul><li><p>开启服务：<code>sudo systemctl start nginx</code></p></li><li><p>关闭服务：<code>sudo systemctl stop nginx</code></p></li><li><p>重启服务：<code>sudo systemctl restart nginx</code></p></li><li><p>重新加载配置：<code>sudo systemctl reload nginx</code></p></li><li><p>设置开机自启：<code>sudo systemctl enable nginx</code></p></li><li><p>禁止开机自启：<code>sudo systemctl disable nginx</code></p></li><li><p>默认下载至&#x2F;etc&#x2F;下</p></li></ul><h4 id="方式2："><a href="#方式2：" class="headerlink" title="方式2："></a>方式2：</h4><ol><li>下载nginx相关依赖包</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get install gcc<br><br>apt-get install libpcre3 libpcre3-dev<br><br>apt-get install zlib1g zlib1g-dev<br><br>sudo apt-get install openssl<br><br>sudo apt-get install libssl-dev<br></code></pre></td></tr></table></figure><ol start="2"><li>新建nginx的安装目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/local<br><br><span class="hljs-built_in">mkdir</span> nginx<br><br></code></pre></td></tr></table></figure><ol start="3"><li>通过wget下载nginx安装包</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://nginx.org/download/nginx-1.24.0.tar.gz<br></code></pre></td></tr></table></figure><ol start="4"><li>解压nginx的安装包</li></ol><p>下载的nginx是tar.gz文件<br>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zvxf nginx-1.24.0.tar.gz<br></code></pre></td></tr></table></figure><p>下载的nginx是zip文件<br>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip nginx-1.24.0.tar.gz<br></code></pre></td></tr></table></figure><ol start="5"><li>切换到解压好的nginx-1.24.0目录下</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ./nginx-1.24.0<br></code></pre></td></tr></table></figure><ol start="6"><li>配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li><p>prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx：指定安装目录为&#x2F;usr&#x2F;local&#x2F;nginx。在编译和安装完成后，软件将被安装到该目录下.</p></li><li><p>with-http_stub_status_module：启用 HTTP Stub Status 模块。该模块是 Nginx 的一个内置模块，用于获取 Nginx 服务器的状态信息。</p></li><li><p>with-http_ssl_module：启用 HTTP SSL 模块。该模块使得 Nginx 支持通过 HTTPS 提供安全的加密传输。</p></li></ul><ol start="7"><li>编译</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br></code></pre></td></tr></table></figure><ol start="8"><li>安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make install<br></code></pre></td></tr></table></figure><p> 四、启动或关闭</p><ol><li>启动Nginx</li></ol><ul><li>切换到nginx的安装目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/local/nginx/sbin<br></code></pre></td></tr></table></figure><ul><li>启动nginx</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./nginx<br><span class="hljs-comment">#或</span><br>/usr/local/nginx/sbin/nginx<br></code></pre></td></tr></table></figure><ol start="2"><li>关闭nginx</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/local/nginx/sbin/nginx -s stop<br><span class="hljs-comment">#或</span><br><br><span class="hljs-comment">#查看Nginx的进程</span><br>ps -ef | grep nginx<br><br><span class="hljs-comment">#杀死Nginx相关进程</span><br><span class="hljs-built_in">kill</span> xxx<br></code></pre></td></tr></table></figure><p>五、访问nginx</p><ul><li>在浏览器上面，输入当前你服务器ip+nginx的端口号，如果出现网页，就说明成功。</li></ul><ol><li><strong>编辑 Nginx 配置文件</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /usr/local/nginx/conf/nginx.conf  <br></code></pre></td></tr></table></figure><p><img src="/.com//image-20250324174531728.png" alt="image-20250324174531728"></p><p>保存并退出编辑器。</p><ol start="2"><li><strong>重新加载配置后停止 Nginx</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo /usr/local/nginx/sbin/nginx -s reload  <span class="hljs-comment"># 应用新配置  </span><br>sudo /usr/local/nginx/sbin/nginx -s stop     <span class="hljs-comment"># 尝试停止  </span><br></code></pre></td></tr></table></figure><h3 id="对-Nginx-配置文件进行修改，可按以下步骤操作："><a href="#对-Nginx-配置文件进行修改，可按以下步骤操作：" class="headerlink" title="对 Nginx 配置文件进行修改，可按以下步骤操作："></a>对 Nginx 配置文件进行修改，可按以下步骤操作：</h3><h4 id="1-明确配置文件位置"><a href="#1-明确配置文件位置" class="headerlink" title="1. 明确配置文件位置"></a>1. 明确配置文件位置</h4><p>在不同 Linux 发行版中，Nginx 配置文件的存放位置存在差异，下面是常见的配置文件路径：</p><ul><li><strong>主配置文件</strong>：通常为 <code>/etc/nginx/nginx.conf</code>，它是 Nginx 的核心配置文件，会引入其他配置文件。</li><li><strong>站点配置文件</strong>：一般位于 <code>/etc/nginx/sites - available</code> 和 <code>/etc/nginx/sites - enabled</code> 目录（适用于 Ubuntu、Debian 等），或者 <code>/etc/nginx/conf.d</code> 目录（适用于 CentOS、Fedora 等）。</li></ul><h4 id="2-备份原始配置文件"><a href="#2-备份原始配置文件" class="headerlink" title="2. 备份原始配置文件"></a>2. 备份原始配置文件</h4><p>在修改配置文件之前，建议先对其进行备份，以防修改过程中出现错误导致 Nginx 无法正常运行。以主配置文件为例，备份命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">cp</span> /etc/nginx/nginx.conf /etc/nginx/nginx.conf.bak<br><span class="hljs-comment">#备份配置文件 覆盖修改后的配置文件</span><br>sudo <span class="hljs-built_in">cp</span> /etc/nginx/nginx.conf.bak /etc/nginx/nginx.conf<br></code></pre></td></tr></table></figure><h4 id="3-编辑配置文件"><a href="#3-编辑配置文件" class="headerlink" title="3. 编辑配置文件"></a>3. 编辑配置文件</h4><p>使用文本编辑器（如 <code>nano</code>、<code>vim</code> 等）来编辑配置文件。这里以使用 <code>vim</code> 编辑主配置文件为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/nginx/nginx.conf<br></code></pre></td></tr></table></figure><p>若要编辑站点配置文件，可使用以下命令（以 Ubuntu 系统为例）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/nginx/sites - available/default<br></code></pre></td></tr></table></figure><h4 id="4-常见配置修改"><a href="#4-常见配置修改" class="headerlink" title="4. 常见配置修改"></a>4. 常见配置修改</h4><h5 id="调整监听端口"><a href="#调整监听端口" class="headerlink" title="调整监听端口"></a>调整监听端口</h5><p>若要将 Nginx 的监听端口从默认的 80 改为 8080，可在配置文件中找到 <code>listen</code> 指令并进行修改：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">8080</span>;<br>    <span class="hljs-attribute">server_name</span> example.com;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span> /var/www/html;<br>        <span class="hljs-attribute">index</span> index.html index.htm;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="配置虚拟主机"><a href="#配置虚拟主机" class="headerlink" title="配置虚拟主机"></a>配置虚拟主机</h5><p>如果你要为多个域名或站点配置不同的访问规则，可以添加多个 <code>server</code> 块：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span> example1.com;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span> /var/www/example1;<br>        <span class="hljs-attribute">index</span> index.html index.htm;<br>    &#125;<br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span> example2.com;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span> /var/www/example2;<br>        <span class="hljs-attribute">index</span> index.html index.htm;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="配置反向代理"><a href="#配置反向代理" class="headerlink" title="配置反向代理"></a>配置反向代理</h5><p>若要将请求反向代理到后端服务器，可使用 <code>proxy_pass</code> 指令：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span> example.com;<br>     <span class="hljs-section">location</span><span class="hljs-regexp"> ^~</span> /api/ &#123;<br><span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/api/(.*)$</span> /<span class="hljs-variable">$1</span> <span class="hljs-literal">break</span>;<br><span class="hljs-attribute">proxy_pass</span> http://localhost:8080;<br>        &#125;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://backend_server_ip:backend_server_port;<br>        <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> X - Real - IP <span class="hljs-variable">$remote_addr</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-检查配置文件语法"><a href="#5-检查配置文件语法" class="headerlink" title="5. 检查配置文件语法"></a>5. 检查配置文件语法</h4><p>在重新加载或重启 Nginx 之前，需要检查配置文件的语法是否正确，可使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nginx -t<br></code></pre></td></tr></table></figure><p>若输出结果显示 <code>syntax is ok</code> 和 <code>test is successful</code>，则表示配置文件语法正确。</p><h4 id="6-重新加载或重启-Nginx"><a href="#6-重新加载或重启-Nginx" class="headerlink" title="6. 重新加载或重启 Nginx"></a>6. 重新加载或重启 Nginx</h4><p>当配置文件语法检查通过后，你可以重新加载配置文件（不中断正在处理的连接）或重启 Nginx 服务：</p><ul><li><strong>重新加载配置</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl reload nginx<br></code></pre></td></tr></table></figure><ul><li><strong>重启服务</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart nginx<br></code></pre></td></tr></table></figure><h2 id="10-防火墙"><a href="#10-防火墙" class="headerlink" title="10.防火墙"></a>10.防火墙</h2><p><img src="/.com//image-20250324160030104.png" alt="image-20250324160030104"></p><p>在 Linux 系统中，常见的防火墙有 <code>iptables</code>、<code>firewalld</code> 和 <code>ufw</code> ，不同的发行版可能默认使用不同的防火墙工具，以下为你详细介绍各防火墙的操作：</p><h3 id="1-iptables"><a href="#1-iptables" class="headerlink" title="1. iptables"></a>1. <code>iptables</code></h3><p><code>iptables</code> 是一个基于规则的防火墙工具，在许多 Linux 发行版中被广泛使用，尤其是一些较旧的系统。</p><h4 id="查看规则"><a href="#查看规则" class="headerlink" title="查看规则"></a>查看规则</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo iptables -L -n -v<br></code></pre></td></tr></table></figure><ul><li><code>-L</code> 表示列出当前的规则链。</li><li><code>-n</code> 表示以数字形式显示 IP 地址和端口号，而不是解析为域名和服务名。</li><li><code>-v</code> 表示显示详细信息。</li></ul><h4 id="添加规则"><a href="#添加规则" class="headerlink" title="添加规则"></a>添加规则</h4><p>允许特定 IP 地址访问 SSH 服务（端口 22）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo iptables -A INPUT -s 192.168.1.100 -p tcp --dport 22 -j ACCEPT<br></code></pre></td></tr></table></figure><ul><li><code>-A</code> 表示将规则添加到指定链的末尾。</li><li><code>-s</code> 用于指定源 IP 地址。</li><li><code>-p</code> 用于指定协议（如 <code>tcp</code> 或 <code>udp</code>）。</li><li><code>--dport</code> 用于指定目标端口。</li><li><code>-j</code> 用于指定动作（如 <code>ACCEPT</code> 表示允许，<code>DROP</code> 表示丢弃）。</li></ul><h4 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h4><p>删除刚刚添加的允许特定 IP 访问 SSH 的规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo iptables -D INPUT -s 192.168.1.100 -p tcp --dport 22 -j ACCEPT<br></code></pre></td></tr></table></figure><ul><li><code>-D</code> 表示删除指定的规则。</li></ul><h4 id="保存规则"><a href="#保存规则" class="headerlink" title="保存规则"></a>保存规则</h4><p>不同的发行版保存 <code>iptables</code> 规则的方法不同，以 Ubuntu 为例，可以安装 <code>iptables-persistent</code> 来保存规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install iptables-persistent<br>sudo netfilter-persistent save<br></code></pre></td></tr></table></figure><h3 id="2-firewalld"><a href="#2-firewalld" class="headerlink" title="2. firewalld"></a>2. <code>firewalld</code></h3><p><code>firewalld</code> 是 CentOS 7 及以上版本默认使用的防火墙管理工具，提供了更高级的防火墙管理功能。</p><h4 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl status firewalld<br></code></pre></td></tr></table></figure><p>如果显示 <code>active (running)</code> 表示防火墙正在运行。</p><h4 id="启动和停止"><a href="#启动和停止" class="headerlink" title="启动和停止"></a>启动和停止</h4><p>启动 <code>firewalld</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start firewalld<br></code></pre></td></tr></table></figure><p>停止 <code>firewalld</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl stop firewalld<br></code></pre></td></tr></table></figure><h4 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h4><p>开放 HTTP 服务的端口 80</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo firewall-cmd --zone=public --add-port=80/tcp --permanent<br></code></pre></td></tr></table></figure><ul><li><code>--zone</code> 用于指定区域，<code>public</code> 是默认的公共区域。</li><li><code>--add-port</code> 用于添加开放的端口，格式为 <code>端口号/协议</code>。</li><li><code>--permanent</code> 表示将规则永久保存，否则重启后规则会失效。</li></ul><p>重新加载防火墙规则使新规则生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo firewall-cmd --reload<br></code></pre></td></tr></table></figure><h4 id="关闭端口"><a href="#关闭端口" class="headerlink" title="关闭端口"></a>关闭端口</h4><p>关闭刚刚开放的端口 80：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo firewall-cmd --zone=public --remove-port=80/tcp --permanent<br>sudo firewall-cmd --reload<br></code></pre></td></tr></table></figure><h3 id="3-ufw"><a href="#3-ufw" class="headerlink" title="3. ufw"></a>3. <code>ufw</code></h3><p><code>ufw</code>（Uncomplicated Firewall）是 Ubuntu 等系统默认使用的简单防火墙配置工具，旨在简化防火墙的配置过程。</p><h4 id="查看状态-1"><a href="#查看状态-1" class="headerlink" title="查看状态"></a>查看状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ufw status<br></code></pre></td></tr></table></figure><p>如果显示 <code>Status: inactive</code> 表示防火墙未启用，<code>Status: active</code> 表示已启用。</p><h4 id="启用和禁用"><a href="#启用和禁用" class="headerlink" title="启用和禁用"></a>启用和禁用</h4><p>启用 <code>ufw</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ufw <span class="hljs-built_in">enable</span><br></code></pre></td></tr></table></figure><p>禁用 <code>ufw</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ufw <span class="hljs-built_in">disable</span><br></code></pre></td></tr></table></figure><h4 id="开放端口-1"><a href="#开放端口-1" class="headerlink" title="开放端口"></a>开放端口</h4><p>开放 SSH 服务的端口 22：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ufw allow 22<br></code></pre></td></tr></table></figure><p>也可以指定协议：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ufw allow 22/tcp<br></code></pre></td></tr></table></figure><h4 id="关闭端口-1"><a href="#关闭端口-1" class="headerlink" title="关闭端口"></a>关闭端口</h4><p>关闭刚刚开放的端口 22：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ufw deny 22<br></code></pre></td></tr></table></figure><h4 id="删除规则-1"><a href="#删除规则-1" class="headerlink" title="删除规则"></a>删除规则</h4><p>删除允许端口 22 的规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ufw delete allow 22<br></code></pre></td></tr></table></figure><p>以上就是 Linux 系统中常见防火墙工具的基本操作，你可以根据自己使用的发行版和需求选择合适的工具进行防火墙配置。</p><h3 id="4-端口和进程"><a href="#4-端口和进程" class="headerlink" title="4.端口和进程"></a>4.端口和进程</h3><p><img src="/.com//image-20250325093557335.png" alt="image-20250325093557335"></p><ul><li>查看进程</li></ul><blockquote><h3 id="查看进程"><a href="#查看进程" class="headerlink" title=". 查看进程"></a>. 查看进程</h3><ul><li><code>ps</code> 命令</li></ul><p> ：用于查看当前系统中正在运行的进程。</p><ul><li><code>ps aux</code>：显示所有用户的所有进程的详细信息。</li><li><code>ps -ef</code>：以标准格式显示所有进程的详细信息，包括进程的父进程 ID。</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef | grep java  <span class="hljs-comment">#查找java相关进程</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>top</code> 命令</strong>：实时动态显示系统中各个进程的资源占用情况。按下 <code>q</code> 键可退出 <code>top</code> 界面。</li><li><strong><code>htop</code> 命令</strong>：功能比 <code>top</code> 更强大，界面更友好，可直观查看进程的各种信息。如果系统未安装 <code>htop</code>，可以使用 <code>sudo apt-get install htop</code>（Debian&#x2F;Ubuntu）或 <code>sudo yum install htop</code>（CentOS&#x2F;RHEL）进行安装。</li></ul></blockquote><ul><li>查看对应端口的进程</li></ul><blockquote><ul><li><strong>使用 <code>netstat</code> 命令</strong>：<br> <code>netstat</code> 是一个用于查看网络连接、路由表和网络接口等信息的工具，结合 <code>grep</code> 命令可以查看特定端口对应的进程。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;sudo netstat -tulnp | grep :&lt;端口号&gt;<br></code></pre></td></tr></table></figure><p>例如，查看 80 端口对应的进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;sudo netstat -tulnp | grep :80<br></code></pre></td></tr></table></figure><ul><li><strong>使用 <code>lsof</code> 命令</strong>：<br> <code>lsof</code> 用于列出被进程打开的文件，也可以方便地查看特定端口对应的进程。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;sudo lsof -i :&lt;端口号&gt;<br></code></pre></td></tr></table></figure><p>例如，查看 443 端口对应的进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;sudo lsof -i :443<br></code></pre></td></tr></table></figure></blockquote><ul><li>杀死对应进程</li></ul><blockquote><ul><li><strong>使用 <code>kill</code> 命令（正常终止）</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;sudo <span class="hljs-built_in">kill</span> &lt;PID&gt;<br></code></pre></td></tr></table></figure><p>例如，进程 ID 为 1234，要终止该进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;sudo <span class="hljs-built_in">kill</span> 1234<br></code></pre></td></tr></table></figure><ul><li><strong>使用 <code>kill -9</code> 命令（强制终止）</strong>：<br> 如果进程无法正常响应 <code>kill</code> 命令，可以使用 <code>kill -9</code> 强制终止进程。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;sudo <span class="hljs-built_in">kill</span> -9 &lt;PID&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;sudo <span class="hljs-built_in">kill</span> -9 1234<br></code></pre></td></tr></table></figure></blockquote><ul><li>后台运行进程</li></ul><blockquote><p><code>nohup</code>（<strong>No Hang Up</strong>）命令用于在后台运行程序，使进程在用户退出登录或关闭终端后仍能继续执行。</p><h4 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;<span class="hljs-built_in">nohup</span> <span class="hljs-built_in">command</span> [arguments] &amp;<br></code></pre></td></tr></table></figure><ul><li>**<code>command</code>**：要运行的命令或程序。</li><li>**<code>[arguments]</code>**：命令的参数。</li><li>**<code>&amp;</code>**：可选，用于将命令放入后台执行（通常与<code>nohup</code>配合使用）。</li></ul><h4 id="后台运行命令并忽略挂断信号"><a href="#后台运行命令并忽略挂断信号" class="headerlink" title="后台运行命令并忽略挂断信号"></a>后台运行命令并忽略挂断信号</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;<span class="hljs-built_in">nohup</span> ./your_script.sh &amp;<br></code></pre></td></tr></table></figure><ul><li>此命令会在后台运行<code>your_script.sh</code>，即使关闭终端，脚本仍会继续执行。</li><li>输出默认会被重定向到当前目录的<code>nohup.out</code>文件中。</li></ul><h4 id="2-自定义输出文件"><a href="#2-自定义输出文件" class="headerlink" title="2. 自定义输出文件"></a>2. 自定义输出文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;<span class="hljs-built_in">nohup</span> ./your_script.sh &gt; custom_output.log 2&gt;&amp;1 &amp;<br>&gt;<span class="hljs-comment">#或者</span><br>&gt;<span class="hljs-built_in">nohup</span> java -jar xxxx.jar &amp;&gt; XXX.<span class="hljs-built_in">log</span> &amp;<br></code></pre></td></tr></table></figure><ul><li><code>&gt; custom_output.log</code>：将标准输出重定向到<code>custom_output.log</code>。</li><li><code>2&gt;&amp;1</code>：将标准错误输出也重定向到同一个文件。</li></ul><h4 id="3-运行无输出的命令"><a href="#3-运行无输出的命令" class="headerlink" title="3. 运行无输出的命令"></a>3. 运行无输出的命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;<span class="hljs-built_in">nohup</span> <span class="hljs-built_in">command</span> &gt; /dev/null 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><ul><li>将输出和错误信息都丢弃，不生成任何日志文件。</li></ul><h4 id="4-查看-nohup-的输出"><a href="#4-查看-nohup-的输出" class="headerlink" title="4. 查看 nohup 的输出"></a>4. 查看 nohup 的输出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;<span class="hljs-built_in">tail</span> -f nohup.out  <span class="hljs-comment"># 实时查看nohup.out的内容</span><br></code></pre></td></tr></table></figure><hr><h3 id="停止-nohup-进程"><a href="#停止-nohup-进程" class="headerlink" title="停止 nohup 进程"></a>停止 nohup 进程</h3><ol><li>查找进程 ID（PID）</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps aux | grep your_command  <span class="hljs-comment"># 或使用pgrep</span><br>pgrep -f your_command<br></code></pre></td></tr></table></figure><ol start="2"><li>终止进程</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">kill</span> &lt;PID&gt;    <span class="hljs-comment"># 正常终止</span><br>sudo <span class="hljs-built_in">kill</span> -9 &lt;PID&gt;  <span class="hljs-comment"># 强制终止</span><br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/JVM/"/>
    <url>/2025/07/02/JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="1-什么是JVM？"><a href="#1-什么是JVM？" class="headerlink" title="1.什么是JVM？"></a>1.什么是JVM？</h2><ul><li><p><code>JVM</code>的全称是Java Virtual Machine,即Java虚拟机</p><blockquote><ul><li>用于执行Java字节码文件的虚拟计算机，提供了一个与平台无关的运行环境，实现了”一次编写，到处运行”的特性。</li><li>JVM运作在操作系统之上</li><li>由c++编写</li></ul></blockquote></li></ul><h2 id="2-JVM有哪些部分组成？"><a href="#2-JVM有哪些部分组成？" class="headerlink" title="2.JVM有哪些部分组成？"></a>2.JVM有哪些部分组成？</h2><ul><li><p>组成部分</p><blockquote><ul><li><p>类加载器(Class Loader) -加载Class文件</p></li><li><p>运行时数据区-五个区</p></li><li><p>执行引擎（解释器interpreter，JIT编译器，垃圾回收器GC）</p></li><li><p>本地方法接口（Java本地接口-JNI）-调用本地方法库</p></li></ul></blockquote></li></ul><h2 id="3-类加载器详解"><a href="#3-类加载器详解" class="headerlink" title="3.类加载器详解"></a>3.类加载器详解</h2><ul><li>作用：将类加载为Class文件</li></ul><blockquote><p>一个<strong>类</strong>通过<strong>类加载器（Class Loader）  <strong>生成唯一对应的</strong>Class对象</strong>，创建该类的实例化对象时（即new操作）是通过<strong>该Class对象</strong>来实例化对象。反射操作（classone.getClass()）则是通过实例化对象来获取<strong>该类</strong>的<strong>Class对象</strong>。通过<strong>Class对象</strong>又可以获得<strong>类加载器对象</strong>-AppClassLoader(应用程序加载器)（Classone.getClassLoader）</p><p><img src="/.com//image-20250423152140275.png" alt="image-20250423152140275"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&#123;<br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>&gt;Car car1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<span class="hljs-comment">//三个实例化对象，hashcode不相同</span><br>&gt;Car car2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br>&gt;Car car3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br><br>&gt;Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&gt; aClass1=car1.getClass();<span class="hljs-comment">//Class对象 -唯一</span><br><br>&gt;ClassLoader classLoader=aClass1.getClassLoader();<span class="hljs-comment">//获取类加载器,自己编写的类-APPClassLoader</span><br><br>&gt;classLoader.getParent();<span class="hljs-comment">//扩展类加载器 -ExtClassLoader  </span><br><br>&gt;classLoader.getParent().getParent();<span class="hljs-comment">//null 1.不存在 2.Java程序获取不到（RootClassLoader）- 用c++写的</span><br>&gt;&#125;<br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><ul><li><p>加载器分类</p><ul><li><p>虚拟机自带的加载器</p></li><li><p>启动类（根加载器）-RootClassLoader 位于jre&#x2F;lib&#x2F;rt.jar</p></li><li><p>扩展类加载器 -ExtClassLoader  位于jre&#x2F;lib&#x2F;ext或者系统变量Java.ext.dirs指定的目录下的jar包和类库</p></li><li><p>应用程序加载器 -AppClassLoader&#x2F;系统类加载器 -SysClassLoader</p><p>可以通过ClassLoader.getSystemClassLoader()方法获取到。</p></li><li><p>自定义加载器</p><p>自定义类加载器是继承自 <code>java.lang.ClassLoader</code> 类或其子类，通过重写某些方法来实现特定加载逻辑的类加载器。</p><p><strong>实现步骤</strong></p><ol><li><strong>继承 <code>ClassLoader</code> 类</strong>：Java 提供了 <code>ClassLoader</code> 作为所有类加载器的基类，自定义类加载器需要继承它。</li><li><strong>重写 <code>findClass</code> 方法</strong>：该方法的作用是根据类的全限定名查找并加载类的字节码。当父类加载器无法加载类时，会调用此方法。默认实现是空方法。 - 不打破双亲委派机制</li><li><strong>重写 <code>loadClass</code> 方法</strong>：加载指定二进制名称的类，实现了双亲委派机制 。<code>name</code> 为类的二进制名称，<code>resolve</code> 如果为 true，在加载时调用 <code>resolveClass(Class&lt;?&gt; c)</code> 方法解析该类。</li></ol></li></ul></li><li><p><strong>双亲委派机制</strong></p></li></ul><blockquote><ul><li>这些类加载器之间的关系形成了双亲委派模型，其核心思想是当一个类加载器收到类加载的请求时，首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。这些类加载器之间的关系形成了双亲委派模型，其核心思想是当一个类加载器收到类加载的请求时，首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。</li></ul><ol><li>类加载器收到类加载器的请求</li><li>将这个请求向上委托给父类加载器去完成，一直向上委托，直到启动类加载器即根加载器</li><li>根加载器能加载直接加载，根加载器不能加载，抛出异常，通知子加载器进行加载，依次向子加载器进行通知直到能够加载就进行加载，或者没有子加载器能够加载报错Class Not Found</li></ol><ul><li>保证类的唯一性：通过委托机制，确保了所有加载请求都会传递到启动类加载器，避免了不同类加载器重复加载相同类的情况，保证了Java核心类库的统一性，也防止了用户自定义类覆盖核心类库的可能。</li><li>保证安全性：由于Java核心库被启动类加载器加载，而启动类加载器只加载信任的类路径中的类，这样可以防止不可信的类假冒核心类，增强了系统的安全性。例如，恶意代码无法自定义一个Java.lang.System类并加载到JVM中，因为这个请求会被委托给启动类加载器，而启动类加载器只会加载标准的Java库中的类。</li><li>支持隔离和层次划分：双亲委派模型支持不同层次的类加载器服务于不同的类加载需求，如应用程序类加载器加载用户代码，扩展类加载器加载扩展框架，启动类加载器加载核心库。这种层次化的划分有助于实现沙箱安全机制，保证了各个层级类加载器的职责清晰，也便于维护和扩展</li><li>简化了加载流程：通过委派，大部分类能够被正确的类加载器加载，减少了每个加载器需要处理的类的数量，简化了类的加载过程，提高了加载效率。</li></ul></blockquote><ul><li><p><strong>加载过程</strong></p><blockquote><ul><li>找到对应的加载器后，类加载过程分为三个主要步骤：加载、链接、初始化。 链接又分为三个步骤：验证，准备，解析</li></ul><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul><li><strong>查找并加载类的字节码</strong>：类加载器根据类的全限定名查找并加载类的字节码文件。字节码文件可以来自本地文件系统、网络、jar 包等各种来源。类加载器将字节码文件读入内存，并将其转化为一种内部的数据结构，通常是一个字节数组。</li><li><strong>创建 <code>Class</code> 对象</strong>：将字节码数据加载到内存后，JVM 会在方法区中创建一个代表该类的 <code>Class</code> 对象。这个 <code>Class</code> 对象是对类的各种信息（如类的结构、方法、字段等）的抽象表示，是后续操作的基础。</li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li><strong>验证</strong>：确保加载的类的字节码符合 Java 虚拟机规范，并且是安全的。包括文件格式验证、元数据验证、字节码验证和符号引用验证等，以防止恶意代码或错误的字节码对系统造成损害。</li><li><strong>准备</strong>：为类的静态变量分配内存，并设置默认的初始值。例如，对于 <code>int</code> 类型的静态变量，默认初始值为 0；对于引用类型的静态变量，默认初始值为 <code>null</code>。此时，静态变量还没有被赋予程序员在代码中指定的初始值。</li><li><strong>解析</strong>：将类的二进制数据中的符号引用转换为直接引用。符号引用是在编译时对类、方法、字段等的引用，以字符串形式表示；直接引用是指向内存中实际对象或地址的引用。解析过程会根据符号引用在运行时常量池中查找对应的直接引用，并将其替换到字节码中。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li><strong>执行静态初始化代码</strong>：按照程序员编写的代码，执行类的静态变量初始化语句和静态代码块。在这个阶段，静态变量会被赋予程序员指定的初始值，静态代码块中的代码也会被执行。这是类加载过程中最后一个阶段，也是类真正开始可用的阶段。</li></ul></blockquote></li></ul><h2 id="4-运行时数据区详解"><a href="#4-运行时数据区详解" class="headerlink" title="4.运行时数据区详解"></a>4.运行时数据区详解</h2><ul><li><p>JDK1.7 -五个部分都在JVM内存空间</p><blockquote><ul><li><p>java堆 -对象<code>实例</code>  字符串常量池 -线程共享</p></li><li><p>Java虚拟机栈 -执行方法-线程独立</p></li></ul><p> 每个方法在执行时都会创建一个栈帧，用于存储局部变量表(对于对象实例的引用)、操作数栈、动态链接、方法出口等信息。</p><ul><li><p>方法区（永久代） -类的消息，运行时常量池（1.7之前有字符串常量池），静态变量，即时编译后的代码。 -线程共享</p></li><li><p>本地方法栈  -为虚拟机使用到的本地（Native）方法服务 -线程独立</p></li><li><p>程序计数器（PC）-记录当前线程所执行的字节码的行号指示器。 -线程独立</p></li></ul><p> 字节码解释器工作时，通过改变这个计数器的值来选取下一条需要执行的字节码指令。如果执行的是本地方法，计数器的值则为空（Undefined）。</p></blockquote></li><li><p>JDK1.8 原来1.7的方法区改为元空间且元空间内存在本地内存</p><blockquote><ul><li><p>java堆 -对象<code>实例</code>  字符串常量池 -线程共享</p></li><li><p>Java虚拟机栈 -执行方法-线程独立</p></li></ul><p> 每个方法在执行时都会创建一个栈帧，用于存储局部变量表(对于对象实例的引用)、操作数栈、动态链接、方法出口等信息。</p><ul><li><p>元空间  -类的消息，运行时常量池（1.7之前有字符串常量池），静态变量，即时编译后的代码。-本地内存  -线程共享</p></li><li><p>本地方法栈  -为虚拟机使用到的本地（Native）方法服务 -线程独立</p></li><li><p>程序计数器（PC）-记录当前线程所执行的字节码的行号指示器。 -线程独立</p></li></ul><p> 字节码解释器工作时，通过改变这个计数器的值来选取下一条需要执行的字节码指令。如果执行的是本地方法，计数器的值则为空（Undefined）。实现了流程控制。</p><p> 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</p></blockquote></li><li><p>⚠️ 注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> （OOM）的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p></li><li><p>在 JDK 1.7 之前，HotSpot 虚拟机将运行时常量池和字符串常量池都存放在方法区中，而 HotSpot 对方法区的实现称为永久代1。永久代用于存放类的元数据、静态变量、常量池（包括字符串常量池）等1。</p><p>不过，在 JDK 1.7 中，HotSpot 对内存管理进行了调整，字符串常量池从永久代中移到了堆内存中1。到了 JDK 1.8，HotSpot VM 彻底移除了永久代，并引入了元空间，运行时常量池保留在元空间中，字符串常量池继续保存在堆中1。</p></li></ul><h2 id="5-GC垃圾回收"><a href="#5-GC垃圾回收" class="headerlink" title="5.GC垃圾回收"></a>5.GC垃圾回收</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/java/"/>
    <url>/2025/07/02/java/</url>
    
    <content type="html"><![CDATA[<h1 id="java（有c-c-基础）"><a href="#java（有c-c-基础）" class="headerlink" title="java（有c&#x2F;c++基础）"></a>java（有c&#x2F;c++基础）</h1><h2 id="1-初识java"><a href="#1-初识java" class="headerlink" title="1.初识java"></a>1.初识java</h2><h3 id="1-1-java的体系结构"><a href="#1-1-java的体系结构" class="headerlink" title="1.1.java的体系结构"></a>1.1.java的体系结构</h3><ul><li>javaSE :标准版，个人计算机上的应用（重点）</li><li>JavaEE：企业版，服务器端的应用（重点）</li><li>JavaME：微型版，定位在消费性产品</li></ul><h3 id="1-2-Java的特性与优势"><a href="#1-2-Java的特性与优势" class="headerlink" title="1.2.Java的特性与优势"></a>1.2.Java的特性与优势</h3><ul><li>Java就是c++语法的简化版，相当于将c++的一些内容去除；比如：头文件，指针运算，结构，联合，操作符重载，虚基类等等。同时，语法基于C语言。</li><li>高性能：通过虚拟机优化提升速度</li><li>分布式</li><li>多线程</li><li>健壮性</li></ul><h3 id="1-3-核心机制"><a href="#1-3-核心机制" class="headerlink" title="1.3.核心机制"></a>1.3.核心机制</h3><ul><li><p>垃圾收集机制</p></li><li><p>跨平台原理</p></li></ul><p>Java的跨平台原理</p><p><img src="/.com//image-20241015175105864.png" alt="image-20241015175105864"></p><p>C语言的跨平台原理</p><p><img src="/.com//image-20241015175622423.png" alt="image-20241015175622423"></p><p>比较：</p><p><img src="/.com//image-20241015175759664.png" alt="image-20241015175759664"></p><h3 id="1-4-常用的DOS命令"><a href="#1-4-常用的DOS命令" class="headerlink" title="1.4.常用的DOS命令"></a>1.4.常用的DOS命令</h3><blockquote><p>win+r+cmd</p></blockquote><p>打开控制台</p><ol><li>切换盘符：c:  ,   d:    ,  e:   不用区分大小写</li><li>显示详细信息：dir   相当于Linux中的ls</li><li>改变当前目录：  cd   和Linux中的一样</li><li>.  当前目录   和  ..  上级目录  ：和Linux里一样</li><li>清屏cls</li><li>上下箭头切换历史命令</li><li>tab键补齐</li><li>创建目录和删除目录：md 和rd 后面加文件   对应Linux中的mkdir和rm</li><li>copy复制文件：和Linux中的cp一样</li></ol><h3 id="1-5-快捷总结"><a href="#1-5-快捷总结" class="headerlink" title="1.5.快捷总结"></a>1.5.快捷总结</h3><p>CTRL+ALT+L：自动对齐</p><p>CTRL+ALT+T:对代码块进行包围操作（异常、同步锁）</p><p>CTRL+H:查看类的层级关系</p><p>Ctrl+Alt+←：回到光标前面一次的位置，→同理</p><p>SHIFT+F6:同时修改变量</p><h2 id="2-数据类型——常量、变量、输入输出"><a href="#2-数据类型——常量、变量、输入输出" class="headerlink" title="2.数据类型——常量、变量、输入输出"></a>2.数据类型——常量、变量、输入输出</h2><h3 id="2-1-常量、变量"><a href="#2-1-常量、变量" class="headerlink" title="2.1.常量、变量"></a>2.1.常量、变量</h3><ul><li>字面常量</li></ul><blockquote><p>整型常量、字符常量、逻辑常量、字符串常量</p></blockquote><p>null常量：可以赋值给任何类型的变量。</p><ul><li>变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">pubilc <span class="hljs-keyword">class</span> <span class="hljs-title class_">value</span>()&#123;<br>    pubilc <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">byte</span> mybyte=<span class="hljs-number">120</span>;<span class="hljs-comment">//  byte变量（-127，128）一个字节</span><br>        <span class="hljs-type">short</span> myshort=<span class="hljs-number">120</span>;<span class="hljs-comment">// short变量 两个字节</span><br>        <span class="hljs-type">int</span> myint=<span class="hljs-number">120</span>; <span class="hljs-comment">//int变量 4个字节</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">mylong</span> <span class="hljs-operator">=</span><span class="hljs-number">12123L</span>;<span class="hljs-comment">// long变量 8个字节  最后加上L来标识</span><br>        <span class="hljs-type">float</span> myfloat=<span class="hljs-number">3.14f</span>;<span class="hljs-comment">//float变量 4个字节  最后加上f来标识</span><br>        <span class="hljs-type">double</span> mydouble=<span class="hljs-number">3.1415926</span>;<span class="hljs-comment">// double变量 8个字节</span><br>        <span class="hljs-type">char</span> mychar=<span class="hljs-string">&#x27;A&#x27;</span>; <span class="hljs-comment">//char变量 2个字节</span><br>        <span class="hljs-type">boolean</span> myboolean=ture;<span class="hljs-comment">//false 布尔变量理论上只要一位，Java中占一个字节</span><br>        <span class="hljs-type">int</span>[] myarray=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<span class="hljs-comment">//int数组型变量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;myarray.length;i++)&#123;<span class="hljs-comment">//赋值</span><br>            myarray[i]=i+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> element :myarray)&#123;<br>            System.out.println(element+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<span class="hljs-comment">//输出</span><br>        <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Season</span>&#123;<span class="hljs-comment">//枚举型变量</span><br>            spring,summer,autumn,winter<br>        &#125;<br>        <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>字符常量<code>final</code></li></ul><p>和c++中的const性质类似，被final修饰的字符变量变成常量不可修改</p><p>在Java中final可以用来修饰类和方法</p><p><code>被final修饰的类不能被继承</code></p><p><code>被final修饰的方法不能被子类重写。</code></p><p><code>final修饰引用类型地址值不能改变</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">final</span> num=<span class="hljs-number">10</span>;<br>num=<span class="hljs-number">5</span><span class="hljs-comment">//无法改变</span><br><span class="hljs-keyword">final</span> Dog d=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>d=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<span class="hljs-comment">//---&gt;地址值不能改</span><br><span class="hljs-comment">//d对象的属性依然可以改变</span><br></code></pre></td></tr></table></figure><h3 id="2-2-类型转换"><a href="#2-2-类型转换" class="headerlink" title="2.2. 类型转换"></a>2.2. 类型转换</h3><h4 id="2-2-1隐式转换"><a href="#2-2-1隐式转换" class="headerlink" title="2.2.1隐式转换"></a>2.2.1隐式转换</h4><ul><li><strong>字节数从小到大</strong>：byte-&gt;short-&gt;char-&gt;int-&gt;long-&gt;float-&gt;double</li></ul><p>long比float字节多所以转换可能存在丢失</p><ul><li><strong>字符类型与整数类型</strong>：<code>char可以自动转换为int</code>,因为char在Java中是2字节的无符号整数，其本质上可以看成是一种特殊的整数类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">byte</span> b=<span class="hljs-number">120</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span>b;<span class="hljs-comment">//byte 自动转换为int</span><br><br><span class="hljs-type">char</span> ch=<span class="hljs-string">&#x27;A&#x27;</span>;<br><span class="hljs-type">int</span> code=ch;<span class="hljs-comment">//char自动转换为int，得到字符‘A’的码值</span><br></code></pre></td></tr></table></figure><h4 id="2-2-2强制转换（显式转换）"><a href="#2-2-2强制转换（显式转换）" class="headerlink" title="2.2.2强制转换（显式转换）"></a>2.2.2强制转换（显式转换）</h4><ul><li>当需要将大的数据类型转换为小的数据类型时，需要进行强制类型转换。可能会导致数据精度的损失。</li><li>targetType v&#x3D;(tergetType)value</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">double</span> d=<span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> j=(<span class="hljs-type">int</span>)d;<span class="hljs-comment">//得到3，小数部分被截断</span><br><span class="hljs-type">long</span> l=<span class="hljs-number">121892364819236412793L</span>;<br><span class="hljs-type">int</span> k=(<span class="hljs-type">int</span>)l; <span class="hljs-comment">//长整型强制转换为整型，可能出现数据溢出</span><br></code></pre></td></tr></table></figure><h4 id="2-2-3特殊的类型转换"><a href="#2-2-3特殊的类型转换" class="headerlink" title="2.2.3特殊的类型转换"></a>2.2.3特殊的类型转换</h4><p>字符串与基本数据结构的转换</p><ul><li><p>基本数据类型转字符串</p><ul><li>可以使用连接操作（<code>+</code>） 或相应的字符串转换方法。</li><li>使用<code>String.valueOf()</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用+连接操作</span><br><span class="hljs-type">int</span> num=<span class="hljs-number">456</span>;<br>String str1=<span class="hljs-string">&quot;&quot;</span>+num;<br><br><span class="hljs-comment">//使用String.valueOf()方法：</span><br><span class="hljs-type">int</span> num2=<span class="hljs-number">456</span>;<br>String str2=String.valueOf(num2);<br></code></pre></td></tr></table></figure></li><li><p>字符串转基本数据类型</p><ul><li>使用相应的包装类的parsexxx()方法（xxx表示具体的数据类型，如Integer.parseInt()、Double.parseDouble()等）。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String str3=<span class="hljs-string">&quot;123356&quot;</span>;<br><span class="hljs-type">int</span> num3=Integer.parseInt(str3);<br></code></pre></td></tr></table></figure><p>如果字符串的内容不符合数字格式，会抛出NumberFormatException异常。</p><h3 id="2-3-Scanner基础用法"><a href="#2-3-Scanner基础用法" class="headerlink" title="2.3.Scanner基础用法"></a>2.3.<code>Scanner</code>基础用法</h3><ul><li>读取基本数据类型</li></ul><blockquote><p>nextInt()-读取整数</p><p>nextDouble()-读取双精度浮点数</p><p>nextBoolean()-读取布尔值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br>Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">int</span> age=sc.nextInt();<span class="hljs-comment">//键盘录入年龄</span><br><span class="hljs-type">double</span> hign=sc.nextDouble();<span class="hljs-comment">//键盘录入身高</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>读取字符串&#x2F;字符</li></ul><blockquote><p>next()-读取下一个单词</p><p>nextLine()-读取一行字符串</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java">Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>String word=sc.next();<span class="hljs-comment">//读取一个单词</span><br>String str=sc.nextLine();<span class="hljs-comment">//读取一行</span><br><span class="hljs-type">char</span> ch=word.charAt();<span class="hljs-comment">//读取一个字符</span><br></code></pre></td></tr></table></figure><ul><li>其它方法</li></ul><blockquote><p>hasNext()-判断是否还有下一个输入项</p><p>hasNextInt、hasNextDouble等等</p></blockquote><h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3.运算符"></a>3.运算符</h2><h3 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1.算术运算符"></a>3.1.算术运算符</h3><ol><li><strong>基本算术运算符</strong><ul><li>加法（+）<ul><li>用于计算两个数值的和。例如：<code>int a = 3 + 5;</code>，结果<code>a</code>为 8。</li><li>当用于字符串时，它起到连接字符串的作用，如<code>String s1 = &quot;Hello&quot; + &quot;World&quot;;</code>，结果<code>s1</code>为<code>&quot;HelloWorld&quot;</code>。</li></ul></li><li>减法（-）<ul><li>用于计算两个数值的差。例如：<code>int b = 7 - 4;</code>，结果<code>b</code>为 3。</li></ul></li><li>乘法（*）<ul><li>用于计算两个数值的乘积。例如：<code>int c = 2 * 6;</code>，结果<code>c</code>为 12。</li></ul></li><li>除法（&#x2F;）<ul><li>当用于整数时，它执行整除操作。例如：<code>int d = 10 / 3;</code>，结果<code>d</code>为 3。</li><li>当用于浮点数时，执行常规的除法运算，得到带有小数的结果，如<code>double e = 10.0 / 3.0;</code>，结果<code>e</code>约为 3.3333。</li></ul></li><li>取余（%）<ul><li>用于计算两个数相除的余数。例如：<code>int f = 10 % 3;</code>，结果<code>f</code>为 1。</li></ul></li></ul></li><li><strong>自增（++）和自减（–）运算符</strong><ul><li>自增（++）<ul><li>分为前置自增和后置自增。</li><li>前置自增（<code>++i</code>）：先将变量的值加 1，然后再使用变量的值。例如：</li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> ++i;<br><span class="hljs-comment">// 此时i的值为4，j的值也为4</span><br></code></pre></td></tr></table></figure><ul><li>后置自增（<code>i++</code>）：先使用变量的值，然后再将变量的值加 1。例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> m++;<br><span class="hljs-comment">// 此时m的值为4，n的值为3</span><br></code></pre></td></tr></table></figure><ul><li>自减（–）<ul><li>与自增类似，分为前置自减和后置自减。</li><li>前置自减（<code>--k</code>）：先将变量的值减 1，然后再使用变量的值。</li><li>后置自减（<code>k--</code>）：先使用变量的值，然后再将变量的值减 1。</li></ul></li></ul><h3 id="3-2-关系运算符"><a href="#3-2-关系运算符" class="headerlink" title="3.2.关系运算符"></a>3.2.关系运算符</h3><ol><li>比较大小关系<ul><li>等于（&#x3D;&#x3D;）<ul><li>用于判断两个值是否相等。例如：<code>boolean b1 = (3 == 3);</code>，结果<code>b1</code>为<code>true</code>；<code>boolean b2 = (3 == 4);</code>，结果<code>b2</code>为<code>false</code>。</li></ul></li><li>不等于（!&#x3D;）<ul><li>用于判断两个值是否不相等。例如：<code>boolean c1 = (3!= 4);</code>，结果<code>c1</code>为<code>true</code>。</li></ul></li><li>大于（&gt;）<ul><li>用于判断左边的值是否大于右边的值。例如：<code>boolean d1 = (5 &gt; 3);</code>，结果<code>d1</code>为<code>true</code>。</li></ul></li><li>小于（&lt;）<ul><li>用于判断左边的值是否小于右边的值。例如：<code>boolean e1 = (2 &lt; 3);</code>，结果<code>e1</code>为<code>true</code>。</li></ul></li><li>大于等于（&gt;&#x3D;）<ul><li>用于判断左边的值是否大于等于右边的值。例如：<code>boolean f1 = (3 &gt;= 3);</code>，结果<code>f1</code>为<code>true</code>。</li></ul></li><li>小于等于（&lt;&#x3D;）<ul><li>用于判断左边的值是否小于等于右边的值。例如：<code>boolean g1 = (2 &lt;= 3);</code>，结果<code>g1</code>为<code>true</code>。</li></ul></li></ul></li></ol><h3 id="3-3-逻辑运算符"><a href="#3-3-逻辑运算符" class="headerlink" title="3.3.逻辑运算符"></a>3.3.逻辑运算符</h3><ol><li>逻辑与（&amp;&amp;）和逻辑或（||）<ul><li>逻辑与（&amp;&amp;）<ul><li>当且仅当两个操作数都为<code>true</code>时，结果才为<code>true</code>。例如：<code>boolean a = (3 &gt; 2) &amp;&amp; (4 &lt; 5);</code>，结果<code>a</code>为<code>true</code>；<code>boolean b = (3 &gt; 2) &amp;&amp; (4 &gt; 5);</code>，结果<code>b</code>为<code>false</code>。</li><li>逻辑与具有短路特性，即当第一个操作数为<code>false</code>时，不会再计算第二个操作数。</li></ul></li><li>逻辑或（||）<ul><li>只要两个操作数中有一个为<code>true</code>，结果就为<code>true</code>。例如：<code>boolean c = (3 &gt; 2) || (4 &gt; 5);</code>，结果<code>c</code>为<code>true</code>；<code>boolean d = (3 &lt; 2) || (4 &lt; 5);</code>，结果<code>d</code>为<code>true</code>；<code>boolean e = (3 &lt; 2) || (4 &gt; 5);</code>，结果<code>e</code>为<code>false</code>。</li><li>逻辑或也具有短路特性，即当第一个操作数为<code>true</code>时，不会再计算第二个操作数。</li></ul></li></ul></li><li>逻辑非（!）<ul><li>用于对操作数取反。例如：<code>boolean f =!(3 &gt; 2);</code>，结果<code>f</code>为<code>false</code>。</li></ul></li></ol><h3 id="3-4-位运算符"><a href="#3-4-位运算符" class="headerlink" title="3.4.位运算符"></a>3.4.位运算符</h3><ol><li><p>按位与（&amp;）、按位或（|）、按位异或（^）和取反（~）</p><ul><li><p>按位与（&amp;）</p><ul><li>对两个操作数的每一位进行与操作。例如：<code>int a = 5 &amp; 3;</code>，5 的二进制是<code>101</code>，3 的二进制是<code>011</code>，按位与后得到<code>001</code>，即<code>a</code>为 1。</li></ul></li><li><p>按位或（|）</p><ul><li>对两个操作数的每一位进行或操作。例如：<code>int b = 5 | 3;</code>，得到<code>111</code>，即<code>b</code>为 7。</li></ul></li><li><p>按位异或（^）</p><ul><li>对两个操作数的每一位进行异或操作。相同为 0，不同为 1。例如：<code>int c = 5 ^ 3;</code>，得到<code>110</code>，即<code>c</code>为 6。</li></ul></li><li><p>取反（~）</p><ul><li>对操作数的每一位进行取反操作。例如：<code>int d = ~5;</code>，5 的二进制是<code>00000101</code>，取反后得到<code>11111010</code>，即<code>d</code>为 - 6（在有符号二进制表示中）。</li></ul><p>计算机中负数使用补码表示：</p><p>6：00000000 00000000 00000000 00000110</p><p>取反：11111111 11111111 11111111 11111001</p><p>加1：11111111 11111111 11111111 11111010    —–》-6</p></li></ul></li><li><p>左移（&lt;&lt;）、右移（&gt;&gt;）和无符号右移（&gt;&gt;&gt;）</p><ul><li>左移（&lt;&lt;）<ul><li>将操作数的二进制位向左移动指定的位数，右边补 0。例如：<code>int e = 2 &lt;&lt; 1;</code>，2 的二进制是<code>00000010</code>，左移 1 位后得到<code>00000100</code>，即<code>e</code>为 4。</li></ul></li><li>右移（&gt;&gt;）<ul><li>将操作数的二进制位向右移动指定的位数，左边补符号位。例如：<code>int f = 4 &gt;&gt; 1;</code>，4 的二进制是<code>00000100</code>，右移 1 位后得到<code>00000010</code>，即<code>f</code>为 2。</li></ul></li><li>无符号右移（&gt;&gt;&gt;）<ul><li>将操作数的二进制位向右移动指定的位数，左边补 0。例如：<code>int g = -4 &gt;&gt;&gt; 1;</code>，-4 的二进制是<code>11111100</code>，无符号右移 1 位后得到<code>01111110</code>，即<code>g</code>为 126。</li></ul></li></ul></li></ol><h3 id="3-5-赋值运算符"><a href="#3-5-赋值运算符" class="headerlink" title="3.5.赋值运算符"></a>3.5.赋值运算符</h3><ol><li>基本赋值运算符（&#x3D;）和复合赋值运算符<ul><li>基本赋值运算符（&#x3D;）<ul><li>用于将一个值赋给一个变量。例如：<code>int x = 5;</code>，将 5 赋给变量<code>x</code>。</li></ul></li><li>复合赋值运算符<ul><li>包括<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>等。例如：<code>int y = 3; y += 2;</code>等价于<code>y = y + 2;</code>，结果<code>y</code>为 5。</li></ul></li></ul></li></ol><h3 id="3-6-条件运算符（-）-三元运算符"><a href="#3-6-条件运算符（-）-三元运算符" class="headerlink" title="3.6.条件运算符（?:）&#x2F;三元运算符"></a>3.6.条件运算符（?:）&#x2F;三元运算符</h3><ol><li>语法和示例<ul><li>语法为<code>condition? expression1 : expression2</code>。当<code>condition</code>为<code>true</code>时，返回<code>expression1</code>的值；当<code>condition</code>为<code>false</code>时，返回<code>expression2</code>的值。例如：<code>int a = (3 &gt; 2)? 5 : 10;</code>，结果<code>a</code>为 5。</li></ul></li></ol><h2 id="4-随机数"><a href="#4-随机数" class="headerlink" title="4.随机数"></a>4.随机数</h2><h3 id="4-1-Math-random-方法"><a href="#4-1-Math-random-方法" class="headerlink" title="4.1.Math.random()方法"></a>4.1.<code>Math.random()</code>方法</h3><ol><li>基本原理<ul><li><code>Math.random()</code>是<code>java.lang.Math</code>类中的一个静态方法，它会返回一个大于等于 0.0 且小于 1.0 的双精度随机浮点数。</li><li>每次调用<code>Math.random()</code>都会生成一个新的随机数。它的实现基于伪随机数生成器（Pseudo - Random Number Generator，简称 PRNG），在内部会维护一个种子值，通过特定的算法根据种子值生成随机数序列。</li></ul></li><li>使用方法<ul><li>例如，要生成一个 0 到 9 之间的随机整数，可以使用以下代码：</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">randomNumber</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(Math.random() * <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><ul><li>这里首先<code>Math.random()</code>生成一个 0 到 1 之间的浮点数，然后乘以 10 得到一个 0 到 10 之间（不包含 10）的浮点数，最后通过强制类型转换<code>(int)</code>将其转换为整数，得到 0 到 9 之间的随机整数。</li><li>如果要生成一个指定范围内的随机整数，例如<code>min</code>到<code>max</code>（包含<code>min</code>和<code>max</code>），可以使用以下公式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">randomInRange</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(Math.random() * (max - min + <span class="hljs-number">1</span>)) + min;<br></code></pre></td></tr></table></figure><h3 id="4-2-java-util-Random类"><a href="#4-2-java-util-Random类" class="headerlink" title="4.2.java.util.Random类"></a>4.2.<code>java.util.Random</code>类</h3><ol><li>创建对象<ul><li>可以通过<code>new</code>关键字创建<code>Random</code>类的实例，例如：</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-comment">// 使用random对象生成随机数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Random</code>类也有一个可以传入种子值的构造函数，例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">seededRandom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">12345</span>);<br></code></pre></td></tr></table></figure><ul><li>当使用相同的种子值创建<code>Random</code>对象时，它们会生成相同的随机数序列，这在需要重现随机数序列的场景中很有用。</li></ul><ol><li>常用方法<ul><li><code>nextInt()</code>方法<ul><li>该方法有两种形式：<ul><li>无参数形式：<code>nextInt()</code>会返回一个随机的整数，其范围是整个整数范围（负无穷到正无穷，但实际上受限于<code>int</code>类型的范围）。例如：</li></ul></li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">randomInt</span> <span class="hljs-operator">=</span> random.nextInt();<br></code></pre></td></tr></table></figure><ul><li>有参数形式：<code>nextInt(int n)</code>会返回一个大于等于 0 且小于<code>n</code>的随机整数。例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">randomInRange</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-number">10</span>); <span class="hljs-comment">// 生成0到9之间的随机整数</span><br></code></pre></td></tr></table></figure><ul><li><code>nextDouble()</code>方法<ul><li>它返回一个大于等于 0.0 且小于 1.0 的随机双精度浮点数，与<code>Math.random()</code>类似，但使用<code>Random</code>类可以更方便地结合其他随机数生成方法使用。例如：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-type">double</span> <span class="hljs-variable">randomDouble</span> <span class="hljs-operator">=</span> random.nextDouble();<br></code></pre></td></tr></table></figure><ul><li><code>nextBoolean()</code>方法<ul><li>用于生成一个随机的布尔值（<code>true</code>或<code>false</code>）。例如：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-type">boolean</span> <span class="hljs-variable">randomBoolean</span> <span class="hljs-operator">=</span> random.nextBoolean();<br></code></pre></td></tr></table></figure><h3 id="4-3-java-security-SecureRandom类"><a href="#4-3-java-security-SecureRandom类" class="headerlink" title="4.3. java.security.SecureRandom类"></a>4.3. <code>java.security.SecureRandom</code>类</h3><ol><li>安全性特点<ul><li><code>SecureRandom</code>类用于生成安全的随机数，适用于加密、安全协议等对随机数质量要求较高的场景。它基于更复杂的随机源（如操作系统的随机事件）来生成随机数，相比<code>Math.random()</code>和<code>Random</code>类，具有更高的随机性和不可预测性。</li></ul></li><li>使用方法<ul><li>与<code>Random</code>类类似，也可以通过<code>new</code>关键字创建<code>SecureRandom</code>类的实例，例如：</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.security.SecureRandom;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecureRandomExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SecureRandom</span> <span class="hljs-variable">secureRandom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecureRandom</span>();<br>        <span class="hljs-comment">// 使用secureRandom对象生成安全随机数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><pre><code class="hljs">SecureRandom<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>  类也有一些方法用于生成不同类型的随机数，例如：<br><br>  - `nextInt()`方法<br>    - 与`Random`类的`nextInt`方法类似，例如：<br><br>```java<br>         SecureRandom secureRandom = <span class="hljs-keyword">new</span> SecureRandom()<span class="hljs-comment">;</span><br>         int secureRandomInt = secureRandom.nextInt(<span class="hljs-number">10</span>)<span class="hljs-comment">; // 生成0到9之间的安全随机整数</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p><code>nextBytes(byte[] bytes)</code>方法</p><ul><li>用于填充一个字节数组，使其包含随机字节数据。例如：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] randomBytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">16</span>];<br><span class="hljs-type">SecureRandom</span> <span class="hljs-variable">secureRandom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecureRandom</span>();<br>secureRandom.nextBytes(randomBytes);<br></code></pre></td></tr></table></figure><ul><li>这种生成随机字节数组的功能在加密算法（如生成密钥、初始化向量等）中非常有用。</li></ul><h2 id="5-流程控制（复习）"><a href="#5-流程控制（复习）" class="headerlink" title="5.流程控制（复习）"></a>5.流程控制（复习）</h2><h3 id="5-1-分支的嵌套使用"><a href="#5-1-分支的嵌套使用" class="headerlink" title="5.1.分支的嵌套使用"></a>5.1.分支的嵌套使用</h3><p>会员积分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String [] args)</span>&#123;<br><span class="hljs-comment">//会员积分</span><br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.print(<span class="hljs-string">&quot;请输入会员积分：&quot;</span>);<br><span class="hljs-comment">//int score=sc.nextInt();//输入浮点型、负数、字符会报错，使用hasNextInt()来防止错误输入</span><br>        <span class="hljs-keyword">if</span>(sc.hasNextDouble()) &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> sc.nextDouble();<br>            <span class="hljs-keyword">if</span>(score&gt;=<span class="hljs-number">8000</span>) System.out.println(<span class="hljs-string">&quot;会员六折&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(score&gt;=<span class="hljs-number">4000</span>) System.out.println(<span class="hljs-string">&quot;会员七折&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(score&gt;=<span class="hljs-number">2000</span>) System.out.println(<span class="hljs-string">&quot;会员八折&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(score&gt;=<span class="hljs-number">0</span>) System.out.println(<span class="hljs-string">&quot;会员九折&quot;</span>);<br>            <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;无折扣&quot;</span>);<br>            <br>        &#125;<br>        <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;输入错误&quot;</span>);<br><span class="hljs-comment">//**if判断失败进入下一个else；**</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>小朋友搬桌子：年龄大于7，可以搬</p><p>大于5岁，性别是男，可以搬</p><p>否则不可搬</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入年龄：&quot;</span>);<br>        <span class="hljs-type">int</span> age=sc.nextInt();<br>        <span class="hljs-keyword">if</span>(age&gt;=<span class="hljs-number">7</span>) System.out.println(<span class="hljs-string">&quot;可以搬&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(age&gt;=<span class="hljs-number">5</span>)&#123;<br>    System.out.println(<span class="hljs-string">&quot;请输入性别&quot;</span>);<br>            String sex=sc.next();<br>            <span class="hljs-type">char</span> s=sex.charAt(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(s==<span class="hljs-string">&#x27;男&#x27;</span>)System.out.println(<span class="hljs-string">&quot;可以搬&quot;</span>);<br>            <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;不能搬&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;不能搬&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//String类的charAt(n);方法用于获得字符串的单个字符</span><br></code></pre></td></tr></table></figure><p>根据学生分数判断等级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入学生成绩：&quot;</span>);<br>        <span class="hljs-keyword">if</span>(sc.hasNextInt())&#123;<br>            <span class="hljs-type">int</span> score=sc.nextInt();<br>            <span class="hljs-keyword">switch</span>(score/<span class="hljs-number">10</span>)&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>: <span class="hljs-comment">//System.out.println(&quot;A&quot;);break;</span><br>                <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: System.out.println(<span class="hljs-string">&quot;A&quot;</span>);<span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: System.out.println(<span class="hljs-string">&quot;B&quot;</span>);<span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: System.out.println(<span class="hljs-string">&quot;C&quot;</span>);<span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: System.out.println(<span class="hljs-string">&quot;D&quot;</span>);<span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:  System.out.println(<span class="hljs-string">&quot;E&quot;</span>);<span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-comment">// System.out.println(&quot;E&quot;);break;</span><br>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-comment">// System.out.println(&quot;E&quot;);break;</span><br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">// System.out.println(&quot;E&quot;);break;</span><br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">// System.out.println(&quot;E&quot;);break;</span><br>                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">// System.out.println(&quot;E&quot;);break;</span><br><br>                    defalut: System.out.println(<span class="hljs-string">&quot;无效成绩&quot;</span>);<br>            &#125;<br><br><br>        &#125;<span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;输入错误&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//case下的操作一样可以省略</span><br>模板：<br><span class="hljs-keyword">switch</span>(表达式)&#123;<br>    <span class="hljs-keyword">case</span> 值:操作;<span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 值:操作;<span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 值:操作;<span class="hljs-keyword">break</span>;<br>    ....<br>        defalut: 操作;<br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="5-2循环"><a href="#5-2循环" class="headerlink" title="5.2循环"></a>5.2循环</h3><h4 id="5-2-1for"><a href="#5-2-1for" class="headerlink" title="5.2.1for"></a>5.2.1for</h4><ol><li>基本语法<ul><li>基本形式为<code>for(初始化表达式; 布尔表达式; 更新表达式) &#123;循环体&#125;</code>。</li><li>例如：</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里初始化表达式<code>int i = 0</code>定义并初始化循环变量，布尔表达式<code>i &lt; 5</code>用于判断循环是否继续，更新表达式<code>i++</code>在每次循环后更新循环变量。</li></ul><ol start="2"><li>增强 for 循环（foreach）</li></ol><ul><li>语法为<code>for(元素类型 元素变量 : 数组或集合) &#123;循环体&#125;</code>。</li><li>用于遍历数组或集合。例如，遍历数组：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> number : numbers) &#123;<br>    System.out.println(number);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里<code>number</code>依次代表数组<code>numbers</code>中的每个元素。</li><li>遍历集合（以<code>ArrayList</code>为例）：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br>ArrayList&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>names.add(<span class="hljs-string">&quot;Alice&quot;</span>);<br>names.add(<span class="hljs-string">&quot;Bob&quot;</span>);<br>names.add(<span class="hljs-string">&quot;Charlie&quot;</span>);<br><span class="hljs-keyword">for</span>(String name : names) &#123;<br>    System.out.println(name);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-2-while-循环"><a href="#5-2-2-while-循环" class="headerlink" title="5.2.2.while 循环"></a>5.2.2.while 循环</h4><ol><li>基本语法<ul><li>语法为<code>while(布尔表达式) &#123;循环体&#125;</code>。</li><li>例如：</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(j &lt; <span class="hljs-number">3</span>) &#123;<br>    System.out.println(j);<br>    j++;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>只要布尔表达式<code>j &lt; 3</code>为真，循环体就会执行，并且在循环体中通过<code>j++</code>更新循环变量。</li></ul><ol start="2"><li>do - while 循环</li></ol><ul><li>语法为<code>do &#123;循环体&#125; while(布尔表达式);</code>。</li><li>与 while 循环不同的是，do - while 循环先执行一次循环体，再判断布尔表达式。例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span> &#123;<br>    System.out.println(k);<br>    k++;<br>&#125; <span class="hljs-keyword">while</span>(k &lt; <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><ul><li>这里即使布尔表达式一开始不成立，循环体也会执行一次。</li></ul><h4 id="5-2-3-循环控制语句"><a href="#5-2-3-循环控制语句" class="headerlink" title="5.2.3.循环控制语句"></a>5.2.3.循环控制语句</h4><ol><li>break 语句<ul><li>用于跳出当前循环。</li><li>在 for 循环中的应用：</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">5</span>) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当<code>i</code>等于 5 时，执行<code>break</code>，循环立即结束，只会输出 0 到 4。</li><li>在 while 循环中的应用：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span>(m == <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    System.out.println(m);<br>    m++;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里通过<code>while(true)</code>创建一个无限循环，但当<code>m</code>等于 3 时，<code>break</code>语句<code>跳出循环</code>。</li></ul><ol start="2"><li>continue 语句</li></ol><ul><li>用于<code>跳过当前循环的剩余语句，直接进入下一次循环</code>。</li><li>在 for 循环中的应用：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; n &lt; <span class="hljs-number">5</span>; n++) &#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    System.out.println(n);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当<code>n</code>等于 2 时，执行<code>continue</code>，跳过本次循环中<code>System.out.println(n);</code>这一语句，直接进入下一次循环，会输出 0、1、3、4。</li><li>在 while 循环中的应用：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(p &lt; <span class="hljs-number">5</span>) &#123;<br>    p++;<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    System.out.println(p);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当<code>p</code>等于 3 时，执行<code>continue</code>，跳过本次循环的输出语句，会输出 1、2、4、5。</li></ul><ol start="3"><li>return</li></ol><ul><li><code>直接结束程序</code></li></ul><h4 id="5-2-4-多重循环嵌套"><a href="#5-2-4-多重循环嵌套" class="headerlink" title="5.2.4.多重循环嵌套"></a>5.2.4.多重循环嵌套</h4><ol><li>乘法口诀</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<br>            <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">do</span>&#123;<br>                System.out.print(j+<span class="hljs-string">&quot;*&quot;</span>+i+<span class="hljs-string">&quot;=&quot;</span>+i*j+<span class="hljs-string">&quot;\t&quot;</span>);<br>                j++;<br>            &#125;<span class="hljs-keyword">while</span> (j&lt;=i);<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>百钱买百鸡</li></ol><p>公鸡5文钱一只，母鸡3文钱一只，小鸡3只一文钱，用100文钱买一百只鸡，其中公鸡，母鸡，小鸡都必须要有，问公鸡，母鸡，小鸡要买多少只刚好凑足100文钱。</p><p>公鸡：x,</p><p>母鸡：y,</p><p>小鸡：z</p><p>x+y+z&#x3D;100;</p><p>5x+3y+z&#x2F;3&#x3D;100;</p><p><code>暴力</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;=<span class="hljs-number">100</span>;x++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=<span class="hljs-number">1</span>;y&lt;=<span class="hljs-number">100</span>;y++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> z=<span class="hljs-number">1</span>;z&lt;=<span class="hljs-number">100</span>;z++)&#123;<br><span class="hljs-keyword">if</span>((x+y+z==<span class="hljs-number">100</span>)&amp;&amp;(<span class="hljs-number">5</span>*x+<span class="hljs-number">3</span>*y+z/<span class="hljs-number">3</span>==<span class="hljs-number">100</span>)&amp;&amp;(z%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>))<br>System.out.println(x+<span class="hljs-string">&quot;\t&quot;</span>+y+<span class="hljs-string">&quot;\t&quot;</span>+z+<span class="hljs-string">&quot;\t&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>优化</code></p><p>循环的最的值考虑最多能买多少只；把z的循环去除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;=<span class="hljs-number">19</span>;x++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=<span class="hljs-number">1</span>;y&lt;=<span class="hljs-number">31</span>;y++)&#123;<br><span class="hljs-type">int</span> z=<span class="hljs-number">100</span>-x-y;<br><span class="hljs-keyword">if</span>((<span class="hljs-number">5</span>*x+<span class="hljs-number">3</span>*y+z/<span class="hljs-number">3</span>==<span class="hljs-number">100</span>)&amp;&amp;(z%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>))<br>System.out.println(x+<span class="hljs-string">&quot;\t&quot;</span>+y+<span class="hljs-string">&quot;\t&quot;</span>+z+<span class="hljs-string">&quot;\t&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-方法、数组"><a href="#6-方法、数组" class="headerlink" title="6.方法、数组"></a>6.方法、数组</h2><h3 id="6-1-方法"><a href="#6-1-方法" class="headerlink" title="6.1.方法"></a>6.1.方法</h3><ul><li>和c\c++中的函数性质一样</li></ul><ol><li>面试题：两个数是否交换成功</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b=<span class="hljs-number">20</span>;<br>System.out.println(<span class="hljs-string">&quot;输出交换前的两个数：&quot;</span>+a+<span class="hljs-string">&quot;---&quot;</span>+b);<br>changeNum(a,b);<br>System.out.println(<span class="hljs-string">&quot;输出交换后的两个数：&quot;</span>+a+<span class="hljs-string">&quot;---&quot;</span>+b);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num1,<span class="hljs-type">int</span> num2)</span>&#123;<br><span class="hljs-type">int</span> t;<br>t=num1;<br>num1=num2;<br>num2=t;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>答案：不一样，<code>Java中一切都是值传递</code>，交换的只是形参。</p></blockquote><ol start="2"><li><code>方法重载Overload</code></li></ol><p>定义：</p><ul><li>在同一个类中，方法签名（Method Signature）不同,即方法名相同，形参列表不同，构成了方法的重载</li><li>方法的重载只和方法的<code>形参列表</code>和<code>方法名</code>有关，与<code>修饰符</code>，<code>返回值类型</code>无关</li></ul><ol start="3"><li><code>方法重写Override</code></li></ol><p>定义：</p><ul><li>在子类中对于父类方法的重写，方法签名（Method Signature）相同，即修饰符，返回值类型，方法名，形参列表都相同，构成了方法的重写。</li></ul><ol start="4"><li><code>静态绑定和动态绑定</code></li></ol><ul><li>静态绑定（编译时绑定）：</li><li><ul><li>编译代码时就确定调用的方法</li><li>常见于重载的方法，private，static，final修饰的方法以及构造方法默认静态绑定</li></ul></li><li>动态绑定（运行时绑定）：</li><li><ul><li>运行中才能确定调用的是哪个方法</li><li>常见于重写的方法，private，static，final修饰的方法以及构造方法以外的方法。</li></ul></li></ul><h3 id="6-2-数组"><a href="#6-2-数组" class="headerlink" title="6.2.数组"></a>6.2.数组</h3><ul><li><code>java中的数组以对象形象存储在堆区，对象的引用存储在栈区。</code></li></ul><h4 id="6-2-1数组的初始化以及常用操作"><a href="#6-2-1数组的初始化以及常用操作" class="headerlink" title="6.2.1数组的初始化以及常用操作"></a>6.2.1数组的初始化以及常用操作</h4><ol><li>声明数组</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr;<br><span class="hljs-type">int</span> arr2[];<br><span class="hljs-type">int</span>[] arr3=<span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><blockquote><p>如果数组只声明，没有后续操作相当于没定义。</p><p>在反编译代码中没有相应操作</p><p>辨别：数组赋值为null和什么都没有赋值 不一样</p></blockquote><ol start="2"><li>创建</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">arr =<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<span class="hljs-comment">//给数组开辟了一个长度为4的空间</span><br></code></pre></td></tr></table></figure><blockquote><p>编译期声明和创建会被合为一句话</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>[] arr=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">4</span>];<br><span class="hljs-comment">//java;java中的数组是对象，在创建时会自动初始化为默认值；Java有自动垃圾回收机制（Garbage Collection，GC），程序员不需要显示的释放内存。有严格的边界检查机制，越界访问时会抛出异常</span><br><br><span class="hljs-type">int</span>* arr=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">4</span>]; <br><span class="hljs-keyword">delete</span>[] arr;<br><span class="hljs-comment">//c++ new会调用相应的构造函数来初始化对象；使用完后需要程序员使用delete[]来释放内存。没有数组边界检查机制，越界访问会使程序崩溃或产生未定义行为</span><br><br><span class="hljs-type">int</span> n=<span class="hljs-number">4</span>;<br><span class="hljs-type">int</span>* arr=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(n*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-built_in">free</span>(arr);<br><span class="hljs-comment">//malloc分配的内存是未初始化的，使用之前需要自行初始化。使用后需要程序员使用free（）来释放内存。没有数组边界检查机制，越界访问会使程序崩溃或产生未定义行为</span><br><br></code></pre></td></tr></table></figure><blockquote><p>在c&#x2F;c++&#x2F;java中分配的内存都在堆区</p></blockquote><ol start="3"><li>使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">arr[<span class="hljs-number">0</span>]=<span class="hljs-number">12</span>;<br>arr[<span class="hljs-number">1</span>]=<span class="hljs-number">47</span>;<br>...<br></code></pre></td></tr></table></figure><ol start="4"><li>使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(arr[<span class="hljs-number">2</span>]);<br>System.out.println(arr[<span class="hljs-number">0</span>]+<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><blockquote><p>通过数组一个属性来获取  length 长度</p></blockquote><p><code> arr.length</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;数组的长度使：&quot;</span>+arr.length);<br></code></pre></td></tr></table></figure><ol start="5"><li><p>数组的三种初始化</p><ul><li>静态初始化&#x2F;&#x2F;直接赋值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr=&#123;<span class="hljs-number">12</span>,<span class="hljs-number">23</span>,<span class="hljs-number">45</span>&#125;;<br><span class="hljs-type">int</span>[] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">12</span>,<span class="hljs-number">23</span>,<span class="hljs-number">45</span>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li><pre><code class="java">int[] arr=new int[3]&#123;12,23,45&#125;;---》;错误<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><br><span class="hljs-attribute">2</span>. ~~~Java<br>   <span class="hljs-attribute">int</span>[] arr;<br>   <span class="hljs-attribute">arr</span>=&#123;<span class="hljs-number">12</span>,<span class="hljs-number">23</span>,<span class="hljs-number">34</span>&#125;;---&gt;错误<br></code></pre></td></tr></table></figure></code></pre></li></ol></blockquote><ul><li>动态初始化&#x2F;&#x2F;定义和赋值分开</li></ul><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr;<br>arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<span class="hljs-comment">//int[] arr=new int[3];</span><br>arr[<span class="hljs-number">0</span>]=<span class="hljs-number">12</span>;<br>arr[<span class="hljs-number">1</span>]=<span class="hljs-number">23</span>;<br>arr[<span class="hljs-number">2</span>]=<span class="hljs-number">45</span>;<br></code></pre></td></tr></table></figure></blockquote><ul><li>默认初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span>[] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<span class="hljs-comment">//每个里面都是0</span><br>Boolean[] b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>[<span class="hljs-number">3</span>];<span class="hljs-comment">//每个里面都是false</span><br></code></pre></td></tr></table></figure></li><li><p><code> 最值问题</code>&#x2F;&#x2F;选择排序&#x2F;&#x2F;冒泡排序&#x2F;&#x2F;<code> 数组的复制</code></p></li></ol><ul><li><p>给定一个数组求数组的最大值并且排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span>[] arr=&#123;<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">125</span>,<span class="hljs-number">9</span>,<span class="hljs-number">45</span>&#125;;<br>        <span class="hljs-type">int</span> maxNum=arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span>[] arr1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>        <span class="hljs-type">int</span>[] arr2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>        System.arraycopy(arr,<span class="hljs-number">0</span>,arr1,<span class="hljs-number">0</span>,arr.length);<br>        System.arraycopy(arr,<span class="hljs-number">0</span>,arr2,<span class="hljs-number">0</span>,arr.length);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:arr)<span class="hljs-comment">//找出最大值</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(x&gt;maxNum)<br>                maxNum=x;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;最大值：&quot;</span>+maxNum);<br><br>        <span class="hljs-type">int</span> temp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr1.length-<span class="hljs-number">1</span>;i++)<span class="hljs-comment">//冒泡排序，从大到小</span><br>        &#123;<span class="hljs-comment">//遍历数组，比当前大就互换</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;arr1.length;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(arr1[i]&lt;arr1[j]) &#123;<br>                    temp=arr1[i];<br>                    arr1[i]=arr1[j];<br>                    arr1[j]=temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.printf(<span class="hljs-string">&quot;从大到小：&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:arr1)<br>            System.out.print(x+<span class="hljs-string">&quot;\t&quot;</span>);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr2.length-<span class="hljs-number">1</span>;i++)&#123;<span class="hljs-comment">//从小到大；</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;arr2.length;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(arr2[i]&gt;arr2[j])&#123;<br>                    temp=arr2[i];<br>                    arr2[i]=arr2[j];<br>                    arr2[j]=temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.printf(<span class="hljs-string">&quot;\n从小到大：&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y:arr2)<br>            System.out.print(y+<span class="hljs-string">&quot;\t&quot;</span>);<br>        System.out.printf(<span class="hljs-string">&quot;\n原数组：&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> z:arr)<br>            System.out.print(z+<span class="hljs-string">&quot;\t&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//冒泡排序</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length-<span class="hljs-number">1</span>;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;arr.length-<span class="hljs-number">1</span>-i;j++)&#123;<br><span class="hljs-type">int</span> temp;<br><span class="hljs-keyword">if</span>(arr[j]&gt;arr[j+<span class="hljs-number">1</span>])&#123;<br>temp=arr[j+<span class="hljs-number">1</span>];<br>arr[j+<span class="hljs-number">1</span>]=arr[j];<br>arr[j]=temp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/.com//image-20241023144932770.png" alt="image-20241023144932770"></p></li></ul><blockquote><p>注意点：-</p><ul><li>选择排序的边界问题</li><li>选择排序- 第一个先和后面所有的比，完全确定第一个，再第二个和后面所有的比较，依次往后走一个开始。</li></ul><blockquote><p>两个指针参数i，j,一个【0，length-1）；一个【1，length）</p></blockquote><p>注：j&#x3D;(i+1)</p><p><img src="/.com//image-20241023150558249.png" alt="image-20241023150558249"></p><ul><li><p>冒泡排序的边界问题</p></li><li><p>从第一个开始每次相邻两个比较，比较一轮可以确定最后一个，依次往后每次从头开始。</p><p><img src="/.com//image-20250222173943751.png" alt="image-20250222173943751"></p></li></ul></blockquote><blockquote><ul><li>复制数组的方式</li></ul><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span>[] arr1=arr;<br><span class="hljs-type">int</span>[] arr2=arr;<span class="hljs-comment">//这种复制方式只是让arr1和arr2指向了与arr相同的数组对象</span><br></code></pre></td></tr></table></figure><p>这种方式属于<code> arr对象的引用</code>，在Java中数组是对象</p><p>想要不改变原数组并且独立的对数组进行不同排序应该使用<code> System.arraycopy(sourceArray,sourcepos,destinationArray,destinationpos,length)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br><span class="hljs-type">int</span>[] arr2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>System.arraycopy(arr,<span class="hljs-number">0</span>,arr1,<span class="hljs-number">0</span>,length);<br>System.arraycopy(arr,<span class="hljs-number">0</span>,arr1,<span class="hljs-number">0</span>,length);<br></code></pre></td></tr></table></figure><p>System.arraycopy是一个本地方法，直接在内存层面进行数据复制，效率比普通的循环遍历复制效率高</p></blockquote></blockquote><h4 id="6-2-2数组-详述-main方法"><a href="#6-2-2数组-详述-main方法" class="headerlink" title="6.2.2数组_详述 main方法"></a>6.2.2数组_详述<code> main</code>方法</h4><ol><li>main方法：程序的入口，在同一个类中，如果有多个方法，那么虚拟机就会识别main方法，从这个方法作为程序的入口</li><li>main方法格式严格要求：</li></ol><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>public static —&gt;修饰符  &#x2F;&#x2F;面对对象的知识</p><p>void —&gt;代表方法没有返回值</p><p>String[] args —&gt;形参—》不确定因素</p></blockquote><ol start="3"><li>问题：程序中是否可以有其它的方法也叫main方法？</li></ol><blockquote><p>可以，构成了函数的重载</p><ul><li><p>在 Java 中，一个类中只能有一个<code>public static void main(String[] args)</code>方法作为程序的入口点。</p></li><li><p>如果在一个类中定义了多个<code>main</code>方法，并且其中只有一个是<code>public static void main(String[] args)</code>这种形式，那么只有这个符合规定的<code>main</code>方法会被 Java 虚拟机（JVM）识别并作为程序启动的入口。</p></li><li><p><code> c/c++</code>中只能有一个<code> main</code>函数作为程序的入口，如果有多个链接器不知道哪个才是程序的入口。</p></li></ul></blockquote><ol start="4"><li>String[] args实参到底是什么</li></ol><blockquote><p>可以手动传入实参，参数是String[],实参是 new String[0]  </p><p>默认情况下，虚拟机在调用main方法的时候就是传入了一个长度为0的数组</p></blockquote><h4 id="6-2-3数组-可变参数"><a href="#6-2-3数组-可变参数" class="headerlink" title="6.2.3数组__可变参数"></a>6.2.3数组__<code>可变参数</code></h4><ol><li>可变参数：作用提供了一个方法，参数的个数是可变的(jdk1.5之后的版本)</li></ol><blockquote><p>解决了部分方法重载的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    method01(<span class="hljs-number">10</span>);<br>    method01();<br>    method01(<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>);<br>    method01(<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>,<span class="hljs-number">60</span>,<span class="hljs-number">70</span>);<br>    method01(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>&#125;);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meyhod01</span><span class="hljs-params">(<span class="hljs-type">int</span>...num)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;---1&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><ol start="2"><li>对于参数的处理</li></ol><blockquote><p>方法的内部对可变参数的处理跟数组是一样（内部隐式创建一个数组来存储这些参数）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method01</span><span class="hljs-params">(<span class="hljs-type">int</span>...num)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;---1&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:num)&#123;<br>System.out.println(i+<span class="hljs-string">&quot;\t&quot;</span>);<br>&#125;<br>System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure><p>依次输出参数</p></blockquote><ol start="3"><li>在可变参数的基础上再加一个参数</li></ol><blockquote><ul><li><p>可变参数一定要放在最后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method01</span><span class="hljs-params">(<span class="hljs-type">int</span> num2,<span class="hljs-type">int</span>...num)</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></blockquote><ol start="4"><li>可变参数不建议使用</li></ol><h2 id="7-面对对象"><a href="#7-面对对象" class="headerlink" title="7.面对对象"></a>7.面对对象</h2><blockquote><ul><li><p>万事万物皆对象</p></li><li><p>对象：具体的事物，实体</p></li><li><p>类：对对象向上抽取的部分，形成类，类是抽象的，一个模板</p></li><li><blockquote><p> 权限修饰符：private（本身类中）&lt;defalut(默认)同一个包&lt;protect（类中，子类中）&lt;public（全都可以）</p><p>java中私有属性不能被直接继承</p></blockquote></li><li><p>先有父类再有子类—》继承；先有子类再有父类—-》泛化</p></li><li><p>类是一个引用变量指向堆中的实例</p></li></ul></blockquote><h3 id="7-1、面向对象编程的基本概念"><a href="#7-1、面向对象编程的基本概念" class="headerlink" title="7.1、面向对象编程的基本概念"></a><strong>7.1、面向对象编程的基本概念</strong></h3><h4 id="7-1-1-类（Class）—》引用数据类型"><a href="#7-1-1-类（Class）—》引用数据类型" class="headerlink" title="7.1.1.类（Class）—》引用数据类型"></a>7.1.1.类（Class）—》引用数据类型</h4><ul><li>类是 Java 中面向对象编程的核心概念之一。它是一种模板或蓝图，用于定义对象的属性和行为。例如，我们可以定义一个<code>Car</code>类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-comment">// 成员变量（属性）</span><br>    <span class="hljs-keyword">private</span> String color;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> speed;<br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(String color, <span class="hljs-type">int</span> speed)</span> &#123;<br>        <span class="hljs-built_in">this</span>.color = color;<br>        <span class="hljs-built_in">this</span>.speed = speed;<br>    &#125;<br>    <span class="hljs-comment">// 成员方法（行为）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The &quot;</span> + color + <span class="hljs-string">&quot; car is driving at &quot;</span> + speed + <span class="hljs-string">&quot; mph.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在这个<code>Car</code>类中，<code>color</code>和<code>speed</code>是属性，<code>drive</code>是行为，而构造方法用于创建<code>Car</code>类的对象。</li></ul><h4 id="7-1-2-对象（Object）"><a href="#7-1-2-对象（Object）" class="headerlink" title="7.1.2.对象（Object）"></a>7.1.2.对象（Object）</h4><ul><li>对象是类的实例。通过使用类的构造方法，我们可以创建对象。例如，使用上面定义的<code>Car</code>类创建对象：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">myCar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-number">60</span>);<br>        myCar.drive();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里<code>myCar</code>就是<code>Car</code>类的一个对象，它具有<code>Car</code>类定义的属性和行为。</li></ul><h4 id="7-1-3-封装（Encapsulation）"><a href="#7-1-3-封装（Encapsulation）" class="headerlink" title="7.1.3.封装（Encapsulation）"></a>7.1.3.封装（Encapsulation）</h4><ul><li>封装是将数据（属性）和操作数据的方法（行为）捆绑在一起，并对数据的访问进行限制。在 Java 中，通常使用<code>private</code>关键字来限制属性的直接访问，然后通过公共的方法（getter 和 setter 方法）来访问和修改属性。例如，在<code>Car</code>类中：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-keyword">private</span> String color;<br>    <span class="hljs-comment">// 获取颜色的getter方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> color;<br>    &#125;<br>    <span class="hljs-comment">// 设置颜色的setter方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColor</span><span class="hljs-params">(String color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>这样可以隐藏内部数据的实现细节，提高代码的安全性和可维护性。</p></li><li><blockquote><p>高内聚：类的内部数据操作细节自己完成，不允许外部干涉；</p><ul><li>低耦合：仅对外部暴露少量的方法用于使用</li></ul></blockquote></li></ul><h4 id="7-1-4-继承（Inheritance）"><a href="#7-1-4-继承（Inheritance）" class="headerlink" title="7.1.4.继承（Inheritance）"></a>7.1.4.继承（Inheritance）</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-type">Java</span>：<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>  <span class="hljs-keyword">extends</span>   <span class="hljs-title">A</span> </span>&#123;&#125;<br><span class="hljs-meta">@override</span><br>public void method（）&#123;&#125;<br><br>c++：<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-title">：public</span> <span class="hljs-title">A</span></span>&#123;&#125;<br>void method() <span class="hljs-keyword">override</span> &#123;&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p><code>java中：</code></p><ul><li>继承允许一个类（子类）继承另一个类（父类）的属性和行为。子类可以在父类的基础上添加新的属性和行为，或者重写父类的方法。例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> wheels;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Vehicle</span><span class="hljs-params">(<span class="hljs-type">int</span> wheels)</span> &#123;<br>        <span class="hljs-built_in">this</span>.wheels = wheels;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The vehicle is moving.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-keyword">private</span> String brand;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(<span class="hljs-type">int</span> wheels, String brand)</span> &#123;<br>        <span class="hljs-built_in">super</span>(wheels);<br>        <span class="hljs-built_in">this</span>.brand = brand;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The car is moving.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里<code>Car</code>类继承自<code>Vehicle</code>类，它继承了<code>wheels</code>属性和<code>move</code>方法，并且可以添加自己的<code>brand</code>属性和重写<code>move</code>方法。</li></ul><p><code>protected</code>常用于在继承关系中，允许子类访问和扩展父类的部分功能。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentClass</span> &#123;<br>       <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> protectedVar;<br>       <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">protectedMethod</span><span class="hljs-params">()</span> &#123;<br>           protectedVar = <span class="hljs-number">20</span>;<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">package</span> anotherpackage;<br>   <span class="hljs-keyword">import</span> mypackage.ParentClass;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ParentClass</span> &#123;<br>       <span class="hljs-keyword">void</span> <span class="hljs-title function_">accessProtected</span><span class="hljs-params">()</span> &#123;<br>           <span class="hljs-comment">// 可以访问父类的protectedVar和protectedMethod</span><br>           protectedVar = <span class="hljs-number">30</span>;<br>           protectedMethod();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p><code> c++中：</code></p><ul><li>C++ 支持类的继承。例如，定义一个<code>Square</code>类继承自<code>Rectangle</code>类：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Rectangle &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Square</span>(<span class="hljs-type">int</span> side) : <span class="hljs-built_in">Rectangle</span>(side, side) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>这里<code>Square</code>类继承了<code>Rectangle</code>类的属性和方法，并且在构造函数中通过调用父类的构造函数来初始化对象。</li><li>还可以重写父类的方法，例如重写<code>area</code>方法（如果有特殊需求）：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Rectangle &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Square</span>(<span class="hljs-type">int</span> side) : <span class="hljs-built_in">Rectangle</span>(side, side) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">getLength</span>();<br>        <span class="hljs-keyword">return</span> l * l;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><h4 id="7-1-5-多态（Polymorphism）"><a href="#7-1-5-多态（Polymorphism）" class="headerlink" title="7.1.5.多态（Polymorphism）"></a>7.1.5.多态（Polymorphism）</h4><blockquote><p><code>java中：</code></p><ul><li>多态有两种主要形式：方法重载（Overloading）和方法重写（Overriding）。</li><li>方法重载是指在一个类中定义多个方法名相同但参数列表不同的方法。例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法重写是指子类重写父类中定义的方法，如上面<code>Car</code>类重写<code>Vehicle</code>类的<code>move</code>方法。多态性使得程序可以根据对象的实际类型来调用相应的方法，增强了代码的灵活性和可扩展性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">animal</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shut</span><span class="hljs-params">()</span>&#123;&#125;;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">animal</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shut</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">animal</span>&#123;<br><span class="hljs-meta">@Override</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shut</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">girl</span> &#123;<br><span class="hljs-meta">@Override</span>    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">(class animal)</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>girl pp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">girl</span>();<br>cat c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">cat</span>();<br>dog d=<span class="hljs-keyword">new</span> <span class="hljs-title class_">dog</span>();<br>animal an=c;<br>pp.play(c);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p><code> c++中：</code></p><ul><li>函数重载是 C++ 实现多态的一种方式。例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MathUtils</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>另一种多态是通过虚函数实现的动态多态。定义一个基类<code>Shape</code>和派生类<code>Circle</code>和<code>Rectangle</code>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> radius;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Circle</span>(<span class="hljs-type">int</span> r) : <span class="hljs-built_in">radius</span>(r) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span> * radius * radius;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-type">int</span> width;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rectangle</span>(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> w) : <span class="hljs-built_in">length</span>(l), <span class="hljs-built_in">width</span>(w) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> length * width;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>这里<code>Shape</code>类中的<code>area</code>函数是虚函数，派生类<code>Circle</code>和<code>Rectangle</code>重写了<code>area</code>函数。当通过基类指针或引用调用<code>area</code>函数时，会根据对象的实际类型调用相应的函数，实现动态多态。</li></ul></blockquote><h4 id="7-1-6-局部变量和成员变量"><a href="#7-1-6-局部变量和成员变量" class="headerlink" title="7.1.6.局部变量和成员变量"></a>7.1.6.局部变量和成员变量</h4><ul><li>局部变量：方法体（函数）中定义的变量，类外定义的变量，需要手动初始化</li><li>成员变量：类中定义且方法体外的变量，可以由类的构造函数自动初始化</li><li>static静态成员变量：类中定义且方法体外的变量，可供类的所以实例使用</li></ul><h4 id="7-1-7-c-和Java中的静态成员变量之间的区别："><a href="#7-1-7-c-和Java中的静态成员变量之间的区别：" class="headerlink" title="7.1.7.c++和Java中的静态成员变量之间的区别："></a>7.1.7.c++和Java中的静态成员变量之间的区别：</h4><blockquote><p>在静态的方法里不能访问非静态的属性；在非静态的方法里都可以访问。</p></blockquote><h5 id="7-1-7-1-定义方式"><a href="#7-1-7-1-定义方式" class="headerlink" title="7.1.7.1.定义方式"></a>7.1.7.1.定义方式</h5><blockquote><ol><li>C++<ul><li>在 C++ 中，类的静态成员变量需要先在类中声明，然后在类外进行定义和初始化。例如：</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVar;<br>&#125;;<br><span class="hljs-type">int</span> MyClass::staticVar = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><ul><li>这里先在<code>MyClass</code>类中声明了<code>staticVar</code>这个静态成员变量，然后在类外通过<code>int MyClass::staticVar = 0;</code>进行定义和初始化。</li></ul><ol start="2"><li>Java</li></ol><ul><li>在 Java 中，可以在声明静态成员变量时直接初始化，或者通过静态代码块初始化。例如：</li><li>直接初始化：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyJavaClass</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">staticVar</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过静态代码块初始化：&#x2F;&#x2F;在类加载的时候直接执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyJavaClass</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> staticVar;<br>    <span class="hljs-keyword">static</span> &#123;<br>        staticVar = <span class="hljs-number">20</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote><h5 id="7-1-7-2内存分配和生命周期"><a href="#7-1-7-2内存分配和生命周期" class="headerlink" title="7.1.7.2内存分配和生命周期"></a>7.1.7.2内存分配和生命周期</h5><blockquote><ol><li>C++</li></ol><ul><li>静态成员变量在程序启动时分配内存，在整个程序运行期间都存在。它在内存中的存储位置与全局变量类似，在数据段。当类的第一个对象被创建之前，静态成员变量就已经存在了。</li><li>例如，当有多个<code>MyClass</code>对象时，它们共享同一个静态成员变量<code>staticVar</code>的存储空间。无论创建多少个<code>MyClass</code>对象，<code>staticVar</code>在内存中只有一份。</li></ul><ol start="2"><li>Java</li></ol><ul><li>在 Java 中，静态成员变量在类加载时被分配内存。当类加载器将类加载到 JVM（Java Virtual Machine）中时，静态成员变量就会被初始化并占用内存空间。</li><li>其生命周期从类加载开始，直到类被卸载。只要类存在于 JVM 中，静态成员变量就一直存在。例如，对于<code>MyJavaClass</code>类，一旦<code>MyJavaClass</code>被加载，其静态变量<code>staticVar</code>就会存在，与是否创建<code>MyJavaClass</code>的对象无关。</li></ul></blockquote><h5 id="7-1-7-3访问方式"><a href="#7-1-7-3访问方式" class="headerlink" title="7.1.7.3访问方式"></a>7.1.7.3访问方式</h5><blockquote><p><code> 类名.静态变量/方法</code></p></blockquote><blockquote><ol><li>C++</li></ol><ul><li>在 C++ 中，可以通过类名直接访问静态成员变量，也可以通过类的对象来访问。例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MyClass obj;<br><span class="hljs-comment">// 通过类名访问</span><br>std::cout &lt;&lt; MyClass::staticVar &lt;&lt; std::endl;<br><span class="hljs-comment">// 通过对象访问</span><br>std::cout &lt;&lt; obj.staticVar &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><ul><li>不过，通过类名访问是更符合规范的方式。</li></ul><ol><li>Java</li></ol><ul><li>在 Java 中，同样可以通过类名直接访问静态成员变量。通过对象访问静态成员变量在语法上是允许的，但不被推荐，因为这容易让人误解静态成员变量与对象相关。例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyJavaClass</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">staticVar</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 通过类名访问</span><br>        System.out.println(MyJavaClass.staticVar);<br>    &#125;<br>        <span class="hljs-type">MyJavaClass</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyJavaClass</span>();<br>        <span class="hljs-comment">// 通过对象访问（不推荐）</span><br>        System.out.println(obj.staticVar);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="7-1-7-4继承中的表现"><a href="#7-1-7-4继承中的表现" class="headerlink" title="7.1.7.4继承中的表现"></a>7.1.7.4继承中的表现</h5><blockquote><ol><li>C++</li></ol><ul><li>在 C++ 中，子类可以继承父类的静态成员变量。如果子类重新定义了父类的同名静态成员变量，那么子类的静态成员变量会隐藏父类的同名静态成员变量。</li><li>例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVar;<br>&#125;;<br><span class="hljs-type">int</span> Parent::staticVar = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> : <span class="hljs-keyword">public</span> Parent &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVar;<br>&#125;;<br><span class="hljs-type">int</span> Child::staticVar = <span class="hljs-number">2</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 访问父类的静态成员变量</span><br>    std::cout &lt;&lt; Parent::staticVar &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 访问子类的静态成员变量</span><br>    std::cout &lt;&lt; Child::staticVar &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在这个例子中，<code>Child</code>类中的<code>staticVar</code>隐藏了<code>Parent</code>类中的<code>staticVar</code>。</li></ul><ol><li>Java</li></ol><ul><li>在 Java 中，子类也可以继承父类的静态成员变量。但是，由于静态成员变量属于类本身，所以通过子类访问父类的静态成员变量时，不存在多态性。</li><li>例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentClass</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">staticVar</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ParentClass</span> &#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 通过父类访问静态成员变量</span><br>        System.out.println(ParentClass.staticVar);<br>        <span class="hljs-comment">// 通过子类访问静态成员变量</span><br>        System.out.println(ChildClass.staticVar);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>这里<code>ChildClass</code>继承了<code>ParentClass</code>的静态成员变量<code>staticVar</code>，通过<code>ChildClass</code>和<code>ParentClass</code>访问到的是同一个变量。</p></li><li><p><strong>子类无法重写父类的静态方法：</strong></p></li><li><p><strong>重写（Override）</strong>：重写是针对实例方法而言的，它是实现多态性的一种方式。当子类重写父类的实例方法时，通过父类引用指向子类对象，调用该方法时会执行子类重写后的方法。重写遵循 “运行时绑定”，即根据实际对象的类型来决定调用哪个方法。</p></li><li><p><strong>隐藏（Hide）</strong>：对于静态方法，由于静态方法属于类本身，而不属于类的实例，子类可以定义与父类相同名称、参数列表和返回类型的静态方法，这被称为静态方法的隐藏。静态方法的调用遵循 “编译时绑定”，即根据引用变量的类型来决定调用哪个方法</p></li></ul></blockquote><h3 id="7-2-static代码块"><a href="#7-2-static代码块" class="headerlink" title="7.2.static代码块"></a>7.2.static代码块</h3><ul><li><p>代码块执行顺序：</p></li><li><blockquote><p>静态块:在类加载的时候执行一次，用于一些全局性的初始化操作</p><ul><li>构造块</li><li>构造器</li><li>普通块</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><span class="hljs-comment">//属性</span><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> sa;<br>    <span class="hljs-comment">//方法</span><br>    <span class="hljs-comment">//代码块</span><br>    <span class="hljs-comment">//构造器</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<span class="hljs-comment">//构造块</span><br>        <span class="hljs-built_in">this</span>.a=a;<br>    &#125;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.a);<span class="hljs-comment">//普通块</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(sa);<br>    &#125;<br>    <span class="hljs-comment">//静态块</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        sa=<span class="hljs-number">10</span>;<br>        System.out.println(sa);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="7-3-导包import"><a href="#7-3-导包import" class="headerlink" title="7.3.导包import"></a>7.3.导包import</h3><h4 id="7-3-1在-Java-中的包（package）和导入（import）"><a href="#7-3-1在-Java-中的包（package）和导入（import）" class="headerlink" title="7.3.1在 Java 中的包（package）和导入（import）"></a>7.3.1在 Java 中的包（package）和导入（import）</h4><blockquote><ul><li>包的创建：名字小写，中间用点隔开，不能用系统的关键字，对应目录路径</li><li>在Java中的导包没有包含和被包含的关系</li></ul></blockquote><ol><li>包（package）的概念与作用<ul><li>概念<ul><li>包是 Java 中用于组织类和接口的一种机制。它类似于文件系统中的文件夹，将相关的类和接口分组在一起。例如，<code>java.util</code>就是一个包，它包含了许多实用工具类，如<code>ArrayList</code>、<code>HashMap</code>等。</li></ul></li><li>作用<ul><li><strong>解决命名冲突</strong>：在大型项目中，不同的开发人员可能会创建同名的类。通过将类放在不同的包中，可以避免这种命名冲突。例如，公司 A 和公司 B 可能都有一个名为<code>Employee</code>的类，但如果公司 A 将其类放在<code>com.companyA</code>包中，公司 B 将其类放在<code>com.companyB</code>包中，就不会产生冲突。</li><li><strong>管理代码结构</strong>：有助于更好地组织和管理代码。例如，与图形相关的类可以放在<code>com.graphics</code>包中，与数据库操作相关的类可以放在<code>com.database</code>包中，使项目的代码结构更加清晰。</li></ul></li></ul></li><li>包的定义与使用<ul><li>定义包<ul><li>在 Java 源文件的开头使用<code>package</code>关键字来定义包。例如：</li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.myproject;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-comment">// 类的内容</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上述代码将<code>MyClass</code>类放在了<code>com.example.myproject</code>包中。源文件所在的目录结构应该与包名的层次结构相对应，即上述类文件应该放在<code>com/example/myproject</code>目录下（在实际的文件系统中，目录用<code>/</code>分隔）。</li><li>访问包中的类<ul><li>要在其他类中访问另一个包中的类，有以下几种方式：</li><li><strong>使用全限定名</strong>：例如，如果要在<code>com.anotherpackage</code>包中的类中使用<code>com.example.myproject.MyClass</code>，可以这样写：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.anotherpackage;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnotherClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        com.example.myproject.<span class="hljs-type">MyClass</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">com</span>.example.myproject.MyClass();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这种方式比较繁琐，但在没有导入包的情况下是可行的。</li></ul><ol start="3"><li>导入（import）语句</li></ol><ul><li>作用<ul><li>为了避免每次使用其他包中的类时都要写全限定名，Java 提供了<code>import</code>语句来导入包中的类。例如：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.anotherpackage;<br><span class="hljs-keyword">import</span> com.example.myproject.MyClass;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnotherClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过<code>import</code>语句，就可以直接使用<code>MyClass</code>类名，而不需要写全限定名。</li><li>通配符导入（*）<ul><li>除了导入单个类，还可以使用通配符<code>*</code>来导入一个包中的所有类。例如：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br></code></pre></td></tr></table></figure><ul><li><p>这将导入<code>java.util</code>包中的所有类。不过需要注意的是，这种导入方式并不会提高程序的运行效率，只是在编写代码时更加方便，但可能会导致命名冲突（如果导入的多个包中有同名类），所以在实际使用中要谨慎。</p></li><li><p>静态导入：<code> static</code>搭配通配符可以导入类中的所有的静态内容</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.*;<br></code></pre></td></tr></table></figure><ul><li>在静态导入以后同一个类中有相同的方法时会优先走自己定义的方法。</li></ul><h4 id="7-3-2-在-C-中的命名空间（namespace）类似概念"><a href="#7-3-2-在-C-中的命名空间（namespace）类似概念" class="headerlink" title="7.3.2.在 C++ 中的命名空间（namespace）类似概念"></a>7.3.2.在 C++ 中的命名空间（namespace）类似概念</h4><ol><li>命名空间（namespace）的概念与作用<ul><li>概念<ul><li>命名空间是 C++ 中用于避免命名冲突的一种机制。它将相关的类型、函数、变量等封装在一个命名空间内。例如：</li></ul></li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> mynamespace &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>        <span class="hljs-comment">// 类的内容</span><br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 函数内容</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>作用<ul><li>与 Java 中的包类似，主要用于解决命名冲突问题。在 C++ 库和大型项目中，不同的模块可能会定义相同名字的函数或类型，通过命名空间可以将它们区分开来。例如，<code>std</code>是 C++ 标准库的命名空间，其中包含了<code>cout</code>、<code>vector</code>等众多标准类型和函数。</li></ul></li></ul><ol start="2"><li>命名空间的使用</li></ol><ul><li>访问命名空间中的成员<ul><li>有以下几种方式访问命名空间中的成员：</li><li><strong>使用全限定名（::）</strong>：例如：</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    mynamespace::MyClass obj;<br>    mynamespace::<span class="hljs-built_in">myFunction</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这种方式每次都要写出命名空间名和作用域解析运算符<code>::</code>，比较麻烦。</li><li><strong>使用<code>using</code>声明</strong>：例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> mynamespace::MyClass;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    mynamespace::<span class="hljs-built_in">myFunction</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过<code>using</code>声明，可以在当前作用域内直接使用<code>MyClass</code>，而不需要写出命名空间名，但对于<code>myFunction</code>，如果要使用，还是需要写出命名空间名，除非也对<code>myFunction</code>进行<code>using</code>声明。</li><li><strong>使用<code>using namespace</code>指令（不推荐在头文件中使用）</strong>：例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> mynamespace;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    <span class="hljs-built_in">myFunction</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这种方式将命名空间中的所有成员都引入到当前作用域，使用起来最方便，但可能会导致命名冲突。如果在头文件中使用<code>using namespace</code>指令，可能会在包含该头文件的多个源文件中产生意外的命名冲突，所以在头文件中一般不建议使用这种方式。</li></ul><h3 id="7-4-super修饰符"><a href="#7-4-super修饰符" class="headerlink" title="7.4.super修饰符"></a>7.4.super修饰符</h3><h4 id="7-4-1调用父类的构造方法"><a href="#7-4-1调用父类的构造方法" class="headerlink" title="7.4.1调用父类的构造方法"></a>7.4.1调用父类的构造方法</h4><ul><li>当子类的构造方法需要调用父类的构造方法时，可以使用super（).</li><li>如果父类有默认构造方法（无参构造方法），在子类构造方法中不写super（）时，编译器会自动添加一个super（）调用。</li><li>例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Parent</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;parent constructor&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Child</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//编译器会自动添加super（）</span><br>System.out.println(<span class="hljs-string">&quot;Child constructor&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>但如果父类没有默认构造方法，子类构造方法必须显示的调用父类的某个构造方法，此时就要有super（参数列表）。例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Parent</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Parent constructor with value:&quot;</span>+value);<br><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Child</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">super</span>(<span class="hljs-number">10</span>);<br>System.out.println(<span class="hljs-string">&quot;Child constructor&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-4-2访问父类的成员（方法和变量）"><a href="#7-4-2访问父类的成员（方法和变量）" class="headerlink" title="7.4.2访问父类的成员（方法和变量）"></a>7.4.2访问父类的成员（方法和变量）</h4><ul><li><p>访问父类的方法</p><ul><li>当子类重写了父类的方法以后，如果子类想要调用父类被重写的方法，可以用<code> super.方法名（参数列表）。</code>例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>System.outprintln(<span class="hljs-string">&quot;Parent print method&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Child print method&quot;</span>);<br><span class="hljs-built_in">super</span>.print();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在<code>Child</code>类的<code>print</code>方法中，先执行了自己的打印语句，然后通过<code>super.print()</code>调用了父类的<code>print</code>方法。</p></li></ul><h4 id="7-4-3访问父类的变量"><a href="#7-4-3访问父类的变量" class="headerlink" title="7.4.3访问父类的变量"></a>7.4.3访问父类的变量</h4><ul><li>类似地，当子类和父类有同名变量时，在子类中可以用<code>super.变量名</code>来访问父类的变量。例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showValues</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Child value: &quot;</span> + <span class="hljs-built_in">this</span>.value);<br>        System.out.println(<span class="hljs-string">&quot;Parent value: &quot;</span> + <span class="hljs-built_in">super</span>.value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-5-Object类"><a href="#7-5-Object类" class="headerlink" title="7.5 Object类"></a>7.5 Object类</h3><ol><li>概述<ul><li>在 Java 中，<code>Object</code>类是所有类的根类。这意味着，所有的 Java 类都直接或间接地继承自<code>Object</code>类。它位于<code>java.lang</code>包中，无需显式导入。</li></ul></li><li>主要方法<ul><li><code>equals(Object obj)</code>方法<ul><li>该方法用于比较两个对象是否相等。在<code>Object</code>类中，<code>equals</code>方法默认的实现是比较两个对象的引用是否相同，即<code>==</code>操作。例如：</li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">     <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>             <span class="hljs-type">Object</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>             <span class="hljs-type">Object</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>             System.out.println(obj1==obj2);<span class="hljs-comment">//一定是false，比较的是地址值</span><br>             System.out.println(obj1.equals(obj2)); <span class="hljs-comment">// 通常返回false，因为是不同对象的引用，比较的也是地址值</span><br>         &#125;<br>     &#125;<br>源码：<span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>&#123;<span class="hljs-comment">//比较地址</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>==obj;<br>&#125;<br><br>通常重写为比较两个类的属性是否相同<br>   <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>&#123;<br>    <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> xxx)&#123;<span class="hljs-comment">//判断obj是否是xxx的实例</span><br>        <span class="hljs-comment">//将obj转为同类型</span><br>    <span class="hljs-type">XXX</span> <span class="hljs-variable">other</span> <span class="hljs-operator">=</span>(XXX)obj;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.getXXX()==other.getXXX()&amp;&amp;...)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125;<br>   <br>&#125; <br></code></pre></td></tr></table></figure><ul><li>很多类会重写<code>equals</code>方法来实现基于对象内容的比较。例如，<code>String</code>类重写了<code>equals</code>方法，用于比较字符串的内容：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>System.out.println(str1.equals(str2)); <span class="hljs-comment">// 返回true，因为内容相同</span><br></code></pre></td></tr></table></figure><ul><li><code>hashCode()</code>方法<ul><li><code>hashCode</code>方法返回对象的哈希码值。哈希码在哈希表等数据结构中用于快速查找。在<code>Object</code>类中，<code>hashCode</code>方法返回的是对象的内部地址的某种转换值（通常与内存地址相关）。例如：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>System.out.println(obj.hashCode());<br></code></pre></td></tr></table></figure><ul><li>当重写<code>equals</code>方法时，通常也需要重写<code>hashCode</code>方法，以保证相等的对象具有相同的哈希码。例如，在自定义类中：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClass</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass()!= o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">myClass</span> <span class="hljs-operator">=</span> (MyClass) o;<br>        <span class="hljs-keyword">return</span> value == myClass.value;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>toString()</code>方法<ul><li><code>toString</code>方法返回对象的字符串表示。在<code>Object</code>类中，<code>toString</code>方法返回的是对象的类名加上哈希码的十六进制表示。例如：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">     <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>     System.out.println(obj.toString());<br><span class="hljs-comment">//原理</span><br>getClass().getName()+<span class="hljs-string">&#x27;@&#x27;</span>+Integer.toHexString(hashCode())<span class="hljs-comment">//</span><br>    全限定路径：包名+类名的完整表示<br></code></pre></td></tr></table></figure><ul><li>很多类会重写<code>toString</code>方法来提供更有意义的字符串表示。例如，<code>Date</code>类重写了<code>toString</code>方法来返回日期的字符串形式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>System.out.println(date.toString());<br></code></pre></td></tr></table></figure><ul><li><p>可以在类中重写为介绍类的信息的方法。</p></li><li><p><code>getClass()</code>方法</p><ul><li>该方法返回对象的运行时类。例如：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>System.out.println(obj.getClass()); <span class="hljs-comment">// 输出java.util.ArrayList</span><br></code></pre></td></tr></table></figure><ul><li>instanceof和（classA.getClass()&#x3D;&#x3D;classB.class）区别</li></ul><blockquote><p>instanceof是Java中的二元运算符，考虑继承和实现，左边为null时，返回false</p><p>A.getClass()&#x3D;&#x3D;B.class,通过比较Class对象来判断是非是同一个类的实例，不考虑实现和继承，左边为null时，报空指针异常。</p></blockquote><ul><li>这个方法在反射等机制中非常有用，可以用来获取对象所属的类的相关信息，如类名、方法、字段等。</li><li><code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>方法<ul><li>这些方法用于线程间的协作，实现线程的等待和唤醒机制。例如：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Thread 1 is waiting&quot;</span>);<br>                    lock.wait();<br>                    System.out.println(<span class="hljs-string">&quot;Thread 1 is awakened&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Thread 2 is notifying&quot;</span>);<br>                lock.notify();<br>            &#125;<br>        &#125;);<br>        thread1.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在这个例子中，<code>thread1</code>等待，<code>thread2</code>唤醒<code>thread1</code>。</li></ul><h3 id="7-6-向上（下）转型"><a href="#7-6-向上（下）转型" class="headerlink" title="7.6.向上（下）转型"></a>7.6.向上（下）转型</h3><ul><li>在 Java 中，向上转型（upcasting）和向下转型（downcasting）是与多态相关的重要概念。</li></ul><h4 id="7-6-1-向上转型"><a href="#7-6-1-向上转型" class="headerlink" title="7.6.1.向上转型"></a>7.6.1.向上转型</h4><blockquote><ul><li>定义和作用</li><li>向上转型是指将一个子类对象赋值给一个父类类型的引用。这是自动进行的，不需要显式的类型转换。 作用：实现多态性，使代码更加灵活和可维护。通过父类引用可以调用子类重写的方法，从而实现不同的行为。</li></ul></blockquote><p> 示例:</p><p> 考虑以下代码： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;      <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;             <br>System.out.println(<span class="hljs-string">&quot;Animal makes a sound&quot;</span>);  <br>&#125; <br>&#125;     <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123; <br><span class="hljs-meta">@Override</span>         <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;             <br>System.out.println(<span class="hljs-string">&quot;Meow&quot;</span>); <br>&#125;    <br>&#125; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;     <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;             <br><span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();             <br>animal.makeSound(); <span class="hljs-comment">// 输出 &quot;Meow&quot;    </span><br>&#125;   <br>&#125; <br></code></pre></td></tr></table></figure><ul><li>在这个例子中，将 Cat 类的对象赋值给 Animal 类型的变量 animal，这就是向上转型。此时，通过 animal 引用调用 makeSound() 方法，实际上调用的是 Cat 类中重写的方法。</li></ul><h4 id="7-6-2向下转型"><a href="#7-6-2向下转型" class="headerlink" title="7.6.2向下转型"></a>7.6.2向下转型</h4><blockquote><p>定义和作用:父类的引用类型无法调用子类特殊的方法得通过向下转型，变成子类引用后才能调用子类得特殊方法</p><ul><li>向下转型是指将一个父类对象的引用强制转换为一个子类类型的引用。这是显式的类型转换，需要小心进行，因为如果转换不正确可能会导致 ClassCastException。 作用：当需要访问子类特有的方法或属性时，可以进行向下转型。</li></ul></blockquote><p>示例 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;         <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;        <br>System.out.println(<span class="hljs-string">&quot;Animal makes a sound&quot;</span>);<br>&#125;     &#125;     <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;       <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scratch</span><span class="hljs-params">()</span> &#123;             <br>System.out.println(<span class="hljs-string">&quot;Cat is scratching&quot;</span>);         &#125;     <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;             <br><span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();             <br><span class="hljs-keyword">if</span> (animal <span class="hljs-keyword">instanceof</span> Cat) &#123;            <br><span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> (Cat) animal;               <br>cat.scratch(); <span class="hljs-comment">// 输出 &quot;Cat is scratching&quot;             </span><br>&#125;        <br>&#125;    <br>&#125; <br></code></pre></td></tr></table></figure><ul><li>在这个例子中，首先进行向上转型，将 Cat 对象赋值给 Animal 引用。然后，通过 instanceof 运算符检查 animal 是否是 Cat 类型的实例，如果是，进行向下转型，将 animal 强制转换为 Cat 类型的变量 cat，这样就可以调用 Cat 类特有的 scratch() 方法。 总之，向上转型和向下转型在 Java 编程中是非常有用的技术，但需要谨慎使用，特别是在进行向下转型时，要确保转换的正确性，以避免运行时错误。</li><li><code>编译看左边，运行看右边</code>：编译的时候如果用向上转型（父类对象指向子类的实例）调用方法必须是父类中有的，不然编译出错，运行的时候根据右边具体子类对应的重写的方法来执行。</li></ul><h2 id="8-抽象类-方法和内部类"><a href="#8-抽象类-方法和内部类" class="headerlink" title="8.抽象类_方法和内部类"></a>8.抽象类_方法和内部类</h2><h3 id="8-1-抽象类"><a href="#8-1-抽象类" class="headerlink" title="8.1.抽象类"></a><strong>8.1.抽象类</strong></h3><p>在 Java 中，抽象类和抽象方法是实现抽象概念和多态性的重要工具。</p><ol><li>定义和特点<ul><li>抽象类是使用 <code>abstract</code> 关键字修饰的类。它可以包含抽象方法和非抽象方法，也可以包含成员变量和构造方法。</li><li>抽象类不能被实例化，即<code>不能使用 new</code>关键字创建抽象类的对象。它的存在主要是为了被其他类继承，提供一个通用的模板或框架。</li></ul></li><li>作用<ul><li>抽象类可以作为其他类的基类，定义一些通用的属性和方法，供子类继承和实现。它可以强制子类实现某些特定的方法，确保代码的一致性和可维护性。</li><li>抽象类可以包含抽象方法，这些方法只有方法签名，没有具体的实现。子类必须实现这些抽象方法，否则子类也必须声明为抽象类。</li></ul></li></ol><p><strong>二、抽象方法</strong></p><ol><li>定义和特点<ul><li>抽象方法是使用 <code>abstract</code> 关键字修饰的方法，只有方法签名，没有方法体。例如：<code>public abstract void doSomething();</code>。</li><li>抽象方法必须在抽象类中声明。如果一个类包含抽象方法，那么这个类必须声明为抽象类。</li></ul></li><li>作用<ul><li>抽象方法定义了一种行为规范，子类必须实现这些方法来提供具体的行为。这使得代码更加灵活和可扩展，不同的子类可以根据自己的需求实现不同的行为。</li></ul></li></ol><p><strong>三、示例</strong></p><p>以下是一个使用抽象类和抽象方法的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-comment">// 成员变量</span><br>    <span class="hljs-keyword">private</span> String color;<br><br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Shape</span><span class="hljs-params">(String color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-comment">// 抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getArea</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 非抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printColor</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Color: &quot;</span> + color);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> radius;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(String color, <span class="hljs-type">double</span> radius)</span> &#123;<br>        <span class="hljs-built_in">super</span>(color);<br>        <span class="hljs-built_in">this</span>.radius = radius;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getArea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.PI * radius * radius;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> width;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> height;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Rectangle</span><span class="hljs-params">(String color, <span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height)</span> &#123;<br>        <span class="hljs-built_in">super</span>(color);<br>        <span class="hljs-built_in">this</span>.width = width;<br>        <span class="hljs-built_in">this</span>.height = height;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getArea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> width * height;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">circle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-string">&quot;Red&quot;</span>, <span class="hljs-number">5.0</span>);<br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">rectangle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-string">&quot;Blue&quot;</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">6.0</span>);<br><br>        circle.printColor();<br>        System.out.println(<span class="hljs-string">&quot;Circle area: &quot;</span> + circle.getArea());<br><br>        rectangle.printColor();<br>        System.out.println(<span class="hljs-string">&quot;Rectangle area: &quot;</span> + rectangle.getArea());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>Shape</code> 是一个抽象类，它定义了一个抽象方法 <code>getArea()</code> 和一个非抽象方法 <code>printColor()</code>。<code>Circle</code> 和 <code>Rectangle</code> 类继承自 <code>Shape</code> 类，并实现了 <code>getArea()</code> 方法。通过这种方式，不同的形状类可以根据自己的特点实现计算面积的方法，同时共享通用的属性和方法。</p><p>总之，抽象类和抽象方法在 Java 编程中提供了一种强大的方式来实现代码的复用、多态性和可维护性。它们可以帮助开发者更好地组织和设计代码，提高代码的质量和可读性。</p><h3 id="8-2-内部类"><a href="#8-2-内部类" class="headerlink" title="8.2.内部类"></a>8.2.内部类</h3><p>在 Java 中，内部类是定义在另一个类内部的类。它可以访问外部类的成员，包括私有成员，并且可以实现更好的封装和代码组织。</p><p><strong>一、内部类的类型</strong></p><ol><li>成员内部类<ul><li>定义在外部类的成员位置，就像外部类的成员变量和成员方法一样。它可以访问外部类的所有成员，包括私有成员。</li><li>示例：</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">outerVariable</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printOuterVariable</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Outer variable: &quot;</span> + outerVariable);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>局部内部类</li></ol><ul><li>定义在外部类的方法内部，只能在该方法内部使用。局部内部类可以访问外部类的成员以及方法中的局部变量，但局部变量必须是 final 或 effectively final 的。</li><li>示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">outerMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">localVariable</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalInnerClass</span> &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLocalVariable</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Local variable: &quot;</span> + localVariable);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">LocalInnerClass</span> <span class="hljs-variable">localInner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalInnerClass</span>();<br>        localInner.printLocalVariable();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>匿名内部类</li></ol><ul><li>没有名字的内部类，通常用于创建接口或抽象类的实现，或者继承一个类并重写其中的方法。它通常在需要一次性使用一个类的情况下使用。</li><li>示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">outerMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MyInterface</span> <span class="hljs-variable">myInterface</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterface</span>() &#123;<br><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Doing something.&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>        myInterface.doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二、内部类的优点</strong></p><ol><li>实现更好的封装<ul><li>内部类可以隐藏在外部类内部，对外界不可见，只有外部类可以访问它。这有助于提高代码的安全性和可维护性。</li></ul></li><li>访问外部类的成员<ul><li>内部类可以访问外部类的所有成员，包括私有成员。这使得在某些情况下实现特定的功能更加方便。</li></ul></li><li>代码组织和可读性<ul><li>内部类可以将相关的代码放在一起，使代码结构更清晰，提高可读性。</li></ul></li></ol><p><strong>三、内部类的注意事项</strong></p><ol><li>命名冲突<ul><li>内部类的名称不能与外部类或其他内部类的名称相同，否则会导致编译错误。</li></ul></li><li>访问权限<ul><li>内部类的访问权限受到外部类的限制。如果外部类是私有的，内部类也只能在外部类内部访问。</li></ul></li><li>内存管理<ul><li>内部类的对象会持有外部类对象的引用，这可能会导致内存泄漏问题。在使用内部类时，要注意及时释放资源，避免内存泄漏。</li></ul></li></ol><p>总之，内部类是 Java 中一种强大的特性，它可以帮助开发者实现更好的封装、代码组织和可读性。在使用内部类时，要注意命名冲突、访问权限和内存管理等问题，以确保代码的正确性和性能。</p><h3 id="8-3-简单工厂设计模式"><a href="#8-3-简单工厂设计模式" class="headerlink" title="8.3.简单工厂设计模式"></a>8.3.简单工厂设计模式</h3><ul><li><p>不仅可以使用父类的形参，还可以使用父类左方法的返回值类型，真是返回的对象可以是该类的任意一个子类对象。</p></li><li><p>简单工厂模式的实现，它是解决大量对象创建问题的一个解决方案，将创建和使用分开，公厂负责创建，使用者直接调用即可，简单工厂模式的基本要求是（<code> 定义一个创建对象的类并且通过静态方法来实现创建</code>）</p><blockquote><ul><li>定义一个static方法，通过类名直接实现</li><li>返回值类型是父类类型，返回的可以是其任意子类类型</li><li>传入一个字符串类型的参数，工厂根据参数创建对应的子类产品</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<span class="hljs-comment">//抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shut</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<span class="hljs-comment">//子类猫</span><br><span class="hljs-meta">@Override</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shut</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;喵喵喵&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<span class="hljs-comment">//子类狗</span><br><span class="hljs-meta">@Overrride</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shut</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;汪汪汪&quot;</span>);<br>&#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PetStore</span>&#123;<span class="hljs-comment">//宠物店  单例模式</span><br><span class="hljs-comment">//私有构造函数</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">PetStore</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-comment">//</span><br><span class="hljs-comment">//方法提供动物</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Animal <span class="hljs-title function_">getanimal</span><span class="hljs-params">(String petname)</span>&#123;<br>Animal an=<span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;猫&quot;</span>.equals(petname)) an=<span class="hljs-keyword">new</span> <span class="hljs-title class_">cat</span>();<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;狗&quot;</span>.equals(petname)) an=<span class="hljs-keyword">new</span> <span class="hljs-title class_">dog</span>();<br>    <span class="hljs-keyword">return</span> an;<br>&#125;<span class="hljs-comment">//petname.equals(&quot;猫&quot;)  当petname为空时会报空指针异常</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">girl</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">(Animal an)</span>&#123;<br>        an.shut();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>        girl g=<span class="hljs-keyword">new</span> <span class="hljs-title class_">girl</span>();<br>        Animal an=PetStore.getanimal(<span class="hljs-string">&quot;狗&quot;</span>);<br>        g.play(an);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="9-接口"><a href="#9-接口" class="headerlink" title="9.接口"></a>9.接口</h2><h3 id="9-1-接口的基本概念"><a href="#9-1-接口的基本概念" class="headerlink" title="9.1.接口的基本概念"></a>9.1.接口的基本概念</h3><ol><li>类是类，接口是接口，属于同一层次的概念。</li><li>接口中没有构造器。接口声明使用 <code>interface</code>关键字。</li><li>在 JDK 1.8 之前，接口主要有两部分：<ul><li>常量：固定修饰符为 <code>public static final</code>，可不写系统默认补全。</li><li>抽象方法：固定修饰符为 <code>public abstract</code>。</li></ul></li></ol><h3 id="9-2-类和接口的关系"><a href="#9-2-类和接口的关系" class="headerlink" title="9.2.类和接口的关系"></a>9.2.类和接口的关系</h3><ol><li>实现关系：类通过 <code>implements</code>关键字实现接口。</li><li>一旦实现一个接口，实现类必须重写接口的全部抽象方法。如果没有全部重写，可以把类变成抽象类。</li><li>Java 只有单继承，但可以多实现（类只能有一个直接父类，但可以实现多个接口），一般先继承再实现。</li><li>接口不能创建对象，但接口可以指向实现类，如 <code>test_interface t = new Student();</code>。</li></ol><h3 id="9-3-接口的常量访问"><a href="#9-3-接口的常量访问" class="headerlink" title="9.3.接口的常量访问"></a>9.3.接口的常量访问</h3><ol><li>接口.常量，如 <code>test_interface.Num</code>。</li><li>通过实现接口的类来访问，接口中的属性都是静态常量，可直接通过类名.常量（如 <code>Student.num</code>）或通过实例（如 <code>s.Num</code>）。</li></ol><h3 id="9-4-接口的作用"><a href="#9-4-接口的作用" class="headerlink" title="9.4.接口的作用"></a>9.4.接口的作用</h3><ol><li>接口定义规则与类不同，实现类负责实现接口定义的规则即可。</li><li>用类继承侧重属性的本质，用接口实现不追寻本质，只是实现特定功能（如 -able）。例如手机和照相机不同根无法继承，但手机可拍照，可通过接口实现拍照功能。</li></ol><h3 id="9-5-增加多态的应用场合"><a href="#9-5-增加多态的应用场合" class="headerlink" title="9.5.增加多态的应用场合"></a>9.5.增加多态的应用场合</h3><ol><li>父类当作方法的形参，传入具体的子类对象。</li><li>父类当作方法的返回值，返回的是具体的子类对象。</li><li>接口当作方法的形参，传入具体的实现类的对象。</li><li>接口当作方法的返回值，返回的是具体的实现类的对象。</li></ol><h3 id="9-6-接口和抽象类的区别"><a href="#9-6-接口和抽象类的区别" class="headerlink" title="9.6.接口和抽象类的区别"></a>9.6.接口和抽象类的区别</h3><ol><li>JDK 1.8 之后，接口新增非抽象方法：<ul><li>被 <code>public default</code>修饰的非抽象方法，加上 <code>default</code>后不能被重写，其它修饰符可默认不加。</li><li>静态方法。</li></ul></li><li>在接口中加入非抽象方法的原因：如果接口中只能定义抽象方法，修改接口内容对实现类影响太大，加入非抽象方法可供某些实现类调用。</li></ol><h3 id="9-7-示例代码"><a href="#9-7-示例代码" class="headerlink" title="9.7.示例代码"></a>9.7.示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">test_interface</span> &#123;<br>    <span class="hljs-comment">//常量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">Num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>;<br>    <span class="hljs-comment">//非抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">c</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;---&gt;method c非抽象方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//静态方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">d</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;---&gt;static方法&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">test_interface</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;------默认抽象方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;---num:&quot;</span> + num);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testc_d</span><span class="hljs-params">()</span> &#123;<br>        c(); <span class="hljs-comment">//可以</span><br>        <span class="hljs-comment">// super.c();不可以</span><br>        test_interface.<span class="hljs-built_in">super</span>.c(); <span class="hljs-comment">//可以</span><br>        test_interface.d(); <span class="hljs-comment">//调用静态方法</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">test_interface</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        s.a();<br>        s.b(test_interface.Num);<br>        System.out.println(Student.Num);<br>        System.out.println(s.Num);<br>        s.testc_d();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-8-接口与Lambda表达式"><a href="#9-8-接口与Lambda表达式" class="headerlink" title="9.8.接口与Lambda表达式"></a>9.8.接口与Lambda表达式</h3><ul><li><p>Lambda表达式就是一个只写参数列表和方法体的匿名方法（参数列表和方法体之间的符号是-&gt;)</p></li><li><pre><code class="java">(a,b)-&gt;&#123;return a+b;&#125;<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br>- java中的Lambda表达式主要用于在给单接口变量（接口中有且只有一个<span class="hljs-keyword">abstract</span>方法）赋值，让代码更简洁。<br><br>- ~~~java<br>  <span class="hljs-keyword">interface</span> <span class="hljs-title">ShowMessage</span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span>(<span class="hljs-params">String s</span>)</span>;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">test</span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String args[]</span>)</span>&#123;<br>  ShowMessage sm;<span class="hljs-comment">//声明接口变量</span><br>  sm= (s)-&gt;&#123;     <span class="hljs-comment">//接口变量中存放Lambda表达式的值,把一整个Lambda表达式看作右值，所以结尾加&#x27;;&#x27;</span><br>  System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;tvtvtv&quot;</span>);<br>  System.<span class="hljs-keyword">out</span>.println(s);<br>  System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;tvtvtv&quot;</span>);<br>  &#125;;<br>  sm.print(<span class="hljs-string">&quot;长城牌电视机&quot;</span>)<span class="hljs-comment">//接口回调Lambda表达式实现的接口方法</span><br>  <br>  &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>函数式接口</p></li><li><pre><code class="java">// 定义一个函数式接口@FunctionalInterfaceinterface Calculator &#123;    int calculate(int a, int b);&#125;public class LambdaExample &#123;    public static void main(String[] args) &#123;        // 使用 Lambda 表达式实现 Calculator 接口        Calculator addition = (a, b) -&gt; a + b;        Calculator subtraction = (a, b) -&gt; a - b;        int result1 = addition.calculate(5, 3);        int result2 = subtraction.calculate(5, 3);        System.out.println(&quot;5 + 3 = &quot; + result1);        System.out.println(&quot;5 - 3 = &quot; + result2);    &#125;&#125;<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs d"><br>- 代码解释：<br><br>  - <span class="hljs-string">`Calculator`</span> 接口是一个函数式接口，使用 <span class="hljs-string">`@FunctionalInterface`</span> 注解进行标注，它只包含一个抽象方法 <span class="hljs-string">`calculate()`</span>。<br>  - 在 <span class="hljs-string">`main`</span> 方法中，使用 Lambda 表达式分别实现了加法和减法操作。<span class="hljs-string">`(a, b) -&gt; a + b`</span> 表示一个接收两个整数参数并返回它们之和的函数，<span class="hljs-string">`(a, b) -&gt; a - b`</span> 表示一个接收两个整数参数并返回它们之差的函数。<br>  - 调用 <span class="hljs-string">`calculate()`</span> 方法并传入相应的参数，将结果存储在变量中并打印输出。<br><br>  <br><br>  通过上述示例，你可以看到 Java 中接口和 Lambda 表达式的基本用法和它们之间的关联，Lambda 表达式为实现函数式接口提供了一种简洁、灵活的方式。<br><br><br><br>## <span class="hljs-number">10.</span>异常（Exception）处理<br><br>### <span class="hljs-number">10.1</span>捕获异常<br><br>- <span class="hljs-number">1.</span>基于<span class="hljs-keyword">if</span>-<span class="hljs-keyword">else</span>处理异常缺点太多，所以Java中专门出了一个异常处理机制：<br><br>- &gt; 异常三连：<span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span>-<span class="hljs-keyword">finally</span><br><br>- <span class="hljs-number">2.</span>异常出现了以后怎么看：<br><br>- 第一行提示异常的类型，最后一行提示异常出现的位置<br><br>- ![image-<span class="hljs-number">20241102161403029</span>](java.assets/image-<span class="hljs-number">20241102161403029.</span>png)<br><br>- <span class="hljs-number">3.</span>捕获异常： <span class="hljs-string">` try-catch`</span><br><br>- &gt; ~~~Java<br>  &gt; <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> test&#123;<br>  &gt; <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[]args)&#123;<br>  &gt; <span class="hljs-comment">//录入两个数求商</span><br>  &gt; <span class="hljs-keyword">try</span>&#123;<br>  &gt; Scanner sc=<span class="hljs-keyword">new</span> Scanner(System.<span class="hljs-keyword">in</span>);<br>  &gt; System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;请输入第一个数:&quot;</span>);<br>  &gt; <span class="hljs-keyword">int</span> num1=sc.nextInt();<br>  &gt; System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;请输入第二个数：&quot;</span>);<br>  &gt; <span class="hljs-keyword">int</span> num2=sc.nextInt();<br>  &gt; System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;商：&quot;</span>+num1/num2);<br>  &gt; &#125;<br>  &gt; <span class="hljs-keyword">catch</span>(Exception ex)&#123;<span class="hljs-comment">//Exception是所有异常的父类</span><br>  &gt; System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;对不起，程序出现异常！&quot;</span>)；<br>  &gt; &#125;<br>  &gt;     System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;------enjoy(o.o)&quot;</span>);<br>  &gt; &#125;<br>  &gt; &#125;<br></code></pre></td></tr></table></figure>&gt;&gt; &gt; 原理：把可能会出现的异常放入try代码块中，然后将异常封装成对象，被catch后面的（）中的异常对象接受，接受以后执行catch后面的&#123;&#125;里面的代码。&gt; &gt;&gt; &gt; - 1. try中没有异常，catch中代码不执行&gt; &gt;   2. try中有异常，catch进行捕获：&gt; &gt;&gt; &gt;   如果异常匹配，走catch中的代码块&gt; &gt;&gt; &gt;   如果异常不匹配，不走catch中的代码，异常中断&gt; &gt;&gt; &gt;   注意：（1）try中如果出现异常，然后用catch捕获成功的话，那么try中后续的代码是不会执行的&gt; &gt;&gt; &gt;   （2）如果catch捕获异常成功，那么try-catch后面的代码该执行还是继续执行无影响</code></pre></li></ul><h3 id="10-2-异常处理"><a href="#10-2-异常处理" class="headerlink" title="10.2.异常处理"></a>10.2.异常处理</h3><ul><li><p>打印异常信息：</p><blockquote><p>调用toString方法，显示异常的类名（全限定路径）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(ex);<br>System.out.println(ex.toString());<br></code></pre></td></tr></table></figure><p>显示异常描述信息对应的字符串,如果没有就显示null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(ex.getMessage());<br></code></pre></td></tr></table></figure><p>显示异常的堆栈信息：将异常的信息在控制台打印而不中断程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ex.printStackTrace();<br></code></pre></td></tr></table></figure><p>抛出异常，程序中断（异常两次）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> ex;<br></code></pre></td></tr></table></figure></blockquote></li></ul><h3 id="10-3finally"><a href="#10-3finally" class="headerlink" title="10.3finally"></a>10.3finally</h3><ul><li>（1）什么情况下，try-catch后面的代码不执行？</li></ul><ol><li>throw抛出异常的情况</li><li>异常捕获失败（与捕获的异常类型不相容，直接中断）</li><li>在try中遇到return</li></ol><ul><li>（2）如何将try-catch后面的代码必须执行？</li></ul><blockquote><p>只要将必须执行的代码放入finally中，那么这代码无论如何一定执行</p></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-comment">//录入两个数求商</span><br><span class="hljs-keyword">try</span>&#123;<br>Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(<span class="hljs-string">&quot;请输入第一个数:&quot;</span>);<br><span class="hljs-type">int</span> num1=sc.nextInt();<br>System.out.println(<span class="hljs-string">&quot;请输入第二个数：&quot;</span>);<br><span class="hljs-type">int</span> num2=sc.nextInt();<br>System.out.println(<span class="hljs-string">&quot;商：&quot;</span>+num1/num2);<br>    <span class="hljs-comment">//System.exit(0);//终止当前的虚拟器执行</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">catch</span>(Exception ex)&#123;<span class="hljs-comment">//Exception是所有异常的父类</span><br><span class="hljs-comment">//throw ex;</span><br>&#125;<br><span class="hljs-keyword">finally</span>&#123;<span class="hljs-comment">//一定执行</span><br>System.out.println(<span class="hljs-string">&quot;----enjoy(o.o)&quot;</span>);<br>&#125;<br>    <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>（3）先执行finally再执行return</p></li><li><p>（4）什么代码会放在finally中？</p></li><li><blockquote><p>关闭数据库资源、关闭IO流资源、关闭socket资源。</p><p>如果把资源放<code>try(&quot;资源&quot;)&#123;&#125;</code>，如此会自动释放。不需要在finally中手动释放。</p></blockquote></li><li><p>（5）finally代码块不执行的情况：</p></li><li><blockquote><pre><code class="Java">System.exit(0);//终止当前的虚拟器执行<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs haxe">   <br> -   (<span class="hljs-number">6</span>)带有close的语法糖<span class="hljs-keyword">try</span>(IO流对象)&#123;&#125;     自动关闭文件流，不需要使用finally代码块<br><br> - &gt; ~~~java<br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedTset</span></span>&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args)&#123;<br>     <span class="hljs-keyword">try</span>( BufferedReader br=<span class="hljs-keyword">new</span> <span class="hljs-type">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">FileReader</span>(<span class="hljs-string">&quot;path&quot;</span>));<br>           BufferedWriter bw=<span class="hljs-keyword">new</span> <span class="hljs-type">bufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">FlieWriter</span>(<span class="hljs-string">&quot;path1&quot;</span>));<br>          )<span class="hljs-comment">//资源放在try-catch块中，自动刷新关闭释放</span><br>         &#123;<br>             List&lt;<span class="hljs-keyword">String</span>&gt; data=<span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>             <span class="hljs-keyword">String</span> line;<span class="hljs-comment">//读出加入到List容器</span><br>             <span class="hljs-keyword">while</span>((line=br.readline())!=<span class="hljs-literal">null</span>) data.add(line);<br>         &#125;<br>     Collection.sort(data);<span class="hljs-comment">//排序</span><br>     System.out.println(adta);<br>     <span class="hljs-comment">//写入</span><br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">String</span> s:<span class="hljs-type">data</span>)&#123;<br>         bw.Writer(s);<br>         bw.<span class="hljs-keyword">new</span><span class="hljs-type">Line</span>;<span class="hljs-comment">//换行</span><br>     &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>         e.printStackTrace();<br>     &#125;<br><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre></blockquote></li></ul><h3 id="10-4-多重catch"><a href="#10-4-多重catch" class="headerlink" title="10.4.多重catch"></a>10.4.多重catch</h3><ul><li><p>（1）try中出现异常以后，将异常类型跟catch后面的类型依次匹配，执行第一个与异常类型匹配的catch语句，后面的catch语句就会被忽略</p></li><li><p>（2）将特殊异常放前面；（先写子类异常再写父类异常）</p></li><li><p>（3）在jdk1.7以后，异常处理方式：可以并列用|符号连接：</p></li><li><pre><code class="java">public static Integer getInteger(String nm,Integer val)&#123;String v=null;try&#123;v=System.getProperty(nm);&#125;catch(IllegalArgumentException|NullPointerException e)&#123;&#125;if(v!=null)&#123;try&#123;return Integer.decode(v);&#125;catch(NumberFormatException e)&#123;&#125;&#125;return val;&#125;<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs php"><br><span class="hljs-comment">### 10.5.异常分类</span><br><br>- &gt; Object类--》<span class="hljs-built_in">Throwable</span>类--》<br>  &gt;<br>  &gt; &gt; <span class="hljs-built_in">Error</span>(错误)、<span class="hljs-built_in">Exception</span>(异常)     <span class="hljs-comment">//Error错误不用关注，一般靠程序本身无法解决</span><br>  &gt;<br>  &gt; &gt; <span class="hljs-built_in">Exception</span>---》检查异常、运行时异常<br><br>  注意：程序中语法错、逻辑错误都不属于上面的error、<span class="hljs-built_in">Exception</span><br><br><span class="hljs-number">1</span>. 运行时异常（免检异常unchecked exception）<span class="hljs-built_in">Error</span>和<span class="hljs-built_in">RuntimeException</span><br><br>- 写代码的时候，不用特意对异常进行处理，在程序运行以后系统自动检测，然后报出异常<br><br><span class="hljs-number">2</span>. 检查异常(必检异常checked exception)<br><br>- 写代码的时候，就要对代码进行异常处理：throws向外抛或者<span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span>捕获异常<br><br>常见的必检异常：（继承自<span class="hljs-built_in">Exception</span>)<br><br>&gt;SQLException、IOException、ClassnotFindexception、InterruptException<br><br>常见的免检异常：(继承自<span class="hljs-built_in">RuntimeException</span>)<br><br>&gt;NullPointerException（空指针）、ArrthmaticException、ClassCastException（类转换）、<span class="hljs-title function_ invoke__">IndexOutOfBandException</span>(越界)<br><br><br><br>&gt; ALT+enter用idea生成<span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span><br>&gt;<br>&gt; CTRL+ALT+T生成<span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span><br><br><span class="hljs-number">1</span>. <span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span>嵌套<br><span class="hljs-number">2</span>. 多重<span class="hljs-keyword">catch</span><br><span class="hljs-number">3</span>. throws<br><br>- **<span class="hljs-keyword">throw</span>和throws**的区别<br><br>  &gt;~~~java<br>  &gt;package com.fortest1;<br>  &gt;import java.util.Scanner;<br>  &gt;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test01</span> </span>&#123;<br>  &gt;<span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_ invoke__">main</span>(String[] args) throws <span class="hljs-built_in">Exception</span> <span class="hljs-comment">//把异常抛给方法名</span><br>  &gt;&#123;<br>  &gt;   Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>  &gt;   System.out.<span class="hljs-title function_ invoke__">println</span>(<span class="hljs-string">&quot;请输入第一个数:&quot;</span>);<br>  &gt;   <span class="hljs-keyword">int</span> num1=sc.<span class="hljs-title function_ invoke__">nextInt</span>();<br>  &gt;   System.out.<span class="hljs-title function_ invoke__">println</span>(<span class="hljs-string">&quot;请输入第二个数：&quot;</span>);<br>  &gt;   <span class="hljs-keyword">int</span> num2=sc.<span class="hljs-title function_ invoke__">nextInt</span>();<br>  &gt;<span class="hljs-keyword">if</span>(num2==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//除数为0，制造异常</span><br>  &gt;<span class="hljs-comment">//制造运行时异常：</span><br>  &gt;<span class="hljs-comment">//throw new RuntimeException();</span><br>  &gt;<span class="hljs-comment">//制造检查异常</span><br>  &gt;<span class="hljs-comment">/*  try &#123;</span><br><span class="hljs-comment">  &gt;   throw new Exception();</span><br><span class="hljs-comment">  &gt;&#125; catch (Exception e) &#123;</span><br><span class="hljs-comment">  &gt;   e.printStackTrace();</span><br><span class="hljs-comment">  &gt;&#125;</span><br><span class="hljs-comment">  &gt;*/</span><br>  &gt;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>();<br>  &gt;&#125;<br>  &gt;<span class="hljs-keyword">else</span> System.out.<span class="hljs-title function_ invoke__">println</span>(<span class="hljs-string">&quot;商：&quot;</span>+num1/num2);<br>  &gt;   &#125;<br>  &gt;&#125;<br></code></pre></td></tr></table></figure>&gt;&gt;&gt; 1. 位置不同：throw：在方法内部；throws:方法的声明处，谁调用谁处理或者继续往外抛出&gt;&gt; 2. 内容不同：throw+异常对象（检查异常、运行时异常）；throws+异常的类型（可以多个类型，用&quot;,&quot;拼接）&gt;&gt; 3. 作用不同：throw:异常出现的源头，制造异常；throws：在方法的声明处，告诉方法的调用者，这个方法中可能存在异常，要么自己处理要么在继续向外抛出异常</code></pre></li></ul><h3 id="10-6-异常-重载和重写以及自定义异常"><a href="#10-6-异常-重载和重写以及自定义异常" class="headerlink" title="10.6.异常_重载和重写以及自定义异常"></a>10.6.异常_重载和重写以及自定义异常</h3><h4 id="10-6-1异常重载和重写"><a href="#10-6-1异常重载和重写" class="headerlink" title="10.6.1异常重载和重写"></a>10.6.1异常重载和重写</h4><ul><li>重载：方法名相同，形参列表不同(与异常无关)</li></ul><blockquote><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception</span>&#123;<br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span><span class="hljs-keyword">throws</span> ArithmeticException</span>&#123;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><ul><li>重写：子类继承；接口实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception&#123;<br>System.out.println(<span class="hljs-string">&quot;父类方法&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> exdents Person&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> RunTimeException&#123;<br>System.out.println(<span class="hljs-string">&quot;子类方法&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><blockquote><p>子类的异常范围&lt;&#x3D;父类的异常；即子类的异常不能是父类异常的父类</p></blockquote></li></ul><h4 id="10-6-2自定义异常"><a href="#10-6-2自定义异常" class="headerlink" title="10.6.2自定义异常"></a>10.6.2自定义异常</h4><ul><li><p>创建一个类：</p></li><li><blockquote><p>该类可以继承自运行时异常RuntimeException为免检异常</p><p>也可以继承检查异常Exception为必检异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java">&gt;<span class="hljs-keyword">package</span> com.fortest1;<br><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> extends <span class="hljs-comment">//Exception RuntimeException </span><br>&gt;&#123;<br>&gt;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">790745766939L</span>;<br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-title function_">MyException</span><span class="hljs-params">()</span>&#123;&#125;<br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-title function_">MyException</span><span class="hljs-params">(String msg)</span>&#123;<br> <span class="hljs-built_in">super</span>(msg);<br>&gt;&#125;<br>&gt;&#125;<br><br></code></pre></td></tr></table></figure><p>通过throw new MyException(“sdasdsad”);抛出异常不强调额外处理，也可以用try-catch捕获</p><p>如果继承的是检查异常需要捕获异常或者throws向上抛出</p></blockquote></li><li><p><strong>搞清楚五个关键词</strong>：try-catch-finally-throw-throws</p></li></ul><h3 id="10-7-断言"><a href="#10-7-断言" class="headerlink" title="10.7.断言"></a>10.7.断言</h3><ul><li><p>断言语句在调试代码阶段非常有用，断言语句一般用于程序不准备通过捕获异常来处理的错误，例如：当发生某个错误时要求程序必须立即停止执行。</p></li><li><p>语法结构：</p></li><li><pre><code class="hljs">assert number&gt;10;//number&gt;10的值为true，程序继续执行，否则程序立即结束执行assert booleanExpression;//true继续执行，否则程序立即结束执行assert booleanExpression:messageExcept;//booleanExpression为true继续执行，为false，停止执行，并且输出messageExcept表达式的值<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><br>  <br><br><span class="hljs-comment">## 11.常用类</span><br><br><span class="hljs-comment">### 11.1.包装类</span><br><br>- （<span class="hljs-number">1</span>）什么是包装类？<br><br>- &gt; 将基本数据类型对应进行了一个封装，产生了一个新的类，---》**包装类**<br>  &gt;<br>  &gt; 基本数据类型：boolean<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span>-&gt;</span>byte<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span>-&gt;</span>char<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">2</span>)</span>-&gt;</span>short<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">2</span>)</span>-&gt;</span>int<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">4</span>)</span>-&gt;</span>long<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">8</span>L)</span>-&gt;</span>float<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">4f</span>)</span>-&gt;</span>double(<span class="hljs-number">8</span>)<br>  &gt;<br>  &gt; 包装类---&gt;引用数据类型<br><br>  &gt;（<span class="hljs-number">2</span>）对应关系：<br>  &gt;<br>  &gt;基本数据类型                包装类     继承关系<br>  &gt;<br>  &gt;byte                               Byte    ---》<span class="hljs-built_in">Number</span>--》<span class="hljs-built_in">Object</span>    <br>  &gt;<br>  &gt;short                             Short   ---》<span class="hljs-built_in">Number</span>--》<span class="hljs-built_in">Object</span><br>  &gt;<br>  &gt;int                                  Integer  ---》<span class="hljs-built_in">Number</span>--》<span class="hljs-built_in">Object</span><br>  &gt;<br>  &gt;long                               Long     ---》<span class="hljs-built_in">Number</span>--》<span class="hljs-built_in">Object</span><br>  &gt;<br>  &gt;float                               Float    ---》<span class="hljs-built_in">Number</span>--》<span class="hljs-built_in">Object</span><br>  &gt;<br>  &gt;double                           Double   ---》<span class="hljs-built_in">Number</span>--》<span class="hljs-built_in">Object</span><br>  &gt;<br>  &gt;char                               Character    ---》<span class="hljs-built_in">Object</span><br>  &gt;<br>  &gt;boolean                         <span class="hljs-built_in">Boolean</span>    ---》<span class="hljs-built_in">Object</span><br><br>- （<span class="hljs-number">3</span>）已经有数据类型了为什么要使用包装类？<br><br>&gt; 把基本数据类型封装成包装类便于引用数据类型操作<br><br>- **类Integer**<br><br>- &gt; <span class="hljs-number">1.</span> 直接使用无需导包  Java.Lang下<br>  &gt; <span class="hljs-number">2.</span> 类的继承关系   ---&gt;<span class="hljs-built_in">Number</span>---&gt;<span class="hljs-built_in">Object</span><br>  &gt; <span class="hljs-number">3.</span> 实现接口：  Serializable,Comparable&lt;Integer&gt;<br>  &gt; <span class="hljs-number">4.</span> 这个类被final修饰不能被继承：<br>  &gt;<br>  &gt; &gt; ~~~java<br>  &gt; &gt; public final <span class="hljs-keyword">class</span> <span class="hljs-title class_">Integer</span> <br>  &gt; &gt; <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Number</span><br>  &gt; &gt; implements Comparable&lt;Integer&gt;<br></code></pre></td></tr></table></figure>&gt;&gt; 5. 对int类型进行包装&gt; 6. 属性：共有静态字符常量通过类名调用public static final&gt;&gt; &gt; <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">System.out.println(Integer.MAX_VALUE);<span class="hljs-comment">//int的最大值</span><br>System.out.println(Integer.MIN_VALUE);<span class="hljs-comment">//int的最小值</span><br></code></pre></td></tr></table></figure>&gt; &gt;&gt; &gt; 注意：最大值+1=最小值；最小值-1=最大值&gt;&gt; 7. 构造方法：(无空参)&gt;&gt; &gt; <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">12</span>);<span class="hljs-comment">//12--&gt;private final value</span><br>Integer i2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-string">&quot;12&quot;</span>);<span class="hljs-comment">//转为12--&gt;private final value</span><br>Integer i3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-string">&quot;abc&quot;</span>);<span class="hljs-comment">//NumFormatException异常</span><br></code></pre></td></tr></table></figure>&gt;&gt; 8. 包装类的自动类型转化&gt;&gt; &gt; <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i=<span class="hljs-number">12</span>;<span class="hljs-comment">//Integer---&gt;int通过Integer.ValeuOf()</span><br>Integer i2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">12</span>);<br><span class="hljs-type">int</span> num=i2;<span class="hljs-comment">//int---&gt;Integer 通过Integer.intValue()</span><br></code></pre></td></tr></table></figure>&gt;&gt; 9. 常用方法：&gt;&gt; &gt;i1.compareTo(i2) ;  //返回-1，0，1   &gt; &gt;&gt; &gt;i1.equals（i2）;   //返回true，false&gt; &gt;&gt; &gt;int num = Integer.parseInt(&quot;123&quot;);//将字符串转化为int&gt; &gt;&gt; &gt;int value = i1.intValue(); //返回Integer对象的int值&gt; &gt;&gt; &gt;String str=i1.toString();//以字符串方式返回Integer的值</code></pre></li></ul><h3 id="11-2-日期相关"><a href="#11-2-日期相关" class="headerlink" title="11.2.日期相关"></a>11.2.日期相关</h3><ul><li><p>Java.util.Date</p></li><li><blockquote><pre><code class="java">//Date类的使用  java.util.DateDate d=new Date();  //初始化一个Date对象    //获取当前时间    System.out.println(d);System.out.println(d.toString());//返回自1970年1月1日00.00.00GMT以来的毫秒数    System.out.println(d.getTime());    System.out.println(System.currentTimeMillis());//System.currentTimeMillis()更方便直接静态调用无需创建对象//public static native long currentTimeMillis();本地方法没有方法体//该时间差的作用：用于衡量一些算法的时间：    long startTime=System.currentTimeMillis();    for(int i=0;i&lt;10000;i++)    &#123;        System.out.print(i);    &#125;    System.out.println();    long endTime=System.currentTimeMillis();    System.out.println(endTime-startTime);<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>- java.<span class="hljs-keyword">sql</span>.Date(只包含日期，与数据库交互)<br><br>- &gt; ~~~~java<br>//java.<span class="hljs-keyword">sql</span>.Date   需要传入long型参数 <span class="hljs-number">1970</span>年<span class="hljs-number">1</span>月<span class="hljs-number">1</span>日<span class="hljs-number">00.00</span><span class="hljs-number">.00</span>到所要表示的时间的毫秒数<br>    <span class="hljs-type">Date</span> d=<span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>(<span class="hljs-keyword">System</span>.currentTimeMillis());<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(d);<br>//区别：<span class="hljs-keyword">sql</span>.Date只返回年月日；util.Date包括时分秒<br>    //联系：<span class="hljs-keyword">sql</span>.Date(子) exdents util.Date（父）<br>    //相互转换：//向上转型：子类对象赋值给父类的引用   //父类的引用类型无法调用子类特殊的方法得通过向下转型，变成子类引用后才能调用子类得特殊方法<br>                   java.util.Date date_fa=<span class="hljs-built_in">new</span> java.<span class="hljs-keyword">sql</span>.Date(<span class="hljs-keyword">System</span>.currentTimeMillis());<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(date_fa.getTime());<br>//向下转型：<br>    java.util.Date date_fa1=<span class="hljs-built_in">new</span> java.<span class="hljs-keyword">sql</span>.Date(<span class="hljs-keyword">System</span>.currentTimeMillis());<br><span class="hljs-keyword">if</span>(date_fa1 instanceof java.<span class="hljs-keyword">sql</span>.Date)&#123;<br>    <span class="hljs-type">Date</span> date_son1=(<span class="hljs-type">Date</span>) date_fa1;<br>&#125;<br><br>~~~~<br><br>- SimpleDateFormat（少用）<br><br> - &gt; String<span class="hljs-comment">---&gt;java.util.Date类型转换</span><br><br>&gt; String<span class="hljs-comment">---&gt;java.sql.Date</span><br>&gt;<br>&gt; java.<span class="hljs-keyword">sql</span>.Date<span class="hljs-comment">---&gt;java.util.Date</span><br>&gt;<br>&gt; ~~~java<br>&gt; <span class="hljs-type">Date</span> date3=<span class="hljs-type">Date</span>.valueOf(&quot;2024-11-03&quot;);<br>&gt;     java.util.Date date_3= (java.util.Date) date3;<br>&gt;     <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(date_3.toString());<br></code></pre></td></tr></table></figure>- 缺点：字符串只能是年-月-日；- 引入DateFormat(抽象类)无法初始化，SimpleDateFormat作为子类可以初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"> <span class="hljs-comment">//日期转换</span><br>    <span class="hljs-comment">//String---&gt;Date</span><br>    <span class="hljs-comment">//SimpleDateFormat extends DateFormat(抽象类)</span><br>    DateFormat df=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<span class="hljs-comment">//自己定义的日期格式年y,月M,日d,时H(24)/h(12),分m,秒s,毫秒S</span><br><span class="hljs-comment">//定义好了格式化标准</span><br>    <span class="hljs-keyword">try</span> &#123;<br>       Date date= df.parse(<span class="hljs-string">&quot;2024-11-03 17:25:55&quot;</span>);<br>        System.out.println(date);<br>    &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br><span class="hljs-comment">//Date---&gt;String</span><br>   String df_now= df.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>System.out.println(df_now);<br></code></pre></td></tr></table></figure>- parse（接受字符串返回Date），format（接受Date返回字符串）</code></pre></blockquote></li><li><p>日历Calendar(抽象类)(少用)</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Calendar是一个抽象类，不可以直接创建对象</span><br><span class="hljs-comment">//GregorianCalendar()子类extends Calendar</span><br>Calendar cal=<span class="hljs-keyword">new</span> <span class="hljs-title class_">GregorianCalendar</span>();<br>Calendar cal2=Calendar.getInstance();<br>System.out.println(cal2);<br><span class="hljs-comment">//常用的方法  get方法；传入Calendar中定义的常量</span><br>   System.out.println(cal2.get(Calendar.YEAR));<span class="hljs-comment">//年</span><br>    System.out.println(cal2.get(Calendar.MONTH));<span class="hljs-comment">//月</span><br>    System.out.println(cal2.get(Calendar.DATE));<span class="hljs-comment">//日</span><br>    System.out.println(cal2.get(Calendar.DAY_OF_WEEK));<span class="hljs-comment">//按国外星期日第一天</span><br>    System.out.println(cal2.getActualMaximum(Calendar.DATE));<span class="hljs-comment">//获取最大</span><br>    System.out.println(cal2.getActualMinimum(Calendar.DATE));<span class="hljs-comment">//获取最小</span><br> <span class="hljs-comment">//set方法：可以改变Calendar的内容</span><br> cal2.set(Calendar.YEAR,<span class="hljs-number">2025</span>);<br>cal2.set(Calendar.DATE,<span class="hljs-number">6</span>);<br><span class="hljs-comment">//setTime方法：</span><br> java.sql.Date date=java.sql.Date.valueOf(<span class="hljs-string">&quot;2026-11-03&quot;</span>);<br>cal2.setTime(date);<br><br></code></pre></td></tr></table></figure></blockquote><ul><li><p>完成需求:</p></li><li><p><img src="/.com//image-20241103174048966.png" alt="image-20241103174048966"></p></li><li><blockquote><pre><code class="java"> //String--》Calendar//录入日期的字符串    Scanner sc=new Scanner(System.in);    System.out.println(&quot;请输入你要查看的日期：（提示：请按照年-月-日的格式）&quot;);String strDate=sc.next();//String --&gt;Calendar//1.String--&gt;Date    java.sql.Date date=java.sql.Date.valueOf(strDate);//2.Date--&gt;Caendar    Calendar cal=Calendar.getInstance();cal.setTime(date);//    System.out.println(&quot;日\t一\t二\t三\t四\t五\t六&quot;);//获取本月的最大天数int maxDay=cal.getActualMaximum(Calendar.DATE);//获取当前日期的日    int now_Day=cal.get(Calendar.DATE);    //将当前日期中的日调为本月的1号,在看1号是星期几    cal.set(Calendar.DATE,1);   int num= cal.get(Calendar.DAY_OF_WEEK);int count=0;for(int i=1;i&lt;=num-1;i++)&#123;    System.out.print(&quot;\t&quot;);    count++;&#125;for(int i=1 ;i&lt;=maxDay;i++)&#123;    if (i==now_Day)&#123;    System.out.print(i+&quot;*&quot;+&quot;\t&quot;);&#125;else &#123;    System.out.print(i+&quot;\t&quot;);&#125;count++;if(count%7==0) System.out.println();&#125;<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>- LocalDate;LocalTime;LocalDateTime（多用）<br><br>- &gt;~~~java<br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">//初始化</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">//now()方法,现在时刻</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">LocalDate localDate= LocalDate.now();</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">System.out.println(localDate);</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">LocalTime localTime=LocalTime.now();</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">System.out.println(localTime);</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">LocalDateTime localDateTime=LocalDateTime.now();</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">System.out.println(localDateTime);</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">//of（）方法，设计时间</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">LocalDate of=LocalDate.of(2024,11,3);</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">LocalTime of1=localTime.of(18,22,11);</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">//LocalDateTime使用频率最高</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">//get方法</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">System.out.println(localDateTime.getYear());</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">System.out.println(localDateTime.getMonth());//月的英文</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">System.out.println(localDateTime.getDayOfMonth());//月的值</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">System.out.println(localDateTime.getMonthValue());</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">System.out.println(localDateTime.getHour());</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">//.....</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">//不叫<span class="hljs-built_in">set</span>方法，叫with方法，不在自身的基础上改变</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">LocalDateTime localDateTime1=localDateTime.withMonth(8);</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">System.out.println(localDateTime);</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">System.out.println(localDateTime1);</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">//.plusMonth（n）加n个月  .minusMonth（n） 减n个月</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">//.plusDay(n) 加n天      .minusDay(n) 减n天</span><br><br></code></pre></td></tr></table></figure></code></pre></blockquote></li><li><p>DateTimeFormatter    <code>ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;);  </code>常用</p></li><li><blockquote><pre><code class="Java">//格式化类//自定义的格式化  ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;);  常用DateTimeFormatter dateTimeFormatter=DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;);//LocalDateTime  ----&gt;String LocalDateTime now=LocalDateTime.now(); System.out.println(now);//2024-11-03T19:09:07.842778100String format=DateTimeFormatter.format(now);System.out.println(format);//2024-11-03 07:10:05 //String----&gt;LocalTimeDate TemporalAccessor parse1=dateTimeFormatter.parse(&quot;2024-11-03 07:10:05&quot;);System.out.println(parse1);<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ruby"> <br> <br><br><span class="hljs-comment">### 11.3.Math类</span><br><br>- <span class="hljs-number">1</span>.使用<span class="hljs-string">``</span><span class="hljs-title class_">Math</span>类<span class="hljs-string">``</span>的时候无需导包，直接使用即可<br><br><span class="hljs-string">`package java.lang;`</span><br><br> <span class="hljs-number">2</span>.<span class="hljs-string">` Math类`</span>没有子类，不能被其它类继承<br><br> ~~~java<br> <span class="hljs-keyword">public</span> final <span class="hljs-keyword">class</span> <span class="hljs-title class_">Math</span>&#123;&#125;<br></code></pre></td></tr></table></figure></code></pre></blockquote></li></ul><p>3.里面的属性全部被final修饰，方法也是被final修饰的。</p><p>4.外界不可以创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Math</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Math</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造器私有化</p><p>5.Math类中的所有属性，方法都被static修饰，不用创建对象去调用（也不能），直接通过<code> 类名.属性名  类名.方法名</code>去调用。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//常用属性，方法</span><br>Math.PI;<span class="hljs-comment">//Π圆周率</span><br>Math.random();<span class="hljs-comment">//[0.0,1.0)随机数</span><br>Math.obs(-<span class="hljs-number">80</span>);<span class="hljs-comment">//80绝对值</span><br>Math.ceil(<span class="hljs-number">9.1</span>);<span class="hljs-comment">//10.0向上取值</span><br>Math.floor(<span class="hljs-number">9.9</span>);<span class="hljs-comment">//9向下取值</span><br>Math.round(<span class="hljs-number">3.5</span>);<span class="hljs-comment">//4四舍五入</span><br>Math.max(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//6取最大</span><br>Math.min(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>)<span class="hljs-comment">//3取最小</span><br></code></pre></td></tr></table></figure><h3 id="11-4-String类"><a href="#11-4-String类" class="headerlink" title="11.4.String类"></a>11.4.String类</h3><ul><li><ol><li><code>String类</code>直接使用无需导包</li></ol><blockquote><p>package java.lang;</p></blockquote><ol start="2"><li>无法继承，不能有子类</li></ol><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span>;<br></code></pre></td></tr></table></figure></blockquote><ol start="3"><li>Strng底层是一个char类型的数组</li></ol><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br></code></pre></td></tr></table></figure></blockquote><ol start="4"><li>常用方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">String str=<span class="hljs-string">&quot;asdasdad&quot;</span>;<br>String str1=<span class="hljs-string">&quot;asdasd&quot;</span>;<br>System.out.println(str.length());<span class="hljs-comment">//返回数组的长度</span><br>str.isEmpty();<span class="hljs-comment">//判断是否为空，返回Boolean</span><br>System.out.println(str.chaAt(<span class="hljs-number">1</span>))<span class="hljs-comment">//获取索引对应的字符</span><br>System.out.println(<span class="hljs-string">&quot;asdasdad&quot;</span>.equals(str));<span class="hljs-comment">//比较字符串是否一致，返回Boolean；注意：str1.equals(&quot;sdadad&quot;);如果传入引用str1为空；会报空指针异常</span><br><span class="hljs-comment">//String类实现了Compareable接口，所以String中一定要对这个方法进行重写；</span><br>System.out.println(str.compareTo(str1));<br>System.out.println(str.subString(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>));<span class="hljs-comment">//截取【3，6）部分</span><br>str.replace(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>);<span class="hljs-comment">//把a替换为u</span><br><span class="hljs-comment">//split</span><br>String str2=<span class="hljs-string">&quot;a,v,b,s,d,f&quot;</span>;<br>String[] strs=str2.split(<span class="hljs-string">&quot;,&quot;</span>);<br>System.out.println(strs[<span class="hljs-number">0</span>]);<span class="hljs-comment">//a</span><br><span class="hljs-comment">//lastIndexOf</span><br>string url=<span class="hljs-string">&quot;asdasdasdas.asda.png&quot;</span>;<br>String extension=url.subString(url.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br><br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;compareTo的逻辑：s8.compareTo(s9);</p><p><img src="/.com//image-20241104182403532.png" alt="image-20241104182403532"></p><h4 id="为什么new一个String会创建两个对象？"><a href="#为什么new一个String会创建两个对象？" class="headerlink" title="为什么new一个String会创建两个对象？"></a>为什么new一个String会创建两个对象？</h4><ul><li><p>在 Java 中，使用 <code>new String(&quot;xxx&quot;)</code> 这种方式创建字符串对象时，通常会创建两个对象，下面详细解释其原因。</p><h5 id="1-字符串常量池"><a href="#1-字符串常量池" class="headerlink" title="1. 字符串常量池"></a>1. 字符串常量池</h5><p>在 Java 里，为了节省内存和提高性能，字符串常量池（String Pool）被引入。字符串常量池是 Java 堆内存中的一个特殊区域，用于存储字符串常量。当你在代码中使用双引号直接声明一个字符串时，例如 <code>String s = &quot;hello&quot;;</code>，Java 首先会检查字符串常量池中是否已经存在值为 <code>&quot;hello&quot;</code> 的字符串对象。如果存在，就直接返回该对象的引用；如果不存在，就会在字符串常量池中创建一个新的字符串对象，并返回其引用。</p><h5 id="2-new-String-xxx-创建对象的过程"><a href="#2-new-String-xxx-创建对象的过程" class="headerlink" title="2. new String(&quot;xxx&quot;) 创建对象的过程"></a>2. <code>new String(&quot;xxx&quot;)</code> 创建对象的过程</h5><p>当使用 <code>new String(&quot;xxx&quot;)</code> 这种方式创建字符串对象时，会经历以下两个步骤，从而创建两个对象：</p><ul><li><strong>第一步：在字符串常量池中创建对象</strong>：当 Java 遇到双引号括起来的字符串字面量 <code>&quot;xxx&quot;</code> 时，会先检查字符串常量池中是否已经存在值为 <code>&quot;xxx&quot;</code> 的字符串对象。如果不存在，就在字符串常量池中创建一个新的字符串对象来存储 <code>&quot;xxx&quot;</code>。</li><li><strong>第二步：在堆内存中创建对象</strong>：<code>new</code> 关键字会在 Java 堆内存中创建一个新的 <code>String</code> 对象，这个对象会复制字符串常量池中 <code>&quot;xxx&quot;</code> 的值。最终返回的是堆内存中这个新创建的 <code>String</code> 对象的引用。</li></ul><h5 id="3-示例代码及解释"><a href="#3-示例代码及解释" class="headerlink" title="3. 示例代码及解释"></a>3. 示例代码及解释</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringCreationExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 在字符串常量池中创建 &quot;hello&quot; 对象</span><br>        <span class="hljs-comment">// 同时在堆内存中创建一个新的 String 对象，复制常量池 &quot;hello&quot; 的值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>); <br>        <span class="hljs-comment">// 检查字符串常量池中是否已有 &quot;hello&quot;，已有则直接返回引用</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>; <br>        String s3=s1.intern();<br>        System.out.println(s1 == s2); <span class="hljs-comment">// 输出 false，因为 s1 和 s2 引用的是不同的对象</span><br>        System.out.println(s1.equals(s2)); <span class="hljs-comment">// 输出 true，因为它们的值相同</span><br>        System.out.println(s2 == s3);<span class="hljs-comment">// 输出 true，因为 s2 和 s3 都引用字符串常量池中的对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="intern-方法"><a href="#intern-方法" class="headerlink" title="intern() 方法"></a><code>intern()</code> 方法</h4><p><code>intern()</code> 方法用于手动将字符串对象添加到字符串常量池中。当调用一个字符串对象的 <code>intern()</code> 方法时，JVM 会检查字符串常量池中是否已经存在与该对象值相等的字符串对象。</p><ul><li>如果存在，返回字符串常量池中该对象的引用。</li><li>如果不存在，将该对象的引用添加到字符串常量池中，并返回该引用。</li></ul><p>在上述代码中：</p><ul><li><code>String s1 = new String(&quot;hello&quot;);</code> 会在字符串常量池中创建一个 <code>&quot;hello&quot;</code> 对象，同时在堆内存中创建一个新的 <code>String</code> 对象，<code>s1</code> 引用的是堆内存中的对象。</li><li><code>String s2 = &quot;hello&quot;;</code> 会检查字符串常量池中是否已经存在 <code>&quot;hello&quot;</code> 对象，由于前面已经创建，所以 <code>s2</code> 直接引用字符串常量池中的 <code>&quot;hello&quot;</code> 对象。</li><li><code>s1 == s2</code> 比较的是两个引用是否指向同一个对象，由于 <code>s1</code> 和 <code>s2</code> 分别指向堆内存和字符串常量池中的不同对象，所以结果为 <code>false</code>。</li><li><code>s1.equals(s2)</code> 比较的是两个字符串的值是否相等，由于它们的值都是 <code>&quot;hello&quot;</code>，所以结果为 <code>true</code>。</li><li><code>s2 == s3</code>比较的是两个引用是否指向同一个对象,由于s2 和 s3 都引用字符串常量池中的对象，所以结果为true。</li></ul><h5 id="4-特殊情况"><a href="#4-特殊情况" class="headerlink" title="4. 特殊情况"></a>4. 特殊情况</h5><p>如果字符串常量池中已经存在对应值的字符串对象，那么使用 <code>new String(&quot;xxx&quot;)</code> 只会在堆内存中创建一个新的 <code>String</code> 对象，而不会在字符串常量池中再次创建。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>; <br><span class="hljs-comment">// 此时字符串常量池中已有 &quot;hello&quot;，只会在堆内存创建新对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>); <br></code></pre></td></tr></table></figure><p>综上所述，一般情况下 <code>new String(&quot;xxx&quot;)</code> 会创建两个对象，一个在字符串常量池中，一个在堆内存中。</p></li></ul></li></ul><h3 id="11-5-StringBuilder和StringBuffer常用方法如下："><a href="#11-5-StringBuilder和StringBuffer常用方法如下：" class="headerlink" title="11.5.StringBuilder和StringBuffer常用方法如下："></a>11.5.<code>StringBuilder</code>和<code>StringBuffer</code>常用方法如下：</h3><p><strong>一、append () 方法</strong></p><ol><li><strong>功能</strong>：<ul><li>用于在字符串末尾添加内容，可以是字符串、字符、整数、浮点数等各种数据类型。</li><li>例如，<code>StringBuilder sb = new StringBuilder(); sb.append(&quot;Hello&quot;);</code>，此时<code>sb</code>的内容变为 “Hello”。如果继续执行<code>sb.append(123);</code>，则<code>sb</code>变为 “Hello123”。</li></ul></li><li><strong>应用场景</strong>：<ul><li>当需要动态地构建一个字符串时非常有用。比如在生成日志信息时，可以逐步将不同的信息片段添加到一个<code>StringBuilder</code>或<code>StringBuffer</code>对象中。</li><li>例如，在一个程序中记录用户的操作日志，可以使用<code>StringBuilder</code>来拼接用户的操作信息、时间戳等内容。</li></ul></li></ol><p><strong>二、insert () 方法</strong></p><ol><li><strong>功能</strong>：<ul><li>在指定位置插入内容。可以插入字符串、字符、整数、浮点数等各种数据类型。</li><li>例如，<code>StringBuilder sb = new StringBuilder(&quot;Hello&quot;); sb.insert(2, &quot;orld&quot;);</code>，此时<code>sb</code>的内容变为 “HeWorldllo”。</li></ul></li><li><strong>应用场景</strong>：<ul><li>当需要在特定位置插入内容时使用。比如在编辑文本时，如果需要在特定位置插入一些补充信息，就可以使用这个方法。</li><li>例如，在一个文本编辑器中，用户可以在已有的文本中选择一个位置插入新的字符或字符串。</li></ul></li></ol><p><strong>三、delete () 方法</strong></p><ol><li><strong>功能</strong>：<ul><li>删除指定范围内的字符。可以指定起始索引和结束索引来确定要删除的字符范围。</li><li>例如，<code>StringBuilder sb = new StringBuilder(&quot;Hello World&quot;); sb.delete(5, 10);</code>，此时<code>sb</code>的内容变为 “Hello”，因为删除了从索引 5 到索引 10（不包括 10）的字符。</li></ul></li><li><strong>应用场景</strong>：<ul><li>当需要删除部分字符串内容时使用。比如在处理用户输入的错误信息时，可以删除特定的错误部分。</li><li>例如，在一个表单验证程序中，如果用户输入了错误的格式，可以使用<code>StringBuilder</code>或<code>StringBuffer</code>来删除错误的部分，并插入正确的格式提示。</li></ul></li></ol><p><strong>四、reverse () 方法</strong></p><ol><li><strong>功能</strong>：<ul><li>将字符串反转。例如，“Hello” 反转后变为 “olleH”。</li><li>例如，<code>StringBuilder sb = new StringBuilder(&quot;Hello&quot;); sb.reverse();</code>，此时<code>sb</code>的内容变为 “olleH”。</li></ul></li><li><strong>应用场景</strong>：<ul><li>在需要对字符串进行反转操作时使用。比如在某些加密算法中，可能需要对字符串进行反转处理。</li><li>例如，在一个简单的加密程序中，可以将用户输入的字符串反转后再进行其他加密操作。</li></ul></li></ol><p><strong>五、toString () 方法</strong></p><ol><li><strong>功能</strong>：<ul><li>将<code>StringBuilder</code>或<code>StringBuffer</code>对象转换为<code>String</code>类型。</li><li>例如，<code>StringBuilder sb = new StringBuilder(&quot;Hello&quot;); String str = sb.toString();</code>，此时<code>str</code>的内容为 “Hello”。</li></ul></li><li><strong>应用场景</strong>：<ul><li>当需要将<code>StringBuilder</code>或<code>StringBuffer</code>对象作为字符串使用时，比如将其传递给需要<code>String</code>类型参数的方法。</li><li>例如，在一个打印输出的方法中，需要将<code>StringBuilder</code>对象转换为<code>String</code>类型才能进行打印。</li></ul></li></ol><ul><li>注意:<code>StringBuilder</code>是非线程安全的，在单线程环境下，它通常比<code>StringBuffer</code>效率更高</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-type">StringBuilder</span>();<span class="hljs-comment">//空构造器；但是实际上对数组进行了初始化，长度为16；</span><br>StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-type">StringBuilder</span>(<span class="hljs-number">4</span>);<span class="hljs-comment">//有参构造器，长度为4；</span><br>StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-type">StringBuilder</span>(<span class="hljs-string">&quot;dads&quot;</span>);<span class="hljs-comment">//有参构造器；字符串初始化为&quot;dads&quot;;长度为4+16；  实际操作为：super(str.length()+16);append(str)//str为传入的参数</span><br><br></code></pre></td></tr></table></figure><h3 id="11-6-System"><a href="#11-6-System" class="headerlink" title="11.6.System"></a>11.6.System</h3><h3 id="11-7-Runtime"><a href="#11-7-Runtime" class="headerlink" title="11.7.Runtime"></a>11.7.Runtime</h3><h3 id="11-8-Arrays类的使用"><a href="#11-8-Arrays类的使用" class="headerlink" title="11.8 Arrays类的使用"></a>11.8<code> Arrays类</code>的使用</h3><blockquote><p><code> import java.util.Arrays;</code></p></blockquote><ol><li><code>toString</code>方法</li></ol><blockquote><ul><li>数组转化为字符串，返回字符串</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr =<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">24</span>,<span class="hljs-number">25</span>,<span class="hljs-number">26</span>,<span class="hljs-number">27</span>&#125;;<br>        String str=Arrays.toString(arr);<br>        System.out.println(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">24</span>,<span class="hljs-number">25</span>,<span class="hljs-number">26</span>,<span class="hljs-number">27</span>]<br></code></pre></td></tr></table></figure></blockquote><ol start="2"><li><code> binarySearch二分法查找</code></li></ol><blockquote><ul><li>找出指定<code> 有序</code>数组的指定元素对应的索引，返回int</li><li>binarysearch(arr,value);</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr =<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">24</span>,<span class="hljs-number">25</span>,<span class="hljs-number">26</span>,<span class="hljs-number">27</span>&#125;;<br>        <span class="hljs-type">int</span> index=Arrays.binarySearch(arr,<span class="hljs-number">26</span>);<br>        System.out.println(index);<br>        <span class="hljs-comment">//String str=Arrays.toString(arr);</span><br>        <span class="hljs-comment">//System.out.println(str);</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><ul><li><p>注意：</p><blockquote><p><code> binarysearch</code>只能对有序数组进行查找，无序数组使用前应该进行<code>sort</code>排序</p></blockquote></li></ul></blockquote><ol start="3"><li><code> sort排序</code></li></ol><blockquote><ul><li>对指定数组进行升序排序（从小到大）</li><li>sort(arr)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr =<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">22</span>,<span class="hljs-number">21</span>,<span class="hljs-number">26</span>,<span class="hljs-number">20</span>,<span class="hljs-number">29</span>,<span class="hljs-number">27</span>&#125;;<br>        Arrays.sort(arr);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:arr)<br>            System.out.print(x+<span class="hljs-string">&quot;\t&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-number">20</span><span class="hljs-number">21</span><span class="hljs-number">22</span><span class="hljs-number">26</span><span class="hljs-number">27</span><span class="hljs-number">29</span><br></code></pre></td></tr></table></figure></blockquote><ol start="4"><li><code> copyOf复制</code>&#x2F;<code> copyOfRange区间复制</code></li></ol><blockquote><ul><li>将老数组按新的长度进行复制得到一个新数组</li><li>copyOf(arr,newlength)</li><li>copyOfRange(arr,pos1,pos2)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr =<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">22</span>,<span class="hljs-number">21</span>,<span class="hljs-number">26</span>,<span class="hljs-number">20</span>,<span class="hljs-number">29</span>,<span class="hljs-number">27</span>&#125;;<br>        <span class="hljs-type">int</span>[] arr1=Arrays.copyOf(arr,<span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:arr1)<br>            System.out.print(x+<span class="hljs-string">&quot;\t&quot;</span>);<br>        System.out.println();<br>        <span class="hljs-type">int</span>[] arr2=Arrays.copyOfRange(arr,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y:arr2)<br>        System.out.print(y+<span class="hljs-string">&quot;\t&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-number">22</span><span class="hljs-number">21</span><span class="hljs-number">26</span><span class="hljs-number">20</span><br><span class="hljs-number">26</span><span class="hljs-number">20</span><span class="hljs-number">29</span><br></code></pre></td></tr></table></figure><ul><li><p>注意：</p><blockquote><p>copyOfRange(arr,pos1,pos2),复制的区间为索引[pos1,pos2);</p><p>pos1取，pos2不取</p><p>和随机数一样左包含右不包含</p></blockquote></li></ul></blockquote><ol start="5"><li><code> equals比较</code></li></ol><blockquote><ul><li>比较两个数组的值是否一样</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr1=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br><span class="hljs-type">int</span>[] arr2=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>System.out.println(Arrays.equals(arr1,arr2));<span class="hljs-comment">//true</span><br>System.out.println(arr1==arr2);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><ul><li><pre><code class="Java">System.out.println(arr1==arr2);//比较的是两个数组的地址<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><br><br><span class="hljs-number">6</span>. 填充（`fill`）<br><br>- `Arrays.fill(int[] a, int val)`用于将数组`a`中的所有元素填充为`val`。<br><br>```java<br>       import java.util.Arrays<span class="hljs-comment">;</span><br><br>       public class Main &#123;<br>           public static void main(String[] args) &#123;<br>               int[] arr = <span class="hljs-keyword">new</span> int[<span class="hljs-number">5</span>]<span class="hljs-comment">;</span><br>               Arrays.fill(arr, <span class="hljs-number">10</span>)<span class="hljs-comment">;</span><br><span class="hljs-title">               for (int num :</span> arr) &#123;<br>                   System.out.print(num + <span class="hljs-string">&quot; &quot;</span>)<span class="hljs-comment">;</span><br>               &#125;<br>           &#125;<br>       &#125;<br>```<br><br>上述代码会将长度为 <span class="hljs-number">5</span> 的数组`arr`的所有元素填充为 <span class="hljs-number">10</span><br><br><br><br><span class="hljs-number">7</span>. 转换为List集合（`asList()`）<br><br>&gt;- `Arrays.asList()` 可以将一个数组或者多个参数转换成一个 `List` 集合。<br><br>&gt;~~~java<br>&gt;List&lt;String&gt; list=Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>,&#x27;b&#x27;,&#x27;c&#x27;)<span class="hljs-comment">;//将多个参数转化为List</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><p>上述代码通过 <code>Arrays.asList</code> 把三个字符串元素转换为了一个 <code>List</code> 集合。</p><p>不过需要注意：</p><ul><li><strong>不支持基本数据类型数组</strong>：<code>Arrays.asList</code> 只能接受 <code>Object</code> 类型的参数或者数组。如果传入基本数据类型数组，它会把数组当作一个 <code>Object</code> 类型元素，导致返回的 <code>List</code> 只有一个元素，即原始数组本身。</li><li><strong>返回的 <code>List</code> 具有固定大小</strong>：<code>Arrays.asList</code> 返回的 <code>List</code> 是 <code>Arrays</code> 类的一个内部类，它持有对原始数组的引用，大小固定，不支持调用 <code>add</code>、<code>remove</code>、<code>clear</code> 等修改集合大小的方法，否则会抛出 <code>UnsupportedOperationException</code> 异常 。但对该 <code>List</code> 的修改会反映到原始数组上，反之亦然。</li></ul></blockquote><ol start="8"><li>转换为stream流</li></ol><blockquote><ul><li><code>Arrays.stream</code> 是 <code>java.util.Arrays</code> 类中的一个静态方法，它接受一个数组作为参数，并将该数组转换为一个 <code>Stream</code> 对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;Arrays.stream(Str.split(<span class="hljs-string">&quot;,&quot;</span>))<br></code></pre></td></tr></table></figure><p>这里将分割后的字符串数组转换为一个 <code>Stream&lt;String&gt;</code> 对象，方便后续的流操作。</p></blockquote><h3 id="11-9-Collections-类"><a href="#11-9-Collections-类" class="headerlink" title="11.9.Collections 类"></a>11.9.<code>Collections</code> 类</h3><p><code>Collections</code> 类位于 <code>java.util</code> 包下，提供了大量用于操作集合（如 <code>List</code>、<code>Set</code>、<code>Map</code> 等）的静态方法。</p><h4 id="常用方法分类及示例"><a href="#常用方法分类及示例" class="headerlink" title="常用方法分类及示例"></a>常用方法分类及示例</h4><h5 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h5><ul><li>**<code>sort(List&lt;T&gt; list)</code>**：对 <code>List</code> 集合中的元素进行自然排序，要求元素实现 <code>Comparable</code> 接口。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SortExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-number">3</span>);<br>        list.add(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-number">2</span>);<br>        Collections.sort(list);<br>        System.out.println(list); <span class="hljs-comment">// 输出: [1, 2, 3]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>**<code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>**：使用指定的比较器对 <code>List</code> 集合中的元素进行排序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;, age=&quot;</span> + age + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SortWithComparatorExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Person&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">20</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">18</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">22</span>));<br><br>        Collections.sort(list, Comparator.comparingInt(Person::getAge));<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="查找和替换操作"><a href="#查找和替换操作" class="headerlink" title="查找和替换操作"></a>查找和替换操作</h5><ul><li>**<code>max(Collection&lt;? extends T&gt; coll)</code>**：返回集合中的最大元素，元素需实现 <code>Comparable</code> 接口。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-number">3</span>);<br>        list.add(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Collections.max(list);<br>        System.out.println(max); <span class="hljs-comment">// 输出: 3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>**<code>replaceAll(List&lt;T&gt; list, T oldVal, T newVal)</code>**：将 <code>List</code> 集合中所有指定的旧值替换为新值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReplaceAllExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-number">2</span>);<br>        list.add(<span class="hljs-number">1</span>);<br>        Collections.replaceAll(list, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>        System.out.println(list); <span class="hljs-comment">// 输出: [3, 2, 3]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h5><ul><li>**<code>synchronizedList(List&lt;T&gt; list)</code>**：返回指定列表的同步（线程安全的）列表。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedListExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; synList = Collections.synchronizedList(list);<br>        <span class="hljs-comment">// 在多线程环境下可以安全使用 synList</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-IO流"><a href="#12-IO流" class="headerlink" title="12.IO流"></a>12.IO流</h2><ul><li><p>File类：封装文件&#x2F;目录的各种信息，对文件&#x2F;目录进行操作，但是我们不可以获取到文件&#x2F;目录中的内容。</p></li><li><p>I&#x2F;O流：Input&#x2F;Output的缩写，用于对设备之间的数据传输</p><p><img src="/.com//image-20241112190146403.png"></p></li></ul><p>try-catch捕获异常，finally最后关闭流</p><p><img src="/.com//image-20241127200033060.png" alt="image-20241127200033060"></p><ul><li>FileReader,FileWriter完成文本复制(字符-文本类)一个一个</li></ul><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">File f1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:\\temporymemory\\user.txt&quot;</span>);<br>File f2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:\\temporymemory\\message.txt&quot;</span>);<br>FileReader fr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(f1);<br>FileWriter fw=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(f2);<br><span class="hljs-comment">//一个字符一个字符进行读写，返回-1表示文件结尾</span><br><span class="hljs-type">int</span> n=fr.read();<br><span class="hljs-keyword">while</span>(n!=-<span class="hljs-number">1</span>)&#123;<br>fw.write(n);<br>n=fr.read();<br>&#125;<br><span class="hljs-comment">//利用缓冲字符数组</span><br><span class="hljs-type">char</span>[] ch=<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> len=ch;<br><span class="hljs-keyword">while</span>(len!=-<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//String s=new String(ch,0,len);</span><br>fr.write(ch,<span class="hljs-number">0</span>,len);<span class="hljs-comment">//fr.write(s);</span><br>len=fr.read(ch);<br>&#125;<br><span class="hljs-comment">//关闭流；先用的后关</span><br>fw.close();<br>fr.close();<br><br></code></pre></td></tr></table></figure></blockquote><ul><li>FileInputStream,FileOutputStream完成非文本复制（字节-图片类）</li></ul><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">File f1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;path&quot;</span>);<br>File f2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;path2&quot;</span>);<br>FileInputStream fis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(f1);<br>FileOutputStream fos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(f2);<br><span class="hljs-comment">//文件是Utf-8存储，英文占一个字节，中文占三个字节</span><br><span class="hljs-type">int</span> n=fis.read();<br><span class="hljs-keyword">while</span>(n!=-<span class="hljs-number">1</span>)&#123;<br>fos.write(n);<br>n=fis.read();<br>&#125;<br><span class="hljs-comment">//利用缓存数组</span><br><span class="hljs-type">byte</span>[] b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">8</span>]；<br><span class="hljs-type">int</span> len=fis.read(b);<br><span class="hljs-keyword">while</span>(len！=-<span class="hljs-number">1</span>)&#123;<br>fos.write(b,<span class="hljs-number">0</span>,len);<br>len=fis.read(b);<br>&#125;<br><br><span class="hljs-comment">//关闭流，先用后关</span><br>fos.close();<br>fin.close();<br></code></pre></td></tr></table></figure></blockquote><ul><li><p>BufferedInputStream,BufferedOutputStream（缓冲字节处理流）</p></li><li><p>作用：可以提高字节流的读写性能</p></li><li><blockquote><p>通过缓冲池减少系统调用的次数</p><p>原理：缓冲字节流自带了8kb的缓冲池；缓冲字节输出流也自带了8kb的缓冲池</p></blockquote></li></ul><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">//功能加强，在FileInputStream和FileOutputStream外面套一个管BufferedInputStream和BufferedOutputStream</span><br>&gt;BufferedInputStream bis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis);<br>&gt;BufferedOutputStream bos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fos);<br>&gt;<span class="hljs-type">byte</span>[] b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">8</span>];<br>&gt;<span class="hljs-type">int</span> len=bis.read(b);<br>&gt;<span class="hljs-keyword">while</span>(len!=-<span class="hljs-number">1</span>)&#123;<br>&gt;bos.write(b,<span class="hljs-number">0</span>,len);<br>&gt;len=bis.read(b);<br>&gt;&#125;<br>&gt;<span class="hljs-comment">//关闭流；先开后关</span><br>&gt;bos.close();<br>&gt;bis.close();<br>&gt;fos.close();<br>&gt;fis.close();<br></code></pre></td></tr></table></figure></blockquote><ul><li>BufferedReader,BufferedWriter完成文本复制（缓冲字符处理流）一行一行</li></ul><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">File f1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;path&quot;</span>);<br>File f2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;path2&quot;</span>);<br>BufferedReader fr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlieReader</span>(f1));<span class="hljs-comment">//参数是FileReader</span><br>BufferedWriter fw=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(f2));<span class="hljs-comment">//参数是FileWriter</span><br><span class="hljs-comment">//BufferedWriter fw=bufferedWriter(new FileWriter(f2,true))//追加模式写</span><br><span class="hljs-comment">//一行一行的读，写</span><br>String str;<br><span class="hljs-keyword">while</span>((str=fr.readerline())!=<span class="hljs-literal">null</span>)<span class="hljs-comment">//读取</span><br>&#123;<br> fw.write(str);<span class="hljs-comment">//此时写在缓冲区</span><br> fw.newline();<span class="hljs-comment">//换行</span><br>&#125;<br>fw.flush();<span class="hljs-comment">//写入磁盘</span><br>fw.close();<br>fr.close();<br></code></pre></td></tr></table></figure><p>案例：<img src="/.com//image-20241127202555955.png" alt="image-20241127202555955"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedTset</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">try</span>( BufferedReader br=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;path&quot;</span>));<br>              BufferedWriter bw=<span class="hljs-keyword">new</span> <span class="hljs-title class_">bufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlieWriter</span>(<span class="hljs-string">&quot;path1&quot;</span>));<br>             )<span class="hljs-comment">//资源放在try-catch块中，自动刷新关闭释放</span><br>            &#123;<br>                List&lt;String&gt; data=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                String line;<span class="hljs-comment">//读出加入到List容器</span><br>                <span class="hljs-keyword">while</span>((line=br.readline())!=<span class="hljs-literal">null</span>) data.add(line);<br>            &#125;<br>        Collection.sort(data);<span class="hljs-comment">//排序</span><br>        System.out.println(adta);<br>        <span class="hljs-comment">//写入</span><br>        <span class="hljs-keyword">for</span>(String s:data)&#123;<br>            bw.Writer(s);<br>            bw.newLine();<span class="hljs-comment">//换行</span><br>        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><ul><li>原始流、缓冲流的性能分析</li></ul><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br></code></pre></td></tr></table></figure></blockquote><ul><li><p>将文件转成字节数组</p></li><li><p>序列化和反序列化IO</p></li></ul><h2 id="13-集合-容器"><a href="#13-集合-容器" class="headerlink" title="13.集合(容器)"></a>13.集合(容器)</h2><ul><li>基本体系</li><li><img src="/.com//image-20241104155653318.png" alt="image-20241104155653318"></li></ul><h3 id="13-1-Collection接口-List可以添加重复元素，Set不能"><a href="#13-1-Collection接口-List可以添加重复元素，Set不能" class="headerlink" title="13.1.Collection接口(List可以添加重复元素，Set不能)"></a>13.1.Collection接口(List可以添加重复元素，Set不能)</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><code>Collection</code> 是 Java 集合框架中的一个接口，它是所有单列集合类的根接口，定义了集合的基本操作方法，如添加元素、删除元素、判断集合是否为空等。它派生了许多子接口，如 <code>List</code>、<code>Set</code> 和 <code>Queue</code> 等，这些子接口又有各自的具体实现类。</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li><p><code>add(E e)</code>：向集合中添加一个元素。</p></li><li><p><code>remove(Object o)</code>：从集合中移除指定的元素。</p></li><li><p><code>contains(Object o)</code>：判断集合中是否包含指定的元素。</p></li><li><p><code>size()</code>：返回集合中元素的数量。</p></li><li><p><code>isEmpty()</code>：判断集合是否为空。</p></li><li><p>集合有个特点：只能存放引用数据类型，不能是基本数据类型</p></li><li><p>遍历集合</p></li></ul><blockquote><ul><li><pre><code class="java">//对集合遍历，查看元素        Integer[] i=new Integer[]&#123;11,12,13,14,15&#125;;        col.addAll(Arrays.asList(i));        System.out.println(col);//for (int j=0;j&lt;col.size();j++)&#123;//普通for循环//    col.//&#125; 无通过索引找元素的方法        //增强for循环        col.add(&quot;abc&quot;);        for(Object L:col)&#123;//只能用Object接收，集合中包含不同的元素            System.out.println(L);        &#125;//通过迭代器iterator对集合进行遍历        System.out.println(col.iterator());        Iterator iterator=col.iterator();        while (iterator.hasNext())&#123;//通过haxNext()放啊来判断是否下一个元素；如果有返回true            System.out.println(iterator.next());//next()方法将元素获取到；并且将指针下移        &#125;    <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">  <br>- 通过迭代器iterator对集合进行遍历；haxNext()放啊来判断是否下一个元素；如果有返回<span class="hljs-keyword">true</span>；next()方法将元素获取到；并且将指针下移<br><br>- 注意：增强<span class="hljs-keyword">for</span>循环是一种语法糖（一种简化的语法）；它简化了遍历集合或数组的代码，但底层的实现还是依赖于迭代器或者类似的机制。<br><br>### <span class="hljs-number">13.2</span>.List接口<br><br>- 元素可重复<br>- 有序，有索引<br><br>- &gt;- 常用方法<br><br> &gt;- ~~~Java<br>  //增：<span class="hljs-keyword">add</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>,E element)  <br>   //删：remove(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>)  remove(<span class="hljs-keyword">Object</span> o)<br>   //改:<span class="hljs-keyword">set</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>,E element) <br>   //查：<span class="hljs-keyword">get</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>)<br>   //判断：与Collection一致<br>                                                                      <br>        //增：<span class="hljs-keyword">add</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>,E element)<br>   //删：remove(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>)  remove(<span class="hljs-keyword">Object</span> o)<br>   //改:<span class="hljs-keyword">set</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>,E element)<br>   //查：<span class="hljs-keyword">get</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>)<br>   //判断：<br>   List list=<span class="hljs-built_in">new</span> ArrayList();//接口引用实现类<br>   list.<span class="hljs-keyword">add</span>(<span class="hljs-number">12</span>);//element<br>   list.<span class="hljs-keyword">add</span>(<span class="hljs-number">17</span>);<br>   list.<span class="hljs-keyword">add</span>(<span class="hljs-number">13</span>);<br>   <span class="hljs-type">Integer</span>[] i=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>   list.addAll(Arrays.asList(i));<br>   <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(list);//[<span class="hljs-number">12</span>, <span class="hljs-number">17</span>, <span class="hljs-number">13</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>   list.<span class="hljs-keyword">add</span>(<span class="hljs-number">0</span>,<span class="hljs-number">66</span>);//在索引为<span class="hljs-number">0</span>处添加<span class="hljs-number">66</span><br>   <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(list);//[<span class="hljs-number">66</span>, <span class="hljs-number">12</span>, <span class="hljs-number">17</span>, <span class="hljs-number">13</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>   list.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span>,<span class="hljs-number">77</span>);//把索引为<span class="hljs-number">0</span>的元素改为<span class="hljs-number">77</span><br>   <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(list);//[<span class="hljs-number">77</span>, <span class="hljs-number">12</span>, <span class="hljs-number">17</span>, <span class="hljs-number">13</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>   list.remove(<span class="hljs-number">2</span>);//在集合在存入的是<span class="hljs-type">Integer</span>数据类型时，删除的是对应索引的元素<br>   <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(list);//[<span class="hljs-number">77</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>   list.<span class="hljs-keyword">add</span>(<span class="hljs-number">2</span>,&quot;asdasd&quot;);<br>   list.remove(&quot;asdasd&quot;);//其它数据类型直接删除对应元素，而非对应索引的元素<br>   <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(list);//[<span class="hljs-number">77</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>   <span class="hljs-keyword">Object</span> o=list.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);//返回传入索引的对应元素<br>   <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(o);//<span class="hljs-number">77</span><br>   //遍历<br>        //普通<span class="hljs-keyword">for</span>循环<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt; list.size();j++)&#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(list.<span class="hljs-keyword">get</span>(j));<br>        &#125;<br>        //强制<span class="hljs-keyword">for</span>循环<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">Object</span> obj:list) <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(obj);<br>        //迭代器Iterator<br>        Iterator iterator=list.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext())<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(iterator.next());<br><br><br>~~~Java<br> &gt;- 与Collection相比多了通过索引增加和删除以及查看；如此一来就能通过普通<span class="hljs-keyword">for</span>循环遍历<br> &gt;- 扩展方法都和索引相关<br></code></pre></td></tr></table></figure></code></pre></li></ul></blockquote><ul><li><p><img src="/.com//image-20241222155322256.png" alt="image-20241222155322256"></p><ul><li><p><strong><code>void remove()          删除集合中调用next()返回的对象</code></strong></p></li><li><p>Iterator 是一个接口，用于遍历集合中的元素。</p></li><li><p>haxNext()方法来判断是否下一个元素；如果有返回true；next()方法将元素获取到；并且将指针下移</p></li><li><p>迭代器遍历完毕，指针不会复位，可以获取一个新的迭代器对象进行再次遍历</p></li><li><p>循环中只能用一次next（），因为hasNext()只能保证下一个元素存在，下下个元素无法确定。</p></li><li><p>迭代器遍历时，不能使用集合的方法进行增删操作，迭代器在遍历集合时，会维护一个内部的状态来跟踪集合的结构。如果在迭代过程中使用集合的方法（如 <code>add()</code>、<code>remove()</code> 等）对集合进行增删操作，会破坏迭代器的内部状态，导致迭代器无法正确跟踪集合的元素，从而可能抛出 <code>ConcurrentModificationException</code> 异常。</p></li><li><p><strong><code>Iterator Iterable  ListIterator  区别</code></strong></p></li><li><p>早期只有Iterator接口，提供对集合进行遍历的方法，在jdk1.8后，引入Iterable接口，在Iterable接口代码中也提供了Iterator接口，实现该接口的集合依然可以使用迭代器遍历，此外还提供forEach()方法支持增强for循环，底层依然使用迭代器进行遍历。</p></li><li><p>ListIterator存在与List集合中，通过调用方法可以返回<strong>起始下标</strong>为 <code>index</code>的迭代器，大多数方法与 Iterator 中定义的含义相同，但是比 Iterator 强大的地方是可以在<strong>任意一个下标位置</strong>返回该迭代器，且可以实现<strong>双向遍历</strong>。</p></li><li><pre><code class="Java">List&lt;Integer&gt; list=new ArrayList&lt;&gt;();ListIterator&lt;Integer&gt; listInter1=list.listIterator();//返回索引为0的迭代器ListIterator&lt;Integer&gt; listInter2=list.listIterator(5);//返回索引为5的迭代器<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp">  <br>- ~~~java<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ListIterator</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-title">extends</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; &#123;<br>      <span class="hljs-function">boolean <span class="hljs-title">hasNext</span>()</span>;<br>      <span class="hljs-function">E <span class="hljs-title">next</span>()</span>;<br>      <span class="hljs-function">boolean <span class="hljs-title">hasPrevious</span>()</span>;<br>      <span class="hljs-function">E <span class="hljs-title">previous</span>()</span>;<br>      <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">nextIndex</span>()</span>;<br>      <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">previousIndex</span>()</span>;<br>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span>()</span>;<br>      <span class="hljs-comment">// 替换当前下标的元素,即访问过的最后一个元素</span><br>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span>(<span class="hljs-params">E e</span>)</span>;<br>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span>(<span class="hljs-params">E e</span>)</span>;<br>  &#125;<br>  <br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="1-ArrayList实现类"><a href="#1-ArrayList实现类" class="headerlink" title="1.ArrayList实现类"></a>1.ArrayList实现类</h4><ul><li><blockquote><ul><li>动态数组（<code>Object[] elementData</code>）</li><li>常用方法与List相近</li><li>第一次扩容到十（使用无参构造器没有指定大小的情况下），第二次扩容到1.5倍</li></ul></blockquote></li></ul><ol><li><strong>ArrayList 概述</strong><ul><li>ArrayList 是 Java 集合框架中的一个重要类，它位于<code>java.util</code>包中。它实现了<code>List</code>接口，这意味着它具有<code>List</code>接口所定义的所有方法，例如可以通过索引访问元素、可以包含重复元素等特点。</li><li>ArrayList 本质上是一个动态大小的数组。它提供了方便的方法来添加、删除和访问元素，并且会自动调整大小以适应存储元素的数量变化。与普通数组相比，ArrayList 更加灵活，因为不需要在创建时指定固定的大小。</li></ul></li><li><strong>创建 ArrayList 对象</strong><ul><li>可以使用以下方式创建一个空的 ArrayList：</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><ul><li>这里创建了一个可以存储<code>String</code>类型元素的 ArrayList。<code>&lt;String&gt;</code>是 Java 泛型的语法，用于指定列表中元素的类型。如果不使用泛型，ArrayList 可以存储任何类型的对象，但这样容易导致类型安全问题。例如，以下代码会在编译时产生警告：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ArrayList</span> <span class="hljs-variable">listWithoutGeneric</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>listWithoutGeneric.add(<span class="hljs-string">&quot;String&quot;</span>);<br>listWithoutGeneric.add(<span class="hljs-number">123</span>);  <span class="hljs-comment">// 可以添加不同类型的元素，可能导致问题</span><br></code></pre></td></tr></table></figure><ol><li>添加元素到 ArrayList<ul><li>使用<code>add</code>方法可以将元素添加到 ArrayList 中。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; stringList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>stringList.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>stringList.add(<span class="hljs-string">&quot;World&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>还可以在指定位置添加元素。例如，将一个元素插入到索引为 1 的位置：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stringList.add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Java&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>此时，<code>stringList</code>的内容为<code>[&quot;Hello&quot;, &quot;Java&quot;, &quot;World&quot;]</code>。需要注意的是，如果指定的索引超出了当前列表的范围（例如，索引大于列表的大小），会抛出<code>IndexOutOfBoundsException</code>异常。</li></ul><ol><li>访问 ArrayList 中的元素<ul><li>可以通过索引来访问 ArrayList 中的元素，就像访问数组元素一样。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> stringList.get(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 获取索引为0的元素，这里是&quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><ul><li>如果使用了非法的索引（例如，负数或大于等于列表大小的数），会抛出<code>IndexOutOfBoundsException</code>异常。</li></ul><ol><li>修改 ArrayList 中的元素<ul><li>通过索引和<code>set</code>方法可以修改 ArrayList 中的元素。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stringList.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;Hi&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>此时，<code>stringList</code>的第一个元素被修改为<code>Hi</code>。同样，使用非法的索引会导致<code>IndexOutOfBoundsException</code>异常。</li></ul><ol><li>删除 ArrayList 中的元素<ul><li>可以使用<code>remove</code>方法来删除元素。如果知道元素的索引，可以这样删除：</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stringList.remove(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><ul><li>这会删除索引为 1 的元素。如果知道元素本身的值，也可以删除：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> stringList.remove(<span class="hljs-string">&quot;World&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li><code>result</code>的值为<code>true</code>表示元素被成功删除，<code>false</code>表示列表中不存在该元素。</li></ul><ol><li>遍历 ArrayList<ul><li>使用 for 循环遍历<ul><li>通过索引来遍历 ArrayList，这种方式类似于遍历数组。</li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stringList.size(); i++) &#123;<br>    System.out.println(stringList.get(i));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用增强 for 循环遍历<ul><li>这种方式更简洁，不需要使用索引。底层也是使用迭代器遍历，是一个语法糖，方便简洁的使用。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String str : stringList) &#123;<br>    System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>使用迭代器遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;String&gt; iterator = stringList.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>    System.out.println(iterator.next());<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol><li><strong>ArrayList 的容量和大小</strong><ul><li>ArrayList 有一个容量（<code>capacity</code>）的概念，它表示底层数组的大小。当添加元素导致元素数量超过当前容量时，ArrayList 会自动扩容。例如，初始容量可能是 10，当添加第 11 个元素时，ArrayList 会创建一个新的、更大的数组，并将原来的元素复制到新数组中。</li><li>可以使用<code>size</code>方法来获取 ArrayList 中实际元素的数量。例如，<code>stringList.size()</code>返回<code>stringList</code>中元素的个数。</li></ul></li><li><strong>与其他集合的比较和转换</strong><ul><li>与<code>LinkedList</code>相比，ArrayList 在随机访问（通过索引访问元素）方面性能更好，因为它内部是基于数组实现的；而 LinkedList 在插入和删除操作（特别是在列表中间进行操作）时性能更好，因为它是基于链表实现的。</li><li>ArrayList 可以方便地与其他集合进行转换。例如，将 ArrayList 转换为数组：</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] array = stringList.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[stringList.size()]);<br></code></pre></td></tr></table></figure><ul><li>也可以将数组转换为 ArrayList，例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] anotherArray = &#123;<span class="hljs-string">&quot;One&quot;</span>, <span class="hljs-string">&quot;Two&quot;</span>, <span class="hljs-string">&quot;Three&quot;</span>&#125;;<br>ArrayList&lt;String&gt; newList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(anotherArray));<br></code></pre></td></tr></table></figure><ul><li><p>部分核心源码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArrayList</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> Object[] elementData;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyArrayList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[DEFAULT_CAPACITY];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);<br>        elementData[size++] = e;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>) &#123;<br>            grow(minCapacity);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>) &#123;<br>            newCapacity = minCapacity;<br>        &#125;<br>        elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        rangeCheck(index);<br>        <span class="hljs-keyword">return</span> (E) elementData[index];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheck</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;Index: &quot;</span> + index + <span class="hljs-string">&quot;, Size: &quot;</span> + size);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2.LinkedList"></a>2.LinkedList</h4><ul><li>LinkedList底层是基于双向链表存储数据的</li></ul><blockquote><ul><li>双向链表（<code>Node&lt;E&gt; </code>值，前驱结点，后继结点）</li><li>无论查询哪个数据都要从头开始找或者从尾部开始</li><li>增删相对快</li><li>对首尾元素进行增删改查速度快</li><li>占用内存多，使用场景少</li><li>同时实现了Deque接口，具有双端队列的特性</li></ul></blockquote><p><img src="/.com//image-20241221192020851.png" alt="image-20241221192020851"></p><ul><li><p>总结：</p></li><li><p>优势：LinkedList 底层没有<code>扩容机制</code>，使用<code>双向链表</code>存储元素，所以插入和删除元素效率较高，适用于频繁操作元素的场景</p></li><li><p>劣势：LinkedList 不具备<code>随机访问</code>的特点，查找某个元素只能从 <code>head</code> 或 <code>tail</code> 指针一个一个比较，所以<strong>查找中间的元素时效率很低</strong></p></li><li><p>部分核心源码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> Node&lt;E&gt; first;<br>    <span class="hljs-keyword">private</span> Node&lt;E&gt; last;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        E item;<br>        Node&lt;E&gt; next;<br>        Node&lt;E&gt; prev;<br><br>        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>            <span class="hljs-built_in">this</span>.item = element;<br>            <span class="hljs-built_in">this</span>.next = next;<br>            <span class="hljs-built_in">this</span>.prev = prev;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        linkLast(e);<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);<br>        last = newNode;<br>        <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>) &#123;<br>            first = newNode;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l.next = newNode;<br>        &#125;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        checkElementIndex(index);<br>        <span class="hljs-keyword">return</span> node(index).item;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkElementIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isElementIndex(index)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;Index: &quot;</span> + index + <span class="hljs-string">&quot;, Size: &quot;</span> + size);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isElementIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; size;<br>    &#125;<br><br>    Node&lt;E&gt; <span class="hljs-title function_">node</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>            Node&lt;E&gt; x = first;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>                x = x.next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Node&lt;E&gt; x = last;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt; index; i--) &#123;<br>                x = x.prev;<br>            &#125;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-Vector-Stack"><a href="#3-Vector-Stack" class="headerlink" title="3.Vector&#x2F;Stack"></a>3.Vector&#x2F;Stack</h4><ul><li><p>Vector 在现在已经是一种过时的集合了，包括继承它的 Stack 集合也如此，它们被淘汰的原因都是因为性能低下。</p></li><li><p>JDK 1.0 时代，ArrayList 还没诞生，大家都是使用 Vector 集合，但由于 Vector 的每个操作都被 synchronized 关键字修饰，即使在线程安全的情况下，仍然进行无意义的加锁与释放锁，造成额外的性能开销，做了无用功。<br>在 JDK 1.2 时，Collection 家族出现了，它提供了大量高性能、适用於不同场合的集合，而 Vector 也是其中一员，但由于 Vector 在每个方法上都加了锁，由于需要兼容许多老的项目，很难在此基础上优化Vector了，所以渐渐地也就被历史淘汰了。</p></li></ul><p>现在，在线程安全的情况下，不需要选用 Vector 集合，取而代之的是 ArrayList 集合；在并发环境下，出现了 CopyOnWriteArrayList，Vector 完全被弃用了。同样Stack也被弃用了</p><h4 id="4-CopyOnWriteArrayList"><a href="#4-CopyOnWriteArrayList" class="headerlink" title="4.CopyOnWriteArrayList"></a>4.CopyOnWriteArrayList</h4><h3 id="13-5-Set接口"><a href="#13-5-Set接口" class="headerlink" title="13.5.Set接口"></a>13.5.Set接口</h3><ul><li>无序（添加顺序和获取出的数据顺序不一致）</li><li>不重复</li><li>无索引</li></ul><blockquote><ul><li>HashSet:无序、不重复、无索引、底层利用HashMap（构造函数直接new HashMap）</li><li>LinkedHashSet:有序、不重复、无索引、底层利用LinkedHashMap(继承)</li><li>TreeSet:排序（比较器和排序接口）、不重复、无索引、底层利用TreeMap</li></ul></blockquote><ul><li><p>注意set接口用到的常用方法，基本上就是Collection提供的，自己几乎没有额外新增的一些常用功能</p></li><li><p>HashSet集合的底层原理</p></li><li><blockquote><p>哈希值</p><ul><li><p>Java中所有对象都有一个哈希值，都可以调用Object提供的hashCode方法，返回对象自己的哈希值</p></li><li><pre><code class="Java">public int hashCode():返回对象的哈希码值<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>- 同一个对象调用该方法返回的哈希值是相同的<br><br>- 不同的对象，他们的哈希值大概率不一样。<span class="hljs-type">int</span>(<span class="hljs-number">-21</span>亿多到<span class="hljs-number">21</span>亿多，当对象个数超过可能会出现哈希碰撞，但是几乎不可能)<br><br>基于哈希表HashMap实现<br><br>- JDK8之前的哈希表：数组+链表<br><br>- ~~~Java<br>  <span class="hljs-keyword">Set</span>&lt;String&gt; <span class="hljs-keyword">set</span>=<span class="hljs-built_in">new</span> HashSet&lt;&gt;();<br>  //构造函数直接<span class="hljs-built_in">new</span>一个hashmap<br>  <span class="hljs-keyword">set</span>.<span class="hljs-keyword">add</span>(&quot;数据1&quot;);//第一次加数据，创建一个默认长度为<span class="hljs-number">16</span>的数组，默认加载因子为<span class="hljs-number">0.75</span>，使用元素的哈希值对数组长度做运算计算出应该存入的位置<br>  //后续加入数据先判断该位置是否为<span class="hljs-keyword">null</span>，如果是<span class="hljs-keyword">null</span>则直接存入，如果不是<span class="hljs-keyword">null</span>，表示有元素，则调用equals方法比较，相等不存，不相等则存入数据<br>  //<span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> <span class="hljs-keyword">add</span>(E e) &#123;<br>      <span class="hljs-keyword">return</span> this.map.put(e, PRESENT) == <span class="hljs-keyword">null</span>;<br>  &#125;//我们看到 PRESENT 就是一个静态常量：使用 PRESENT 作为 HashMap 的 <span class="hljs-keyword">value</span> 值，使用HashSet的开发者只需关注于需要插入的 key，屏蔽了 HashMap 的 <span class="hljs-keyword">value</span><br>                                                                    <br></code></pre></td></tr></table></figure></code></pre></li><li><p>JDK开始，当链表长度超过8，且数组长度超过64时，自动将链表转成红黑树</p></li><li><p>红黑树</p></li><li><blockquote><ul><li>自平衡的二叉排序树（左右子树的高度差不超过一的排序树（左根右））</li><li>根叶黑：根结点和叶子结点视为黑色（叶子结点是树底部的空结点）</li><li>不红红：没有连续的红色结点</li><li>黑路同：每一条到叶子结点的路径上黑色结点数量相同</li><li>高度差不超过两倍</li><li>插入删除比平衡二叉搜索树快，查询比平衡二叉搜索树慢</li></ul></blockquote></li></ul></blockquote></li><li><p>HashSet和TreeSet分别如何实现去重的</p><ul><li>HashSet的去重机制：hashcode()+equals(),底层先通过存入对象，进行运算得到一个hash值，通过hash值得到对应的索引，如果发现table索引所在的位置没有数据，就直接存放，如果有数据，就进行equals比较，如果比较后，不相同就加入，否则不加入。</li><li>TreeSet的去重机制：如果你传入了一个Comparator匿名对象，就使用实现的compare去重，如果方法返回0，就认为是重复元素，就不添加，如果你没有传入一个比较器，则以添加的对象实现的Compareable接口的compareTo去重。同理，如果TreeSet在初始化的时候没有传入比较器，那么在后续添加元素是，元素必须是实现了Comparable接口的元素，否则报ClassCastException.</li><li><img src="/.com//image-20250222235931156.png" alt="image-20250222235931156"></li></ul></li></ul><h3 id="13-6-Map接口"><a href="#13-6-Map接口" class="headerlink" title="13.6.Map接口"></a>13.6.Map接口</h3><ul><li>Map接口定义了存储的数据结构是键值对&lt;key,value&gt;形式，根据key映射到value，一个key对应一个value</li><li>分为两类：<ul><li>SortedMap接口：可按自己的规则排序</li><li>AbsractMap抽象类：为子类提供模板（通用的API实现）</li></ul></li></ul><p><img src="/.com//image-20250221233439364.png" alt="image-20250221233439364"></p><p>以下是 <code>Map</code> 接口中一些常用的方法：</p><ul><li><p>添加元素</p><ul><li><code>V put(K key, V value)</code>：将指定的键值对插入到 <code>Map</code> 中。如果键已经存在，则会覆盖旧值，并返回旧值；如果键不存在，则返回 <code>null</code>。</li><li><code>void putAll(Map&lt;? extends K, ? extends V&gt; m)</code>：将指定 <code>Map</code> 中的所有键值对复制到当前 <code>Map</code> 中。</li></ul></li><li><p>获取元素</p><ul><li><code>V get(Object key)</code>：根据指定的键获取对应的值。如果键不存在，则返回 <code>null</code>。</li><li><code>boolean containsKey(Object key)</code>：判断 <code>Map</code> 中是否包含指定的键。</li><li><code>boolean containsValue(Object value)</code>：判断 <code>Map</code> 中是否包含指定的值。</li></ul></li><li><p>删除元素</p><ul><li><code>V remove(Object key)</code>：根据指定的键删除对应的键值对，并返回被删除的值。如果键不存在，则返回 <code>null</code>。</li><li><code>void clear()</code>：清空 <code>Map</code> 中的所有键值对。</li></ul></li><li><p>获取大小和判断是否为空</p><ul><li><code>int size()</code>：返回 <code>Map</code> 中键值对的数量。</li><li><code>boolean isEmpty()</code>：判断 <code>Map</code> 是否为空。</li></ul></li><li><p>获取键集、值集和键值对集</p><ul><li><code>Set&lt;K&gt; keySet()</code>：返回 <code>Map</code> 中所有键组成的 <code>Set</code> 集合。</li><li><code>Collection&lt;V&gt; values()</code>：返回 <code>Map</code> 中所有值组成的 <code>Collection</code> 集合。</li><li><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code>：返回 <code>Map</code> 中所有键值对组成的 <code>Set</code> 集合，其中 <code>Map.Entry</code> 是一个表示键值对的接口。<code>Map</code> 实现类（如 <code>HashMap</code>）通过创建实现了 <code>Map.Entry</code> 接口的具体类（如 <code>Node</code>）的对象来存储键值对。<code>entrySet()</code> 方法会返回一个包含所有这些 <code>Map.Entry</code> 对象的 <code>Set</code> 集合，从而允许用户遍历 <code>Map</code> 中的所有键值对。</li></ul></li><li><p>对Map进行快速遍历</p><blockquote><ul><li><strong>使用 <code>keySet()</code> 遍历键，再通过键获取值</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">import</span> java.util.HashMap;<br>&gt;<span class="hljs-keyword">import</span> java.util.Map;<br><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapTraversalExample</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>      map.put(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">1</span>);<br>      map.put(<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">2</span>);<br>      <span class="hljs-keyword">for</span> (String key : map.keySet()) &#123;<br>          System.out.println(key + <span class="hljs-string">&quot;: &quot;</span> + map.get(key));<br>      &#125;<br>  &#125;<br>&gt;&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>使用 <code>entrySet()</code> 遍历键值对</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">import</span> java.util.HashMap;<br>&gt;<span class="hljs-keyword">import</span> java.util.Map;<br><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapTraversalExample2</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>      map.put(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">1</span>);<br>      map.put(<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">2</span>);<br>      <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;<br>          System.out.println(entry.getKey() + <span class="hljs-string">&quot;: &quot;</span> + entry.getValue());<br>      &#125;<br>  &#125;<br>&gt;&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>使用 <code>forEach()</code> 方法遍历</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">import</span> java.util.HashMap;<br>&gt;<span class="hljs-keyword">import</span> java.util.Map;<br><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapTraversalExample3</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>      map.put(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">1</span>);<br>      map.put(<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">2</span>);<br>      map.forEach((key, value) -&gt; System.out.println(key + <span class="hljs-string">&quot;: &quot;</span> + value));<br>  &#125;<br>&gt;&#125;<br></code></pre></td></tr></table></figure><ul><li>使用<code>Stream API</code>：Java 8 引入的Stream API也可以用于遍历Map，可以将Map转换为流，然后进行各种操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">import</span> java.util.HashMap;  <span class="hljs-comment">// 导入HashMap类  </span><br>&gt;<span class="hljs-keyword">import</span> java.util.Map;      <span class="hljs-comment">// 导入Map接口  </span><br>&gt;<span class="hljs-keyword">import</span> java.util.stream.Collectors;  <span class="hljs-comment">// 导入Collectors用于结果收集  </span><br><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapTraversalExample</span> &#123;  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>      <span class="hljs-comment">// 创建一个HashMap实例，键为String类型，值为Integer类型  </span><br>      Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();  <br>      <br>      <span class="hljs-comment">// 向HashMap中添加键值对  </span><br>      map.put(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-number">1</span>);  <br>      map.put(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-number">2</span>);  <br>      map.put(<span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-number">3</span>);  <br><br>      <span class="hljs-comment">// 使用Stream API遍历Map并打印所有的键值对  </span><br>      map.entrySet().stream()  <span class="hljs-comment">// 将Map的条目集转换为Stream流  </span><br>        .forEach(entry -&gt; &#123;    <span class="hljs-comment">// 对每个条目执行操作  </span><br>            System.out.println(<span class="hljs-string">&quot;Key: &quot;</span> + entry.getKey() + <span class="hljs-string">&quot;, Value: &quot;</span> + entry.getValue());  <br>        &#125;);  <br><br>      <span class="hljs-comment">// 应用过滤条件，创建一个新Map，包含值大于1的键值对  </span><br>      Map&lt;String, Integer&gt; filteredMap = map.entrySet().stream()  <span class="hljs-comment">// 再次将Map的条目集转换为Stream流  </span><br>                                          .filter(entry -&gt; entry.getValue() &gt; <span class="hljs-number">1</span>)  <span class="hljs-comment">// 过滤出值大于1的条目  </span><br>                                          .collect(Collectors.toMap(            <span class="hljs-comment">// 收集过滤后的条目为新Map  </span><br>                                              Map.Entry::getKey,                 <span class="hljs-comment">// 键为原Map的键  </span><br>                                              Map.Entry::getValue                <span class="hljs-comment">// 值为原Map的值  </span><br>                                          ));  <span class="hljs-comment">//lambda表达式::表示引用，类名：：方法名</span><br>      <span class="hljs-comment">// 打印出过滤后的Map  </span><br>      System.out.println(filteredMap);  <br>  &#125;  <br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul><h4 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1.HashMap"></a>1.HashMap</h4><ul><li><p>JDK1.8以前：数组+链表（头插法）</p></li><li><p>JDK1.8后：数组+链表&#x2F;红黑树（尾插法，链表≥8且数组≥64时树化以减少搜索时间,链表数量小于6时转回链表）</p></li><li><p>HashMap不是线程安全的：假设有两个线程 A 和 B 同时对 HashMap 进行操作，并且都触发了扩容。线程 A 先开始扩容，它创建了一个新的数组，并将部分元素复制到新数组中。然后线程 B 也开始扩容，它也创建了一个新的数组。由于线程 A 和线程 B 的执行顺序不确定，可能会导致元素在两个新数组之间来回复制，形成循环链表，从而在后续访问 HashMap 时出现死循环。</p></li><li><p>通过哈希映射函数计算元素的哈希值来定位</p></li><li><p>核心参数：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">// 数组默认的初始大小,16</span><br>&gt;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br>&gt;<span class="hljs-comment">// 负载因子，如果你在数组里的元素的个数达到了数组大小 * 负载因子，就会进行数组的扩容</span><br>&gt;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br>&gt;<span class="hljs-comment">// 这个数组就是所谓的map里的核心数据结构的数组，数组的元素就可以看到是Node类型的，天然就可以挂成一个链表，单向链表，Node里面只有一个next指针</span><br>&gt;<span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br>&gt;<span class="hljs-comment">// 这个size代表的是就是当前hashmap中有多少个key-value对，如果这个数量达到了指定大小 * 负载因子，那么就会进行数组的扩容</span><br>&gt;<span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> size;<br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>      <span class="hljs-keyword">final</span> K key;<br>      V value;<br>      Node&lt;K,V&gt; next;<br>&gt;&#125;<br><br></code></pre></td></tr></table></figure><p>这是一个很关键的<code>内部类</code>，他其实是代表了一个key-value对，里面包含了key的hash值，key，value，还有就是可以有一个next的指针，指向下一个Node，也就是指向单向链表中的下一个节点</p><p>通过这个next指针，就可以形成一个链表</p><p>entryset（）方法就是返回结点集合，由于结点实现了Map.Entry&lt;K,V&gt;接口, 可以多态的使用接口集合来指向结点集合，从而进行遍历，并且该接口Map.Entry&lt;K,V&gt;内有getKey()和getValue()方法，for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) 可以遍历整个HashMap并且能够取键值对。</p></blockquote></li><li><p>Hash计算优化</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>&gt;<span class="hljs-type">int</span> h;<br>&gt;<span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>); <span class="hljs-comment">// 扰动函数</span><br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>hash计算把键（key）对应的哈希码值的高16位和低16位进行异或计算得到hash值的低16位，低16位保存了哈希码的高低16位的特征，最后得到的结果去定位数组的index，降低了哈希冲突的概率。</p><p>键和值（key和value）都可以为null，但是key为null的键值对只能一个，而value为null的键值对可以为多个</p></blockquote></li></ul><h5 id="put操作原理"><a href="#put操作原理" class="headerlink" title="put操作原理"></a>put操作原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key,V value)</span>&#123;<br><span class="hljs-keyword">return</span> putVal(hash(key),key,value,<span class="hljs-literal">false</span>,<span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>        <span class="hljs-comment">// 1.假设，hashmap是空的，通过resize扩容，数组大小就是默认的16，负载因子就是默认的12</span><br>        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            n = (tab = resize()).length;<br>        <span class="hljs-comment">// 2.这是一个寻址算法，用&amp;操作寻址，性能会比用取模高</span><br>        <span class="hljs-comment">// 2.1 n是数组的长度，用数组长度和hash做与运算</span><br>        <span class="hljs-comment">// 2.2在数组长度比较小的时候，高16基本上就废掉了</span><br>        <span class="hljs-comment">// 3.这个数组里的元素是空的</span><br>        <span class="hljs-comment">// 3.1这个分支，他的意思是说tab[i]，i就是hash定位到的数组index，tab[i]如果为空，也就是hash定位到的这个位置是空的，之前没有任何人在这里，此时直接是放一个Node在数组的这个位置即可</span><br>        <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// 3.2定位到数组了，那就把元素插入到链表或者红黑树里</span><br>            tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 4.hash定位到的数组位置，是已经有了Node了</span><br>            Node&lt;K,V&gt; e; K k;<br>            <span class="hljs-comment">// 5.相同的key（会覆盖旧的value）</span><br>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>                ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                e = p;<br>    <span class="hljs-comment">// 6.红黑树</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>            <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">// 7.链表</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                        p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                        <span class="hljs-comment">// 8.如果链表的长度大于等于8的话，链表的总长度达到8的话，那么此时就需要将这个链表转换为一个红黑树的数据结构</span><br>                        <span class="hljs-comment">// 当你遍历到第8个节点，此时binCount是7，同时你挂上了第9个节点，然后就会发现binCount &gt;= 7，达到了临界值，也就是说，当你的链表节点的数量超过8的时候，此时就会将链表转换为红黑树</span><br>                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                            treeifyBin(tab, hash);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// 相同的key（会覆盖旧的value）</span><br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                        <span class="hljs-keyword">break</span>;<br>                    p = e;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 9.相同的key，覆盖旧的value</span><br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>                <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                    e.value = value;<br>                afterNodeAccess(e);<br>                <span class="hljs-keyword">return</span> oldValue;<br>            &#125;<br>        &#125;<br>        ++modCount;<br>        <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>            resize();<br>        afterNodeInsertion(evict);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>put方法的流程：<ul><li>判断数组是否为空，空则进行第一次扩容，数组大小扩为16。</li><li>根据key计算出hashcode(int hashcode&#x3D;hash(key))</li><li>根据hashcode获得数组下标index(int index&#x3D;hashcode&amp;(table.length-1)</li><li>得到数组下标后，如果对应位置为空，把结点对象放入对应位置</li><li>对应位置不为空，比较hash和key,相同则覆盖，不相同则遍历红黑树或者链表，直到覆盖或者没有相同则直接插入链表首部或者红黑树中，插入前如果链表达到一定长度（8），则转换为红黑树进行插入。</li><li>判断如果元素大小超载，则进行数组扩容</li></ul></li><li>如果数组为空，进行第一次扩容数组大小n为16，不为空则进行寻址定位（n-1）&amp;hash得到元素索引，对应位置如果为空，直接插入，如果不为空，比较hash和key,相同则覆盖，不相同则遍历红黑树或者链表，直到覆盖或者没有相同则直接插入链表首部或者红黑树中，插入前如果链表达到一定长度（8），则转换为红黑树进行插入。如果元素大小超载，则进行数组扩容。</li><li><code>(n - 1) &amp; hash</code>与取模运算hash%n等价，但是效率高于取模运算，保证数组大小n为2的次幂时，n-1具有特殊形式（011111），则保证了（n-1）%hash结果和取模运算相同。</li><li>数组扩容原理：扩容的大小一定是2的n次幂，每次扩容后，重新计算hash,hash值要么停留在之前，要么变为原hash+原大小，有利于分散冲突。</li></ul><h5 id="get操作代码"><a href="#get操作代码" class="headerlink" title="get操作代码"></a>get操作代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>     Node&lt;K,V&gt; e;<br>     <span class="hljs-comment">// 1.计算key的hash值</span><br>     <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;<br>&#125;<br><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-type">int</span> n; K k;<br>        <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        <span class="hljs-comment">// 1.先确定数组下标</span><br>            (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 2.如果第一个节点的hash和当前值的hash相等，且值也相等，直接返回</span><br>            <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>                ((k = first.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                <span class="hljs-keyword">return</span> first;<br>            <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 3.如果是红黑树，走红黑树获取节点方法</span><br>                <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>         <span class="hljs-comment">// 4.如果是链表，遍历链表比较</span><br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                        <span class="hljs-keyword">return</span> e;<br>                &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>链表转红黑树的实现逻辑</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs processing">  ~~~<br><br>  <br><br>#### <span class="hljs-number">2.</span>LinkedHashMap<br><br>- 继承自<span class="hljs-built_in">HashMap</span><br><br>- LinkedHashMap内部维护了一个双向链表，能保证元素按插入的顺序访问，也能以访问顺序访问，可以用来实现LRU缓存策略。<br><br>- 核心属性<br><br>  ~~~java<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 双向链表头结点,存放旧数据</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">transient</span> LinkedHashMap.<span class="hljs-property">Entry</span>&lt;K,V&gt; head;<br>  <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 双向链表尾结点,存放新数据</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">transient</span> LinkedHashMap.<span class="hljs-property">Entry</span>&lt;K,V&gt; tail;<br>  <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 是否按访问顺序排序，true为按访问顺序，false为按插入顺序</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> accessOrder;<br></code></pre></td></tr></table></figure></li><li><p>按照插入顺序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedHashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShoppingCartExample</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span>&#123;<br>LinkedHashMap&lt;String,Integer&gt; shoppingCart=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>shoppingCart.put(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-number">3</span>);<br>shoppingCart.put(<span class="hljs-string">&quot;Banana&quot;</span>,<span class="hljs-number">2</span>);<br>shoppingCart.put(<span class="hljs-string">&quot;Orange&quot;</span>,<span class="hljs-number">5</span>);<br><span class="hljs-keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry:shopping.entrySet())&#123;<br>System.put.println(entry.getKey()+<span class="hljs-string">&quot;:&quot;</span>+entry.getValue());<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>按访问顺序排序，并且实现LRU(least recently used 最近最少使用)缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedHashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">// 自定义 LRU 缓存类，继承自 LinkedHashMap</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-comment">// 缓存的最大容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> capacity;<br><br>    <span class="hljs-comment">// 构造函数，初始化缓存容量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-comment">// 调用父类的构造函数</span><br>        <span class="hljs-comment">// 初始容量为 capacity，负载因子为 0.75f，accessOrder 设为 true 表示按访问顺序排序</span><br>        <span class="hljs-built_in">super</span>(capacity, <span class="hljs-number">0.75f</span>, <span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 重写 removeEldestEntry 方法，当缓存大小超过容量时返回 true</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;<br>                <span class="hljs-keyword">return</span> size() &gt; capacity;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个容量为 2 的 LRU 缓存</span><br>        LRUCache&lt;Integer, String&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUCache</span>&lt;&gt;(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">// 向缓存中添加元素</span><br>        cache.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;One&quot;</span>);<br>        cache.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Two&quot;</span>);<br><br>        <span class="hljs-comment">// 访问元素 1，使其成为最近使用的元素</span><br>        System.out.println(cache.get(<span class="hljs-number">1</span>)); <br><br>        <span class="hljs-comment">// 插入元素 3，此时缓存已满，会移除最久未使用的元素（元素 2）</span><br>        cache.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Three&quot;</span>); <br><br>        <span class="hljs-comment">// 尝试获取元素 2，由于已被移除，返回 null</span><br>        System.out.println(cache.get(<span class="hljs-number">2</span>)); <br><br>        <span class="hljs-comment">// 插入元素 4，此时缓存已满，会移除最久未使用的元素（元素 1）</span><br>        cache.put(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;Four&quot;</span>); <br><br>        <span class="hljs-comment">// 尝试获取元素 1，由于已被移除，返回 null</span><br>        System.out.println(cache.get(<span class="hljs-number">1</span>)); <br><br>        <span class="hljs-comment">// 获取元素 3 和 4</span><br>        System.out.println(cache.get(<span class="hljs-number">3</span>)); <br>        System.out.println(cache.get(<span class="hljs-number">4</span>)); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h5><h6 id="基础概念类"><a href="#基础概念类" class="headerlink" title="基础概念类"></a>基础概念类</h6><ul><li><p>问题</p><p>：LinkedHashMap和HashMap有什么区别？</p><ul><li><strong>回答</strong>：<code>HashMap</code> 不保证元素的顺序，它根据键的哈希值来存储元素，元素的存储和遍历顺序是无序的。而 <code>LinkedHashMap</code> 是 <code>HashMap</code> 的子类，它维护了一个双向链表，默认按照插入顺序来存储元素，也可以设置为按照访问顺序来存储元素，因此可以保证元素的插入顺序或访问顺序。</li></ul></li><li><p>问题</p><p>：LinkedHashMap是如何实现保持插入顺序或访问顺序的？</p><ul><li><strong>回答</strong>：<code>LinkedHashMap</code> 内部维护了一个双向链表，每个节点除了包含键值对信息外，还包含指向前一个节点和后一个节点的引用。在插入元素时，会将新元素添加到链表的尾部；在访问元素时（如果设置为按访问顺序），会将被访问的元素移动到链表的尾部。通过这种方式，就可以保持元素的插入顺序或访问顺序。</li></ul></li></ul><h6 id="源码与原理类"><a href="#源码与原理类" class="headerlink" title="源码与原理类"></a>源码与原理类</h6><ul><li><p>问题</p><p>：LinkedHashMap的get方法在按访问顺序时做了什么？</p><ul><li><strong>回答</strong>：当 <code>LinkedHashMap</code> 设置为按访问顺序时，调用 <code>get</code> 方法会将被访问的元素移动到双向链表的尾部。这是通过修改双向链表中节点的前后引用关系来实现的，具体步骤包括先将该节点从当前位置移除，然后将其添加到链表的尾部。</li></ul></li><li><p>问题</p><p>： LinkedHashMap的removeEldestEntry方法有什么作用？</p><ul><li><strong>回答</strong>：<code>removeEldestEntry</code> 方法是一个可重写的方法，用于判断是否需要移除最旧的元素。在插入新元素时，<code>LinkedHashMap</code> 会调用该方法，如果返回 <code>true</code>，则会移除链表头部的元素（即最旧的元素）。在实现 LRU 缓存时，通常会重写该方法，当缓存大小超过容量时返回 <code>true</code>，从而实现自动移除最久未使用的元素。默认情况下返回false不删除元素。</li></ul></li></ul><h6 id="应用场景类"><a href="#应用场景类" class="headerlink" title="应用场景类"></a>应用场景类</h6><ul><li><p>问题</p><p>：在什么情况下你会选择使用LinkedHashMap而不是HashMap</p><ul><li><strong>回答</strong>：当需要保证元素的插入顺序或访问顺序时，会选择使用 <code>LinkedHashMap</code>。例如，实现一个需要按照用户操作顺序记录数据的日志系统，或者实现 LRU 缓存等场景。而如果不需要考虑元素的顺序，只关注键值对的存储和查找效率，<code>HashMap</code> 是更好的选择。</li></ul></li><li><p>问题</p><p>：请设计一个使用LinkedHashMap实现的简单 LRU 缓存。</p><ul><li><strong>回答</strong>：可以通过继承 <code>LinkedHashMap</code> 并重写 <code>removeEldestEntry</code> 方法来实现。如上述的 <code>LRUCache</code> 类示例，设置 <code>accessOrder</code> 为 <code>true</code> 表示按访问顺序排序，并重写 <code>removeEldestEntry</code> 方法，当缓存大小超过容量时返回 <code>true</code> 以移除最旧的元素。</li></ul></li></ul></li></ul><h4 id="3-HashTable"><a href="#3-HashTable" class="headerlink" title="3.HashTable"></a>3.HashTable</h4><ul><li>存储结构是数组+链表</li><li>线程安全：所有的方法都加上了synchronized关键字</li><li>HashTable 默认长度为 <code>11</code>，负载因子为 <code>0.75F</code>，即元素个数达到数组长度的 75% 时，会进行一次扩容，每次扩容为原来数组长度的 <code>2</code> 倍</li></ul><h4 id="4-TreeMap"><a href="#4-TreeMap" class="headerlink" title="4.TreeMap"></a>4.TreeMap</h4><ul><li><p>TreeMap实现了Map、SortedMap、NavigableMap、Cloneable、Serializble等接口</p></li><li><p>使用红黑树存储元素，按Key的自然顺序来排序。</p></li><li><p>不能存储null键，因为要对键进行排序</p></li><li><p>线程同样不安全，在多线程下使用，需要进行额外处理，例如使用Collections.synchronizedSortedMap方法</p></li><li><p>构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.TreeMap;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeMapExample</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-comment">//函数式比较器接口,逆序</span><br>Comparator&lt;String&gt;reverseComparator=(s1,s2)-&gt;s2.comparaTo(s1);<br>TreeMap&lt;String,Integer&gt;treeMap1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<span class="hljs-comment">//默认构造按Key的自然顺序排序</span><br>TreeMap&lt;String,Integer&gt;treeMap2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;(reverseComparator);<span class="hljs-comment">//按传入的比较器</span><br>TreeMap&lt;String,Integer&gt;treeMap3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;((o1,o2)-&gt;String.compare(o2,o1));<span class="hljs-comment">//简化版写法</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>常用方法</p><ul><li>put(K，V)</li><li>get(K)</li><li>remove(K)</li><li>firstKey()</li><li>lastKey()</li></ul></li><li><p>遍历</p><ul><li><p>使用entrySet()或者keySet()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry:treeMap.entrySet())&#123;<br>System.out.println(entry.getKey()+<span class="hljs-string">&quot;:&quot;</span>+entry.getValue());<br>&#125;<br><br><span class="hljs-keyword">for</span>(String key:treeMap.keySet())&#123;<br>System.out.println(key+<span class="hljs-string">&quot;:&quot;</span>+treeMap.get(key));<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Java 中，<code>Comparable</code>、<code>Comparator</code> 接口以及 <code>compareTo</code> 方法都与对象的比较和排序相关，下面将分别详细介绍它们。</p><p><code>Comparable</code> 接口</p><ul><li><strong>定义</strong>：<code>Comparable</code> 是 Java 中的一个泛型接口，位于 <code>java.lang</code> 包下。它只有一个抽象方法 <code>compareTo</code>，用于定义对象的自然排序规则。一个类实现了 <code>Comparable</code> 接口，就意味着该类的对象可以进行比较和排序。</li><li><strong>接口定义</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T o)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>compareTo</code> 方法规则：<ul><li>如果当前对象小于指定对象 <code>o</code>，返回一个负整数。</li><li>如果当前对象等于指定对象 <code>o</code>，返回 0。</li><li>如果当前对象大于指定对象 <code>o</code>，返回一个正整数。</li></ul></li><li><strong>示例代码</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt; &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student other)</span> &#123;<br>        <span class="hljs-comment">// 按年龄升序排序，如果年龄相同则按姓名排序</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ageComparison</span> <span class="hljs-operator">=</span> Integer.compare(<span class="hljs-built_in">this</span>.age, other.age);<br>        <span class="hljs-keyword">if</span> (ageComparison != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> ageComparison;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.compareTo(other.name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;, age=&quot;</span> + age + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用 <code>Arrays.sort</code> 或 <code>Collections.sort</code> 对实现了 <code>Comparable</code> 接口的对象数组或列表进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparableExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Student[] students = &#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">20</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">18</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">20</span>)<br>        &#125;;<br>        Arrays.sort(students);<br>        <span class="hljs-keyword">for</span> (Student student : students) &#123;<br>            System.out.println(student);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Comparator</code> 接口</p><ul><li><strong>定义</strong>：<code>Comparator</code> 是一个函数式接口，位于 <code>java.util</code> 包下。它用于定义一种比较策略，允许在不修改对象类本身的情况下，为对象提供不同的排序规则。<code>Comparator</code> 接口中包含一个抽象方法 <code>compare</code>。</li><li><strong>接口定义</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparator</span>&lt;T&gt; &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(T o1, T o2)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>compare</code> 方法规则</p><p>：</p><ul><li>如果 <code>o1</code> 小于 <code>o2</code>，返回一个负整数。</li><li>如果 <code>o1</code> 等于 <code>o2</code>，返回 0。</li><li>如果 <code>o1</code> 大于 <code>o2</code>，返回一个正整数。</li></ul></li><li><p><strong>示例代码</strong>：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;, age=&quot;</span> + age + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparatorExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Student[] students = &#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">20</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">18</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">20</span>)<br>        &#125;;<br>        <span class="hljs-comment">// 使用 Comparator 按年龄降序排序</span><br>        Arrays.sort(students, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student s1, Student s2)</span> &#123;<br>                <span class="hljs-keyword">return</span> Integer.compare(s2.getAge(), s1.getAge());<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (Student student : students) &#123;<br>            System.out.println(student);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用 Lambda 表达式简化 <code>Comparator</code> 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(students, (s1, s2) -&gt; Integer.compare(s2.getAge(), s1.getAge()));<br></code></pre></td></tr></table></figure><p><code>compareTo</code> 方法</p><ul><li><strong>作用</strong>：<code>compareTo</code> 是 <code>Comparable</code> 接口中定义的唯一抽象方法，用于定义对象之间的自然排序规则。当一个类实现了 <code>Comparable</code> 接口，就必须实现 <code>compareTo</code> 方法，这样该类的对象才能进行比较和排序。</li><li><strong>使用场景</strong>：通常在需要对对象数组或列表进行默认排序时使用。例如，<code>String</code> 类就实现了 <code>Comparable</code> 接口，其 <code>compareTo</code> 方法按字典顺序比较字符串：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;apple&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;banana&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> str1.compareTo(str2);<br><span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;<br>    System.out.println(str1 + <span class="hljs-string">&quot; 在字典顺序上小于 &quot;</span> + str2);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) &#123;<br>    System.out.println(str1 + <span class="hljs-string">&quot; 等于 &quot;</span> + str2);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    System.out.println(str1 + <span class="hljs-string">&quot; 在字典顺序上大于 &quot;</span> + str2);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>**<code>Comparable</code>**：用于定义对象的自然排序规则，类需要实现该接口并实现 <code>compareTo</code> 方法。</li><li>**<code>Comparator</code>**：用于提供额外的比较策略，不修改对象类本身的情况下为对象定义不同的排序规则。</li><li>**<code>compareTo</code>**：是 <code>Comparable</code> 接口中的方法，用于定义对象之间的比较逻辑。</li></ul></li></ul></li></ul><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><ul><li><p>HashMap不是线程安全的，多线程同时put时可能会出现覆盖现象</p></li><li><p>多线程扩容时，可能产生循环链表。</p></li><li><p>解决方法：</p><ul><li><p>手动加锁或者使用读写锁ReentrantReadWriteLock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span>&#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer,String&gt;map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> Object lock=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key,String Value)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(lock)&#123;<br>            map.put(key,value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用Collections.synchronizedMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>Map&lt;Integer,String&gt;synchronizedMap=Collections.synchronizedMap(map);<br></code></pre></td></tr></table></figure></li><li><p>使用ConcurrentHashMap</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ConcurrentHashMap&lt;Integer,String&gt;map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><ul><li><strong>分段锁（JDK 7 及以前）</strong>：<code>ConcurrentHashMap</code> 在 JDK 7 及以前采用分段锁机制。它将整个哈希表分成多个段（Segment extend ReentrantLock），每个段相当于一个小的 <code>HashMap</code>，并且每个段都有自己的锁。不同的线程可以同时访问不同的段，从而提高并发性能。<ul><li>将HashMap分段为多个Segment，根据key算出对应Segment的索引index,获取对应位置的锁（segments[index].lock()）,再进行put(segemnts[index].put(key,value))，最后释放锁（segments[index].unlock()）。</li></ul></li><li><strong>CAS + synchronized（JDK 8 及以后）</strong>：JDK 8 及以后的 <code>ConcurrentHashMap</code> 摒弃了分段锁机制，采用 CAS（Compare-And-Swap）和 <code>synchronized</code> 来保证线程安全。在插入元素时，首先使用 CAS 尝试更新节点，如果失败则使用 <code>synchronized</code> 锁住当前桶的头节点，然后进行插入操作。</li></ul><h3 id="13-7-泛型"><a href="#13-7-泛型" class="headerlink" title="13.7.泛型"></a>13.7.泛型</h3><ol><li><strong>什么是 Java 泛型</strong><ul><li>Java 泛型是 JDK 5.0 引入的一个重要特性，它提供了一种在编译时期检查类型安全的机制。简单来说，泛型允许你在定义类、接口和方法时使用类型参数，这样这些类型就可以在使用时再确定。</li><li>例如，在没有泛型之前，如果你有一个存储整数的列表，你可能会定义一个<code>ArrayList</code>，然后将整数添加进去。但是如果不小心添加了一个字符串，在运行时才会发现错误。而泛型可以让你在编译时就避免这种类型不匹配的错误。</li><li>泛型的主要目的是提高代码的复用性和类型安全性。</li></ul></li><li><strong>泛型的语法</strong><ul><li>定义泛型类<ul><li>以一个简单的<code>Box</code>类为例，它可以用来存储任意类型的对象。</li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T t;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-built_in">this</span>.t = t;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里的<code>&lt;T&gt;</code>就是定义了一个类型参数<code>T</code>，<code>T</code>可以是任何引用类型（在 Java 中，基本类型不能直接作为泛型类型参数，但可以使用它们对应的包装类型，如<code>Integer</code>对应<code>int</code>）。在<code>Box</code>类中，有一个私有成员变量<code>t</code>的类型是<code>T</code>，还有两个方法<code>set</code>和<code>get</code>来设置和获取这个变量。</li><li>定义泛型接口<ul><li>例如，定义一个<code>Generator</code>接口，用于生成某种类型的对象。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Generator</span>&lt;T&gt; &#123;<br>    T <span class="hljs-title function_">generate</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>类型参数<code>T</code>用于指定生成对象的类型，实现这个接口的类需要提供<code>generate</code>方法的具体实现，并且返回类型是<code>T</code>。</li><li>定义泛型方法<ul><li>泛型方法可以在普通类或泛型类中定义</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Util</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">getMiddle</span><span class="hljs-params">(T... a)</span> &#123;<br>        <span class="hljs-keyword">return</span> a[a.length / <span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里<code>&lt;T&gt;</code>定义了一个泛型方法<code>getMiddle</code>，它可以接受任意数量的<code>T</code>类型的参数（<code>T... a</code>是可变参数的语法），并返回中间位置的元素。</li></ul><ol><li>泛型的使用场景<ul><li>集合框架中的应用<ul><li>在 Java 的集合框架中，泛型被广泛使用。例如<code>ArrayList</code>、<code>HashMap</code>等。</li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; stringList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>stringList.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>stringList.add(<span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-comment">// 编译器会检查类型，下面这行代码会报错，因为不能添加整数</span><br><span class="hljs-comment">// stringList.add(123);</span><br></code></pre></td></tr></table></figure><ul><li>这样就确保了<code>ArrayList</code>中只能存储<code>String</code>类型的元素，提高了代码的类型安全性。</li><li>自定义数据结构和算法<ul><li>当你实现自己的数据结构，如链表、栈、队列等，或者实现一些通用的算法，如排序、查找等，泛型可以让你的代码更加通用。例如，实现一个简单的链表节点类。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;T&gt; &#123;<br>    T data;<br>    Node&lt;T&gt; next;<br>    Node(T data) &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>        <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这个<code>Node</code>类可以用来构建存储不同类型数据的链表。</li></ul><ol><li><strong>类型擦除</strong><ul><li>Java 中的泛型是通过类型擦除来实现的。这意味着在编译后的字节码中，泛型类型信息会被擦除。例如，对于<code>Box&lt;Integer&gt;</code>和<code>Box&lt;String&gt;</code>，在字节码层面，它们都会被转换为<code>Box</code>（原始类型）。</li><li>编译器会在编译时进行类型检查，插入必要的类型转换代码。但是在运行时，通过反射等方式获取的类型信息是擦除后的类型。这也导致了一些限制，比如不能使用<code>new T()</code>（因为在运行时<code>T</code>的具体类型已经被擦除了），但可以通过传递一个工厂对象或者使用反射等方式来解决这个问题。</li></ul></li><li><strong>通配符</strong><ul><li>泛型通配符用于在某些情况下增加泛型的灵活性。</li><li>无界通配符<ul><li><code>&lt;?&gt; </code>是无界通配符，表示可以匹配任何类型。例如，有一个方法用于打印集合中的元素。</li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(ArrayList&lt;?&gt; list)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Object element : list) &#123;<br>        System.out.println(element);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这个方法可以接受任何类型的<code>ArrayList</code>，但是在方法内部，只能将元素当作<code>Object</code>来处理，因为不知道具体的类型。</li><li>上界通配符<ul><li><code>&lt;? extends T&gt;</code>是上界通配符，表示匹配<code>T</code>或者<code>T</code>的子类。例如，假设有一个<code>Animal</code>类和它的子类<code>Dog</code>和<code>Cat</code>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAnimalList</span><span class="hljs-params">(ArrayList&lt;? extends Animal&gt; list)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Animal animal : list) &#123;<br>        System.out.println(animal);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这个方法可以接受<code>ArrayList&lt;Animal&gt;</code>、<code>ArrayList&lt;Dog&gt;</code>或者<code>ArrayList&lt;Cat&gt;</code>等，只要元素类型是<code>Animal</code>或者它的子类就行。</li><li>下界通配符<ul><li><code>&lt;? super T&gt;</code>是下界通配符，表示匹配<code>T</code>或者<code>T</code>的父类。例如，有一个方法用于向集合中添加元素。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addToAnimalList</span><span class="hljs-params">(ArrayList&lt;? <span class="hljs-built_in">super</span> Dog&gt; list)</span> &#123;<br>    <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>    list.add(dog);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这个方法可以接受<code>ArrayList&lt;Animal&gt;</code>或者<code>ArrayList&lt;Object&gt;</code>等，只要元素类型是<code>Dog</code>或者它的超类就行，这样就可以向集合中添加<code>Dog</code>类型的元素。</li></ul><h3 id="13-8-stream流"><a href="#13-8-stream流" class="headerlink" title="13.8.stream流"></a>13.8.stream流</h3><h5 id="1-什么是-Stream-流"><a href="#1-什么是-Stream-流" class="headerlink" title="1. 什么是 Stream 流"></a>1. 什么是 Stream 流</h5><p>Stream 流是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。它并不是一种数据结构，不保存数据，而是对数据进行计算和处理。Stream 流具有以下特点：</p><ul><li><strong>元素序列</strong>：Stream 流是一系列元素的序列，它可以来自于集合、数组、文件等。</li><li><strong>按需计算</strong>：Stream 流的操作是按需计算的，只有在调用终端操作时才会开始执行。</li><li><strong>函数式编程</strong>：Stream 流支持函数式编程，通过 Lambda 表达式来定义操作。</li><li><strong>不可变</strong>：Stream 流不会修改原始数据源，而是生成一个新的流。</li></ul><h5 id="2-Stream-流的创建"><a href="#2-Stream-流的创建" class="headerlink" title="2. Stream 流的创建"></a>2. Stream 流的创建</h5><p>可以通过多种方式创建 Stream 流，常见的方式如下：</p><h6 id="从集合创建"><a href="#从集合创建" class="headerlink" title="从集合创建"></a>从集合创建</h6><p>集合类（如 <code>List</code>、<code>Set</code> 等）提供了 <code>stream()</code> 和 <code>parallelStream()</code> 方法来创建顺序流和并行流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamCreation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>);<br>        <span class="hljs-comment">// 创建顺序流</span><br>        Stream&lt;String&gt; stream = list.stream();<br>        <span class="hljs-comment">// 创建并行流</span><br>        Stream&lt;String&gt; parallelStream = list.parallelStream();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="从数组创建"><a href="#从数组创建" class="headerlink" title="从数组创建"></a>从数组创建</h6><p>可以使用 <code>Arrays.stream()</code> 方法从数组创建 Stream 流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamFromArray</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        java.util.stream.<span class="hljs-type">IntStream</span> <span class="hljs-variable">intStream</span> <span class="hljs-operator">=</span> Arrays.stream(array);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="使用-Stream-of-方法"><a href="#使用-Stream-of-方法" class="headerlink" title="使用 Stream.of() 方法"></a>使用 <code>Stream.of()</code> 方法</h6><p>可以使用 <code>Stream.of()</code> 方法直接创建 Stream 流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamOf</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-Stream-流的操作类型"><a href="#3-Stream-流的操作类型" class="headerlink" title="3. Stream 流的操作类型"></a>3. Stream 流的操作类型</h5><p>Stream 流的操作可以分为中间操作和终端操作。</p><h6 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h6><p>中间操作会返回一个新的 Stream 流，多个中间操作可以连接成一个流水线。常见的中间操作有：</p><ul><li>**<code>filter(Predicate&lt;T&gt; predicate)</code>**：过滤流中的元素，只保留满足条件的元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>        numbers.stream()<br>               .filter(n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>               .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>**<code>map(Function&lt;T, R&gt; mapper)</code>**：将流中的每个元素映射为另一个元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>        numbers.stream()<br>               .map(n -&gt; n * <span class="hljs-number">2</span>)<br>               .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>**<code>sorted()</code>**：对流中的元素进行排序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SortedExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>);<br>        numbers.stream()<br>               .sorted()<br>               .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h6><p>终端操作会触发流的执行，并产生一个最终结果。常见的终端操作有：</p><ul><li>**<code>forEach(Consumer&lt;T&gt; action)</code>**：对流中的每个元素执行指定的操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForEachExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>);<br>        list.stream()<br>            .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>**<code>collect(Collector&lt;T, A, R&gt; collector)</code>**：将流中的元素收集到一个集合中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>        List&lt;Integer&gt; evenNumbers = numbers.stream()<br>                                           .filter(n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>                                           .collect(Collectors.toList());<br>        System.out.println(evenNumbers);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>**<code>count()</code>**：返回流中元素的数量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> numbers.stream()<br>                            .filter(n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>                            .count();<br>        System.out.println(<span class="hljs-string">&quot;Even numbers count: &quot;</span> + count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-并行流"><a href="#4-并行流" class="headerlink" title="4. 并行流"></a>4. 并行流</h5><p>并行流是一种可以并行执行的流，它可以充分利用多核处理器的优势，提高处理效率。可以通过 <code>parallelStream()</code> 方法创建并行流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParallelStreamExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> numbers.parallelStream()<br>                          .mapToInt(Integer::intValue)<br>                          .sum();<br>        System.out.println(<span class="hljs-string">&quot;Sum: &quot;</span> + sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，并行流并不总是比顺序流快，因为并行流的执行需要额外的线程管理和同步开销。在使用并行流时，需要根据具体情况进行性能测试和优化。</p><ol start="5"><li>总结</li></ol><p>Java 集合框架的 Stream 流提供了一种强大而灵活的方式来处理集合中的元素。通过中间操作和终端操作的组合，可以实现复杂的数据处理逻辑。同时，并行流的使用可以提高处理效率，但需要注意性能问题。掌握 Stream 流的使用可以让代码更加简洁、易读和高效。</p><h3 id="13-9-Collections和CollectionUtils"><a href="#13-9-Collections和CollectionUtils" class="headerlink" title="13.9.Collections和CollectionUtils"></a>13.9.Collections和CollectionUtils</h3><h4 id="1-Collections"><a href="#1-Collections" class="headerlink" title="1.Collections"></a>1.<code>Collections</code></h4><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><code>Collections</code> 是 Java 提供的一个工具类，它位于 <code>java.util</code> 包中，包含了一系列用于操作集合的静态方法，这些方法提供了对集合进行排序、查找、填充、同步等功能。</p><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li><code>sort(List&lt;T&gt; list)</code>：对列表进行自然排序。</li><li><code>binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)</code>：在有序列表中使用二分查找算法查找指定元素。</li><li><code>reverse(List&lt;?&gt; list)</code>：反转列表中元素的顺序。</li><li><code>shuffle(List&lt;?&gt; list)</code>：随机打乱列表中元素的顺序。</li><li><code>synchronizedCollection(Collection&lt;T&gt; c)</code>：返回指定集合的同步（线程安全）版本。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionsExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-number">3</span>);<br>        list.add(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-number">4</span>);<br>        <span class="hljs-comment">// 对列表进行排序</span><br>        Collections.sort(list);<br>        System.out.println(<span class="hljs-string">&quot;排序后的列表: &quot;</span> + list);<br>        <span class="hljs-comment">// 反转列表</span><br>        Collections.reverse(list);<br>        System.out.println(<span class="hljs-string">&quot;反转后的列表: &quot;</span> + list);<br>        <span class="hljs-comment">// 随机打乱列表</span><br>        Collections.shuffle(list);<br>        System.out.println(<span class="hljs-string">&quot;打乱后的列表: &quot;</span> + list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-CollectionUtils"><a href="#3-CollectionUtils" class="headerlink" title="3. CollectionUtils"></a>3. <code>CollectionUtils</code></h4><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p><code>CollectionUtils</code> 并不是 Java 标准库中的类，而是 Apache Commons Collections 库提供的一个工具类，它提供了一系列用于操作集合的实用方法，这些方法可以帮助开发者更方便地处理集合，减少代码量。</p><h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li><code>isEmpty(Collection&lt;?&gt; collection)</code>：判断集合是否为空。</li><li><code>isNotEmpty(Collection&lt;?&gt; collection)</code>：判断集合是否不为空。</li><li><code>union(Collection&lt;? extends O&gt; a, Collection&lt;? extends O&gt; b)</code>：返回两个集合的并集。</li><li><code>intersection(Collection&lt;? extends O&gt; a, Collection&lt;? extends O&gt; b)</code>：返回两个集合的交集。</li><li><code>subtract(Collection&lt;? extends O&gt; a, Collection&lt;? extends O&gt; b)</code>：返回两个集合的差集。</li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>首先，你需要在项目中添加 Apache Commons Collections 库的依赖。如果你使用的是 Maven 项目，可以在 <code>pom.xml</code> 中添加以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections4<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.collections4.CollectionUtils;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionUtilsExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list1.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>        list1.add(<span class="hljs-string">&quot;banana&quot;</span>);<br><br>        List&lt;String&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list2.add(<span class="hljs-string">&quot;banana&quot;</span>);<br>        list2.add(<span class="hljs-string">&quot;cherry&quot;</span>);<br><br>        <span class="hljs-comment">// 判断集合是否为空</span><br>        System.out.println(<span class="hljs-string">&quot;list1 是否为空: &quot;</span> + CollectionUtils.isEmpty(list1));<br>        <span class="hljs-comment">// 求两个集合的交集</span><br>        Collection&lt;String&gt; intersection = CollectionUtils.intersection(list1, list2);<br>        System.out.println(<span class="hljs-string">&quot;list1 和 list2 的交集: &quot;</span> + intersection);<br>        <span class="hljs-comment">// 求两个集合的并集</span><br>        Collection&lt;String&gt; union = CollectionUtils.union(list1, list2);<br>        System.out.println(<span class="hljs-string">&quot;list1 和 list2 的并集: &quot;</span> + union);<br>        <span class="hljs-comment">// 求两个集合的差集</span><br>        Collection&lt;String&gt; subtract = CollectionUtils.subtract(list1, list2);<br>        System.out.println(<span class="hljs-string">&quot;list1 减去 list2 的差集: &quot;</span> + subtract);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li><code>Collection</code> 是 Java 集合框架的根接口，定义了集合的基本操作方法。</li><li><code>Collections</code> 是 Java 提供的工具类，包含了一系列用于操作集合的静态方法。</li><li><code>CollectionUtils</code> 是 Apache Commons Collections 库提供的工具类，提供了更多实用的集合操作方法。</li></ul><h2 id="14-多线程"><a href="#14-多线程" class="headerlink" title="14.多线程"></a>14.多线程</h2><ul><li>java每次运行至少有两个线程，一个是主线程main(),一个是垃圾回收线程</li></ul><h3 id="14-1-创建多线程"><a href="#14-1-创建多线程" class="headerlink" title="14.1.创建多线程"></a>14.1.创建多线程</h3><ul><li>方式一：继承Thread类来实现</li></ul><blockquote><ul><li>定义一个子类继承Thread类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>&gt;<span class="hljs-comment">//重写Thread类的run方法</span><br>&gt;<span class="hljs-meta">@Override</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>&gt;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>&gt;System.out.println(<span class="hljs-string">&quot;子线程输出&quot;</span>+i);<br>&gt;&#125;<br>&gt;&#125;<br>&gt;&#125;<br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<span class="hljs-comment">//main方法默认也是一条线程，程序的主线程</span><br>&gt;Thread t1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>&gt;<span class="hljs-comment">//调用start方法启动线程</span><br>&gt;t1.start();<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>       System.out.println(<span class="hljs-string">&quot;主线程输出：&quot;</span>+i);<br>   &#125;<br>&gt;&#125;<br><br></code></pre></td></tr></table></figure></blockquote><p>注意：</p><ol><li><p>直接调用run方法会当成普通方法执行，此时相当于还是单线程执行</p></li><li><p>只调用start方法才是启动一个新的线程执行</p></li><li><p>不要把主线任务放在启动子线程之前，这样主线程一直是先跑完的，相当于单线程的效果</p></li></ol><ul><li>方式二：实现Runnable接口</li></ul><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myrunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>&gt;<span class="hljs-meta">@Override</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>&gt;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>&gt;System.out.println(<span class="hljs-string">&quot;子线程输出&quot;</span>+i);<br>&gt;&#125;<br>&gt;&#125;<br><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>&gt;<span class="hljs-comment">//创建线程任务类对象代表一个线程任务</span><br>&gt;Runnable r=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Myrunnable</span>();<br>&gt;<span class="hljs-comment">//把线程任务对象交给一个线程对象来处理</span><br>&gt;Thread t1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>&gt;<span class="hljs-comment">//启动线程</span><br>&gt;t1.start();<br>        <br>&gt;<span class="hljs-comment">//匿名内部写法</span><br>   <span class="hljs-comment">//声明一个接口对象</span><br>   <span class="hljs-comment">//声明一个匿名子类（无声明）内部类,并且接口回调</span><br> Runnable r1= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>       System.out.println(<span class="hljs-string">&quot;子线程输出：&quot;</span>+i);<br>       &#125;           <br>   &#125;;<br>      Thread t2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r1);<br>      t2.start();<br>   <span class="hljs-comment">//直接用Thread接匿名</span><br>     Thread t3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>       System.out.println(<span class="hljs-string">&quot;子线程输出：&quot;</span>+i);<br>       &#125;).start();<br>        <br>   <span class="hljs-comment">//Lambda</span><br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>       System.out.println(<span class="hljs-string">&quot;子线程输出：&quot;</span>+i);<br>            &#125;).start();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>       System.out.println(<span class="hljs-string">&quot;主线程输出：&quot;</span>+i);<br>&#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>优缺点：</li><li>优点：任务类只是实现接口，可以继承其它类，实现其它接口，扩展性强。</li><li>缺点：需要一个Runnable对象</li></ul></blockquote><ul><li><p>方式三：实现Callable接口、Futuretask类（重点）</p></li><li><p>前两种线程创建方式都存在一个问题</p></li><li><p>假如线程执行完毕后有一些数据需要返回，他们重写的run方法均不能直接返回结果。</p></li><li><p>Futuretask类实现了Runnalbe接口和Future接口</p><ul><li>Future接口：对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。<ol><li>取消任务：<code>bollean cancel(boolean mayInterruptIfRunning(是否打断正在执行的任务))</code></li><li><code>isCancelled()</code>表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li><li><code>isDone()</code>表示任务是否已经完成，若任务完成，则返回 true；</li><li><code>get()</code> 用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li><li><code>get(long timeout, TimeUnit unit)</code> 用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回 <code>null</code>。</li></ol></li></ul></li><li><p>Callable是单接口，只有一个call方法</p></li></ul><blockquote><ol><li>定义一个类实现Callable接口，重写call方法，封装要做的事情，和要返回的数据。</li><li>把Callable类型的对象封装成FutureTask（线程任务对象)。</li><li>把线程任务对象交给Thread对象</li><li>调用Thread对象的start方法启动线程</li><li>线程执行完毕后，通过Futuretask对象的get()方法来获取线程任务执行的结果。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>Callable&lt;String&gt; c1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">100</span>);<br><span class="hljs-comment">//把Callable对象封装成FutureTask（线程任务对象)</span><br><span class="hljs-comment">//FutureTask继承于Runnable</span><br>FutureTask&lt;String&gt; f1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(c1);<span class="hljs-comment">//public FutureTask(Callable&lt;V&gt; callable)</span><br>    Thread t1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(f1);<br>    t1.start();<br><br>    Callable&lt;String&gt; c2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">50</span>);<br>    FutureTask&lt;String&gt; f2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(c2);<br>    Thread t2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(f2);<br>    t2.start();<br>    <span class="hljs-comment">//实现Callable的对象重写了call(),把该对象传入FutureTask构造器中，FutureTask对象通过.get()拿到call()的返回值。</span><br><br><br><br>    <span class="hljs-comment">//取线程的结果</span><br>    <span class="hljs-keyword">try</span>&#123;<span class="hljs-comment">//如果主线程发现一个线程t1还没有执行完，会让出CPU，等第一个线程执行完毕，才会往下执行！</span><br>        System.out.println(f1.get());<br>    &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">try</span>&#123;<span class="hljs-comment">//如果主线程发现第二个线程t2还没有执行完，会让出CPU，等第二个线程执行完毕，才会往下执行！</span><br>        System.out.println(f2.get());<br>    &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//定义一个实现类来实现Callable接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCallable</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-built_in">this</span>.n=n;<br>&#125;<br><span class="hljs-comment">//实现call方法，定义线程执行体</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>System.out.println(i);<br>sum+=i;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;子线程计算的结果是：&quot;</span>+sum;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>快速简单创建</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">FutureTask&lt;String&gt; futureTask=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;()&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;call&quot;</span>;<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure></blockquote><h3 id="14-2-常用方法"><a href="#14-2-常用方法" class="headerlink" title="14.2.常用方法"></a>14.2.常用方法</h3><ul><li><p>搞清楚线程的常用方法</p></li><li><pre><code class="java">public static void main(String[]args)&#123;Thread t1=new Mythread(&quot;一号线程&quot;);    //为线程设置名字public void setName(String name)//t1.setName(&quot;一号线程&quot;);   //启动之前 t1.start();System.out.println(t1.getName());//public String getName()获取线程的名字默认是Thread-索引Thread t1=new Mythread(&quot;二号线程&quot;);//t2.setName(&quot;二号线程&quot;);    t2.start();System.out.println(t2.getName());//获取当前线程public static Thread currentThread();    //哪个线程调用这个代码，这个代码就拿到哪个线程    Thread m=Thread.currentThread();//主线程    m.setName(&quot;主线程&quot;);    System.out.println(m.getName());//main        &#125;class Mythread extends Thread&#123;//重写Thread的run方法@Overridepublic void run()&#123;for(int i=0;i&lt;5;i++)&#123;System.out.println(Thread.currentThread.getName()+&quot;子线程输出&quot;+i);&#125;  &#125;<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><br>  &gt; <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> setName(<span class="hljs-built_in">String</span> name)为线程设置名字为线程设置名字,需要在线程开启前<br>  &gt;<br>  &gt; <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> start()启动线程<br>  &gt;<br>  &gt; <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> getName()获取线程的名字默认是<span class="hljs-keyword">Thread</span>-索引<br>  &gt;<br>  &gt; <span class="hljs-keyword">public</span> static <span class="hljs-keyword">Thread</span> currentThread();获取当前线程，哪个线程调用这个代码，这个代码就拿到哪个线程<br><br>- 常用构造器<br><br>~~~java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">Thread</span>(<span class="hljs-built_in">String</span> name)<span class="hljs-comment">//初始化时传入线程的名字</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">Thread</span>(Runnable target)<span class="hljs-comment">//封装Runnable对象，（传入任务）对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">Thread</span>(Runnable target,<span class="hljs-built_in">String</span> name)<span class="hljs-comment">//传入任务对象和线程的名字</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>线程休眠</p></li></ul><p>让**<code>当前执行的线程</code>**进入休眠状态</p><p>public static void sleep(long times)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">10</span>;i++)&#123;<br>System.out.println(i);<br><span class="hljs-keyword">try</span>&#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">//1000ms=1s</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<span class="hljs-comment">//线程被中断抛出InterruptedException</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>案例- 防止CPU占用100%</p><p>单核CPU，在运行java死循环程序时，空转浪费cpu</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-keyword">try</span>&#123;<br>Thread.sleep(<span class="hljs-number">50</span>);<br>&#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>sleep</code>与<code>wait</code>的区别：</p><blockquote><p>sleep()方法，线程不会释放对象锁。而调用wait()方法的时候，线程会放弃对象所，进入等待锁定池，直到针对该对象调用notify()方法后，本线程才进入对象池准备获取对象进入运行状态。</p></blockquote><ul><li>线程插队</li></ul><p>让调用这个方法的线程先执行完毕</p><p>public final void join()..</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>MyThread t1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread2</span>();<br>t1.start();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<br>System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;线程输出：&quot;</span>+i);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> extend Thread&#123;<br><span class="hljs-meta">@Override</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<br>System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;子线程输出：&quot;</span>+i);<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            t1.join();<span class="hljs-comment">//当i为1时，子线程插队;子线程执行完毕再执行主线程。</span><br>        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>       e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>线程让队</li></ul><p>void yield():将正在执行的线程暂停，允许其它线程执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">YieldDemo</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mian</span><span class="hljs-params">(Strin[]args)</span>&#123;<br>Thread thread1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;-Count&quot;</span>+i);<br><span class="hljs-keyword">if</span>(i==<span class="hljs-number">2</span>)&#123;<br>System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;is yielding...&quot;</span>);<br>Thread.<span class="hljs-keyword">yield</span>();<span class="hljs-comment">//让出时间片</span><br>&#125;<br>&#125;<br>&#125;，<span class="hljs-string">&quot;Thread-1&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; - Count: &quot;</span> + i);<br>&#125;<br>&#125;, <span class="hljs-string">&quot;Thread-2&quot;</span>);<br>thread1.start();<br>thread2.start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意事项</li></ul><ol><li><strong>非强制性</strong>：<ul><li><code>yield()</code> 只是向调度器发出一个建议，调度器可以选择忽略这个建议。因此，调用 <code>yield()</code> 后，当前线程仍然可能继续运行。</li></ul></li><li><strong>适用场景</strong>：<ul><li><code>yield()</code> 通常用于调试或优化线程调度，但在实际生产环境中很少使用，因为它的行为不可预测。</li></ul></li><li><strong>优先级影响</strong>：<ul><li><code>yield()</code> 只会让出与当前线程相同优先级的线程运行。如果其他线程的优先级较低，则它们不会被调度。</li></ul></li></ol><ul><li><p>线程优先级</p><p>每个线程执行时都具有一个优先级的属性，优先级高的线程可以获得较多的执行机会，但是线程的优先级依然无法保障线程的执行次数序，优先级高的线程获取CPU资源的概率较大，优先级低的也并非没有机会执行。</p><p>每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main()线程具有普通优先级。</p><p>Thread 类提供了 setPriority(int newPriority) 和 getPriority() 方法来设置和返回一个指定线程的优先级。优先级的参数是一个整数，范围1到10。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> MIN_PRIORITY|最低优先级|<span class="hljs-number">1</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> NORM_PRIORITY|中等优先级，线程默认优先级|<span class="hljs-number">5</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> MAX_PRIORITY|最高优先级|<span class="hljs-number">10</span><br><span class="hljs-comment">//虽然 Java 提供了 10 个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和 Java 的 10 个优先级别对应。所以我们应该使用 MAX_PRIORITY、MIN_PRIORITY 和 NORM_PRIORITY 三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</span><br></code></pre></td></tr></table></figure></li><li><p>中断线程</p><p>通过**interrupt()**方法中断其运行状态</p><p>interrupt() 方法可以用来中断一个正处于阻塞状态（如 sleep()、wait()、join() 等）的线程，以便让线程尽快结束。具体来说，调用线程的 interrupt() 方法之后，它的中断标志位会被设置为 true（实际上是通过将一个名为中断状态的 volatile 变量设为 true 来实现的），表示该线程已经被中断，但并不会强制终止该线程的执行。</p><p>当一个线程处于阻塞状态时，例如在 sleep()、wait()、join() 等方法内部时，如果此时另一个线程调用了该线程的 interrupt() 方法，那么该线程就会被中断，也就是抛出 InterruptedException 异常（如果线程没有处于阻塞状态，则不会有任何影响）。这个 InterruptedException 异常可以被捕获并进行相应的处理，例如跳出循环、释放资源等。因为在 InterruptedException 异常被抛出之前，线程所持有的锁不会被释放，因此需要在 finally 块中处理相关资源的释放。</p><p>需要注意的是，interrupt() 方法只是设置了一个中断标志位，并不能强制结束线程的执行。如果我们希望结束线程的执行，需要在相应的业务逻辑中做出响应的处理，比如检查中断标志位，然后主动退出线程的执行。如果不进行相应的处理，线程就会继续执行下去，直到完成所有任务，这可能不是我们期望的结果。</p><ul><li><p>两阶段终止模式</p><ol><li><strong>第一阶段：通知线程停止</strong><ul><li>主线程向目标线程发送一个停止信号（通常通过设置一个标志位或使用某种通信机制）。</li><li>目标线程在接收到停止信号后，会逐步完成当前任务，并释放占用的资源。</li></ul></li><li><strong>第二阶段：等待线程结束</strong><ul><li>主线程等待目标线程完全退出。如果目标线程在合理的时间内未能退出，可以采取强制终止或其他措施。</li></ul></li></ol></li><li><pre><code class="Java">public class demo&#123;    public static void main(String[]args)&#123;        TwoPhaseTermination tpt=new TwoPhaseTermination();        tpt.start();        Thread.sleep(200);        tpt.stop();//使线程报中断异常    &#125;&#125;class TwoPhaseTermination&#123;    private Thread moniter;    public void start()&#123;        monitor =new Thread(()-&gt;&#123;            while(true)&#123;                if(Thread.currentThred().current.isInerrupted())//未被中断为false                &#123;                    System.out.println(&quot;处理后事，如释放资源等等&quot;);                    break;                &#125;                 try&#123;                    Thread.sleep(1000);                    System.out.println(&quot;执行监控记录&quot;);                &#125;catch(InterruptedException e)&#123;                    e.printStackTrace();                    //重新设置打断标记                    Thread.currentThread().Interrupt();                &#125;            &#125;        &#125;);        monitor.start();    &#125;&#125;public class TwoPhaseTerminationExample &#123;    // 定义一个可终止的任务类    static class Task implements Runnable &#123;        private volatile boolean isRunning = true; // 停止标志//volatile -保证可见性，不同线程之间数据同步可见        @Override        public void run() &#123;            System.out.println(&quot;Task started...&quot;);            while (isRunning) &#123;                try &#123;                    // 模拟任务执行                    System.out.println(&quot;Task is running...&quot;);                    Thread.sleep(1000); // 每秒执行一次                &#125; catch (InterruptedException e) &#123;                    Thread.currentThread().interrupt(); // 恢复中断状态                    System.out.println(&quot;Task was interrupted.&quot;);                    break;                &#125;            &#125;            // 清理操作            cleanup();            System.out.println(&quot;Task terminated gracefully.&quot;);        &#125;        // 请求停止        public void requestStop() &#123;            isRunning = false;        &#125;        // 清理资源        private void cleanup() &#123;            System.out.println(&quot;Performing cleanup...&quot;);            // 在这里执行清理逻辑，例如关闭文件、释放锁等        &#125;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        Task task = new Task();        Thread workerThread = new Thread(task);        workerThread.start();        // 让任务运行一段时间        Thread.sleep(5000);        // 请求任务停止        System.out.println(&quot;Main thread requests task to stop...&quot;);        task.requestStop();        // 等待任务线程退出        workerThread.join(); // 等待线程完全退出        System.out.println(&quot;Main thread continues...&quot;);    &#125;&#125;<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 守护线程<br><br>  守护线程–也称“服务线程”,他是后台线程，它有一个特性，即为用户线程 提供 公共服务，在没有用户线程可服务时会自动离开。<br><br>  守护线程使用的情况较少，但并非无用，举例来说，JVM 的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。调用线程对象的方法 setDaemon(<span class="hljs-literal">true</span>),则可以将其设置为守护线程<br><br>  守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务<br><br>  通过 setDaemon(<span class="hljs-literal">true</span>) 来设置线程为“守护线程”，将一个用户线程设置为守护线程 的方式是在 线程对象创建 之前 用线程对象的 setDaemon 方法。<br><br>  ~~~java<br>  <span class="hljs-keyword">Thread</span> daemonTread = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Thread</span>()<span class="hljs-comment">;</span><br>  <br>   // 设定 daemonThread 为 守护线程,default <span class="hljs-literal">false</span>(非守护线程)<br>  daemonThread.setDaemon(<span class="hljs-literal">true</span>)<span class="hljs-comment">;</span><br>  <br>  // 验证当前线程是否为守护线程,返回 <span class="hljs-literal">true</span> 则为守护线程<br>  daemonThread.isDaemon()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><p>(1) thread.setDaemon(true) 必须在 thread.start() 之前设置，否则会抛出出一个 IllegalThreadStateException 异常。你不能把正在运行的常规线程设置为守护线程。<br>(2) 在 Daemon 线程中产生的新线程也是 Daemon 的。<br>(3) 不要认为所有的应用都可以分配给 Daemon 来进行服务，比如读写操作或者计算逻辑。</p><p>线程则是 JVM 级别的，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的 生命周期并不会和 Web 应用程序保持同步。也就是说，即使你停止了 Web 应用，这个线程 依旧是活跃的。</p></li><li><p>ThreadLocal</p></li></ul><p><img src="/.com//image-20250305213411493.png" alt="image-20250305213411493"></p><h3 id="14-3-线程安全"><a href="#14-3-线程安全" class="headerlink" title="14.3.线程安全"></a>14.3.线程安全</h3><ul><li>多个线程，同时操作同一个共享资源时，可能会出现业务安全问题</li></ul><p>原因：</p><ul><li><blockquote><p>存在多个线程同时执行</p><p>同时访问一个共享资源</p><p>存在修改共享资源</p></blockquote><ul><li>模拟两个账户同时取钱</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>&#123;<br><span class="hljs-keyword">private</span> String cardId;<span class="hljs-comment">//卡号</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">double</span> money;<span class="hljs-comment">//余额</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span>&#123;<br>    <span class="hljs-comment">//拿到当前谁在取钱</span><br>    String name=Thread.currentThread().getName();<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.money&gt;=money)&#123;<br>        System.out.println(name+<span class="hljs-string">&quot;取钱成功，取了&quot;</span>+money+<span class="hljs-string">&quot;元，余额为：&quot;</span>(<span class="hljs-built_in">this</span>.money-money));<br>        <span class="hljs-built_in">this</span>.money-=money;<span class="hljs-comment">//更新余额放最后，更大概率模拟出来两个人都取到钱的情况</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;余额不足！&quot;</span>);<br>&#125;    <br>    <span class="hljs-comment">//。。。构造器以及getter、setter</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-comment">//初始化账户</span><br>Account acc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>(<span class="hljs-string">&quot;ICBC_0910&quot;</span>,<span class="hljs-number">100000</span>);<br><span class="hljs-comment">//创建两个线程同时取钱</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">drawThread</span>(<span class="hljs-string">&quot;小明&quot;</span>,acc).start();   <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">drawThread</span>(<span class="hljs-string">&quot;小红&quot;</span>,acc).start(); <br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">drawThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><span class="hljs-keyword">private</span> Account acc;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">drawThread</span><span class="hljs-params">(String name,Account acc)</span>&#123;<br><span class="hljs-built_in">super</span>(name);<br><span class="hljs-built_in">this</span>.acc=acc;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//取钱</span><br>acc.drawMoney(<span class="hljs-number">100000</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-4-线程同步"><a href="#14-4-线程同步" class="headerlink" title="14.4.线程同步"></a>14.4.线程同步</h3><h4 id="1-简单-同步"><a href="#1-简单-同步" class="headerlink" title="1.简单-同步"></a>1.简单-同步</h4><ul><li>加锁：每次只允许一个线程加锁，加锁后才能进入访问，访问完毕自动解锁，然后其它线程才能进入并且加锁</li><li><strong>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</strong></li><li>对临界区（对共享资源进行读写操作的代码）进行上锁</li></ul><blockquote><ol><li>同步代码块</li></ol><p>作用：把访问的共享资源的核心代码给上锁，以此保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">synchronized</span>(同步锁)&#123;<br>&gt;<span class="hljs-comment">//访问共享资源的核心代码</span><br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>原理：每次只允许一个线程加锁后进入，执行完毕后自动解锁，其它线程才可以进来执行。</p><p>注意：对于当前同时执行的线程来说，同步锁必须是同一把（同一个对象），否则会出bug。</p><ul><li><blockquote><p>建议使用共享资源作为锁对象，对于实例方法建议使用this作为锁对象。<br>对于静态和类中声明的方法建议使用字节码（类名.class）对象作为锁对象。</p></blockquote></li></ul><ol start="2"><li>同步方法</li></ol><p>作用：把访问的资源核心方法给上锁，以此保证线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;修饰符 <span class="hljs-keyword">synchronized</span> 方法名（参数列表）<br></code></pre></td></tr></table></figure><p>对于实例方法默认使用this作为锁对象。</p><p>对于静态方法默认使用字节码（类名.class）对象作为锁对象</p><p>优点：范围更大，可读性好</p><p>缺点：性能缺少</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Method A is running...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Method B is running...&quot;</span>);<br><span class="hljs-comment">//修饰实例方法，锁的是该方法所属对象的实例锁（this）,同一个实例调用才有互斥效果</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethodA</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Static Method A is running...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethodB</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Static Method B is running...&quot;</span>);<br><span class="hljs-comment">//修饰静态方法，锁的是Class对象，同一时间只有一个线程执行其中一个方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodC</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Method C is running...&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodD</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Method D is running...&quot;</span>);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//同步代码块，指定一个对象作为锁，适用于更细粒度的同步控制</span><br>    &#125;<br></code></pre></td></tr></table></figure><ol><li><strong>优先使用专用锁对象</strong>：<code>private final Object LOCK = new Object()</code>。</li><li><strong>静态同步用类锁</strong>：<code>private static final Object LOCK = new Object()</code> 或 <code>synchronized(ClassName.class)</code>。</li><li><strong>避免使用公有对象、字符串常量、包装类作为锁</strong>。</li><li><strong>锁对象必须是<code>final</code>的</strong>，确保引用不可变。</li><li><strong>锁的粒度要合理</strong>：只同步必要的代码块，避免过度同步。</li></ol><blockquote><ol start="3"><li><code>lock锁</code></li></ol><p>作用：可以创建出锁对象进行加锁和解锁，更灵活，更方便，更强大。</p><p>Lock是接口，不能直接实例化，可以采用它的实现类<code>ReentrantLock</code>来构建Lock锁对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java">&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>&#123;<br>&gt;<span class="hljs-keyword">private</span> String cardId;<span class="hljs-comment">//卡号</span><br>&gt;<span class="hljs-keyword">private</span> <span class="hljs-type">double</span> money;<span class="hljs-comment">//余额</span><br>&gt;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock lk=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<span class="hljs-comment">//final保护锁对象</span><br><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span>&#123;<br>  <span class="hljs-comment">//拿到当前谁在取钱</span><br>  String name=Thread.currentThread().getName();<br>  <span class="hljs-comment">//上锁</span><br>  lk.lock();<br>  <span class="hljs-keyword">try</span>&#123;<br>       <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.money&gt;=money)&#123;<br>      System.out.println(name+<span class="hljs-string">&quot;取钱成功，取了&quot;</span>+money+<span class="hljs-string">&quot;元，余额为：&quot;</span>(<span class="hljs-built_in">this</span>.money-money));<br>      <span class="hljs-built_in">this</span>.money-=money;<span class="hljs-comment">//更新余额放最后，更大概率模拟出来两个人都取到钱的情况</span><br>  &#125;<br>  <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;余额不足！&quot;</span>);<br>&gt;&#125; <br>  &#125;<br>  <span class="hljs-keyword">finally</span>&#123;<br>      lk.unlock();<span class="hljs-comment">//解锁，防止出现异常无法解锁</span><br>  &#125;<br><br>  <span class="hljs-comment">//。。。构造器以及getter、setter</span><br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><ul><li><p><code>synchronized</code>详解</p></li><li><p><code>ReentrantLock</code>详解</p></li></ul><h4 id="2-进阶-volatile关键字"><a href="#2-进阶-volatile关键字" class="headerlink" title="2.进阶-volatile关键字"></a>2.进阶-volatile关键字</h4><ul><li>可见性</li></ul><h4 id="3-进阶-JMM"><a href="#3-进阶-JMM" class="headerlink" title="3.进阶-JMM"></a>3.进阶-JMM</h4><h4 id="4-进阶-悲观锁、乐观锁、CAS"><a href="#4-进阶-悲观锁、乐观锁、CAS" class="headerlink" title="4.进阶-悲观锁、乐观锁、CAS"></a>4.进阶-悲观锁、乐观锁、CAS</h4><h4 id="5-进阶-原子性"><a href="#5-进阶-原子性" class="headerlink" title="5.进阶-原子性"></a>5.进阶-原子性</h4><h4 id="6-进阶-并发工具类concurrent"><a href="#6-进阶-并发工具类concurrent" class="headerlink" title="6.进阶-并发工具类concurrent"></a>6.进阶-并发工具类concurrent</h4><p><code>CountDownLatch</code> 是 <code>java.util.concurrent</code> 包中的同步辅助类 ，用于实现多线程同步。其核心要点如下：</p><ul><li><strong>原理</strong>：通过一个计数器实现线程间的协调。创建时指定初始计数，代表需要完成的操作数量。执行任务的线程完成任务后，调用 <code>countDown()</code> 方法使计数器减 1 ；等待的线程调用 <code>await()</code> 方法进入阻塞状态，直到计数器递减为 0 时被唤醒继续执行 。</li><li>关键方法<ul><li><code>countDown()</code>：执行任务的线程调用，将计数器减 1 。</li><li><code>await()</code>：使调用线程阻塞，等待计数器变为 0 。也有带超时参数的 <code>await(long timeout, TimeUnit unit)</code> ，在超时或计数器为 0 时返回 。</li></ul></li><li><strong>线程安全</strong>：内部基于 AQS（抽象队列同步器）实现，保证计数操作的原子性和可见性，多线程并发调用相关方法也能正确工作 。</li><li><strong>应用场景</strong>：适用于一个或多个线程等待其他多个线程完成任务的场景，如子任务并行计算后主线程汇总结果、Web 应用中等待多个 API 响应聚合、服务启动时等待多个外部服务就绪等 。</li><li><strong>局限性</strong>：计数器一旦为 0 无法重置，不能重复使用 ；使用时要确保 <code>countDown()</code> 正确调用，否则可能导致等待线程永久阻塞 。 与 <code>CyclicBarrier</code> 相比，它不可重用且线程行为不同 。</li></ul><h4 id="7-进阶-AQS原理"><a href="#7-进阶-AQS原理" class="headerlink" title="7.进阶-AQS原理"></a>7.进阶-AQS原理</h4><ul><li>全称是AbstractQueuedSynchronizer,是阻塞式锁和相关的同步工具的框架</li></ul><h5 id="1-AQS-的核心思想"><a href="#1-AQS-的核心思想" class="headerlink" title="1.AQS 的核心思想"></a>1.AQS 的核心思想</h5><p>AQS 的核心思想是通过一个共享的同步状态（state）和一个CLH 队列（双向链表）来协调线程的竞争和等待。</p><p>同步状态（state）：表示资源的可用性或锁的状态。线程可以通过原子操作（如 CAS）来修改这个状态。<br>CLH 队列：当多个线程竞争资源时，未能获取资源的线程会被加入到 CLH 队列中，等待资源释放。</p><h5 id="2-AQS-的主要组成部分"><a href="#2-AQS-的主要组成部分" class="headerlink" title="2.AQS 的主要组成部分"></a>2.AQS 的主要组成部分</h5><p>(1) 同步状态（state）</p><ul><li><p>state 是一个volatile变量，用于表示当前的同步状态。<br>线程可以通过以下方法操作 state：</p><ul><li>getState()：获取当前的同步状态。</li><li>setState(int newState)：设置同步状态。</li><li>compareAndSetState(int expect, int update)：通过 CAS 操作更新同步状态。</li></ul></li></ul><p> (2) CLH 队列</p><ul><li><p>CLH 队列是一个双向链表，用于管理等待线程。<br> 每个节点（Node）代表一个线程，包含以下信息：</p><ul><li><p>prev 和 next：指向前后节点的指针。</p></li><li><p>thread：表示当前节点对应的线程。</p></li><li><p>waitStatus：表示节点的状态，可能的值包括： 0：初始状态。</p></li><li><p>SIGNAL (-1)：表示后继节点需要被唤醒。</p></li><li><p>CANCELLED (1)：表示该节点已被取消。</p></li><li><p>CONDITION (-2)：表示该节点在条件队列中等待。</p></li><li><p>PROPAGATE (-3)：表示共享模式下后续节点可以尝试获取资源。</p></li></ul></li></ul><h5 id="3-AQS-的工作原理"><a href="#3-AQS-的工作原理" class="headerlink" title="3.AQS 的工作原理"></a>3.AQS 的工作原理</h5><p>AQS 的工作流程可以分为以下几个步骤：</p><p>(1) 获取同步状态<br>线程尝试获取同步状态（state），具体逻辑由子类实现（例如 tryAcquire 或 tryAcquireShared）。<br>如果获取成功，则线程继续执行。<br>如果获取失败，则线程被加入到 CLH 队列中，并进入等待状态。<br>(2) 加入 CLH 队列<br>当线程无法获取同步状态时，它会被封装为一个 Node 节点并加入到 CLH 队列的尾部。<br>AQS 使用 CAS 操作确保队列操作的线程安全性。<br>(3) 等待与唤醒<br>在 CLH 队列中，线程会阻塞，直到前驱节点释放锁或资源。<br>当前驱节点完成任务后，会唤醒其后继节点，允许后继节点重新尝试获取同步状态。<br>(4) 释放同步状态<br>线程完成任务后，会释放同步状态（state），具体逻辑由子类实现（例如 tryRelease 或 tryReleaseShared）。<br>释放同步状态后，AQS 会唤醒 CLH 队列中的下一个等待线程。</p><h5 id="4-AQS-的两种模式"><a href="#4-AQS-的两种模式" class="headerlink" title="4.AQS 的两种模式"></a>4.AQS 的两种模式</h5><p>AQS 支持两种模式来管理同步状态：</p><p>(1) 独占模式<br>独占模式表示同一时间只有一个线程可以持有锁。<br>示例：ReentrantLock。<br>关键方法：<br>tryAcquire(int arg)：尝试获取独占锁。<br>tryRelease(int arg)：尝试释放独占锁。<br>(2) 共享模式<br>共享模式允许多个线程同时持有锁。<br>示例：Semaphore、CountDownLatch。<br>关键方法：<br>tryAcquireShared(int arg)：尝试获取共享锁。<br>tryReleaseShared(int arg)：尝试释放共享锁。</p><h5 id="5-AQS-的核心方法"><a href="#5-AQS-的核心方法" class="headerlink" title="5.AQS 的核心方法"></a>5.AQS 的核心方法</h5><p>AQS 提供了一些模板方法，子类需要根据具体的同步需求实现这些方法：</p><p>(1) 独占模式的核心方法<br>tryAcquire(int arg)：尝试获取独占锁。<br>tryRelease(int arg)：尝试释放独占锁。<br>isHeldExclusively()：判断当前线程是否独占地持有锁。<br>(2) 共享模式的核心方法<br>tryAcquireShared(int arg)：尝试获取共享锁。<br>tryReleaseShared(int arg)：尝试释放共享锁。<br>(3) 其他方法<br>getState()：获取当前的同步状态。<br>setState(int newState)：设置同步状态。<br>compareAndSetState(int expect, int update)：通过 CAS 操作更新同步状态。</p><h3 id="14-5-线程池"><a href="#14-5-线程池" class="headerlink" title="14.5.线程池"></a>14.5.线程池</h3><ul><li>线程池是一个可以<code>复用线程</code>的技术</li></ul><blockquote><ul><li>创建线程池</li></ul><p>代表线程池的接口：ExecutorService</p><ul><li>方式一：使用ExecutorService的实现类ThreadPoolExecutor</li></ul><p><img src="/.com//image-20241128182621673.png"></p></blockquote><p>最大线程数的配置：</p><p>如果是CPU密集型任务：电脑的逻辑处理器数量+1</p><p>IO密集型任务：电脑的逻辑处理器数量*2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建线程池对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-comment">//1、使用线程池的实现类ThreadPoolExecutor</span><br>ExecutorService pool=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,TimeUnit.SECONDS,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArryBlockingQueue</span>&lt;&gt;(<span class="hljs-number">3</span>),Executors.defaultThreadFactory(),<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolAbortPolicy</span>());<span class="hljs-comment">//拒绝策略为抛异常处理</span><br><span class="hljs-comment">//2、处理Runnable任务和Callable任务,看会不会复用线程</span><br><span class="hljs-comment">//Runnable任务</span><br>Runnable target=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><span class="hljs-comment">//提交任务pool.execute(任务对象)，任务可以复用，创建线程，自动启动线程处理该任务。</span><br>pool.execute(target);<span class="hljs-comment">//提交第一个任务</span><br>pool.execute(target);<span class="hljs-comment">//提交第二个</span><br>pool.execute(target);<span class="hljs-comment">//提交第三个</span><br><span class="hljs-comment">//pool.execute(target);//复用线程</span><br><span class="hljs-comment">//pool.execute(target);//复用线程</span><br>pool.execute(target);<span class="hljs-comment">//无法复用，放入任务队列</span><br>pool.execute(target);<br>pool.execute(target);<br>pool.execute(target);<span class="hljs-comment">//任务队列满，到了创建临时线程时机</span><br>pool.execute(target);<br>pool.execute(target);<span class="hljs-comment">//临时线程满了，到了任务拒绝时机</span><br><br>    <br><span class="hljs-comment">//Callable任务</span><br>Future&lt;String&gt; f1=pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">100</span>));<span class="hljs-comment">//多态，用Future接口来接FutureTask对象</span><br>Future&lt;String&gt; f1=pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">200</span>));  <br>Future&lt;String&gt; f1=pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">300</span>));  <br>Future&lt;String&gt; f1=pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">400</span>));  <br><span class="hljs-keyword">try</span>&#123;<br>    System.out.println(f1.get());<br>    System.out.println(f2.get());<br>    System.out.println(f3.get());<br>    System.out.println(f4.get()); <br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//3、关闭线程池，（*一般不关闭线程池）</span><br>pool.shutdown();<span class="hljs-comment">//等所有任务执行完毕后再关闭线程池</span><br><span class="hljs-comment">//pool.shutdownNow();//立即关闭，不管任务是否执行完毕</span><br>&#125;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><span class="hljs-meta">@OVerride</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;<br>System.out.println(Thred.currentThread().getName()+<span class="hljs-string">&quot;输出：&quot;</span>+i);<br><span class="hljs-comment">//让线程无法复原模拟临时线程的创建时机</span><br><span class="hljs-keyword">try</span>&#123;<br>Thread.sleep(Integer.MAX_VALUE);<br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mycallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCallable</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<span class="hljs-built_in">this</span>.n=n;&#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=;i&lt;=n;i++)sum+=i;<br>        <span class="hljs-keyword">return</span> Thread.currentThread().getName()+<span class="hljs-string">&quot;计算1-&quot;</span>+n+<span class="hljs-string">&quot;的和是：&quot;</span>+sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意：</li><li>临时线程的创建时机：</li></ul><blockquote><ul><li>核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程</li></ul></blockquote><ul><li>拒绝新任务的时机：</li></ul><blockquote><ul><li>核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始拒绝任务</li></ul></blockquote><blockquote><p>任务拒绝策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadPoolExecutor.AbortPOlicy()<span class="hljs-comment">//丢弃任务并且抛出异常</span><br>ThreadPoolExecutor.DiscardPolicy()<span class="hljs-comment">//直接丢弃（不推荐）</span><br>ThreadPOOlExecutor.DiscardOldestPolicy()<span class="hljs-comment">//丢弃任务队列中等待最久的任务，然后把当前任务加入队列</span><br>ThreadPoolExecutor.CallerRunsPolicy()<span class="hljs-comment">//由主线程负责调用任务的run()方法从而绕过线程池直接执行</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><ul><li>方式二：使用Executors(线程池的工具类)调用方法返回不同特点的线程池对象</li></ul><p><img src="/.com//image-20241202172933438.png" alt="image-20241202172933438"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过线程池工具类Executors,调用其静态方法直接的到线程池</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>ExecutorService pool=Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<span class="hljs-comment">//无临时线程</span><br>Future&lt;String&gt; f1=pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">100</span>));<span class="hljs-comment">//多态，用Future接口来接FutureTask对象</span><br>Future&lt;String&gt; f1=pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">200</span>));  <br>Future&lt;String&gt; f1=pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">300</span>));  <br>Future&lt;String&gt; f1=pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">400</span>));  <br><span class="hljs-keyword">try</span>&#123;<br>    System.out.println(f1.get());<br>    System.out.println(f2.get());<br>    System.out.println(f3.get());<br>    System.out.println(f4.get()); <br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意：</li></ul><blockquote><ul><li>这些方法的底层都是通过线程池的实现类ThreadPoolExecutor创建的线程池对象</li><li>尽量使用ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</li><li><ol><li>FixedThreadPool和SingleThreadPool:允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，导致OOM（内存溢出）</li></ol></li></ul><ol start="2"><li>CachedThreadPool和ScheduledThreadPool:允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程,导致OOM（内存溢出）</li></ol></blockquote><h3 id="14-6-并发和并行"><a href="#14-6-并发和并行" class="headerlink" title="14.6.并发和并行"></a>14.6.并发和并行</h3><ul><li><p>进程：正在运行的程序（软件）就是一个独立的进程。</p><ul><li>线程是属于进程的，一个进程中可以同时运行很多个线程</li><li>进程中的多个线程其实是并发和并行执行的（取决于CPU的核数，单核只能并发）</li></ul></li><li><p>并发：进程中的线程是由CPU负责调度执行的，但CPU能同时处理线程的数量有限，为了保证全部线程都能往前执行，CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。</p></li><li><p>并行：在同一个时刻上，同时有多个线程在被CPU调度执行。</p></li><li><p><code>多线程是并发和并行同时</code>。</p></li><li><p>红包雨游戏，某企业100名员工，工号1到100，发出两百个红包，其中小红包在【1-30】元之间，总占比为80%，大红包【31-100】元，总占比为20%<br>模拟100个员工抢红包，输出哪个员工抢到哪个红包的过程，活动结束时提示活动结束<br>结束后对100名员工按照抢到的红包金额进行排序，并输出。。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.Multi_Thread_test;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-comment">//红包雨游戏，某企业100名员工，工号1到100，发出两百个红包，其中小红包在【1-30】元之间，总占比为80%，大红包【31-100】元，总占比为20%</span><br><span class="hljs-comment">//模拟100个员工抢红包，输出哪个员工抢到哪个红包的过程，活动结束时提示活动结束</span><br><span class="hljs-comment">//结束后对100名员工按照抢到的红包金额进行排序，并输出。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest</span> &#123;<br><span class="hljs-comment">//100个员工相当于100个线程来竞争200个红包</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//2、定义线程类，创建100个线程，竞争同一个集合</span><br>    List&lt;Integer&gt;redpacket=getRedPacket();<br>    List&lt;Peoplegetredpacket&gt;Threads=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++)&#123;<br>Peoplegetredpacket t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Peoplegetredpacket</span>(redpacket,<span class="hljs-string">&quot;员工&quot;</span>+i);<br>Threads.add(t);<br>t.start();<br>&#125;<br><span class="hljs-comment">//3、等待所有线程执行完毕，才进入主线程</span><br>    <span class="hljs-keyword">for</span>(Thread t:Threads)&#123;<br><span class="hljs-keyword">try</span> &#123;<br>t.join();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>    <span class="hljs-comment">//4、对抢到的红包进行排序，并输出</span><br>Collections.sort(Threads,(t1,t2)-&gt;t2.getTotalmoney() - t1.getTotalmoney());<br>System.out.println(<span class="hljs-string">&quot;员工按抢到的红包金额排序：&quot;</span>);<br><span class="hljs-keyword">for</span>(Peoplegetredpacket t:Threads)&#123;<br>System.out.println(t.getName()+<span class="hljs-string">&quot;抢到红包总额：&quot;</span>+t.getTotalmoney());<br>&#125;<br><br>&#125;<br><span class="hljs-comment">//1、准备两百个随机的红包返回，放到List集合中去返回</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">getRedPacket</span><span class="hljs-params">()</span>&#123;<br>        Random random=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-comment">//模拟两百个红包,随机产生200个红包，小红包在1-30之间，大红包31-100，小红包占80%，大红包占20%</span><br>        List&lt;Integer&gt;redpacket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">160</span>;i++)redpacket.add(random.nextInt(<span class="hljs-number">30</span>)+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">40</span>;i++)redpacket.add(random.nextInt(<span class="hljs-number">70</span>)+<span class="hljs-number">31</span>);<br>        <span class="hljs-keyword">return</span> redpacket;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.Multi_Thread_test;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Peoplegetredpacket</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>   List&lt;Integer&gt; redpacket;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> totalmoney;<br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Peoplegetredpacket</span><span class="hljs-params">(List&lt;Integer&gt; redpacket,String name)</span>&#123;<br>       <span class="hljs-built_in">super</span>(name);<br>       <span class="hljs-built_in">this</span>.redpacket=redpacket;<br>       totalmoney=<span class="hljs-number">0</span>;<br>   &#125;<br>   <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>           <span class="hljs-comment">//随机获取一个红包</span><br>           <span class="hljs-keyword">synchronized</span> (redpacket) &#123;<br>               <span class="hljs-keyword">if</span>(redpacket.size()==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.random() * redpacket.size();<br>               <span class="hljs-type">int</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> redpacket.remove(index);<br>               totalmoney += money;<br>               System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;抢到红包：&quot;</span> + money);<br>               <span class="hljs-keyword">if</span> (redpacket.size() == <span class="hljs-number">0</span>) &#123;<br>                   System.out.println(<span class="hljs-string">&quot;活动结束！&quot;</span>);<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">try</span> &#123;<br>               Thread.sleep(<span class="hljs-number">500</span>);<br>           &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>               e.printStackTrace();<br>           &#125;<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getTotalmoney</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">return</span> totalmoney;<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="15-网络处理"><a href="#15-网络处理" class="headerlink" title="15.网络处理"></a>15.网络处理</h2><ul><li>基本的通信架构</li></ul><blockquote><ul><li>CS架构（Client客户端&#x2F;Server服务端）</li><li>BS架构(Browser浏览器&#x2F;Server服务器)</li></ul></blockquote><p>域名-》DNS解析-》ip地址-》与服务器通信</p><p>公网IP:是可以连接到互联网的IP地址</p><p>内网IP:也叫局域网IP,是只能组织机构内部使用的IP地址；例如：192.168.开头的就是常见的局域网地址，范围为192.168.0.0-192.168.255.255</p><p>本机IP:127.0.0.1、localhost</p><p>ipconfig:查看本机的网络信息</p><p>ping:检查网络是否联通</p><h4 id="15-1-InetAddress"><a href="#15-1-InetAddress" class="headerlink" title="15.1.InetAddress"></a>15.1.InetAddress</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InetAddress <span class="hljs-title function_">getLocalHost</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> UnknownHostException<span class="hljs-comment">//获取本机Ip</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getHostName</span><span class="hljs-params">()</span><span class="hljs-comment">//获取该IP的主机名</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getHostAddress</span><span class="hljs-params">(String host)</span>  <span class="hljs-keyword">throws</span> UnknownHostException<span class="hljs-comment">//根据ip地址或者域名，返回一个inetAddress对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isReachable</span><span class="hljs-params">(<span class="hljs-type">int</span> timeout)</span><span class="hljs-keyword">throws</span> IOException<span class="hljs-comment">//判断主机在指定毫秒内与该ip对应的主机是否能连通</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InetAddress <span class="hljs-title function_">getByName</span><span class="hljs-params">(<span class="hljs-string">&quot;域名/ip地址&quot;</span>)</span>    <br></code></pre></td></tr></table></figure><ul><li>获取本机ip对象和对方ip对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<span class="hljs-comment">//获取本机ip</span><br>InetAddress ip1=InetAddress.getLocalHost();<br>System.out.println(ip1.getHostName());<br>System.out.println(ip1.getHostAddress());<br><span class="hljs-comment">//获取对方ip对象</span><br>InetAddress ip2=InetAddress.getByName(<span class="hljs-string">&quot;www.baidu.com&quot;</span>);<br>System.out.println(ip2.getHostName());<br>System.out.println(ip2.getHostAddress());<br><span class="hljs-comment">//判断本机与对方主机是否互通</span><br>System.out.println(ip2.isReachable(<span class="hljs-number">5000</span>));<span class="hljs-comment">//五秒内是否可以互通</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>端口</li></ul><p><img src="/.com//java.assets%5Cimage-20241202202113494.png" alt="image-20241202202113494"></p><ul><li>传输层的协议</li></ul><p>UDP协议：无连接不可靠，用户数据报协议，只管发出去（适用于语言、视频）</p><p>TCP协议：面向连接，可靠，要保证在不可靠的信道上实现可靠的通信（网页、文件下载、支付）</p><h4 id="15-2-UDP通信"><a href="#15-2-UDP通信" class="headerlink" title="15.2.UDP通信"></a>15.2.UDP通信</h4><ul><li>特点：无连接不可靠</li><li>DatagramSocket(int port),DatagramPacket(byte[] buf,int length,&#x2F;&#x2F;address,port)</li></ul><p><img src="/.com//image-20241212082603810.png" alt="image-20241212082603810"></p><ul><li>完成UDP通信：实现一发一收</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPclientDemo1</span>  <span class="hljs-comment">//客户端</span><br>&#123;<span class="hljs-comment">//1.创建发送端对象  </span><br>System.out.println(<span class="hljs-string">&quot;客户端启动&quot;</span>)    <br>DatagramSocket socket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();<span class="hljs-comment">//默认分配端口，也可以指定端口</span><br><span class="hljs-comment">//2.创建数据包对象封装要发送的数据</span><br><span class="hljs-comment">//参数1：发送的数据，参数2：发送的数据长度，参数3：目的端的IP地址，参数4：服务端的程序端口号</span><br><span class="hljs-type">byte</span>[] bytes=<span class="hljs-string">&quot;asddsdasd&quot;</span> .getBytes();  <br>DatagramPacket packet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(bytes,bytes.length,InerAddress.getLocalHost,<span class="hljs-number">8000</span>);<br><span class="hljs-comment">//3.让发送端对象发送数据包的数据</span><br>socket.send(packet);<br>socket.close();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPServerDemo2</span>&#123;<span class="hljs-comment">//服务端</span><br><span class="hljs-comment">//1.创建接收端对象，指定端口号</span><br>System.out.println(<span class="hljs-string">&quot;服务端启动&quot;</span>)<br>DatagramSocket socket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">8000</span>);<br><span class="hljs-comment">//2.创建一个数据包负责接收数据</span><br><span class="hljs-type">byte</span>[] buf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">64</span>];<span class="hljs-comment">//一个包最大64kb</span><br>DatagramPacket packet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buf,buf.length);<br><span class="hljs-comment">//3.接收数据，将数据封装到数据包对象的字节数组中</span><br>socket.recive(packet);<br><span class="hljs-comment">//4.看数据是否收到</span><br><span class="hljs-type">int</span> len=packet.getlength();<span class="hljs-comment">//获取收到的数据包长度</span><br>String data=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf,<span class="hljs-number">0</span>,len);<br>System.out.println(<span class="hljs-string">&quot;服务端收到了：&quot;</span>+data);<br><span class="hljs-comment">//5.获取对方的ip地址以及端口号</span><br>String ip=packet.getInetAddress().getHostAddress();<br><span class="hljs-type">int</span> port=packet.getPort();<br>System.out.println(<span class="hljs-string">&quot;对方ip:&quot;</span>+ip+<span class="hljs-string">&quot;对方端口：&quot;</span>+port);<br>socket.close();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>多发多收</li><li><ul><li>客户端和服务端使用死循环</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPclientDemo1</span>  <span class="hljs-comment">//客户端</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-comment">//1.创建发送端对象  </span><br>System.out.println(<span class="hljs-string">&quot;客户端启动&quot;</span>)    <br>DatagramSocket socket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();<span class="hljs-comment">//默认分配端口，也可以指定端口</span><br><span class="hljs-comment">//2.创建数据包对象封装要发送的数据</span><br><span class="hljs-comment">//参数1：发送的数据，参数2：发送的数据长度，参数3：目的端的IP地址，参数4：服务端的程序端口号</span><br>Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>System.out.print(<span class="hljs-string">&quot;请说：&quot;</span>);<br>String msg=sc.nextLine();<br><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;exit&quot;</span>.equals(msg))&#123;<br>System.out.println(<span class="hljs-string">&quot;==客户端退出==&quot;</span>)；<br>socket.close();<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-type">byte</span>[] bytes=msg.getBytes();  <br>DatagramPacket packet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(bytes,bytes.length,InerAddress.getLocalHost,<span class="hljs-number">8000</span>);<br><span class="hljs-comment">//3.让发送端对象发送数据包的数据</span><br>socket.send(packet);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPServerDemo2</span>&#123;<span class="hljs-comment">//服务端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-comment">//1.创建接收端对象，指定端口号</span><br>System.out.println(<span class="hljs-string">&quot;服务端启动&quot;</span>)<br>DatagramSocket socket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">8000</span>);<br><span class="hljs-comment">//2.创建一个数据包负责接收数据</span><br><span class="hljs-type">byte</span>[] buf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">64</span>];<span class="hljs-comment">//一个包最大64kb</span><br>DatagramPacket packet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buf,buf.length);<br><span class="hljs-comment">//3.接收数据，将数据封装到数据包对象的字节数组中</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>socket.recive(packet);<span class="hljs-comment">//等待式接收数据</span><br><span class="hljs-comment">//4.看数据是否收到</span><br><span class="hljs-type">int</span> len=packet.getlength();<span class="hljs-comment">//获取收到的数据包长度</span><br>String data=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf,<span class="hljs-number">0</span>,len);<br>System.out.println(<span class="hljs-string">&quot;服务端收到了：&quot;</span>+data);<br><span class="hljs-comment">//5.获取对方的ip地址以及端口号</span><br>String ip=packet.getIAddress().getHostAddress();<br><span class="hljs-type">int</span> port=packet.getPort();<br>System.out.println(<span class="hljs-string">&quot;对方ip:&quot;</span>+ip+<span class="hljs-string">&quot;对方端口：&quot;</span>+port);<br>System.out.println(<span class="hljs-string">&quot;--------------------------&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="15-3-TCP通信"><a href="#15-3-TCP通信" class="headerlink" title="15.3.TCP通信"></a>15.3.TCP通信</h4><ul><li>特点：面向连接，可靠通信</li><li>“三次握手” -建立连接</li><li>“四次挥手” -断开连接</li></ul><p><img src="/.com//image-20250421165851026.png" alt="image-20250421165851026"></p><blockquote><p>一发一收</p></blockquote><p><img src="/.com//image-20241212092517979.png" alt="image-20241212092517979"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TCpclientDemo1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-comment">//1.创建客户端Socket对象，请求与服务器的连接</span><br>        Socket socket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">9999</span>);<br><span class="hljs-comment">//2.使用socket对象调用getOutputString()方法得到字节输出流</span><br>        OutputStream os=socket.getOutputStream();<br><span class="hljs-comment">//3.使用字节输出流完成数据的发送</span><br>        DataOutputStream dos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(os);<br>        dos.writeInt(<span class="hljs-number">1</span>);<br>        dos.writeUTF(<span class="hljs-string">&quot;嘎嘎嘎！&quot;</span>);<br><span class="hljs-comment">//4.释放资源：关闭socket管道</span><br>        socket.close();<br>    &#125;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><p><img src="/.com//image-20241212093923345.png" alt="image-20241212093923345"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//服务端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo2</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>        <span class="hljs-comment">//实现一发一收</span><br>        <span class="hljs-comment">//1.创建ServerSocket对象，指定端口号</span><br>        ServerSocket ss=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br>        <span class="hljs-comment">//2.调用accept方法，阻塞等待客户端连接，一旦有客户端连接会返回一个Socket对象</span><br>        Socket socket=ss.accept();<br>        <span class="hljs-comment">//3.获取输入流，读取客户端发送的消息</span><br>        IntputStream is=socket.getIntputStream();<br>        <span class="hljs-comment">//4.把字节输入流包装成特殊数据输入流</span><br>        DataInputStream dis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataIntputStream</span>(is);<br>        <span class="hljs-comment">//5.读取数据</span><br>        <span class="hljs-type">int</span> id=dis.readInt();<br>        String msg=dis.readUTF();<br>        System.out.println(<span class="hljs-string">&quot;id&quot;</span>+id+<span class="hljs-string">&quot;,收到的客户端msg:&quot;</span>+msg);<br>        <span class="hljs-comment">//6.获取客户端的ip和端口</span><br>        System.out.println(<span class="hljs-string">&quot;获取客户端的ip地址：&quot;</span>+socket.getInetAddress().getHostAddress());<br>        System.out.println(<span class="hljs-string">&quot;获取客户端的端口号：&quot;</span>+socket.getPort());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>多发多收</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TCpclientDemo1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-comment">//1.创建客户端Socket对象，请求与服务器的连接</span><br>        Socket socket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">9999</span>);<br><span class="hljs-comment">//2.使用socket对象调用getOutputString()方法得到字节输出流</span><br>        OutputStream os=socket.getOutputStream();<br><span class="hljs-comment">//3.使用字节输出流完成数据的发送</span><br>        DataOutputStream dos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(os);<br>       Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        whlie(<span class="hljs-literal">true</span>)&#123;<br>          System.out.println(<span class="hljs-string">&quot;请说：&quot;</span>);  <br>          String msg=sc.nextLine();<br>            <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;exit&quot;</span>.equals(msg))&#123;<br>                System.out.println(<span class="hljs-string">&quot;退出成功！&quot;</span>);<br>                dos.close();<span class="hljs-comment">//关闭输出管道</span><br>                socket.close();<span class="hljs-comment">//关闭socket</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            dos.writeUTF(msg);<span class="hljs-comment">//发送数据</span><br>            dos.flush();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//服务端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo2</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>        <span class="hljs-comment">//实现一发一收</span><br>        <span class="hljs-comment">//1.创建ServerSocket对象，指定端口号</span><br>        ServerSocket ss=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br>        <span class="hljs-comment">//2.调用accept方法，阻塞等待客户端连接，一旦有客户端连接会返回一个Socket对象</span><br>        Socket socket=ss.accept();<br>        <span class="hljs-comment">//3.获取输入流，读取客户端发送的消息</span><br>        IntputStream is=socket.getIntputStream();<br>        <span class="hljs-comment">//4.把字节输入流包装成特殊数据输入流</span><br>        DataInputStream dis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataIntputStream</span>(is);<br>        <span class="hljs-comment">//5.读取数据</span><br>       <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            String msg=dis.readUTF();<span class="hljs-comment">//等待客户端发送消息</span><br>        System.out.println(<span class="hljs-string">&quot;收到的客户端msg:&quot;</span>+msg);<br>        <span class="hljs-comment">//6.获取客户端的ip和端口</span><br>        System.out.println(<span class="hljs-string">&quot;获取客户端的ip地址：&quot;</span>+socket.getInetAddress().getHostAddress());<br>        System.out.println(<span class="hljs-string">&quot;获取客户端的端口号：&quot;</span>+socket.getPort());<br>           System.out.println(<span class="hljs-string">&quot;------------------&quot;</span>);<br>       &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="15-4-多个客户端同时通信"><a href="#15-4-多个客户端同时通信" class="headerlink" title="15.4.多个客户端同时通信"></a>15.4.多个客户端同时通信</h4><ul><li><p>对客户端进行改造</p></li><li><p>主线程接收客户端连接</p></li><li><p>子线程处理消息</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//服务端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo2</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>        <span class="hljs-comment">//实现一发一收</span><br>        <span class="hljs-comment">//1.创建ServerSocket对象，指定端口号</span><br>        ServerSocket ss=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br>        <span class="hljs-comment">//2.调用accept方法，阻塞等待客户端连接，一旦有客户端连接会返回一个Socket对象</span><br>        <span class="hljs-keyword">while</span>(ture)&#123;<br>              Socket socket=ss.accept();<br>            System.out.println(<span class="hljs-string">&quot;一个客户端上线了：&quot;</span>socket.getInetAddress().getHostAddress())<br>            <span class="hljs-comment">//把客户端管道交给一个子线程来处理</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReader</span>(socket).start();<br>        &#125;<br>       &#125;<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerReader</span><span class="hljs-params">(Socket socket)</span>&#123;<br>        <span class="hljs-built_in">this</span>.socket=socket;<br>    &#125;<br>    <span class="hljs-meta">@Override</span> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">try</span>&#123;<br>          <span class="hljs-comment">//读取该管道的消息</span><br>        InputStream is=socket.getInputStream();<br>        DataIuputStream dis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataIntputStream</span>(is);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            String msg=dis.readUTF();<br>             System.out.println(<span class="hljs-string">&quot;收到的客户端msg:&quot;</span>+msg);<br>        System.out.println(<span class="hljs-string">&quot;获取客户端的ip地址：&quot;</span>+socket.getInetAddress().getHostAddress());<br>        System.out.println(<span class="hljs-string">&quot;获取客户端的端口号：&quot;</span>+socket.getPort());<br>           System.out.println(<span class="hljs-string">&quot;------------------&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;一个客户端下线了：&quot;</span>socket.getInetAddress.getHostAddress());<br>        &#125; <br>       &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="15-5-WebSocket"><a href="#15-5-WebSocket" class="headerlink" title="15.5.WebSocket"></a>15.5.WebSocket</h4><ul><li>B&#x2F;S案例-maven引入坐标，注解实现</li></ul><blockquote><p>浏览器端html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs html">&gt;<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>WebSocket Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;send()&quot;</span>&gt;</span>发送消息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;closeWebSocket()&quot;</span>&gt;</span>关闭连接<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-keyword">var</span> websocket = <span class="hljs-literal">null</span>;</span><br><span class="language-javascript">   <span class="hljs-keyword">var</span> clientId = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>().<span class="hljs-title function_">toString</span>(<span class="hljs-number">36</span>).<span class="hljs-title function_">substr</span>(<span class="hljs-number">2</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//判断当前浏览器是否支持WebSocket</span></span><br><span class="language-javascript">   <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;WebSocket&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-comment">//连接WebSocket节点</span></span><br><span class="language-javascript">       websocket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;ws://localhost:8080/ws/&quot;</span>+clientId);</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">   <span class="hljs-keyword">else</span>&#123;</span><br><span class="language-javascript">       <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Not support websocket&#x27;</span>)</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//连接发生错误的回调方法</span></span><br><span class="language-javascript">   websocket.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-title function_">setMessageInnerHTML</span>(<span class="hljs-string">&quot;error&quot;</span>);</span><br><span class="language-javascript">   &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//连接成功建立的回调方法</span></span><br><span class="language-javascript">   websocket.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-title function_">setMessageInnerHTML</span>(<span class="hljs-string">&quot;连接成功&quot;</span>);</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//接收到消息的回调方法</span></span><br><span class="language-javascript">   websocket.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-title function_">setMessageInnerHTML</span>(event.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//连接关闭的回调方法</span></span><br><span class="language-javascript">   websocket.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-title function_">setMessageInnerHTML</span>(<span class="hljs-string">&quot;close&quot;</span>);</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。</span></span><br><span class="language-javascript">   <span class="hljs-variable language_">window</span>.<span class="hljs-property">onbeforeunload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">       websocket.<span class="hljs-title function_">close</span>();</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//将消息显示在网页上</span></span><br><span class="language-javascript">   <span class="hljs-keyword">function</span> <span class="hljs-title function_">setMessageInnerHTML</span>(<span class="hljs-params">innerHTML</span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;message&#x27;</span>).<span class="hljs-property">innerHTML</span> += innerHTML + <span class="hljs-string">&#x27;&lt;br/&gt;&#x27;</span>;</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//发送消息</span></span><br><span class="language-javascript">   <span class="hljs-keyword">function</span> <span class="hljs-title function_">send</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-keyword">var</span> message = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;text&#x27;</span>).<span class="hljs-property">value</span>;</span><br><span class="language-javascript">       websocket.<span class="hljs-title function_">send</span>(message);</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//关闭连接</span></span><br><span class="language-javascript">   <span class="hljs-keyword">function</span> <span class="hljs-title function_">closeWebSocket</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">       websocket.<span class="hljs-title function_">close</span>();</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ul><li>ws协议</li></ul></blockquote><blockquote><p>服务器端</p><p>配置类注册WebSocket的Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">/**</span><br><span class="hljs-comment">* WebSocket配置类，用于注册WebSocket的Bean</span><br><span class="hljs-comment">*/</span><br>&gt;<span class="hljs-meta">@Configuration</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketConfiguration</span> &#123;<br><br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-keyword">public</span> ServerEndpointExporter <span class="hljs-title function_">serverEndpointExporter</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerEndpointExporter</span>();<br>   &#125;<br><br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>WebSocket服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">/**</span><br><span class="hljs-comment">* WebSocket服务</span><br><span class="hljs-comment">*/</span><br>&gt;<span class="hljs-meta">@Component</span><br>&gt;<span class="hljs-meta">@ServerEndpoint(&quot;/ws/&#123;sid&#125;&quot;)</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketServer</span> &#123;<br><br>   <span class="hljs-comment">//存放会话对象</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Session&gt; sessionMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 连接建立成功调用的方法</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@OnOpen</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onOpen</span><span class="hljs-params">(Session session, <span class="hljs-meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;客户端：&quot;</span> + sid + <span class="hljs-string">&quot;建立连接&quot;</span>);<br>       sessionMap.put(sid, session);<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 收到客户端消息后调用的方法</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> message 客户端发送过来的消息</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@OnMessage</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String message, <span class="hljs-meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;收到来自客户端：&quot;</span> + sid + <span class="hljs-string">&quot;的信息:&quot;</span> + message);<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 连接关闭调用的方法</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> sid</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@OnClose</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClose</span><span class="hljs-params">(<span class="hljs-meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;连接断开:&quot;</span> + sid);<br>       sessionMap.remove(sid);<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 群发</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> message</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendToAllClient</span><span class="hljs-params">(String message)</span> &#123;<br>       Collection&lt;Session&gt; sessions = sessionMap.values();<br>       <span class="hljs-keyword">for</span> (Session session : sessions) &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-comment">//服务器向客户端发送消息</span><br>               session.getBasicRemote().sendText(message);<br>           &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>               e.printStackTrace();<br>           &#125;<br>       &#125;<br>   &#125;<br><br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="16-JDBC"><a href="#16-JDBC" class="headerlink" title="16.JDBC"></a>16.JDBC</h2><ul><li><p>JDBC:java语言操作关系型数据库的一套API</p></li><li><p>入门程序</p><p><img src="/.com//image-20250227155911896.png" alt="image-20250227155911896"></p></li></ul><h3 id="1-JDBC-工作原理"><a href="#1-JDBC-工作原理" class="headerlink" title="1. JDBC 工作原理"></a>1. JDBC 工作原理</h3><ul><li><strong>加载驱动程序</strong>：Java 程序通过 <code>Class.forName()</code> 方法加载数据库的驱动程序，不同的数据库有不同的驱动类。</li><li><strong>建立连接</strong>：使用 <code>DriverManager.getConnection()</code> 方法与数据库建立连接，需要提供数据库的 URL、用户名和密码。</li><li><strong>创建语句对象</strong>：通过连接对象创建 <code>Statement</code>、<code>PreparedStatement</code> 或 <code>CallableStatement</code> 对象，用于执行 SQL 语句。</li><li><strong>执行 SQL 语句</strong>：使用语句对象执行 SQL 语句，如查询、插入、更新或删除操作。</li><li><strong>处理结果集</strong>：如果执行的是查询语句，会返回一个 <code>ResultSet</code> 对象，用于处理查询结果。</li><li><strong>关闭资源</strong>：使用完数据库连接、语句对象和结果集后，需要关闭它们以释放资源。</li></ul><h3 id="2-JDBC-编程步骤及示例（以-MySQL-数据库为例）"><a href="#2-JDBC-编程步骤及示例（以-MySQL-数据库为例）" class="headerlink" title="2. JDBC 编程步骤及示例（以 MySQL 数据库为例）"></a>2. JDBC 编程步骤及示例（以 MySQL 数据库为例）</h3><h4 id="2-1-导入-JDBC-驱动依赖"><a href="#2-1-导入-JDBC-驱动依赖" class="headerlink" title="2.1 导入 JDBC 驱动依赖"></a>2.1 导入 JDBC 驱动依赖</h4><p>如果你使用的是 Maven 项目，可以在 <code>pom.xml</code> 中添加以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.26<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-2-编写-Java-代码"><a href="#2-2-编写-Java-代码" class="headerlink" title="2.2 编写 Java 代码"></a>2.2 编写 Java 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.Statement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 数据库连接信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/your_database_name&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;your_username&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;your_password&quot;</span>;<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1. 加载驱动程序</span><br>            Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br><br>            <span class="hljs-comment">// 2. 建立连接</span><br>            connection = DriverManager.getConnection(url, username, password);<br><br>            <span class="hljs-comment">// 3. 创建语句对象</span><br>            statement = connection.createStatement();<br><br>            <span class="hljs-comment">// 4. 执行 SQL 语句</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SELECT * FROM your_table_name&quot;</span>;<br>            resultSet = statement.executeQuery(sql);<br><br>            <span class="hljs-comment">// 5. 处理结果集</span><br>            <span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>                <span class="hljs-comment">// 假设表中有 id 和 name 两列</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> resultSet.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;ID: &quot;</span> + id + <span class="hljs-string">&quot;, Name: &quot;</span> + name);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 6. 关闭资源</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (resultSet != <span class="hljs-literal">null</span>) resultSet.close();<br>                <span class="hljs-keyword">if</span> (statement != <span class="hljs-literal">null</span>) statement.close();<br>                <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) connection.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/.com//image-20250227161039549.png" alt="image-20250227161039549"></p><h3 id="3-PreparedStatement-的使用"><a href="#3-PreparedStatement-的使用" class="headerlink" title="3. PreparedStatement 的使用"></a>3. <code>PreparedStatement</code> 的使用</h3><p><code>PreparedStatement</code> 是 <code>Statement</code> 的子接口，它可以预编译 SQL 语句，提高执行效率，同时可以防止 SQL 注入攻击。</p><ul><li>SQL注入：通过控制修改事先定义好的SQL语句，以达到执行代码对服务器进行攻击的方法。</li><li><img src="/.com//image-20250227161841918.png" alt="image-20250227161841918"></li><li><strong>什么是 SQL 预编译？</strong><ul><li><strong>定义</strong>：将 SQL 语句模板发送给数据库服务器编译，后续执行时只需传入参数，无需重复编译。</li><li><strong>核心思想</strong>：**”一次编译，多次执行”**。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PreparedStatementExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/your_database_name&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;your_username&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;your_password&quot;</span>;<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>            connection = DriverManager.getConnection(url, username, password);<br><br>            <span class="hljs-comment">// 预编译 SQL 语句</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SELECT * FROM your_table_name WHERE id = ?&quot;</span>;<br>            preparedStatement = connection.prepareStatement(sql);<br><br>            <span class="hljs-comment">// 设置参数</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            preparedStatement.setInt(<span class="hljs-number">1</span>, id);<br><br>            <span class="hljs-comment">// 执行查询</span><br>            resultSet = preparedStatement.executeQuery();<br><br>            <span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">resultId</span> <span class="hljs-operator">=</span> resultSet.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;ID: &quot;</span> + resultId + <span class="hljs-string">&quot;, Name: &quot;</span> + name);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (resultSet != <span class="hljs-literal">null</span>) resultSet.close();<br>                <span class="hljs-keyword">if</span> (preparedStatement != <span class="hljs-literal">null</span>) preparedStatement.close();<br>                <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) connection.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-执行更新操作"><a href="#4-执行更新操作" class="headerlink" title="4. 执行更新操作"></a>4. 执行更新操作</h3><p>除了查询操作，JDBC 还可以执行插入、更新和删除等更新操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/your_database_name&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;your_username&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;your_password&quot;</span>;<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>            connection = DriverManager.getConnection(url, username, password);<br><br>            <span class="hljs-comment">// 插入数据</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">insertSql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;INSERT INTO your_table_name (name, age) VALUES (?, ?)&quot;</span>;<br>            preparedStatement = connection.prepareStatement(insertSql);<br>            preparedStatement.setString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;John&quot;</span>);<br>            preparedStatement.setInt(<span class="hljs-number">2</span>, <span class="hljs-number">25</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowsInserted</span> <span class="hljs-operator">=</span> preparedStatement.executeUpdate();<br>            System.out.println(<span class="hljs-string">&quot;插入的行数: &quot;</span> + rowsInserted);<br><br>            <span class="hljs-comment">// 更新数据</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">updateSql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;UPDATE your_table_name SET age = ? WHERE name = ?&quot;</span>;<br>            preparedStatement = connection.prepareStatement(updateSql);<br>            preparedStatement.setInt(<span class="hljs-number">1</span>, <span class="hljs-number">26</span>);<br>            preparedStatement.setString(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;John&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowsUpdated</span> <span class="hljs-operator">=</span> preparedStatement.executeUpdate();<br>            System.out.println(<span class="hljs-string">&quot;更新的行数: &quot;</span> + rowsUpdated);<br><br>            <span class="hljs-comment">// 删除数据</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">deleteSql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;DELETE FROM your_table_name WHERE name = ?&quot;</span>;<br>            preparedStatement = connection.prepareStatement(deleteSql);<br>            preparedStatement.setString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;John&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowsDeleted</span> <span class="hljs-operator">=</span> preparedStatement.executeUpdate();<br>            System.out.println(<span class="hljs-string">&quot;删除的行数: &quot;</span> + rowsDeleted);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (preparedStatement != <span class="hljs-literal">null</span>) preparedStatement.close();<br>                <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) connection.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="17-反射与注解"><a href="#17-反射与注解" class="headerlink" title="17.反射与注解"></a>17.反射与注解</h2><h3 id="1-反射"><a href="#1-反射" class="headerlink" title="1.反射"></a>1.反射</h3><ul><li>反射：加载类，并且允许以编程的方式操作类的各种成分（成员变量、方法、构造器等）</li></ul><p><img src="/.com//image-20250331142402456.png" alt="image-20250331142402456"></p><blockquote><p>先获取Class对象再获取类的构造器方法等等</p></blockquote><h4 id="1-获取Class对象-字节码类"><a href="#1-获取Class对象-字节码类" class="headerlink" title="1.获取Class对象-字节码类"></a>1.获取Class对象-字节码类</h4><p><img src="/.com//image-20250331142631910.png" alt="image-20250331142631910"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方式一</span><br>Class c1=Student.class;<br>System.out.println(c1.getName());<span class="hljs-comment">//全类名(包括包路径)</span><br>System.out.println(c1.getSimpleName());<span class="hljs-comment">//类名Student</span><br><br><span class="hljs-comment">//方式二：</span><br>Class c2=Class.forName(<span class="hljs-string">&quot;全类名&quot;</span>);<br><br><span class="hljs-comment">//方式三：</span><br>Student stu=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>Class c3=stu.getClass()<br></code></pre></td></tr></table></figure><h4 id="2-通过Class对象获取构造器"><a href="#2-通过Class对象获取构造器" class="headerlink" title="2.通过Class对象获取构造器"></a>2.通过Class对象获取构造器</h4><p><img src="/.com//image-20250331143300867.png" alt="image-20250331143300867"></p><p><img src="/.com//image-20250331143819924.png" alt="image-20250331143819924"></p><h4 id="3-通过Class对象获取类属性"><a href="#3-通过Class对象获取类属性" class="headerlink" title="3.通过Class对象获取类属性"></a>3.通过Class对象获取类属性</h4><p><img src="/.com//image-20250331143959390.png" alt="image-20250331143959390"></p><h4 id="4-通过Class对象调用类方法"><a href="#4-通过Class对象调用类方法" class="headerlink" title="4.通过Class对象调用类方法"></a>4.通过Class对象调用类方法</h4><p><img src="/.com//image-20250331144028471.png" alt="image-20250331144028471"></p><p><img src="/.com//image-20250331144158882.png" alt="image-20250331144158882"></p><h3 id="2-注解"><a href="#2-注解" class="headerlink" title="2.注解"></a>2.注解</h3><ul><li>注解是 Java 提供的一种元数据机制，它为程序的元素（类、方法、字段等）添加额外的信息，这些信息不会影响程序的编译和运行，但可以在编译时、运行时被读取和处理。</li></ul><h4 id="1-内置注解"><a href="#1-内置注解" class="headerlink" title="1.内置注解"></a>1.内置注解</h4><p><img src="/.com//image-20250331144633543.png" alt="image-20250331144633543"></p><h4 id="2-元注解"><a href="#2-元注解" class="headerlink" title="2.元注解"></a>2.元注解</h4><p><img src="/.com//image-20250331145005267.png" alt="image-20250331145005267"></p><p><em><strong>@Target(ElementType.XXX)</strong></em>:描述注解的作用范围</p><h3 id="ElementType-枚举类型"><a href="#ElementType-枚举类型" class="headerlink" title="ElementType 枚举类型"></a><code>ElementType</code> 枚举类型</h3><p><code>ElementType</code> 枚举类型包含以下常量：</p><ul><li><code>TYPE</code>：可应用于类、接口（包含注解类型）或者枚举声明。</li><li><code>FIELD</code>：可应用于字段声明，包含枚举常量。</li><li><code>METHOD</code>：可应用于方法声明。</li><li><code>PARAMETER</code>：可应用于参数声明。</li><li><code>CONSTRUCTOR</code>：可应用于构造函数声明。</li><li><code>LOCAL_VARIABLE</code>：可应用于局部变量声明。</li><li><code>ANNOTATION_TYPE</code>：可应用于注解类型声明。</li><li><code>PACKAGE</code>：可应用于包声明。</li><li><code>TYPE_PARAMETER</code>：可应用于类型参数声明（Java 8 新增）。</li><li><code>TYPE_USE</code>：可应用于任何使用类型的地方（Java 8 新增）。</li></ul><h4 id="3-自定义注解"><a href="#3-自定义注解" class="headerlink" title="3.自定义注解"></a>3.自定义注解</h4><p><img src="/.com//image-20250331145622188.png" alt="image-20250331145622188"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testinterface</span>&#123;<br>    <span class="hljs-comment">//定义了参数就必须传入参数或者使用default声明默认值</span><br>    <span class="hljs-meta">@MyAnnotation(name=&quot;xxx&quot;)</span><br>    <span class="hljs-comment">//@MyAnnotation()</span><br>    <span class="hljs-comment">//@MyAnnotation(&quot;xxx&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br><span class="hljs-meta">@Target(&#123;ElementType.Type,ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> MyAnnotation&#123;<br>    <span class="hljs-comment">//注解的参数： 参数类型+参数名()；</span><br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// String name() default &quot;&quot;;</span><br>    <span class="hljs-comment">//String value();</span><br>    <span class="hljs-comment">//如果注解只有一个值，且用value表示的话，可以省略</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3.动态代理"></a>3.动态代理</h3><ul><li>通过反射创建代理对象</li></ul><p><img src="/.com//image-20250421172401690.png" alt="image-20250421172401690"></p><ul><li><strong>实现对象的方法而不调用对象</strong><ul><li>定义接口-》指定方法</li><li>实现接口</li><li>创建代理对象</li></ul></li></ul><h4 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h4><ul><li><strong>原理</strong>：基于 Java 的反射机制，在运行时动态生成代理类，该代理类实现了目标对象所实现的<strong>接口</strong>。</li><li><strong>适用场景</strong>：适用于目标对象实现了接口的情况，常用于面向接口编程的场景。</li><li><strong>优点</strong>：Java 原生支持，无需额外依赖，性能较高。</li><li><strong>缺点</strong>：只能代理实现了接口的类，无法代理普通类。</li></ul><h4 id="CGLIB-代理"><a href="#CGLIB-代理" class="headerlink" title="CGLIB 代理"></a>CGLIB 代理</h4><ul><li><strong>原理</strong>：通过字节码生成库（如 CGLIB）在运行时动态生成目标类的<strong>子类</strong>作为代理类。</li><li><strong>适用场景</strong>：适用于目标对象没有实现接口的情况，或者需要对类的所有方法进行代理的场景。</li><li><strong>优点</strong>：可以代理普通类，灵活性高。</li><li><strong>缺点</strong>：需要额外依赖，创建代理对象的性能相对较低。</li></ul><h4 id="通过-AopContext-获取代理对象"><a href="#通过-AopContext-获取代理对象" class="headerlink" title="通过 AopContext 获取代理对象"></a>通过 <code>AopContext</code> 获取代理对象</h4><ul><li><strong>原理</strong>：在 Spring AOP 框架中，基于已经配置好的 AOP 切面和代理策略生成代理对象，通过 <code>AopContext</code> 工具类获取当前的代理对象。</li><li><strong>适用场景</strong>：用于解决 AOP 代理对象内部方法调用无法触发 AOP 增强的问题，通常在 Spring AOP 的复杂业务场景中使用。</li><li><strong>优点</strong>：可以让内部方法调用也触发 AOP 增强逻辑。</li><li><strong>缺点</strong>：需要开启暴露代理，会带来一定的性能开销。（引入aop依赖，启动类暴露代理）</li></ul><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><h4 id="JDK-动态代理示例"><a href="#JDK-动态代理示例" class="headerlink" title="JDK 动态代理示例"></a>JDK 动态代理示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-comment">// 定义接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 实现接口的目标类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;RealSubject: Handling request.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现 InvocationHandler 接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JdkProxyHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JdkProxyHandler</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;Before method call&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>        System.out.println(<span class="hljs-string">&quot;After method call&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdkDynamicProxyDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">RealSubject</span> <span class="hljs-variable">realSubject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSubject</span>();<br>        <span class="hljs-type">JdkProxyHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdkProxyHandler</span>(realSubject);<br>        <span class="hljs-type">Subject</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (Subject) Proxy.newProxyInstance(<br>                RealSubject.class.getClassLoader(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[]&#123;Subject.class&#125;,<br>                handler<br>        );<br>        proxy.request();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="CGLIB-代理示例"><a href="#CGLIB-代理示例" class="headerlink" title="CGLIB 代理示例"></a>CGLIB 代理示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">// 目标类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TargetClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;TargetClass: Doing something.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现 MethodInterceptor 接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;Before method call&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> proxy.invokeSuper(obj, args);<br>        System.out.println(<span class="hljs-string">&quot;After method call&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxyDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        enhancer.setSuperclass(TargetClass.class);<br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CglibProxyInterceptor</span>());<br>        <span class="hljs-type">TargetClass</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (TargetClass) enhancer.create();<br>        proxy.doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="通过-AopContext-获取代理对象示例"><a href="#通过-AopContext-获取代理对象示例" class="headerlink" title="通过 AopContext 获取代理对象示例"></a>通过 <code>AopContext</code> 获取代理对象示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.After;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.springframework.aop.framework.AopContext;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-comment">// 目标服务类</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Method A is called.&quot;</span>);<br>        <span class="hljs-type">MyService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (MyService) AopContext.currentProxy();<br>        proxy.methodB();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Method B is called.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 切面类</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.example.demo.MyService.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-meta">@Before(&quot;pointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Before method execution.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@After(&quot;pointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;After method execution.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 配置类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAspectJAutoProxy(exposeProxy = true)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyService <span class="hljs-title function_">myService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyService</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyAspect <span class="hljs-title function_">myAspect</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyAspect</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AopContextDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);<br>        <span class="hljs-type">MyService</span> <span class="hljs-variable">myService</span> <span class="hljs-operator">=</span> context.getBean(MyService.class);<br>        myService.methodA();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上示例代码分别展示了 JDK 动态代理、CGLIB 代理和通过 <code>AopContext</code> 获取代理对象的使用方法，你可以根据实际需求选择合适的代理方式。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/HttpClient/"/>
    <url>/2025/07/02/HttpClient/</url>
    
    <content type="html"><![CDATA[<h1 id="HttpClient-模拟客户端发送请求"><a href="#HttpClient-模拟客户端发送请求" class="headerlink" title="HttpClient-模拟客户端发送请求"></a>HttpClient-模拟客户端发送请求</h1><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><p><img src="/.com//image-20250402180012761.png" alt="image-20250402180012761"></p><ul><li>在java中通过编码模拟客户端的方式发送Http请求</li></ul><blockquote><ul><li>HttpClientUtil</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">/**</span><br><span class="hljs-comment">* Http工具类</span><br><span class="hljs-comment">*/</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpClientUtil</span> &#123;<br><br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span>  <span class="hljs-type">int</span> <span class="hljs-variable">TIMEOUT_MSEC</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span> * <span class="hljs-number">1000</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 发送GET方式请求</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> url</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> paramMap</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">doGet</span><span class="hljs-params">(String url,Map&lt;String,String&gt; paramMap)</span>&#123;<br>       <span class="hljs-comment">// 创建Httpclient对象</span><br>       <span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br><br>       <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>       <span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>       <span class="hljs-keyword">try</span>&#123;<br>           <span class="hljs-type">URIBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URIBuilder</span>(url);<br>           <span class="hljs-keyword">if</span>(paramMap != <span class="hljs-literal">null</span>)&#123;<br>               <span class="hljs-keyword">for</span> (String key : paramMap.keySet()) &#123;<br>                   builder.addParameter(key,paramMap.get(key));<br>               &#125;<br>           &#125;<br>           <span class="hljs-type">URI</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> builder.build();<br><br>           <span class="hljs-comment">//创建GET请求</span><br>           <span class="hljs-type">HttpGet</span> <span class="hljs-variable">httpGet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(uri);<br><br>           <span class="hljs-comment">//发送请求</span><br>           response = httpClient.execute(httpGet);<br><br>           <span class="hljs-comment">//判断响应状态</span><br>           <span class="hljs-keyword">if</span>(response.getStatusLine().getStatusCode() == <span class="hljs-number">200</span>)&#123;<br>               result = EntityUtils.toString(response.getEntity(),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>           &#125;<br>       &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>           e.printStackTrace();<br>       &#125;<span class="hljs-keyword">finally</span> &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               response.close();<br>               httpClient.close();<br>           &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>               e.printStackTrace();<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> result;<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 发送POST方式请求</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> url</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> paramMap</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">doPost</span><span class="hljs-params">(String url, Map&lt;String, String&gt; paramMap)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>       <span class="hljs-comment">// 创建Httpclient对象</span><br>       <span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br>       <span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">resultString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">// 创建Http Post请求</span><br>           <span class="hljs-type">HttpPost</span> <span class="hljs-variable">httpPost</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpPost</span>(url);<br><br>           <span class="hljs-comment">// 创建参数列表</span><br>           <span class="hljs-keyword">if</span> (paramMap != <span class="hljs-literal">null</span>) &#123;<br>               List&lt;NameValuePair&gt; paramList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>               <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; param : paramMap.entrySet()) &#123;<br>                   paramList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicNameValuePair</span>(param.getKey(), param.getValue()));<br>               &#125;<br>               <span class="hljs-comment">// 模拟表单</span><br>               <span class="hljs-type">UrlEncodedFormEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlEncodedFormEntity</span>(paramList);<br>               httpPost.setEntity(entity);<br>           &#125;<br><br>           httpPost.setConfig(builderRequestConfig());<br><br>           <span class="hljs-comment">// 执行http请求</span><br>           response = httpClient.execute(httpPost);<br><br>           resultString = EntityUtils.toString(response.getEntity(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>           <span class="hljs-keyword">throw</span> e;<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               response.close();<br>           &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>               e.printStackTrace();<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> resultString;<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 发送POST方式请求</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> url</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> paramMap</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">doPost4Json</span><span class="hljs-params">(String url, Map&lt;String, String&gt; paramMap)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>       <span class="hljs-comment">// 创建Httpclient对象</span><br>       <span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br>       <span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">resultString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">// 创建Http Post请求</span><br>           <span class="hljs-type">HttpPost</span> <span class="hljs-variable">httpPost</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpPost</span>(url);<br><br>           <span class="hljs-keyword">if</span> (paramMap != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-comment">//构造json格式数据</span><br>               <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>               <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; param : paramMap.entrySet()) &#123;<br>                   jsonObject.put(param.getKey(),param.getValue());<br>               &#125;<br>               <span class="hljs-type">StringEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEntity</span>(jsonObject.toString(),<span class="hljs-string">&quot;utf-8&quot;</span>);<br>               <span class="hljs-comment">//设置请求编码</span><br>               entity.setContentEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>               <span class="hljs-comment">//设置数据类型</span><br>               entity.setContentType(<span class="hljs-string">&quot;application/json&quot;</span>);<br>               httpPost.setEntity(entity);<br>           &#125;<br><br>           httpPost.setConfig(builderRequestConfig());<br><br>           <span class="hljs-comment">// 执行http请求</span><br>           response = httpClient.execute(httpPost);<br><br>           resultString = EntityUtils.toString(response.getEntity(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>           <span class="hljs-keyword">throw</span> e;<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               response.close();<br>           &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>               e.printStackTrace();<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> resultString;<br>   &#125;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> RequestConfig <span class="hljs-title function_">builderRequestConfig</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> RequestConfig.custom()<br>               .setConnectTimeout(TIMEOUT_MSEC)<br>               .setConnectionRequestTimeout(TIMEOUT_MSEC)<br>               .setSocketTimeout(TIMEOUT_MSEC).build();<br>   &#125;<br><br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><h1 id="2-入门"><a href="#2-入门" class="headerlink" title="2.入门"></a>2.入门</h1><h3 id="1-入门案例"><a href="#1-入门案例" class="headerlink" title="1.入门案例"></a>1.入门案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpClientTest</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试通过HttpClient发送get请求</span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGET</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">//创建httpclient对象</span><br>    <span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpclient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br><br>    <span class="hljs-comment">//创建请求对象</span><br>    <span class="hljs-type">HttpGet</span> <span class="hljs-variable">httpGet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(<span class="hljs-string">&quot;http://localhost:8080/user/shop/status&quot;</span>);<br><br>    <span class="hljs-comment">//发送请求,接收响应结果</span><br>    <span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpclient.execute(httpGet);<br>    <span class="hljs-comment">//获取服务端返的状态码</span><br>    <span class="hljs-type">int</span> statuscode=response.getStatusLine().getStatusCode();<br>    System.out.println(<span class="hljs-string">&quot;服务端返回的状态码为：&quot;</span>+statuscode);<br>    <span class="hljs-comment">//获取数据</span><br>    HttpEntity entity=response.getEntity();<br>    String body= EntityUtils.toString(entity);<br>    System.out.println(<span class="hljs-string">&quot;服务端返回的数据为：&quot;</span>+body);<br><br>    <span class="hljs-comment">//关闭资源</span><br>    response.close();<br>    httpclient.close();<br>&#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试通过HttpClient发送post请求</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPOST</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//创建httpClient对象</span><br>        <span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br><br>        <span class="hljs-comment">//创建请求对象</span><br>        <span class="hljs-type">HttpPost</span> <span class="hljs-variable">httpPost</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpPost</span>(<span class="hljs-string">&quot;http://localhost:8080/admin/employee/login&quot;</span>);<br>        <span class="hljs-comment">//设置请求体参数</span><br>        JSONObject jsonObject=<span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>        jsonObject.put(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>);<br>        jsonObject.put(<span class="hljs-string">&quot;password&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br>        StringEntity bodyentity=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEntity</span>(jsonObject.toString());<br>        <span class="hljs-comment">//指定编码方式</span><br>        bodyentity.setContentEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        <span class="hljs-comment">//数据格式</span><br>        bodyentity.setContentType(<span class="hljs-string">&quot;application/json&quot;</span>);<br>        httpPost.setEntity(bodyentity);<br><br>        <span class="hljs-comment">//通过httpClient对象发送请求</span><br>        <span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpClient.execute(httpPost);<br><br>        <span class="hljs-comment">//获取请求返回的信息</span><br>        <span class="hljs-type">HttpEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> response.getEntity();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">statusCode</span> <span class="hljs-operator">=</span> response.getStatusLine().getStatusCode();<br>        String body=EntityUtils.toString(entity);<br>        System.out.println(<span class="hljs-string">&quot;服务端返回的状态码为：&quot;</span>+statusCode);<br>        System.out.println(<span class="hljs-string">&quot;服务端返回的数据为：&quot;</span>+body);<br><span class="hljs-comment">//关闭资源</span><br>    response.close();<br>    httpclient.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>HttpClients创建CloseableHttpClient对象（实现HttpClient接口）-httpclient</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建httpclient对象</span><br> <span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpclient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br></code></pre></td></tr></table></figure><ul><li>创建请求对象–HttpGet&#x2F;HttpPost -传入url参数以及其他请求参数的设置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"> <span class="hljs-comment">//创建请求对象</span><br>    <span class="hljs-type">HttpGet</span> <span class="hljs-variable">httpGet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(<span class="hljs-string">&quot;http://localhost:8080/user/shop/status&quot;</span>);<br><span class="hljs-comment">//创建请求对象</span><br>        <span class="hljs-type">HttpPost</span> <span class="hljs-variable">httpPost</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpPost</span>(<span class="hljs-string">&quot;http://localhost:8080/admin/employee/login&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>通过实现类httpclient调用HttpClient接口的执行方法发送请求并且用CloseableHttpResponse接收请求结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"> <span class="hljs-comment">//发送请求,接收响应结果</span><br>    <span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpclient.execute(httpGet);<br>    <span class="hljs-comment">//通过httpClient对象发送请求</span><br>        <span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpClient.execute(httpPost);<br><span class="hljs-comment">//获取服务端返的状态码</span><br>    <span class="hljs-type">int</span> statuscode=response.getStatusLine().getStatusCode();<br><span class="hljs-type">int</span> <span class="hljs-variable">statusCode</span> <span class="hljs-operator">=</span> response.getStatusLine().getStatusCode();<br></code></pre></td></tr></table></figure><ul><li>使用HttpEntity接收请求结果的实体信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取数据</span><br>    HttpEntity entity=response.getEntity();<br>    String body= EntityUtils.toString(entity);<br>    System.out.println(<span class="hljs-string">&quot;服务端返回的数据为：&quot;</span>+body);<br></code></pre></td></tr></table></figure><ul><li>关闭资源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//关闭资源</span><br>    response.close();<br>    httpclient.close();<br></code></pre></td></tr></table></figure><h3 id="2-请求参数的封装"><a href="#2-请求参数的封装" class="headerlink" title="2. 请求参数的封装"></a>2. 请求参数的封装</h3><h4 id="2-1-GET-请求参数封装"><a href="#2-1-GET-请求参数封装" class="headerlink" title="2.1 GET 请求参数封装"></a>2.1 GET 请求参数封装</h4><p>GET 请求的参数通常会附加在 URL 的查询字符串中。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.http.client.methods.HttpGet;<br><span class="hljs-keyword">import</span> org.apache.http.client.utils.URIBuilder;<br><br><span class="hljs-keyword">import</span> java.net.URI;<br><span class="hljs-keyword">import</span> java.net.URISyntaxException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GetRequestExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> URISyntaxException &#123;<br>        <span class="hljs-comment">// 创建 URIBuilder 对象</span><br>        <span class="hljs-type">URIBuilder</span> <span class="hljs-variable">uriBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URIBuilder</span>(<span class="hljs-string">&quot;https://example.com/api&quot;</span>);<br>        <span class="hljs-comment">// 添加参数</span><br>        uriBuilder.addParameter(<span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>        uriBuilder.addParameter(<span class="hljs-string">&quot;param2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br><br>        <span class="hljs-comment">// 构建 URI</span><br>        <span class="hljs-type">URI</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> uriBuilder.build();<br>        <span class="hljs-comment">// 创建 HttpGet 请求</span><br>        <span class="hljs-type">HttpGet</span> <span class="hljs-variable">httpGet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(uri);<br>        System.out.println(<span class="hljs-string">&quot;Request URL: &quot;</span> + httpGet.getURI());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，使用 <code>URIBuilder</code> 来构建包含参数的 URI，然后将其传递给 <code>HttpGet</code> 对象。参数可以使用工具类进行封装优化</p><h4 id="2-2-POST-请求参数封装"><a href="#2-2-POST-请求参数封装" class="headerlink" title="2.2 POST 请求参数封装"></a>2.2 POST 请求参数封装</h4><p>POST 请求的参数通常放在请求体中。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.http.HttpEntity;<br><span class="hljs-keyword">import</span> org.apache.http.client.methods.HttpPost;<br><span class="hljs-keyword">import</span> org.apache.http.entity.StringEntity;<br><span class="hljs-keyword">import</span> org.apache.http.entity.mime.MultipartEntityBuilder;<br><span class="hljs-keyword">import</span> org.apache.http.entity.mime.content.StringBody;<br><br><span class="hljs-keyword">import</span> java.io.UnsupportedEncodingException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PostRequestExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException &#123;<br>        <span class="hljs-comment">// 创建 HttpPost 请求</span><br>        <span class="hljs-type">HttpPost</span> <span class="hljs-variable">httpPost</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpPost</span>(<span class="hljs-string">&quot;https://example.com/api&quot;</span>);<br><br>        <span class="hljs-comment">// 方式一：使用表单形式传递参数</span><br>        <span class="hljs-type">MultipartEntityBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> MultipartEntityBuilder.create();<br>        builder.addPart(<span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBody</span>(<span class="hljs-string">&quot;value1&quot;</span>));<br>        builder.addPart(<span class="hljs-string">&quot;param2&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBody</span>(<span class="hljs-string">&quot;value2&quot;</span>));<br>        <span class="hljs-type">HttpEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> builder.build();<br>        httpPost.setEntity(entity);<br><br>        <span class="hljs-comment">// 方式二：使用 JSON 形式传递参数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;param1\&quot;: \&quot;value1\&quot;, \&quot;param2\&quot;: \&quot;value2\&quot;&#125;&quot;</span>;<br>        <span class="hljs-type">StringEntity</span> <span class="hljs-variable">jsonEntity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEntity</span>(json);<br>        httpPost.setEntity(jsonEntity);<br>        httpPost.setHeader(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码展示了两种常见的 POST 请求参数封装方式：表单形式和 JSON 形式。参数可以使用工具类进行封装优化。</p><h3 id="3-请求结果的解析"><a href="#3-请求结果的解析" class="headerlink" title="3. 请求结果的解析"></a>3. 请求结果的解析</h3><h4 id="3-1-发送请求并获取响应"><a href="#3-1-发送请求并获取响应" class="headerlink" title="3.1 发送请求并获取响应"></a>3.1 发送请求并获取响应</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.http.HttpResponse;<br><span class="hljs-keyword">import</span> org.apache.http.client.HttpClient;<br><span class="hljs-keyword">import</span> org.apache.http.client.methods.HttpGet;<br><span class="hljs-keyword">import</span> org.apache.http.impl.client.HttpClients;<br><span class="hljs-keyword">import</span> org.apache.http.util.EntityUtils;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 创建 HttpClient 实例</span><br>        <span class="hljs-type">HttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br>        <span class="hljs-comment">// 创建 HttpGet 请求</span><br>        <span class="hljs-type">HttpGet</span> <span class="hljs-variable">httpGet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(<span class="hljs-string">&quot;https://example.com/api&quot;</span>);<br>        <span class="hljs-comment">// 执行请求并获取响应</span><br>        <span class="hljs-type">HttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpClient.execute(httpGet);<br>        <span class="hljs-comment">// 获取响应实体</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">responseBody</span> <span class="hljs-operator">=</span> EntityUtils.toString(response.getEntity());<br>        System.out.println(<span class="hljs-string">&quot;Response: &quot;</span> + responseBody);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，使用 <code>HttpClient</code> 执行请求并获取响应，然后使用 <code>EntityUtils.toString</code> 方法将响应实体转换为字符串。</p><h4 id="3-2-解析-JSON-响应"><a href="#3-2-解析-JSON-响应" class="headerlink" title="3.2 解析 JSON 响应"></a>3.2 解析 JSON 响应</h4><p>如果响应是 JSON 格式的，可以使用 JSON 解析库（如 FastJSON、Jackson 等）进行解析。以 FastJSON 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.fastjson2.JSONObject;<br><span class="hljs-keyword">import</span> org.apache.http.HttpResponse;<br><span class="hljs-keyword">import</span> org.apache.http.client.HttpClient;<br><span class="hljs-keyword">import</span> org.apache.http.client.methods.HttpGet;<br><span class="hljs-keyword">import</span> org.apache.http.impl.client.HttpClients;<br><span class="hljs-keyword">import</span> org.apache.http.util.EntityUtils;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonResponseExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 创建 HttpClient 实例</span><br>        <span class="hljs-type">HttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br>        <span class="hljs-comment">// 创建 HttpGet 请求</span><br>        <span class="hljs-type">HttpGet</span> <span class="hljs-variable">httpGet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(<span class="hljs-string">&quot;https://example.com/api&quot;</span>);<br>        <span class="hljs-comment">// 执行请求并获取响应</span><br>        <span class="hljs-type">HttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpClient.execute(httpGet);<br>        <span class="hljs-comment">// 获取响应实体</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">responseBody</span> <span class="hljs-operator">=</span> EntityUtils.toString(response.getEntity());<br><br>        <span class="hljs-comment">// 解析 JSON 响应</span><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> JSONObject.parseObject(responseBody);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">param1</span> <span class="hljs-operator">=</span> jsonObject.getString(<span class="hljs-string">&quot;param1&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Param1: &quot;</span> + param1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，使用 FastJSON 的 <code>JSONObject.parseObject</code> 方法将响应字符串解析为 <code>JSONObject</code>，然后获取所需的参数。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/hm%E7%82%B9%E8%AF%84/"/>
    <url>/2025/07/02/hm%E7%82%B9%E8%AF%84/</url>
    
    <content type="html"><![CDATA[<h1 id="黑马点评-redis学习"><a href="#黑马点评-redis学习" class="headerlink" title="黑马点评 -redis学习"></a>黑马点评 -redis学习</h1><h2 id="1-使用session和cookie实现手机短信验证码登录和注册"><a href="#1-使用session和cookie实现手机短信验证码登录和注册" class="headerlink" title="1.使用session和cookie实现手机短信验证码登录和注册"></a>1.使用session和cookie实现手机短信验证码登录和注册</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="/.com//image-20250623104305976.png" alt="image-20250623104305976"></p><ul><li>前端请求时后端会为其分配sessionId,并且返回参数sessionId,下次前端请求时会自动携带sessionId作为cookie,后端服务器能够根据cookie携带的sessionId匹配对应的Session</li><li>发送验证码接口传入参数手机号和HttpSession,服务层进行参数验证将短信验证码存到后端的session（session.setAttribute(“code”,code)）并且使用手机验证码服务接口发送验证码</li><li>登录和注册使用同一个接口传递参数（封装手机号和验证码）以及HttpSession,服务层进行参数验证，并且获取session的参数（session.getAttribute(“code”)）进行对比，成功就数据库查询该用户，如果存在就返回，不存在进行注册insert，并且返回主键id,最后返回成功登录&#x2F;注册。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceImpl</span><span class="hljs-params">(UserMapper userMapper)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发送验证码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> phone</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> session</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(String phone, HttpSession session)</span> &#123;<br>        <span class="hljs-comment">//校验手机号</span><br>        <span class="hljs-keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;<span class="hljs-comment">//如果不符合返回错误消息</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//符合，生成验证码</span><br>        String code= RandomUtil.randomNumbers(<span class="hljs-number">6</span>);<br>        <span class="hljs-comment">//保存验证码到session</span><br>        session.setAttribute(<span class="hljs-string">&quot;code&quot;</span>,code);<br>        <span class="hljs-comment">//发送验证码</span><br>        <span class="hljs-comment">//阿里云短信服务</span><br>        log.debug(<span class="hljs-string">&quot;发送短信验证码成功:&#123;&#125;&quot;</span>,code);<br>        <span class="hljs-comment">//返回ok</span><br>        <span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>        <span class="hljs-comment">//校验</span><br>        String phone=loginForm.getPhone();<br>        <span class="hljs-keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;<span class="hljs-comment">//如果不符合返回错误消息</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;code&quot;</span>);<br>        String code=loginForm.getCode();<br>        <span class="hljs-keyword">if</span> (cacheCode==<span class="hljs-literal">null</span>||!cacheCode.toString().equals(code))&#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//查询是否有用户-mybatis-plus</span><br>        User user=query().eq(<span class="hljs-string">&quot;phone&quot;</span>,phone).one();<br>        <span class="hljs-comment">//如果没有用户，进行注册，并且保存到数据库回显id</span><br>        <span class="hljs-keyword">if</span>(user==<span class="hljs-literal">null</span>)&#123;<br>            user=createUserWithPhone(phone);<br>        &#125;<br>        <span class="hljs-comment">//保存用户消息到session</span><br>        session.setAttribute(<span class="hljs-string">&quot;user&quot;</span>, BeanUtil.copyProperties(user,UserDTO.class));<br>        <span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> User <span class="hljs-title function_">createUserWithPhone</span><span class="hljs-params">(String phone)</span>&#123;<br>        <span class="hljs-keyword">return</span> User.builder()<br>                .nickName(USER_NICK_NAME_PREFIX+RandomUtil.randomString(<span class="hljs-number">10</span>))<br>                .phone(phone)<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用拦截器解析</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//获取session</span><br>        HttpSession session=request.getSession();<br>        <span class="hljs-comment">//获取session中的用户</span><br>        Object user=session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>        <span class="hljs-comment">//判断用户是否存在</span><br>        <span class="hljs-keyword">if</span>(user==<span class="hljs-literal">null</span>)&#123;<br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//存在保存LocalThread，放行</span><br><br>        UserHolder.saveUser((UserDTO) user);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        UserHolder.removeUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>配置类配置拦截器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginInterceptor loginInterceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(loginInterceptor).excludePathPatterns(<br>                <span class="hljs-string">&quot;/user/code&quot;</span>,<br>                <span class="hljs-string">&quot;/user/login&quot;</span>,<br>                <span class="hljs-string">&quot;/blog/hot&quot;</span>,<br>                <span class="hljs-string">&quot;/shop/**&quot;</span>,<br>                <span class="hljs-string">&quot;/shop-type/**&quot;</span>,<br>                <span class="hljs-string">&quot;/upload/**&quot;</span>,<br>                <span class="hljs-string">&quot;/voucher/**&quot;</span><br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>存在问题</li></ul><p><img src="/.com//image-20250424000727365.png" alt="image-20250424000727365"></p><h2 id="2-使用Redis-Token实现登录"><a href="#2-使用Redis-Token实现登录" class="headerlink" title="2.使用Redis+Token实现登录"></a>2.使用Redis+Token实现登录</h2><ul><li><strong>对比先前学过的JWT令牌认证</strong></li></ul><h3 id="JWT-实现登录认证"><a href="#JWT-实现登录认证" class="headerlink" title="JWT 实现登录认证"></a>JWT 实现登录认证</h3><ul><li>优点<ul><li><strong>无状态性</strong>：JWT 将用户相关的信息编码在 Token 中，服务器无需存储用户的登录状态，减轻了服务器的负担，易于扩展，能轻松应对高并发场景。</li><li><strong>跨域性好</strong>：由于 JWT 是通过 HTTP 请求头或 URL 参数传递的，与具体的域名和端口无关，所以在跨域应用中能方便地进行身份认证。</li><li><strong>自包含性</strong>：JWT 包含了用户的身份信息、权限信息等，服务器无需再去数据库或其他存储中查询相关信息，能快速完成认证和授权过程，提高了系统的性能。</li></ul></li><li>缺点<ul><li><strong>安全性问题</strong>：JWT 的安全性依赖于密钥的保密性，如果密钥泄露，那么任何人都可以伪造 Token。另外，JWT 一旦签发，在有效期内就会一直有效，即使用户的权限发生了变化，也需要等到 Token 过期后才能生效，存在一定的安全风险。</li><li><strong>Payload 大小限制</strong>：JWT 的 Payload 部分会随着用户信息的增加而变大，这会增加网络传输的负担，并且对 URL 长度和 HTTP 请求头大小有限制的环境不太友好。</li><li><strong>无法主动注销</strong>：由于服务器不存储 Token 状态，所以无法主动使某个 Token 失效，要实现注销功能，通常需要采用一些额外的机制，如在服务器端记录已注销的 Token 列表，但这会破坏 JWT 的无状态特性。</li></ul></li></ul><h3 id="Redis-Token-实现登录认证"><a href="#Redis-Token-实现登录认证" class="headerlink" title="Redis+Token 实现登录认证"></a>Redis+Token 实现登录认证</h3><ul><li>优点<ul><li><strong>灵活性高</strong>：可以根据业务需求在 Redis 中存储各种与用户相关的信息，如用户的登录状态、权限信息、过期时间等，方便对用户进行管理和控制。可以随时根据需要修改或删除 Redis 中的数据，实现对 Token 的灵活管理，例如主动使某个 Token 失效，实现用户的强制下线等功能。</li><li><strong>安全性较高</strong>：Token 可以是随机生成的字符串，具有较高的随机性和复杂性，不容易被猜测或伪造。同时，由于 Token 的状态存储在 Redis 中，服务器可以对 Token 进行实时验证和更新，减少了因 Token 泄露而导致的安全风险。</li><li><strong>适合分布式系统</strong>：Redis 是分布式内存数据库，能在多个服务器之间共享用户的登录状态和 Token 信息，适合用于分布式系统和微服务架构中，保证在不同节点上对用户身份认证的一致性。</li></ul></li><li>缺点<ul><li><strong>增加服务器负载</strong>：Redis 需要占用服务器的内存资源来存储 Token 和用户信息，如果用户量较大，可能会导致内存占用过高，增加服务器的负担。此外，每次认证都需要与 Redis 进行交互，查询 Token 的有效性，这也会增加一定的性能开销。</li><li><strong>依赖 Redis 稳定性</strong>：系统的稳定性和可靠性依赖于 Redis 的稳定性和可用性。如果 Redis 出现故障或宕机，可能会导致用户无法正常登录或认证失败，需要采取相应的容错和备份措施来保证系统的高可用性。</li><li><strong>跨域复杂性</strong>：在跨域场景下，需要处理好 Token 在不同域名之间的传递和验证问题，相对来说比 JWT 复杂一些。可能需要通过设置合适的 CORS（跨域资源共享）策略或采用其他技术来实现跨域认证。</li></ul></li></ul><p><img src="/.com//image-20250424141221460.png" alt="image-20250424141221460"></p><ul><li>使用hash存储来实现Redis+Token</li></ul><p><img src="/.com//image-20250424182155131.png" alt="image-20250424182155131"></p><p><img src="/.com//image-20250424182129146.png" alt="image-20250424182129146"></p><ul><li>业务代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(String phone, HttpSession session)</span> &#123;<br>        <span class="hljs-comment">//校验手机号</span><br>        <span class="hljs-keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;<span class="hljs-comment">//如果不符合返回错误消息</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//符合，生成验证码</span><br>        String code= RandomUtil.randomNumbers(<span class="hljs-number">6</span>);<br>        <span class="hljs-comment">//保存到redis</span><br>        redisTemplate.opsForValue().set(RedisConstants.LOGIN_CODE_KEY +phone,code,<span class="hljs-number">2</span>, TimeUnit.MINUTES);<br>        <span class="hljs-comment">//发送验证码</span><br>        <span class="hljs-comment">//阿里云短信服务</span><br>        log.debug(<span class="hljs-string">&quot;发送短信验证码成功:&#123;&#125;&quot;</span>,code);<br>        <span class="hljs-comment">//返回ok</span><br>        <span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>        <span class="hljs-comment">//校验</span><br>        String phone=loginForm.getPhone();<br>        <span class="hljs-keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;<span class="hljs-comment">//如果不符合返回错误消息</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(RedisConstants.LOGIN_CODE_KEY + phone);<br>        String code=loginForm.getCode();<br>        <span class="hljs-keyword">if</span> (cacheCode==<span class="hljs-literal">null</span>||!cacheCode.toString().equals(code))&#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码w&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//查询是否有用户-使用mybatis-plus</span><br>        User user=query().eq(<span class="hljs-string">&quot;phone&quot;</span>,phone).one();<br>        <span class="hljs-comment">//如果没有用户，进行注册，并且保存到数据库回显id</span><br>        <span class="hljs-keyword">if</span>(user==<span class="hljs-literal">null</span>)&#123;<br>            user=createUserWithPhone(phone);<br>        &#125;<br>        <span class="hljs-comment">//生成token,作为登录令牌</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//将user对象转为Hash存储</span><br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);<br>        Map&lt;String,Object&gt; userMap= BeanUtil.beanToMap(userDTO);<span class="hljs-comment">//创建了新的对象 -改变map不会改变DTO</span><br>        <span class="hljs-comment">//存入redis</span><br>redisTemplate.opsForHash().putAll(RedisConstants.LOGIN_USER_KEY+token,userMap);<br>        <span class="hljs-comment">//设置有效期</span><br>        redisTemplate.expire(RedisConstants.LOGIN_USER_KEY+token,<span class="hljs-number">30</span>,TimeUnit.MINUTES);<br>        <span class="hljs-comment">//返回token</span><br>        <span class="hljs-keyword">return</span> Result.ok(token);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> User <span class="hljs-title function_">createUserWithPhone</span><span class="hljs-params">(String phone)</span>&#123;<br>        <span class="hljs-keyword">return</span> User.builder()<br>                .nickName(USER_NICK_NAME_PREFIX+RandomUtil.randomString(<span class="hljs-number">10</span>))<br>                .phone(phone)<br>                .build();<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>双拦截器实现redis数据的过期时间刷新</li></ul><p><img src="/.com//image-20250424182357651.png" alt="image-20250424182357651"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefreshTokenInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">// TODO 获取请求头中的token</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>);<br>        <span class="hljs-keyword">if</span>(StrUtil.isBlank(token))&#123;<span class="hljs-comment">//无token</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// TODO 拿到UserDTO并且转化为User对象</span><br>        Map&lt;String,Object&gt; userMap = redisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token);<br>       <span class="hljs-keyword">if</span> (userMap.isEmpty()|| userMap==<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>       &#125;<br>         <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(), <span class="hljs-literal">false</span>);<br>         UserHolder.saveUser(userDTO);<br>        <span class="hljs-comment">// TODO 刷新redis缓存的有效期</span><br>        redisTemplate.expire(RedisConstants.LOGIN_USER_KEY+token,<span class="hljs-number">30</span>, TimeUnit.MINUTES);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>   <span class="hljs-keyword">if</span>(UserHolder.getUser()==<span class="hljs-literal">null</span>)&#123;<br>       response.setStatus(<span class="hljs-number">401</span>);<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        UserHolder.removeUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginInterceptor loginInterceptor;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RefreshTokenInterceptor refreshTokenInterceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(loginInterceptor).excludePathPatterns(<br>                <span class="hljs-string">&quot;/user/code&quot;</span>,<br>                <span class="hljs-string">&quot;/user/login&quot;</span>,<br>                <span class="hljs-string">&quot;/blog/hot&quot;</span>,<br>                <span class="hljs-string">&quot;/shop/**&quot;</span>,<br>                <span class="hljs-string">&quot;/shop-type/**&quot;</span>,<br>                <span class="hljs-string">&quot;/upload/**&quot;</span>,<br>                <span class="hljs-string">&quot;/voucher/**&quot;</span><br>        ).order(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//token刷新拦截器</span><br>        registry.addInterceptor(refreshTokenInterceptor).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).order(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>order越小执行优先级越高</li></ul><h2 id="3-商户查询缓存"><a href="#3-商户查询缓存" class="headerlink" title="3.商户查询缓存"></a>3.商户查询缓存</h2><h3 id="1-店铺查询"><a href="#1-店铺查询" class="headerlink" title="1.店铺查询"></a>1.店铺查询</h3><ul><li>string</li></ul><p><img src="/.com//image-20250424192842273.png" alt="image-20250424192842273"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate; <br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryById</span><span class="hljs-params">(Long id)</span> &#123;<br>        String key= RedisConstants.CACHE_SHOP_KEY+id;<br>        <span class="hljs-comment">//从redis查询商铺缓存</span><br>       String shopJson=(String) redisTemplate.opsForValue().get(key);<br>        <span class="hljs-comment">//判断是否存在，若存在直接返回</span><br>        <span class="hljs-keyword">if</span>(StrUtil.isNotBlank(shopJson))&#123;<br>            Shop shop= JSONUtil.toBean(shopJson,Shop.class);<br>            <span class="hljs-keyword">return</span> Result.ok(shop);<br>        &#125;<br>        <span class="hljs-comment">//不存在，查询数据库（MybatisPlus），写入缓存</span><br>        Shop shop=getById(id);<br>        <span class="hljs-comment">//返回数据</span><br>        <span class="hljs-keyword">if</span>(shop==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>  Result.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);<br>        &#125;<br>        redisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop));<br>        <span class="hljs-keyword">return</span> Result.ok(shop);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2-店铺类型查询"><a href="#2-店铺类型查询" class="headerlink" title="2.店铺类型查询"></a>2.店铺类型查询</h3><ul><li><p>查询所有的店铺类型</p></li><li><p>list</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注入redis模板类</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br>    <span class="hljs-comment">//注入mapper</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ShopTypeMapper shopTypeMapper;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;ShopType&gt; <span class="hljs-title function_">getAllType</span><span class="hljs-params">()</span> &#123;<br>        String key= RedisConstants.CACHE_SHOP_TYPE_KEY;<br>        List&lt;ShopType&gt; typeList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//1.查询缓存</span><br>        <span class="hljs-keyword">if</span>(redisTemplate.hasKey(key))&#123;<br>            <span class="hljs-comment">//2.存在，封装，返回</span><br>           typeList = redisTemplate.opsForList().range(key, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>           <span class="hljs-keyword">if</span>(!typeList.isEmpty()&amp;&amp;typeList!=<span class="hljs-literal">null</span>)&#123;<br>               typeList.sort(Comparator.comparingInt(ShopType::getSort));<br>               System.out.println(<span class="hljs-string">&quot;从Redis查数据&quot;</span>);<br>               <span class="hljs-keyword">return</span> typeList;<br>           &#125;<br>        &#125;<br>        <span class="hljs-comment">//3.不存在，查询数据库，返回</span><br>        typeList=query().orderByAsc(<span class="hljs-string">&quot;sort&quot;</span>).list();<br>        System.out.println(<span class="hljs-string">&quot;从数据库查数据&quot;</span>);<br>        <span class="hljs-keyword">if</span>(typeList==<span class="hljs-literal">null</span>||typeList.isEmpty())&#123;<br><span class="hljs-comment">//            return Result.fail(&quot;查询失败，无数据&quot;);</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> ;<br>        &#125;<br>        redisTemplate.opsForList().rightPushAll(key,typeList);<br>        <span class="hljs-keyword">return</span> typeList;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-查询商铺缓存主动更新策略"><a href="#3-查询商铺缓存主动更新策略" class="headerlink" title="3.查询商铺缓存主动更新策略"></a>3.查询商铺缓存主动更新策略</h3><ul><li>修改时，先操作数据库，在删除缓存</li></ul><p><img src="/.com//image-20250428205952682.png" alt="image-20250428205952682"></p><h3 id="4-缓存穿透的解决"><a href="#4-缓存穿透的解决" class="headerlink" title="4.缓存穿透的解决"></a>4.缓存穿透的解决</h3><ul><li>目的：解决空数据的穿透访问</li><li>方案一：存入空数据至缓存，设置TTL</li><li><img src="/.com//image-20250428210431830.png" alt="image-20250428210431830"></li></ul><p><img src="/.com//image-20250428210222791.png" alt="image-20250428210222791"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">     <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryById</span><span class="hljs-params">(Long id)</span> &#123;<br>        String key= RedisConstants.CACHE_SHOP_KEY+id;<br>        <span class="hljs-comment">//从redis查询商铺缓存</span><br>       String shopJson=(String) redisTemplate.opsForValue().get(key);<br>        <span class="hljs-comment">//判断是否存在，若存在直接返回 &quot; &quot;/null =false</span><br>        <span class="hljs-keyword">if</span>(StrUtil.isNotBlank(shopJson))&#123;<br>            Shop shop= JSONUtil.toBean(shopJson,Shop.class);<br>            <span class="hljs-keyword">return</span> Result.ok(shop);<br>        &#125;<br>        <span class="hljs-comment">//命中的是空值，返回错误信息 </span><br>        <span class="hljs-keyword">if</span>(shopJson!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//返回错误信息</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺信息不存在！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//不存在，查询数据库，写入缓存</span><br>        Shop shop=getById(id);<br>        <span class="hljs-comment">//返回数据</span><br>        <span class="hljs-keyword">if</span>(shop==<span class="hljs-literal">null</span>)&#123;<br>            redisTemplate.opsForValue().set(key,<span class="hljs-string">&#x27; &#x27;</span>,RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES);<br>            <span class="hljs-keyword">return</span>  Result.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);<br>        &#125;<br>        redisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);<br>        <span class="hljs-keyword">return</span> Result.ok(shop);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li><p>**<code>isBlank</code>**：若字符序列为空（<code>null</code> 或者长度为 0）或者仅包含空白字符，返回 <code>true</code>；反之返回 <code>false</code>。</p></li><li><p>**<code>isNotBlank</code>**：若字符序列不为空且包含至少一个非空白字符，返回 <code>true</code>；反之返回 <code>false</code>。</p></li><li><p>方案二：布隆过滤器</p></li></ul><p><img src="/.com//image-20250428210348658.png" alt="image-20250428210348658"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//布隆过滤器实现方案</span><br><br></code></pre></td></tr></table></figure><h3 id="5-缓存雪崩的解决"><a href="#5-缓存雪崩的解决" class="headerlink" title="5.缓存雪崩的解决"></a>5.缓存雪崩的解决</h3><ul><li><strong>缓存雪崩</strong>是指同一时间大量的缓存key同时失效或者Redis服务宕机，导致<strong>大量的请求到达数据库</strong>，带来巨大的压力。</li></ul><p><img src="/.com//image-20250428211228045.png" alt="image-20250428211228045"></p><ul><li><strong>解决方案</strong><ul><li>给不同的key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性-主从哨兵</li><li>给缓存业务添加限流策略</li><li>给业务添加多级缓存</li></ul></li></ul><h3 id="6-缓存击穿的解决"><a href="#6-缓存击穿的解决" class="headerlink" title="6.缓存击穿的解决"></a>6.缓存击穿的解决</h3><ul><li>也称热点击穿，热点数据的key失效，同时大量的请求对热点数据进行访问，对数据库造成巨大压力</li><li>解决方法：<ul><li>互斥锁-setnx</li><li>逻辑过期时间，以前的旧数据作为兜底数据</li></ul></li></ul><h4 id="1-互斥锁"><a href="#1-互斥锁" class="headerlink" title="1.互斥锁"></a>1.互斥锁</h4><p><img src="/.com//image-20250428213404232.png" alt="image-20250428213404232"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryById</span><span class="hljs-params">(Long id)</span> &#123;<br>     <span class="hljs-comment">//互斥锁-解决缓存击穿</span><br>      <span class="hljs-comment">//竞争互斥锁-创建缓存数据</span><br>      <span class="hljs-comment">//获取锁-失败延时重试</span><br>      <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> queryWithLock(id);<br>      <span class="hljs-keyword">if</span>(shop==<span class="hljs-literal">null</span>)&#123;<br>          <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在！&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">return</span> Result.ok(shop);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> Shop <span class="hljs-title function_">queryWithLock</span><span class="hljs-params">(Long id)</span>&#123;<br>      String key= RedisConstants.CACHE_SHOP_KEY+id;<br>      Shop shop;<br>      <span class="hljs-comment">//使用空值缓存解决缓存穿透</span><br>      String shopJson=(String) redisTemplate.opsForValue().get(key);<br>      <span class="hljs-comment">//判断是否存在，若存在直接返回-命中</span><br>      <span class="hljs-keyword">if</span>(StrUtil.isNotBlank(shopJson))&#123;<br>           shop= JSONUtil.toBean(shopJson,Shop.class);<br>          <span class="hljs-keyword">return</span> shop;<br>      &#125;<br>      <span class="hljs-comment">//命中的是空值，返回错误信息-命中空值</span><br>      <span class="hljs-keyword">if</span>(shopJson!=<span class="hljs-literal">null</span>)&#123;<br>          <span class="hljs-comment">//返回错误信息</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      &#125;<br>      <span class="hljs-comment">//不存在，查询数据库，写入缓存 -未命中</span><br>      <span class="hljs-comment">//互斥锁实现缓存重建</span><br>      Boolean lock=tryLock(RedisConstants.LOCK_SHOP_KEY+id);<br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">if</span>(BooleanUtil.isFalse(lock))&#123;<br>              <span class="hljs-comment">//获取失败-延时重试</span><br>                 Thread.sleep(<span class="hljs-number">50</span>);<br>                 <span class="hljs-keyword">return</span> queryWithLock(id);<br>          &#125;<br>          shop = getById(id);<br>          <span class="hljs-comment">//模拟延时 -高并发测试</span><br>          Thread.sleep(<span class="hljs-number">200</span>);<br>          <span class="hljs-comment">//返回数据</span><br>          <span class="hljs-keyword">if</span>(shop==<span class="hljs-literal">null</span>)&#123; <span class="hljs-comment">//数据库 -未命中，把空值写入缓存</span><br>              redisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES);<br>              <span class="hljs-keyword">return</span>  <span class="hljs-literal">null</span>;<br>          &#125;<br>          redisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">//释放锁</span><br>          <span class="hljs-keyword">if</span>(BooleanUtil.isTrue(lock))&#123;<br>              unlock(RedisConstants.LOCK_SHOP_KEY+id);<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> shop;<br>  &#125;<br>  <span class="hljs-comment">//获取锁</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span>&#123;<br>      Boolean flag=redisTemplate.opsForValue().setIfAbsent(key,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-number">10</span>,TimeUnit.SECONDS);<br>      <span class="hljs-keyword">return</span> BooleanUtil.isTrue(flag);<span class="hljs-comment">//由于Boolean的自动装箱机制，null值会出现空指针异常</span><br>  &#125;<br><br>  <span class="hljs-comment">//释放锁</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span>&#123;<br>      redisTemplate.delete(key);<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="2-逻辑过期"><a href="#2-逻辑过期" class="headerlink" title="2.逻辑过期"></a>2.逻辑过期</h4><p><img src="/.com//image-20250429143737383.png" alt="image-20250429143737383"></p><ul><li>需要预存带有过期时间的热点数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryById</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-comment">//互斥锁-解决缓存击穿</span><br>        <span class="hljs-comment">//竞争互斥锁-创建缓存数据</span><br>        <span class="hljs-comment">//获取锁-失败延时重试</span><br><span class="hljs-comment">//        Shop shop = queryWithLock(id);</span><br>        <span class="hljs-comment">//逻辑过期时间-过期数据兜底</span><br>        Shop shop=queryWithExpire(id);<br>        <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在！&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Result.ok(shop);<br>    &#125;<br><span class="hljs-comment">//10个线程的线程池</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">CACHE_REBUILD_EXECUTOR</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-comment">//逻辑过期</span><br>    <span class="hljs-keyword">private</span> Shop <span class="hljs-title function_">queryWithExpire</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-comment">//查询缓存</span><br>        Shop shop;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;<br>        RedisData shopRedisData;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> (String) redisTemplate.opsForValue().get(key);<br>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(shopJson)) &#123;<span class="hljs-comment">//null/未初始化/“ ”</span><br>            <span class="hljs-comment">//未命中-返回</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//缓存命中-未过期，直接返回</span><br>        shopRedisData = JSONUtil.toBean(shopJson, RedisData.class);<br>        <span class="hljs-comment">//缓存的数据</span><br>        shop = JSONUtil.toBean((JSONObject) shopRedisData.getData(), Shop.class);<br>        <span class="hljs-keyword">if</span> (shopRedisData.getExpireTime().isAfter(LocalDateTime.now())) &#123;<br>            <span class="hljs-keyword">return</span> shop;<br>        &#125;<br>        <span class="hljs-comment">//缓存命中-过期</span><br>        <span class="hljs-comment">//缓存重建</span><br>        <span class="hljs-comment">//获取锁</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> tryLock(RedisConstants.LOCK_SHOP_KEY + id);<br>        <span class="hljs-comment">//获取锁成功-开启独立线程，实现缓存重建</span><br>        <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(lock)) &#123;<br>            CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//创建缓存</span><br>                    <span class="hljs-built_in">this</span>.buildCache(id);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">//释放锁</span><br>                    unlock(RedisConstants.LOCK_SHOP_KEY + id);<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">//获取锁失败-直接返回过期数据兜底</span><br>        <span class="hljs-keyword">return</span> shop;<br><br>    &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildCache</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    Shop shopCache=getById(id);<br>    <span class="hljs-comment">//休眠-模拟高并发的延迟</span><br>    Thread.sleep(<span class="hljs-number">200</span>);<br>    RedisData redisData=<span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisData</span>();<br>    redisData.setData(shopCache);<br>    redisData.setExpireTime(LocalDateTime.now().plusSeconds(RedisConstants.CACHE_SHOP_TTL));<br>    redisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(redisData));<br><br>&#125;<br><br>    <span class="hljs-comment">//获取锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().setIfAbsent(key, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> BooleanUtil.isTrue(flag);<span class="hljs-comment">//由于Boolean的自动装箱机制，null值会出现空指针异常</span><br>    &#125;<br><br>    <span class="hljs-comment">//释放锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span> &#123;<br>        redisTemplate.delete(key);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="4-优惠卷秒杀"><a href="#4-优惠卷秒杀" class="headerlink" title="4.优惠卷秒杀"></a>4.优惠卷秒杀</h2><h4 id="1-全局唯一Id"><a href="#1-全局唯一Id" class="headerlink" title="1.全局唯一Id"></a>1.全局唯一Id</h4><ul><li><p><strong>UUID</strong></p><ul><li><strong>全球唯一性</strong>：具有极高的唯一性，几乎不可能出现重复。</li><li><strong>无意义性</strong>：UUID 是随机生成的，不包含任何有意义的信息，无法通过 ID 直接了解其生成的上下文或相关业务信息。</li><li><strong>平台独立性</strong>：可以在不同的操作系统、编程语言和数据库系统中使用，具有良好的兼容性。</li><li><strong>长度较长</strong>：32 位的十六进制表示形式，占用空间较大，在存储和传输时可能会带来一定的性能开销。</li></ul></li><li><p><strong>雪花算法</strong></p><ul><li><p><strong>有序性</strong>：由于包含时间戳信息，生成的 ID 在一定程度上是有序的，这对于一些需要按时间顺序处理数据的场景非常有用。</p></li><li><p><strong>高性能</strong>：生成速度快，能够满足高并发场景下的 ID 生成需求。</p></li><li><p><strong>可定制性</strong>：可以根据实际需求对算法中的工作机器 ID、序列号等部分进行定制，以适应不同的业务场景。</p></li><li><p><strong>局部唯一性</strong>：在分布式系统中，如果不同的节点在同一毫秒内生成 ID，可能会出现重复的情况，但通过合理分配工作机器 ID 和序列号，可以保证在整个系统中的唯一性。</p></li><li><p><strong>组成</strong>：符号位1bit,时间戳41bit,数据中心ID部分5bit,机器Id部分5bit，序列号部分12bit。  -时间戳以毫秒为单位可以使用69年。</p></li><li><p>使用hutool工具包的雪花算法：</p><ul><li><pre><code class="java">// 创建 Snowflake 实例，需要传入数据中心 ID 和机器 ID        // 数据中心 ID 和机器 ID 的范围是 0 - 31        Snowflake snowflake = IdUtil.createSnowflake(1, 1);        // 生成唯一 ID        long id = snowflake.nextId();         // 也可以直接使用静态方法生成 ID，默认使用 0 作为数据中心 ID 和机器 ID        long defaultId = IdUtil.getSnowflakeNextId();<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>- 手动实现雪花算法：<br><br>  - ~~~java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SnowflakeIdGenerator</span> &#123;<br>        <span class="hljs-comment">// 起始时间戳，这里以 2020-01-01 00:00:00 为例</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">startTimeStamp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1577836800000L</span>;<br>    <br>        <span class="hljs-comment">// 数据中心 ID 所占位数</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">dataCenterIdBits</span> <span class="hljs-operator">=</span> <span class="hljs-number">5L</span>;<br>        <span class="hljs-comment">// 机器 ID 所占位数</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">workerIdBits</span> <span class="hljs-operator">=</span> <span class="hljs-number">5L</span>;<br>        <span class="hljs-comment">// 序列号所占位数</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">sequenceBits</span> <span class="hljs-operator">=</span> <span class="hljs-number">12L</span>;<br>    <br>        <span class="hljs-comment">// 数据中心 ID 最大值</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">maxDataCenterId</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; dataCenterIdBits);<br>        <span class="hljs-comment">// 机器 ID 最大值</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">maxWorkerId</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; workerIdBits);<br>        <span class="hljs-comment">// 序列号最大值</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">sequenceMask</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; sequenceBits);<br>    <br>        <span class="hljs-comment">// 机器 ID 向左移位数</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">workerIdShift</span> <span class="hljs-operator">=</span> sequenceBits;<br>        <span class="hljs-comment">// 数据中心 ID 向左移位数</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">dataCenterIdShift</span> <span class="hljs-operator">=</span> sequenceBits + workerIdBits;<br>        <span class="hljs-comment">// 时间戳向左移位数</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">timestampLeftShift</span> <span class="hljs-operator">=</span> sequenceBits + workerIdBits + dataCenterIdBits;<br>    <br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> dataCenterId;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> workerId;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">sequence</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastTimestamp</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1L</span>;<br>    <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">SnowflakeIdGenerator</span><span class="hljs-params">(<span class="hljs-type">long</span> dataCenterId, <span class="hljs-type">long</span> workerId)</span> &#123;<br>            <span class="hljs-keyword">if</span> (dataCenterId &gt; maxDataCenterId || dataCenterId &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;数据中心 ID 不能大于 &quot;</span> + maxDataCenterId + <span class="hljs-string">&quot; 且不能小于 0&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;机器 ID 不能大于 &quot;</span> + maxWorkerId + <span class="hljs-string">&quot; 且不能小于 0&quot;</span>);<br>            &#125;<br>            <span class="hljs-built_in">this</span>.dataCenterId = dataCenterId;<br>            <span class="hljs-built_in">this</span>.workerId = workerId;<br>        &#125;<br>    <span class="hljs-comment">//获取Id</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">currentTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <br>            <span class="hljs-keyword">if</span> (currentTimestamp &lt; lastTimestamp) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;时钟回退不能生成时间戳 &quot;</span> + (lastTimestamp - currentTimestamp) + <span class="hljs-string">&quot; 毫秒&quot;</span>);<br>            &#125;<br>    <br>            <span class="hljs-keyword">if</span> (currentTimestamp == lastTimestamp) &#123;<br>                sequence = (sequence + <span class="hljs-number">1</span>) &amp; sequenceMask;<br>                <span class="hljs-keyword">if</span> (sequence == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 当前毫秒内序列号用完，等待下一毫秒</span><br>                    currentTimestamp = waitNextMillis(lastTimestamp);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 不同毫秒，序列号重置为 0</span><br>                sequence = <span class="hljs-number">0L</span>;<br>            &#125;<br>    <br>            lastTimestamp = currentTimestamp;<br>    <span class="hljs-comment">//左移拼接Id</span><br>            <span class="hljs-keyword">return</span> ((currentTimestamp - startTimeStamp) &lt;&lt; timestampLeftShift) |<br>                    (dataCenterId &lt;&lt; dataCenterIdShift) |<br>                    (workerId &lt;&lt; workerIdShift) |<br>                    sequence;<br>        &#125;<br>    <span class="hljs-comment">//等待到下一个毫秒时刻</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">waitNextMillis</span><span class="hljs-params">(<span class="hljs-type">long</span> lastTimestamp)</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            <span class="hljs-keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;<br>                timestamp = System.currentTimeMillis();<br>            &#125;<br>            <span class="hljs-keyword">return</span> timestamp;<br>        &#125;<br>    <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>            <span class="hljs-type">SnowflakeIdGenerator</span> <span class="hljs-variable">idGenerator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SnowflakeIdGenerator</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                System.out.println(idGenerator.nextId());<br>            &#125;<br>        &#125;<br>    &#125;    <br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul><p><img src="/.com//image-20250429213248213.png" alt="image-20250429213248213"></p><ul><li><strong>Redis实现全局Id</strong></li></ul><p><img src="/.com//image-20250429213502422.png" alt="image-20250429213502422"></p><ul><li>创建生成全局唯一Id的工具类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdWorker</span> &#123;<br>    <br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringRedisTemplate redisTemplate;<br><br>    <span class="hljs-comment">//2025-01-01:00:00:00 对应的时间戳（以秒为单位）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Long BEGIN_TIMESTAMP=<span class="hljs-number">1672531200L</span>;<br>    <span class="hljs-comment">//时间戳左移位数(序列号位数)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> COUNT_BITS=<span class="hljs-number">32</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title function_">nextId</span><span class="hljs-params">(String keyPrefix)</span>&#123;<br>        <span class="hljs-comment">//1.计算时间戳 -31 位</span><br>        LocalDateTime now=LocalDateTime.now();<br>        <span class="hljs-comment">//当前时刻对应的时间戳</span><br>        <span class="hljs-type">long</span> nowSecond= now.toEpochSecond(ZoneOffset.UTC);<br>        <span class="hljs-type">long</span> timestamp=nowSecond-BEGIN_TIMESTAMP;<br>        <span class="hljs-comment">//2.生产序列号 -32 位</span><br>        <span class="hljs-comment">//2.1获取当前日期，精确到天</span><br>        String date= LocalDate.now().format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy:MM:dd&quot;</span>));<br>        <span class="hljs-comment">//2.2自增长 获取32位的序列号</span><br>        <span class="hljs-type">long</span> count=redisTemplate.opsForValue().increment(<span class="hljs-string">&quot;irc:&quot;</span>+keyPrefix+<span class="hljs-string">&quot;:&quot;</span>+date);<br>        <span class="hljs-comment">//3.拼接Id (左移+或运算)</span><br>        <span class="hljs-keyword">return</span> timestamp&lt;&lt;COUNT_BITS |count;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-实现优惠卷秒杀下单"><a href="#2-实现优惠卷秒杀下单" class="headerlink" title="2.实现优惠卷秒杀下单"></a>2.实现优惠卷秒杀下单</h4><p><img src="/.com//image-20250503161448380.png" alt="image-20250503161448380"></p><blockquote><ul><li>基本的下单</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-meta">@Override</span><br>   <span class="hljs-meta">@Transactional</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>       <span class="hljs-comment">//根据id抢购秒杀劵</span><br>       <span class="hljs-comment">//1.秒杀劵有效性判断（时间、库存）</span><br>       <span class="hljs-comment">//1.1查询优惠卷</span><br>       <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">voucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getById(voucherId);<br>       <span class="hljs-comment">//1.2判断时效性</span><br>       <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>       <span class="hljs-keyword">if</span> (voucher.getBeginTime().isAfter(now)) &#123;<br>           <span class="hljs-comment">//未开始</span><br>           <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始&quot;</span>);<br>       &#125;<br>       <span class="hljs-keyword">if</span> (voucher.getEndTime().isBefore(now)) &#123;<br>           <span class="hljs-comment">//秒杀已经结束</span><br>           <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束&quot;</span>);<br>       &#125;<br>       <span class="hljs-comment">//1.3判断库存是否充足</span><br>       <span class="hljs-type">Integer</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> voucher.getStock();<br>       <span class="hljs-keyword">if</span> (stock&lt;<span class="hljs-number">1</span>)&#123;<br>           <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>       &#125;<br>       <span class="hljs-comment">//2.扣减库存、创建订单-回显id</span><br>       <span class="hljs-comment">//2.1扣减库存</span><br>       <span class="hljs-type">boolean</span> success=seckillVoucherService.update()<br>               .setSql(<span class="hljs-string">&quot;stock=stock-1&quot;</span>)<br>               .eq(<span class="hljs-string">&quot;vocher_id&quot;</span>,voucherId).update();<br>       <span class="hljs-keyword">if</span>(!success)&#123;<br>           <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>       &#125;<br>       <span class="hljs-comment">//2.2创建订单</span><br>       <span class="hljs-type">long</span> orderId= IdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>       VoucherOrder voucherOrder=VoucherOrder.builder()<br>               .id(orderId)<br>               .voucherId(voucherId)<br>               .userId(UserHolder.getUser().getId())<br>               .build();<br>       save(voucherOrder);<br>       <span class="hljs-keyword">return</span> Result.ok();<br>   &#125;<br></code></pre></td></tr></table></figure></blockquote><ul><li>超卖问题：经200线程并发，库存变为-9</li></ul><h4 id="3-超卖问题"><a href="#3-超卖问题" class="headerlink" title="3.超卖问题"></a>3.超卖问题</h4><ul><li>解决方法：加乐观锁</li></ul><p><img src="/.com//image-20250503175323781.png" alt="image-20250503175323781"></p><ul><li><p>版本号法，添加版本号字段，先查并且对比版本号是否改变，改变则进行不执</p></li><li><p>CAS法：</p><p><img src="/.com//image-20250503175757538.png" alt="image-20250503175757538"></p><ul><li><p>解决了超卖问题，但是交易的成功率太低</p></li><li><p>把库存&#x3D;查到的库存改为，库存大于0。</p></li><li><p>确保交易成功</p></li></ul></li></ul><h4 id="4-一人一单"><a href="#4-一人一单" class="headerlink" title="4.一人一单"></a>4.一人一单</h4><h5 id="4-1单体模式下"><a href="#4-1单体模式下" class="headerlink" title="4.1单体模式下"></a>4.1单体模式下</h5><ul><li>悲观锁实现一人一单</li></ul><p><img src="/.com//image-20250503183152887.png" alt="image-20250503183152887"></p><ul><li><p>在扣减库存之前，检测用户是否已经下单</p></li><li><p>多线程并发情况下出现一人多单</p></li><li><p>给查询操作加锁</p><ul><li>加悲观锁在下单操作外面。</li></ul></li><li><p><strong>事务有效性</strong>：必须由Spring的代理对象来执行**@Transactional**注解标注的方法</p></li><li><p>使用<strong>AopContext.currentProxy()<strong>获取当前对象的</strong>Spring代理对象</strong>，执行当前对象的其他含有事务的方法。</p><ul><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>启动类开启暴露代理对象**@EnableAspectJAutoProxy(exposeProxy &#x3D; true)&#x2F;&#x2F;暴露代理对象**</p></li><li><pre><code class="java"> @Autowired    private IdWorker idWorker;    @Override    public Result seckillVoucher(Long voucherId) &#123;        //根据id抢购秒杀劵        //1.秒杀劵有效性判断（时间、库存）        //1.1查询优惠卷        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);        //1.2判断时效性        LocalDateTime now = LocalDateTime.now();        if (voucher.getBeginTime().isAfter(now)) &#123;            //未开始            return Result.fail(&quot;秒杀尚未开始&quot;);        &#125;        if (voucher.getEndTime().isBefore(now)) &#123;            //秒杀已经结束            return Result.fail(&quot;秒杀已经结束&quot;);        &#125;        //1.3判断库存是否充足        Integer stock = voucher.getStock();        if (stock&lt;1)&#123;            return Result.fail(&quot;库存不足&quot;);        &#125;        Long userId=UserHolder.getUser().getId();        synchronized (userId.toString().intern()) &#123;//锁该字符串对应的字符串常量池的字符串引用            //2.扣减库存、创建订单-回显id            //1.获取代理对象-需要确保线程的安全性 2.引入依赖aspectjweaver 3.启动类开启暴露代理对象            IVoucherOrderService proxy =(IVoucherOrderService) AopContext.currentProxy();            return proxy.creatOrder(userId,voucherId);        &#125;    &#125;      //事务必须时spring的代理对象执行方法才能有效    @Transactional    @Override    public Result creatOrder(Long userId, Long voucherId) &#123;        int count= query().eq(&quot;user_id&quot;,userId).eq(&quot;voucher_id&quot;,voucherId).count();        if(count&gt;0)&#123;            //用户已经买过一单            return Result.fail(&quot;用户已经买过一单&quot;);        &#125;        //2.1扣减库存        boolean success=seckillVoucherService.update()                .setSql(&quot;stock=stock-1&quot;)                .gt(&quot;stock&quot;,0)                .eq(&quot;voucher_id&quot;,voucherId).update();        if(!success)&#123;            return Result.fail(&quot;库存不足&quot;);        &#125;        //2.2创建订单          long orderId= idWorker.nextId(&quot;order&quot;);        VoucherOrder voucherOrder=VoucherOrder.builder()                .id(orderId)                .voucherId(voucherId)                .userId(userId)                .build();        save(voucherOrder);        return Result.ok(orderId);    &#125;<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>##### <span class="hljs-number">4.2</span>集群模式下<br><br>- 集群模式下，**<span class="hljs-keyword">synchronized</span>**存在（JVM内存局限性）并发安全问题<br><br>![image<span class="hljs-number">-20250503200133634</span>](hm点评.assets/image<span class="hljs-number">-20250503200133634.</span>png)<br><br>- 使用分布式锁解决<br><br>#### <span class="hljs-number">5.</span>分布式锁<br><br>##### <span class="hljs-number">5.1</span>基于互斥命令实现<br><br>![image<span class="hljs-number">-20250503201857629</span>](hm点评.assets/image<span class="hljs-number">-20250503201857629.</span>png)<br><br>![image<span class="hljs-number">-20250503203036511</span>](hm点评.assets/image<span class="hljs-number">-20250503203036511.</span>png)<br><br>![image<span class="hljs-number">-20250503204056073</span>](hm点评.assets/image<span class="hljs-number">-20250503204056073.</span>png)<br><br>~~~java<br>@AllArgsConstructor<br>@Data<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRedisLock</span> implements ILock &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> KEY_PREFIX = <span class="hljs-string">&quot;lock:&quot;</span>;<br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param timeoutSec</span><br><span class="hljs-comment">     * @return</span><br><span class="hljs-comment">     */</span><br>    @<span class="hljs-function">Override</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> </span>&#123;<br>        <span class="hljs-comment">//获取线程Id</span><br>        Long ThreadId = Thread.<span class="hljs-built_in">currentThread</span>().<span class="hljs-built_in">getId</span>();<br>        <span class="hljs-comment">//获取锁</span><br>        Boolean success = redisTemplate.<span class="hljs-built_in">opsForValue</span>().<span class="hljs-built_in">setIfAbsent</span>(KEY_PREFIX + name, ThreadId.<span class="hljs-built_in">toString</span>(), timeoutSec, TimeUnit.SECONDS);<br><span class="hljs-comment">//       return success; 自动拆箱存在空指针风险</span><br>        <span class="hljs-keyword">return</span> Boolean.TRUE.<span class="hljs-built_in">equals</span>(success);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放锁</span><br><span class="hljs-comment">     */</span><br>    @<span class="hljs-function">Override</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        redisTemplate.<span class="hljs-built_in">delete</span>(KEY_PREFIX + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>在同一个业务下（key相同），如果1线程的业务阻塞，锁超时释放，2线程获取锁，开始执行业务，此时1线程完成业务释放锁，释放的是2线程的锁，此时线程3又可以获取锁。。。。</p></li><li><p>存在<strong>锁超时误删锁</strong>的问题</p><p><img src="/.com//image-20250504132212458.png" alt="image-20250504132212458"></p><ul><li><p>解决方法：</p><ul><li>获取锁的时候存入线程标识（UUID拼接线程ID）</li><li>释放锁的时候先对比线程标识，再释放</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ID_PREFIX= UUID.randomUUID().toString(<span class="hljs-literal">true</span>)+<span class="hljs-string">&quot;-&quot;</span>;<br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeoutSec</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>        <span class="hljs-comment">//获取线程Id</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">ThreadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        <span class="hljs-comment">//获取锁</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, ID_PREFIX+ThreadId, timeoutSec, TimeUnit.SECONDS);<br><span class="hljs-comment">//       return success; 自动拆箱存在空指针风险</span><br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        String key=KEY_PREFIX + name;<br>        String threadId=ID_PREFIX+Thread.currentThread().getId();<br>        <span class="hljs-comment">//对比标识</span><br>         <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> (String) redisTemplate.opsForValue().get(key);<br>         <span class="hljs-keyword">if</span>(threadId.equals(id))&#123;<br>             <span class="hljs-comment">//释放锁</span><br>             redisTemplate.delete(key);<br>         &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>1线程获取锁并且执行完业务后，释放锁操作判断标识一致通过后，但是此时1线程发生阻塞（JVM-FullGc）,此时2线程获取锁，并且执行业务。但是1线程阻塞结束，开始释放锁，又出现了<strong>锁误删问题</strong></p></li><li><p>原因：<strong>没有保证释放锁操作的原子性</strong></p></li></ul><h5 id="5-2编写Lua脚本实现原子性"><a href="#5-2编写Lua脚本实现原子性" class="headerlink" title="5.2编写Lua脚本实现原子性"></a>5.2编写Lua脚本实现原子性</h5><p><img src="/.com//image-20250504134320454.png" alt="image-20250504134320454"></p><p><img src="/.com//image-20250504134713358.png" alt="image-20250504134713358"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- get key</span><br><span class="hljs-keyword">local</span> id=redis.call(<span class="hljs-string">&#x27;get&#x27;</span>,KEYS[<span class="hljs-number">1</span>])<br><br><span class="hljs-comment">-- 对比</span><br><span class="hljs-keyword">if</span>(id==ARGV[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 释放锁</span><br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h5 id="5-3使用Java代码执行lua脚本"><a href="#5-3使用Java代码执行lua脚本" class="headerlink" title="5.3使用Java代码执行lua脚本"></a>5.3使用Java代码执行lua脚本</h5><p><img src="/.com//image-20250504140223143.png" alt="image-20250504140223143"></p><p>核心改变：</p><blockquote><ul><li>引入脚本</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;<br>  <span class="hljs-keyword">static</span> &#123;<br>      UNLOCK_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>      UNLOCK_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;unlock.lua&quot;</span>));<br>      UNLOCK_SCRIPT.setResultType(Long.class);<br>  &#125;<br></code></pre></td></tr></table></figure><ul><li>执行脚本</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过lua脚本来执行</span><br>       redisTemplate.execute(UNLOCK_SCRIPT, Collections.singletonList(KEY_PREFIX + name), ID_PREFIX + Thread.currentThread().getId());<br></code></pre></td></tr></table></figure></blockquote><p><img src="/.com//image-20250504143925691.png" alt="image-20250504143925691"></p><h5 id="5-4分布式锁-Redisson"><a href="#5-4分布式锁-Redisson" class="headerlink" title="5.4分布式锁-Redisson"></a>5.4分布式锁-Redisson</h5><p><img src="/.com//image-20250504144035301.png" alt="image-20250504144035301"></p><p><strong><code>可重入锁（Reentrant Lock）</code></strong></p><ul><li><strong>原理</strong>：允许同一线程在持有锁的情况下多次获取锁，内部通过计数实现，每次加锁计数 +1 ，解锁计数 -1 ，计数为 0 时才真正释放锁。</li><li><strong>应用场景</strong>：一个方法调用另一个需要相同锁保护的方法时，避免线程自己阻塞自己。比如递归操作共享资源场景。</li></ul><p><strong><code>联锁（MultiLock）</code></strong></p><ul><li><strong>原理</strong>：将多个锁合并成一个锁，只有当所有子锁都成功获取时，联锁才获取成功；释放时也需释放所有子锁。</li><li><strong>应用场景</strong>：涉及多个不同资源，需要同时锁定以保证操作原子性的场景，比如同时操作多个不同 Redis 数据库中的数据。</li></ul><p><img src="/.com//image-20250504145105785.png" alt="image-20250504145105785"></p><h6 id="1-可重入锁"><a href="#1-可重入锁" class="headerlink" title="1.可重入锁"></a>1.可重入锁</h6><ul><li><p>Redis数据结构:String–&gt;Hash</p></li><li><p>实现一人一单</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedissonClient redissonClient;<br>   <br>        <span class="hljs-comment">//使用Redisson锁</span><br>        <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock:order:&quot;</span> + userId);<br>        <span class="hljs-type">boolean</span> isLock=lock.tryLock();<br>        <span class="hljs-keyword">if</span>(isLock)&#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许重复下单&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//        2.扣减库存、创建订单-回显id</span><br>            <span class="hljs-comment">//1.获取代理对象-需要确保线程的安全性 2.引入依赖aspectjweaver 3.启动类开启暴露代理对象</span><br>            <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span>(IVoucherOrderService) AopContext.currentProxy();<br>            <span class="hljs-keyword">return</span> proxy.creatOrder(userId,voucherId);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//释放锁</span><br>            lock.unlock();<br>        &#125;<br>    <br></code></pre></td></tr></table></figure><h6 id="2-联锁"><a href="#2-联锁" class="headerlink" title="2.联锁"></a>2.联锁</h6><ul><li><p>主从模式</p><ul><li>主节点执行写</li><li>从节点执行读</li><li>主节点同步数据至从节点</li></ul></li><li><p>主节点宕机时，哨兵模式下从节点成为新的主节点。如果主从节点未能同步，此时锁在原先的主节点存在，而在新的主节点下不存在。</p><ul><li><p>此时其他线程也能获取锁，出现并发的安全问题</p><p><img src="/.com//image-20250504182353336.png" alt="image-20250504182353336"></p></li></ul></li><li><p>解决方法：</p><ul><li><p>获取锁的时候，向多个节点进行获取锁。</p><p><img src="/.com//image-20250504182530148.png" alt="image-20250504182530148"></p></li><li><p>配置多个redis节点</p></li><li><p>创建联锁</p><p><img src="/.com//image-20250504182950695.png" alt="image-20250504182950695"></p></li></ul></li></ul><p><img src="/.com//image-20250504183501505.png" alt="image-20250504183501505"></p><h4 id="6-Redis优化秒杀"><a href="#6-Redis优化秒杀" class="headerlink" title="6.Redis优化秒杀"></a>6.Redis优化秒杀</h4><h5 id="6-1异步秒杀思路"><a href="#6-1异步秒杀思路" class="headerlink" title="6.1异步秒杀思路"></a>6.1异步秒杀思路</h5><ul><li>当用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤</li></ul><p><img src="/.com//image-20250505200136621.png" alt="image-20250505200136621"></p><ul><li>优化方案：<ul><li>我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成。</li><li>将数据库相关且无需返回结果操作放到另外的线程通过消息队列异步执行</li></ul></li></ul><p><img src="/.com//image-20250505200459276.png" alt="image-20250505200459276"></p><p><img src="/.com//image-20250505200505879.png" alt="image-20250505200505879"></p><h5 id="6-2Redis完成秒杀资格判断"><a href="#6-2Redis完成秒杀资格判断" class="headerlink" title="6.2Redis完成秒杀资格判断"></a>6.2Redis完成秒杀资格判断</h5><p>需求：</p><ul><li><p>新增秒杀优惠券的同时，将优惠券信息（id,库存）保存到Redis中</p><ul><li>以字符串形式统一传入redis</li></ul></li><li><p>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</p><ul><li><pre><code class="lua">-- 优惠券idlocal voucher = &#39;SK_VR_STOCK:VRID&#39;..ARGV[1]-- 用户下单keylocal orderKey = &#39;SK_VR_ORDER:USERID:&#39;..ARGV[1]-- 判断是否剩余库存-- 获取优惠券库存local stock = redis.call(&#39;get&#39;, voucher)-- 将库存转换为数字local numStock = tonumber(stock)-- 检查转换结果是否为 nil-- 判断库存是否小于等于 0if numStock &lt;= 0 then    return 1end-- 判断用户是否能下单-- 已经下单返回2if redis.call(&#39;sismember&#39;, orderKey, ARGV[2]) == 1 then    return 2end-- 用户下单 库存减一、用户id加入set集合redis.call(&#39;decrby&#39;, voucher, 1)redis.call(&#39;sadd&#39;, orderKey, ARGV[2])return 0<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><br>  - 注意：<br><br>    - 传入lua脚本的参数也要以字符串形式。<br>    - 执行脚本和写入redis的数据（lua脚本中使用的）所用的**RedisTemplate统一**（StringRedisTemplate）<br>    - lua脚本未读取到的数据为nil,字符串转化为数字使用**tonumber()**，转化失败也为nil。<br>    - 字符串拼接使用**..**<br><br>* 如果抢购成功，将优惠券id和用户id封装后存入阻塞队列<br><br>~~~java<br>       <span class="hljs-comment">//阻塞队列</span><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">1024</span>);<br>    <span class="hljs-comment">//代理对象</span><br>    <span class="hljs-keyword">private</span> IVoucherOrderService proxy;<br><span class="hljs-comment">//lua脚本 资源初始化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;<span class="hljs-keyword">Long</span>&gt; SKILL_SRCIPT;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        SKILL_SRCIPT = <span class="hljs-keyword">new</span> DefaultRedisScript&lt;&gt;();<br>        SKILL_SRCIPT.setLocation(<span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">&quot;skill.lua&quot;</span>));<br>        SKILL_SRCIPT.setResultType(<span class="hljs-keyword">Long</span>.<span class="hljs-keyword">class</span>);<br>    &#125;<br>@Override<br>    <span class="hljs-keyword">public</span> Result seckillVoucher(<span class="hljs-keyword">Long</span> voucherId) &#123;<br>        <span class="hljs-comment">//编写lua脚本并且执行</span><br>        <span class="hljs-comment">// 判断优惠卷库存--优惠卷id</span><br>        <span class="hljs-comment">// 判断用户是否下单--用户id</span><br>        <span class="hljs-keyword">Long</span> userId = UserHolder.getUser().getId();<br>        <span class="hljs-keyword">Long</span> res = (<span class="hljs-keyword">Long</span>) stringRedisTemplate.execute(SKILL_SRCIPT, Collections.emptyList(), voucherId.toString(), userId.toString());<br>        <span class="hljs-comment">// 1-库存不足 2-用户已经下单 0-秒杀成功</span><br>        <span class="hljs-keyword">if</span> (res != <span class="hljs-number">0</span>) &#123;<br>            log.info(<span class="hljs-string">&quot;下单失败&quot;</span>);<br>            <span class="hljs-keyword">return</span> Result.fail(res == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;库存不足！&quot;</span> : <span class="hljs-string">&quot;不可重复下单！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//秒杀成功</span><br>        <span class="hljs-comment">//创建阻塞队列执行数据库相关操作 -库存扣减、下单</span><br>        VoucherOrder voucherOrder = <span class="hljs-keyword">new</span> VoucherOrder();<br>        <span class="hljs-comment">//创建订单号</span><br>        <span class="hljs-keyword">long</span> orderId = idWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>        voucherOrder.setVoucherId(voucherId).setUserId(userId).setId(orderId);<br>        orderQueue.add(voucherOrder);<br>        <span class="hljs-comment">//1.获取代理对象-需要确保线程的安全性 2.引入依赖aspectjweaver 3.启动类开启暴露代理对象</span><br>        <span class="hljs-comment">//获取代理对象便于子线程使用</span><br>        proxy = (IVoucherOrderService) AopContext.currentProxy();<br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>    &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</p><ul><li><strong>@PostConstruct注解</strong>:实例创建完成后立刻执行该方法init()</li><li>阻塞队列需要在成员变量里先完成初始化</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">//创建异步线程池 单线程</span><br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>)<br>    );<br><br><span class="hljs-comment">//异步执行阻塞队列任务</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        pool.submit(() -&gt; &#123;<br>                    <span class="hljs-comment">//循环获取阻塞队列的任务</span><br>                    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">take</span> <span class="hljs-operator">=</span> orderQueue.take();<br><span class="hljs-comment">//处理阻塞队列的任务</span><br>                            handlerVocherOrder(take);<br>                        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                            log.error(<span class="hljs-string">&quot;阻塞队列任务执行异常！&quot;</span>,e);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>        );<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>异步处理阻塞队列的任务-创建订单</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerVocherOrder</span><span class="hljs-params">(VoucherOrder voucherOrder)</span> &#123;<br>      <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> voucherOrder.getUserId();<br>      <span class="hljs-type">Long</span> <span class="hljs-variable">voucherId</span> <span class="hljs-operator">=</span> voucherOrder.getVoucherId();<br>      <span class="hljs-type">Long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> voucherOrder.getId();<br>      <span class="hljs-comment">// 使用 Redisson 锁</span><br>      <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock:order:&quot;</span> + userId);<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock();<br>      <span class="hljs-keyword">if</span> (!isLock) &#123;<br>          <span class="hljs-comment">//获取所失败</span><br>          log.error(<span class="hljs-string">&quot;不允许重复下单！&quot;</span>);<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 2. 扣减库存、创建订单</span><br>          proxy.creatOrder(userId, voucherId, orderId);<br>      &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>          <span class="hljs-comment">// 处理异常</span><br>          log.error(<span class="hljs-string">&quot;处理订单异常&quot;</span>, e);<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>          <span class="hljs-comment">// 释放锁</span><br>          <span class="hljs-keyword">if</span> (lock.isHeldByCurrentThread()) &#123;<br>              lock.unlock();<br>          &#125;<br>      &#125;<br>  &#125;<br>  <br>  /事务必须时spring的代理对象执行方法才能有效<br>  <span class="hljs-meta">@Transactional</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">creatOrder</span><span class="hljs-params">(Long userId, Long voucherId, Long orderId)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>      <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>          log.error(<span class="hljs-string">&quot;用户已经买过一单&quot;</span>);<br>          <span class="hljs-comment">//用户已经买过一单</span><br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-comment">//2.1扣减库存-解决超卖问题</span><br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>              .setSql(<span class="hljs-string">&quot;stock=stock-1&quot;</span>)<br>              .gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>)<br>              .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).update();<br>      <span class="hljs-keyword">if</span> (!success) &#123;<br>          log.error(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-comment">//2.2创建订单</span><br>      <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> VoucherOrder.builder()<br>              .id(orderId)<br>              .voucherId(voucherId)<br>              .userId(userId)<br>              .build();<br>      save(voucherOrder);<br>      log.info(<span class="hljs-string">&quot;用户-&#123;&#125; 下单成功,订单号&#123;&#125;&quot;</span>, userId, orderId);<br>  &#125;<br><br></code></pre></td></tr></table></figure><p><strong>小总结：</strong></p><p>秒杀业务的优化思路是什么？</p><ul><li><p>先利用Redis完成库存余量、一人一单判断，完成抢单业务</p></li><li><p>再将下单业务放入阻塞队列，利用独立线程异步下单</p></li><li><p>基于阻塞队列的异步秒杀存在哪些问题？</p><ul><li>内存限制问题</li><li>数据安全问题</li></ul><p>原因：JVM内存中，未持久化</p></li></ul><h4 id="7-Redis消息队列"><a href="#7-Redis消息队列" class="headerlink" title="7.Redis消息队列"></a>7.Redis消息队列</h4><ul><li><p>基于list</p></li><li><p>基于PubSubscrib</p></li><li><p>基于Stream</p><ul><li>xadd</li></ul></li></ul><h2 id="5-达人探店"><a href="#5-达人探店" class="headerlink" title="5.达人探店"></a>5.达人探店</h2><h3 id="1-发布blog"><a href="#1-发布blog" class="headerlink" title="1.发布blog"></a>1.发布blog</h3><ul><li><p>实现思路</p><blockquote><p>1.上传图片至OSS或者nginx服务器，并回显url</p><p>2.填写文本内容</p><p>3.Post至后端</p></blockquote><p>文件上传</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//文件上传</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UploadController</span> &#123;<br><br>    <span class="hljs-comment">//public static final String IMAGE_UPLOAD_DIR</span><br>    <span class="hljs-comment">//    = &quot;E:\\Web_develop_tools\\nginx-1.18.0_hmdp\\html\\hmdp\\imgs\\&quot;</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 上传blog</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> image</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;blog&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">uploadImage</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;file&quot;)</span> MultipartFile image)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取原始文件名称</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> image.getOriginalFilename();<br>            <span class="hljs-comment">// 生成新文件名</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> createNewFileName(originalFilename);<br>            <span class="hljs-comment">// 保存文件</span><br>            image.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, fileName));<br>            <span class="hljs-comment">// 返回结果</span><br>            log.debug(<span class="hljs-string">&quot;文件上传成功，&#123;&#125;&quot;</span>, fileName);<br>            <span class="hljs-keyword">return</span> Result.ok(fileName);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;文件上传失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/blog/delete&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">deleteBlogImg</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;name&quot;)</span> String filename)</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, filename);<br>        <span class="hljs-keyword">if</span> (file.isDirectory()) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;错误的文件名称&quot;</span>);<br>        &#125;<br>        FileUtil.del(file);<br>        <span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">createNewFileName</span><span class="hljs-params">(String originalFilename)</span> &#123;<br>        <span class="hljs-comment">// 获取后缀</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">suffix</span> <span class="hljs-operator">=</span> StrUtil.subAfter(originalFilename, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 生成目录</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> name.hashCode();<br>        <span class="hljs-comment">//16-&gt;1111,&amp;取低四位</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> hash &amp; <span class="hljs-number">0xF</span>;<br>        <span class="hljs-comment">//&gt;&gt;4 ,低四位变成5-8位，&amp;取5-8位</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> (hash &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0xF</span>;<br>        <span class="hljs-comment">// 判断目录是否存在</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, StrUtil.format(<span class="hljs-string">&quot;/blogs/&#123;&#125;/&#123;&#125;&quot;</span>, d1, d2));<br>        <span class="hljs-keyword">if</span> (!dir.exists()) &#123;<br>            dir.mkdirs();<br>        &#125;<br>        <span class="hljs-comment">// 生成文件名</span><br>        <span class="hljs-keyword">return</span> StrUtil.format(<span class="hljs-string">&quot;/blogs/&#123;&#125;/&#123;&#125;/&#123;&#125;.&#123;&#125;&quot;</span>, d1, d2, name, suffix);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>提交Blog</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//提交Blog</span><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">saveBlog</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Blog blog)</span> &#123;<br>        <span class="hljs-comment">// 获取登录用户</span><br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>        blog.setUserId(user.getId());<br>        <span class="hljs-comment">// 保存探店博文</span><br>        blogService.save(blog);<br>        <span class="hljs-comment">// 返回id</span><br>        <span class="hljs-keyword">return</span> Result.ok(blog.getId());<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-点赞"><a href="#2-点赞" class="headerlink" title="2.点赞"></a>2.点赞</h3><ul><li><p>点赞&#x2F;取消点赞的实现思路</p><blockquote><ul><li><p>方案1：使用mysql关联表，并且创建唯一关联索引。- 少量数据情况</p></li><li><p>方案2：使用redis的zset,存keyName:blogid-key和value-userid</p></li></ul></blockquote><p>方案二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 点赞</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-comment">//点赞/取消点赞</span><br>        <span class="hljs-comment">//1.获取用户userid</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">UserId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.BLOG_LIKED_KEY + id;<br>        <span class="hljs-comment">//2.查zset中key为BLOG_LIKED_KEY(blog:liked:)+blogId value为userId的优先级score (不存在为null)</span><br>        <span class="hljs-type">Double</span> <span class="hljs-variable">isliked</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForZSet().score(key, UserId);<br>        <span class="hljs-comment">//3.不存在</span><br>        <span class="hljs-keyword">if</span> (isliked == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//3.1.数据库点赞数+1,添加该条value.</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isUpdated</span> <span class="hljs-operator">=</span> lambdaUpdate()<br>                    .setSql(<span class="hljs-string">&quot;liked=liked+1&quot;</span>)<br>                    .eq(Blog::getId, id)<br>                    .update();<br>            <span class="hljs-keyword">if</span>(!isUpdated)&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;点赞失败&quot;</span>);<br>            &#125;<br>            stringRedisTemplate.opsForZSet().add(key, UserId.toString(), System.currentTimeMillis());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//4.存在</span><br>            <span class="hljs-comment">//4.1.数据库点赞数-1,删除该条value</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isUpdated</span> <span class="hljs-operator">=</span> lambdaUpdate()<br>                    .setSql(<span class="hljs-string">&quot;liked=liked-1&quot;</span>)<br>                    .eq(Blog::getId, id)<br>                    .update();<br>            <span class="hljs-keyword">if</span>(!isUpdated)&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;取消点赞失败&quot;</span>);<br>            &#125;<br>            stringRedisTemplate.opsForZSet().remove(key,UserId.toString());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>点赞显示的实现思路</p><blockquote><ul><li>1.添加一个isLike字段用于返回给前端显示</li><li>2.单个&#x2F;批量（需优化）-根据zset中是否有对应的userId来给该字段赋值</li><li>3.显示最早点赞的几个用户的名称和头像，zset按照点赞的时间戳排序，查出对应的用户id，再封装VO -注意范围查询in的无序性,last（order by field(“id”,ids)）尾部添加排序语句</li></ul></blockquote></li></ul><p>​       点赞显示单个&#x2F;批量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//单个/批量查询数据的时候对zset进行查询</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">isLiked</span><span class="hljs-params">(Blog blog)</span>&#123;<br>       UserDTO user=UserHolder.getUser();<br>       <span class="hljs-keyword">if</span> (user==<span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-comment">//用户未登录，无需查询是否点赞</span><br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       <span class="hljs-type">Long</span> <span class="hljs-variable">UserId</span> <span class="hljs-operator">=</span> user.getId();<br>       <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.BLOG_LIKED_KEY +blog.getId();<br>       <span class="hljs-comment">//2.查zset中key为BLOG_LIKED_KEY(blog:liked:)+blogId value为userId的优先级score (不存在为null)</span><br>       <span class="hljs-type">Double</span> <span class="hljs-variable">isliked</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForZSet().score(key, UserId);<br>       <span class="hljs-keyword">if</span>(isliked==<span class="hljs-literal">null</span>)&#123;<br>          <span class="hljs-keyword">return</span>;<br>       &#125;<br>       blog.setIsLike(<span class="hljs-literal">true</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p>​       点赞用户显示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikesTop5</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.BLOG_LIKED_KEY + id;<br>    <span class="hljs-comment">//1.查询zset中top5早点赞的用户id</span><br>    Set&lt;String&gt; top5 =  stringRedisTemplate.opsForZSet().range(key, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">if</span>(top5==<span class="hljs-literal">null</span>||top5.isEmpty())&#123;<br>        <span class="hljs-comment">//没有返回空集合</span><br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    <span class="hljs-comment">//2.查询用户list信息</span><br>    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());<br>    String idStr= StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>,ids);<br>    List&lt;UserDTO&gt; userDTOS = userService.query()<br>            .in(<span class="hljs-string">&quot;id&quot;</span>, ids)<br>            .last(<span class="hljs-string">&quot;order by field(id,&quot;</span> + idStr + <span class="hljs-string">&quot;)&quot;</span>)<br>            .list()<br>            .stream()<br>            .map(user-&gt; BeanUtil.copyProperties(user,UserDTO.class))<br>            .collect(Collectors.toList());<br>    <span class="hljs-keyword">return</span> Result.ok(userDTOS);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-好友关注"><a href="#6-好友关注" class="headerlink" title="6.好友关注"></a>6.好友关注</h2><h3 id="1-关注"><a href="#1-关注" class="headerlink" title="1.关注"></a>1.关注</h3><p>关注和取关 </p><ul><li>关注和取关接口 - 用户follow关联表 设置unique联合索引 -同步至缓存set中</li><li>查询是否关注</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关注/取关</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> followUserId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> isFollow</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(Long followUserId, Boolean isFollow)</span> &#123;<br>        <span class="hljs-comment">//关注/取关</span><br>        UserDTO user= UserHolder.getUser();<br>        Long userId=user.getId();<br>        String key= RedisConstants.FOLLOWS_KEY+userId;<br>        <span class="hljs-comment">//关注</span><br>        <span class="hljs-keyword">if</span>(isFollow)&#123;<br>            <span class="hljs-comment">//添加数据库信息 -添加缓存</span><br>            Follow follow=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();<br>            follow.setFollowUserId(followUserId);<br>            follow.setUserId(userId);<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isSave</span> <span class="hljs-operator">=</span> save(follow);<br>            <span class="hljs-keyword">if</span>(BooleanUtil.isTrue(isSave))&#123;<br>                <span class="hljs-comment">//添加缓存至set</span><br>                stringRedisTemplate.opsForSet().add(key,followUserId.toString());<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//取关</span><br>            <span class="hljs-comment">//删除数据库信息 -删除缓存</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isRemove</span> <span class="hljs-operator">=</span> remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Follow&gt;()<br>                    .eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId)<br>                    .eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, followUserId));<br>            <span class="hljs-keyword">if</span> (BooleanUtil.isTrue(isRemove))&#123;<br>                stringRedisTemplate.opsForSet().remove(key,followUserId);<br>            &#125;<br>        &#125;<br><span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询是否关注</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> followUserId</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">isFollow</span><span class="hljs-params">(Long followUserId)</span> &#123;<br>    UserDTO user= UserHolder.getUser();<br>    Long userId=user.getId();<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> lambdaQuery().eq(Follow::getUserId, userId)<br>            .eq(Follow::getFollowUserId, followUserId)<br>            .count();<br>        <span class="hljs-keyword">return</span> (count&gt;<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-共同关注"><a href="#2-共同关注" class="headerlink" title="2.共同关注"></a>2.共同关注</h3><ul><li>查询当前用户信息</li><li>查询用户的Blog</li><li>查询该用户关注的人的id,查询当前用户的关注的人，求set的交集intersect(key1,key2)找共同的ids,查询ids的用户信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 共同关注</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">followCommons</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-comment">//获取当前用户</span><br>        Long userId=UserHolder.getUser().getId();<br>        String key=RedisConstants.FOLLOWS_KEY+userId;<br>        String key1=RedisConstants.FOLLOWS_KEY+id;<br>        <span class="hljs-comment">//查询缓存中当前用户和目标用户的follows set的交集</span><br>        Set&lt;String&gt; commonIds = stringRedisTemplate.opsForSet().intersect(key, key1);<br>        <span class="hljs-keyword">if</span>(commonIds==<span class="hljs-literal">null</span>||commonIds.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>        &#125;<br>        List&lt;Long&gt; ids = commonIds.stream().map(Long::valueOf).collect(Collectors.toList());<br>        <span class="hljs-comment">//遍历ids集合查询用户信息并且封装</span><br>        List&lt;Object&gt; users = userService.listByIds(ids).stream().map(user -&gt;<br>                    BeanUtil.copyProperties(user, UserDTO.class)<br>                )<br>                .collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> Result.ok(users);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-关注推送"><a href="#3-关注推送" class="headerlink" title="3.关注推送"></a>3.关注推送</h3><ul><li><p>Feed流 投喂 由于数据的变化，不能采用传统的分页模式，采用滚动分页模式</p></li><li><p>Timeline  -不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈</p><ul><li>优点：信息全面，不会有缺失。并且实现也相对简单</li><li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li></ul></li><li><p>该模式的实现方案有三种</p><ul><li><p>拉模式：- 不推荐使用 读扩散  主动读 发件箱 根据时间戳 至收件箱（自动清理）缺点每次都要读</p></li><li><p>推模式：-百万级 写扩散 写内容后主动发 直接推送至粉丝收件箱，大v粉丝多浪费空间</p></li><li><p>推拉结合-千万级 只推送给活跃粉丝，不活跃的用户自己拉</p></li></ul></li><li><p>智能排序 :利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</p><ul><li>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</li><li>缺点：如果算法不精准，可能起到反作用</li></ul></li></ul><p>采用推模式</p><blockquote><p>发布内容时推送到粉丝收件箱zset，以时间戳为score</p><p>粉丝滚动分页接收推送</p><p>滚动分页的实现：读取内容时根据score范围来进行读取，第一次&#x2F;刷新 以当前时间戳为最大，后续滚动时，根据上一页最小的时间戳结合偏移量来读取。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取feed推流 -滚动分页</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> max</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> offset</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogOfFollow</span><span class="hljs-params">(Long max, Integer offset)</span> &#123;<br>        <span class="hljs-comment">//max上一次的最小时间戳-这一次的最大</span><br>        <span class="hljs-comment">//offset偏移量</span><br>        <span class="hljs-comment">//滚动分页查询</span><br>        <span class="hljs-comment">//1.查询当前用户feed 收件箱 -ZREVRANGEBYSCORE key Min Max LIMIT offset count</span><br>        Long userId=UserHolder.getUser().getId();<br>        String key=RedisConstants.FEED_KEY+userId;<br>        Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet().reverseRangeByScoreWithScores(key, <span class="hljs-number">0</span>, max, offset, <span class="hljs-number">3L</span>);<br>        <span class="hljs-keyword">if</span>(typedTuples==<span class="hljs-literal">null</span>||typedTuples.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> Result.ok();<br>        &#125;<br>        <span class="hljs-comment">//2.计算下一次的offset和minTime</span><br>        List&lt;Long&gt; ids=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(typedTuples.size());<br>        Long minTime=<span class="hljs-number">0L</span>;<br>        <span class="hljs-type">int</span> os=<span class="hljs-number">1</span>;<span class="hljs-comment">//由于闭区间，默认偏移值为一</span><br>        <span class="hljs-keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; typedTuple : typedTuples) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">blogIdStr</span> <span class="hljs-operator">=</span> typedTuple.getValue();<br>            Long blogId=Long.valueOf(blogIdStr) ;<br>            ids.add(blogId);<br>            <span class="hljs-type">Long</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> typedTuple.getScore().longValue();<br>            <span class="hljs-keyword">if</span>(minTime==score)&#123;<br>                os++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                os=<span class="hljs-number">1</span>;<br>                minTime=score;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果全为相同数据</span><br>        os = minTime == max ? os : os + offset;<br>        <span class="hljs-comment">//3.根据收件箱的blog-ids查询blog</span><br>        String idlistStr=StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>,ids);<br>        List&lt;Blog&gt; blogs = query().in(<span class="hljs-string">&quot;id&quot;</span>,ids)<br>                .last(<span class="hljs-string">&quot;order by field(id,&quot;</span>+idlistStr+<span class="hljs-string">&quot;)&quot;</span>).list();<br>        <span class="hljs-keyword">for</span> (Blog blog : blogs) &#123;<br>            queryBlogUser(blog);<br>            isLiked(blog);<br>        &#125;<br>        <span class="hljs-type">ScrollResult</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScrollResult</span>();<br>        res.setList(blogs);<br>        res.setOffset(os);<br>        res.setMinTime(minTime);<br>        <span class="hljs-comment">//4.封装返回</span><br>        <span class="hljs-keyword">return</span> Result.ok(res);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="7-附件商铺"><a href="#7-附件商铺" class="headerlink" title="7.附件商铺"></a>7.附件商铺</h2><p><img src="/.com//image-20250519151558431.png" alt="image-20250519151558431"></p><ul><li>跳过</li></ul><h2 id="8-用户签到"><a href="#8-用户签到" class="headerlink" title="8.用户签到"></a>8.用户签到</h2><ul><li>BitMap(位图)</li></ul><p><img src="/.com//image-20250519153842332.png" alt="image-20250519153842332"></p><p><img src="/.com//image-20250519154036472.png" alt="image-20250519154036472"></p><h3 id="1-用户签到"><a href="#1-用户签到" class="headerlink" title="1.用户签到"></a>1.用户签到</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 用户签到</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sign</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//获取当前用户</span><br>       UserDTO user= UserHolder.getUser();<br>       Long userId=user.getId();<br>       <span class="hljs-comment">//获取当前的年月</span><br>       LocalDateTime now=LocalDateTime.now();<br>       <span class="hljs-comment">//后缀</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">keySuffix</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;:yyyyMM&quot;</span>));<br>       String key=RedisConstants.USER_SIGN_KEY+userId+keySuffix;<br>       <span class="hljs-comment">//获取当前的日</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> now.getDayOfMonth();<br>       <span class="hljs-comment">//写入redis的bitMap</span><br>       stringRedisTemplate.opsForValue().setBit(key,dayOfMonth-<span class="hljs-number">1</span>,<span class="hljs-literal">true</span>);<br>       <span class="hljs-keyword">return</span> Result.ok();<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="2-统计连续签到"><a href="#2-统计连续签到" class="headerlink" title="2.统计连续签到"></a>2.统计连续签到</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  统计连续签到天数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">signCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//获取当前年月 -拼接key</span><br>        UserDTO user= UserHolder.getUser();<br>        Long userId=user.getId();<br>        LocalDateTime now=LocalDateTime.now();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">keySuffix</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;:yyyyMM&quot;</span>));<br>        String key=RedisConstants.USER_SIGN_KEY+userId+keySuffix;<br>        <span class="hljs-comment">//获取当前日</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> now.getDayOfMonth();<br>        <span class="hljs-comment">//范围截取0-当前日 左闭右开</span><br>        List&lt;Long&gt; res = stringRedisTemplate.opsForValue().bitField(key, BitFieldSubCommands.create()<br>                .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="hljs-number">0</span>));<br><span class="hljs-keyword">if</span>(res==<span class="hljs-literal">null</span>|| res.isEmpty())&#123;<br>    <span class="hljs-keyword">return</span> Result.ok(<span class="hljs-number">0</span>);<br>&#125;<br>        <span class="hljs-comment">//循环往前遍历，位运算</span><br>        Long num=res.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//list只有一个数</span><br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>((num&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                count++;<br>            &#125;<br>            num&gt;&gt;&gt;=<span class="hljs-number">1</span>;<br>        &#125;<br><span class="hljs-keyword">return</span> Result.ok(count);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="9-UV统计"><a href="#9-UV统计" class="headerlink" title="9.UV统计"></a>9.UV统计</h2><p><img src="/.com//image-20250519161022088.png" alt="image-20250519161022088"></p><p><img src="/.com//image-20250519161120739.png" alt="image-20250519161120739"></p><ul><li>使用原子递增实现PV</li><li>UV:Unique Vistor   PV:Page View</li></ul><h3 id="2-实现方案对比"><a href="#2-实现方案对比" class="headerlink" title="2. 实现方案对比"></a><strong>2. 实现方案对比</strong></h3><h4 id="方案一：基于-Redis-实现"><a href="#方案一：基于-Redis-实现" class="headerlink" title="方案一：基于 Redis 实现"></a><strong>方案一：基于 Redis 实现</strong></h4><p><strong>PV</strong>：使用 Redis 的 <strong>Counter（原子递增）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 记录 PV</span><br>redisTemplate.opsForValue().increment(<span class="hljs-string">&quot;pv:&quot;</span> + date, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 获取 PV</span><br><span class="hljs-type">Long</span> <span class="hljs-variable">pv</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;pv:&quot;</span> + date);<br></code></pre></td></tr></table></figure><p><strong>UV</strong>：</p><ul><li><p>小规模</p><p>：使用 Redis 的<strong>Set</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 记录 UV（自动去重）</span><br>redisTemplate.opsForSet().add(<span class="hljs-string">&quot;uv:&quot;</span> + date, userId);<br><br><span class="hljs-comment">// 获取 UV</span><br><span class="hljs-type">Long</span> <span class="hljs-variable">uv</span> <span class="hljs-operator">=</span> redisTemplate.opsForSet().size(<span class="hljs-string">&quot;uv:&quot;</span> + date);<br></code></pre></td></tr></table></figure></li><li><p>大规模</p><p>：使用<strong>HyperLogLog</strong></p><p>（牺牲 0.81% 精度换取内存优化）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 记录 UV</span><br>redisTemplate.opsForHyperLogLog().add(<span class="hljs-string">&quot;uv:&quot;</span> + date, userId);<br><br><span class="hljs-comment">// 获取 UV（近似值）</span><br><span class="hljs-type">Long</span> <span class="hljs-variable">uv</span> <span class="hljs-operator">=</span> redisTemplate.opsForHyperLogLog().size(<span class="hljs-string">&quot;uv:&quot;</span> + date);<br></code></pre></td></tr></table></figure></li></ul><p><strong>优势</strong>：高性能、实时性强<br><strong>劣势</strong>：UV 数据量大时 Set 占用内存高，HyperLogLog 有误差</p><h4 id="方案二：基于-HBase-Hive-实现"><a href="#方案二：基于-HBase-Hive-实现" class="headerlink" title="方案二：基于 HBase + Hive 实现"></a><strong>方案二：基于 HBase + Hive 实现</strong></h4><p><strong>架构</strong>：</p><ol><li><strong>实时层</strong>：日志收集 → Kafka → Flink 计算实时 PV&#x2F;UV</li><li><strong>离线层</strong>：日志同步至 HDFS → Hive 按天聚合计算</li></ol><p><strong>关键实现</strong>：</p><ul><li><strong>PV</strong>：直接统计日志行数</li><li><strong>UV</strong>：<code>SELECT COUNT(DISTINCT user_id) FROM logs WHERE date=xxx</code></li></ul><p><strong>优势</strong>：可存储海量历史数据，支持复杂多维分析<br><strong>劣势</strong>：实时性差（T+1），架构复杂度高</p><h4 id="方案三：混合架构（企业级常用）"><a href="#方案三：混合架构（企业级常用）" class="headerlink" title="方案三：混合架构（企业级常用）"></a><strong>方案三：混合架构（企业级常用）</strong></h4><p><strong>架构</strong>：</p><ul><li><strong>实时指标</strong>：Redis（HyperLogLog）+ 定时持久化至数据库</li><li><strong>离线指标</strong>：Hive&#x2F;Hadoop 全量计算，用于校验和深度分析</li></ul><p><strong>示例代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实时记录 PV/UV</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recordAccess</span><span class="hljs-params">(String userId, String pageId)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> LocalDate.now().toString();<br>    <br>    <span class="hljs-comment">// 记录 PV（原子递增）</span><br>    redisTemplate.opsForValue().increment(<span class="hljs-string">&quot;pv:&quot;</span> + pageId + <span class="hljs-string">&quot;:&quot;</span> + date, <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-comment">// 记录 UV（HyperLogLog）</span><br>    redisTemplate.opsForHyperLogLog().add(<span class="hljs-string">&quot;uv:&quot;</span> + pageId + <span class="hljs-string">&quot;:&quot;</span> + date, userId);<br>    <br>    <span class="hljs-comment">// 异步写入日志（用于离线分析）</span><br>    logService.asyncLog(userId, pageId, System.currentTimeMillis());<br>&#125;<br><br><span class="hljs-comment">// 每日定时任务：将 Redis 数据持久化至数据库</span><br><span class="hljs-meta">@Scheduled(cron = &quot;0 0 1 * * ?&quot;)</span> <span class="hljs-comment">// 每天凌晨 1 点执行</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">persistDailyStats</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">yesterday</span> <span class="hljs-operator">=</span> LocalDate.now().minusDays(<span class="hljs-number">1</span>).toString();<br>    <br>    <span class="hljs-comment">// 遍历所有页面，持久化 PV/UV</span><br>    pageService.getAllPages().forEach(pageId -&gt; &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">pv</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;pv:&quot;</span> + pageId + <span class="hljs-string">&quot;:&quot;</span> + yesterday);<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">uv</span> <span class="hljs-operator">=</span> redisTemplate.opsForHyperLogLog().size(<span class="hljs-string">&quot;uv:&quot;</span> + pageId + <span class="hljs-string">&quot;:&quot;</span> + yesterday);<br>        <br>        <span class="hljs-comment">// 写入数据库</span><br>        statsDao.saveDailyStats(pageId, yesterday, pv, uv);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-高级优化技术"><a href="#3-高级优化技术" class="headerlink" title="3. 高级优化技术"></a><strong>3. 高级优化技术</strong></h3><h4 id="1-布隆过滤器（Bloom-Filter）"><a href="#1-布隆过滤器（Bloom-Filter）" class="headerlink" title="1. 布隆过滤器（Bloom Filter）"></a><strong>1. 布隆过滤器（Bloom Filter）</strong></h4><ul><li><p><strong>场景</strong>：超大规模 UV 统计（如日活数亿级）</p></li><li><p><strong>优势</strong>：内存占用极小（亿级 UV 约 128MB），误判率可控</p></li><li><p>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 Google Guava 的布隆过滤器</span><br>BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(<br>    Funnels.stringFunnel(StandardCharsets.UTF_8),<br>    expectedInsertions, <span class="hljs-comment">// 预计元素数量</span><br>    fpp <span class="hljs-comment">// 期望误判率（如 0.01%）</span><br>);<br><br><span class="hljs-comment">// 判断用户是否已访问</span><br><span class="hljs-keyword">if</span> (!bloomFilter.mightContain(userId)) &#123;<br>    bloomFilter.put(userId);<br>    <span class="hljs-comment">// 新增 UV 计数</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo</title>
    <link href="/2025/07/02/Hexo/"/>
    <url>/2025/07/02/Hexo/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-StartHexo"><a href="#Quick-StartHexo" class="headerlink" title="Quick StartHexo"></a>Quick StartHexo</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/git%E6%93%8D%E4%BD%9C/"/>
    <url>/2025/07/02/git%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-操作指南"><a href="#Git-操作指南" class="headerlink" title="Git 操作指南"></a>Git 操作指南</h1><h2 id="一、Git-基础概念"><a href="#一、Git-基础概念" class="headerlink" title="一、Git 基础概念"></a>一、Git 基础概念</h2><ul><li><p><strong>仓库</strong>：Git 是一个分布式版本控制系统，用于管理项目的版本。仓库是存储项目代码和版本信息的地方，分为本地仓库和远程仓库。</p></li><li><p><strong>仓库（Repository）</strong></p><ul><li><strong>本地仓库</strong>：存在本机的代码版本库（.git目录）。</li><li><strong>远程仓库</strong>：托管在 GitHub&#x2F;GitLab 等平台的代码库（如 origin）。</li></ul></li><li><p><strong>三大区域</strong></p><ul><li><strong>工作区（WorkSpace）</strong>：你直接编辑的文件（未提交的修改）。</li><li><strong>暂存区（Staging Area）</strong>：通过 git add 暂存的文件（准备提交），工作区的**.git隐藏文件夹下**。</li><li><strong>版本库（Repository）</strong>：通过 git commit 提交的永久快照。工作区的**.git隐藏文件夹下**的HEAD指向的最终版本。</li></ul></li><li><p><strong>分支（Branch）</strong></p><ul><li>每个分支代表独立的开发线，默认主分支为 main 或 master。</li></ul></li></ul><p><img src="/.com//image-20250329162643010.png" alt="image-20250329162643010"></p><h2 id="二、Git-的安装与配置"><a href="#二、Git-的安装与配置" class="headerlink" title="二、Git 的安装与配置"></a>二、Git 的安装与配置</h2><h3 id="（一）安装-Git"><a href="#（一）安装-Git" class="headerlink" title="（一）安装 Git"></a>（一）安装 Git</h3><ul><li><p>Windows：</p><ul><li>从<a href="https://git-scorecard.duckduckgo.com/">Git 官网</a>下载 Git for Windows 安装程序，运行安装程序，按照提示进行安装，通常使用默认设置。</li></ul></li><li><p>macOS：</p><ul><li><p>使用 Homebrew 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install git<br></code></pre></td></tr></table></figure></li><li><p>或从<a href="https://git-scorecard.duckduckgo.com/">Git 官网</a>下载安装程序。</p></li></ul></li><li><p>Linux：</p><ul><li><p>Ubuntu 或 Debian 系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install git<br></code></pre></td></tr></table></figure></li><li><p>Fedora 或 CentOS 系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo dnf install git<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="（二）配置本地-Git-仓库"><a href="#（二）配置本地-Git-仓库" class="headerlink" title="（二）配置本地 Git 仓库"></a>（二）配置本地 Git 仓库</h3><ul><li><p>在想要作为 Git 仓库的目录下，使用</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>命令初始化仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure></li><li><p>配置用户信息（全局或本地）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;Your Name&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;your.email@example.com&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>配置远程仓库（可选）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin &lt;https://github.com/yourusername/yourrepository.git&gt;<br></code></pre></td></tr></table></figure></li><li><p>配置其他设置（可选）：</p><ul><li><p>配置默认编辑器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global core.editor <span class="hljs-string">&quot;vim&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>配置默认分支名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global init.defaultBranch main<br></code></pre></td></tr></table></figure></li><li><p>配置合并工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global merge.tool meld<br></code></pre></td></tr></table></figure></li><li><p>查看配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config -l   <span class="hljs-comment">#查看所有配置</span><br>git config --global --list <span class="hljs-comment">#本地全局配置</span><br>git config --system --list <span class="hljs-comment">#c</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="三、Git-常用操作"><a href="#三、Git-常用操作" class="headerlink" title="三、Git 常用操作"></a>三、Git 常用操作</h2><p><img src="/.com//image-20250329163933854.png" alt="image-20250329163933854"></p><h3 id="（一）提交信息"><a href="#（一）提交信息" class="headerlink" title="（一）提交信息"></a>（一）提交信息</h3><ul><li><p>简单提交（针对已经跟踪的文件）：</p><ol><li>使用<code>git add</code>命令将修改的文件添加到暂存区：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add.<br><span class="hljs-comment"># 或</span><br>git add &lt;特定文件&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>使用<code>git commit</code>命令进行提交暂存区的内容到本地仓库：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;提交信息&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>首次提交（初始化仓库后提交）：</p><ol><li>初始化仓库（如果还没有初始化）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><ol start="2"><li>添加文件到暂存区。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add.<br><span class="hljs-comment"># 或</span><br>git add &lt;特定文件&gt;<br></code></pre></td></tr></table></figure><p><img src="/.com//image-20250329165039227.png" alt="image-20250329165039227"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 通用规则</span><br>/target/          <span class="hljs-comment"># 忽略所有 target 目录</span><br>.idea/            <span class="hljs-comment"># 忽略 IDEA 配置目录</span><br>*.iml             <span class="hljs-comment"># 忽略独立 .iml 文件（若存在）</span><br>*.class           <span class="hljs-comment"># 忽略编译后的类文件</span><br><br><span class="hljs-comment"># 测试相关（需根据实际需求调整）</span><br><span class="hljs-comment"># !**/src/test/    # 保留测试代码目录（取消注释）</span><br><span class="hljs-comment"># *Test.java       # 若需排除测试文件，保留此行</span><br><br><span class="hljs-comment"># 其他生成文件</span><br>*.<span class="hljs-built_in">log</span><br>*.out<br>*.jar<br>*.war<br></code></pre></td></tr></table></figure><ol start="3"><li>进行首次提交：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;项目初始化，添加了基本文件结构&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>详细提交（包含更多操作）：</p><ol><li>查看状态：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br></code></pre></td></tr></table></figure><ol start="2"><li><p>有选择地添加文件到暂存区。</p></li><li><p>使用<code>git commit</code>命令不使用<code>-m</code>选项，打开默认的文本编辑器编写详细的提交信息：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit<br></code></pre></td></tr></table></figure></li></ul><h3 id="（二）覆盖提交信息（使用git-commit-amend）"><a href="#（二）覆盖提交信息（使用git-commit-amend）" class="headerlink" title="（二）覆盖提交信息（使用git commit --amend）"></a>（二）覆盖提交信息（使用<code>git commit --amend</code>）</h3><ol><li>查看当前状态：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br></code></pre></td></tr></table></figure><ol start="2"><li>修改提交信息：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit --amend<br></code></pre></td></tr></table></figure><ol start="3"><li><p>在编辑器中修改信息，保存并退出编辑器（根据不同编辑器操作）。</p></li><li><p>确认修改：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><h3 id="（三）Git-拉取（git-pull）"><a href="#（三）Git-拉取（git-pull）" class="headerlink" title="（三）Git 拉取（git pull）"></a>（三）Git 拉取（<code>git pull</code>）</h3><ul><li>远程仓库配置</li></ul><blockquote><p>注册GitHub或者Gitee账号</p><p>window配置密钥免密登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;ssh -keygen -t rsa -C <span class="hljs-string">&quot;邮箱地址&quot;</span><br></code></pre></td></tr></table></figure><p>C:\User\用户名.ssh\id_rsa.pub文件内容粘贴至公钥部分</p><p>新建仓库</p></blockquote><ul><li><p>基本拉取操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull &lt;远程仓库名&gt; &lt;分支名&gt;<br></code></pre></td></tr></table></figure><ul><li><p>通常使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin master<br><span class="hljs-comment"># 或</span><br>git pull origin main<br></code></pre></td></tr></table></figure></li></ul></li><li><p>解决合并冲突（如果有）：</p><ul><li><p>手动编辑有冲突的文件，删除冲突标记。</p></li><li><p>解决冲突后，使用</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">git <span class="hljs-keyword">add</span><br></code></pre></td></tr></table></figure><p>将修改后的文件添加到暂存区，然后使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git commit</span><br></code></pre></td></tr></table></figure><p>提交结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;冲突文件&gt;<br>git commit -m <span class="hljs-string">&quot;解决合并冲突&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="（四）Git-推送（git-push）"><a href="#（四）Git-推送（git-push）" class="headerlink" title="（四）Git 推送（git push）"></a>（四）Git 推送（<code>git push</code>）</h3><ul><li><p>基本推送操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push &lt;远程仓库名&gt; &lt;分支名&gt;<br></code></pre></td></tr></table></figure><ul><li><p>通常使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin master<br><span class="hljs-comment"># 或</span><br>git push origin main<br></code></pre></td></tr></table></figure></li></ul></li><li><p>强制推送（需谨慎使用）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -f &lt;远程仓库名&gt; &lt;分支名&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="（五）克隆项目（git-clone）"><a href="#（五）克隆项目（git-clone）" class="headerlink" title="（五）克隆项目（git clone）"></a>（五）克隆项目（<code>git clone</code>）</h3><ul><li><p>从远程仓库复制一个完整副本到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> &lt;远程仓库地址&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="（六）分支的使用"><a href="#（六）分支的使用" class="headerlink" title="（六）分支的使用"></a>（六）分支的使用</h3><p>git分支常用的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#列出所有的本地分支</span><br>git branch<br><br><span class="hljs-comment">#列出所有的远程分支</span><br>git branch -r<br><br><span class="hljs-comment">#新建一个分支，但依然停留在当前分支</span><br>git checkout -b [branch]<br><br><span class="hljs-comment">#合并指定分支到当前分支</span><br>git merge [branch]<br><br><span class="hljs-comment">#删除分支</span><br>git branch -d [branch-name]<br><br><span class="hljs-comment">#删除远程分支</span><br>git push origin --delete [branch-name]<br>git branch -dr [remote/branch]<br></code></pre></td></tr></table></figure><ul><li><p>分支的含义：</p><ul><li>分支是指向一系列提交的指针，允许你在不影响主分支的情况下进行开发工作。</li></ul></li><li><p>使用场景及操作步骤：</p><ul><li><p>功能开发：</p><ol><li>创建新分支：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch &lt;新分支名&gt;   <span class="hljs-comment">#创建新分支</span><br>git checkout -b feature/new-feature  <span class="hljs-comment">#创建一个新分支并同时切换到该分支</span><br></code></pre></td></tr></table></figure><ol start="2"><li>在新分支上开发和提交：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add.<br>git commit -m <span class="hljs-string">&quot;开发新功能的第一步&quot;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>完成开发后，将新分支合并回主分支：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout master<br><span class="hljs-comment"># 或</span><br>git checkout main<br>git merge feature/new-feature<br></code></pre></td></tr></table></figure></li><li><p>Bug 修复：</p><ol><li>创建 Bug 修复分支：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b bugfix/issue-123<br></code></pre></td></tr></table></figure><ol start="2"><li>进行 Bug 修复和提交：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add.<br>git commit -m <span class="hljs-string">&quot;修复了Bug #123&quot;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>合并到主分支：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout master<br><span class="hljs-comment"># 或</span><br>git checkout main<br>git merge bugfix/issue-123<br></code></pre></td></tr></table></figure></li><li><p>实验性开发：</p><ol><li>创建实验性分支：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b experiment/new-tech<br></code></pre></td></tr></table></figure><ol start="2"><li>进行实验性开发和提交：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add.<br>git commit -m <span class="hljs-string">&quot;尝试新的技术&quot;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>根据实验结果处理分支。</li></ol></li><li><p>多人协作：</p><ol><li>每个开发者创建自己的分支：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b developer/developer-name<br></code></pre></td></tr></table></figure><ol start="2"><li>各自在自己的分支上开发和提交：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add.<br>git commit -m <span class="hljs-string">&quot;开发者的修改&quot;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>完成开发后，将分支推送到远程：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin developer/developer-name<br></code></pre></td></tr></table></figure><ol start="4"><li>发起合并请求或合并分支。</li></ol></li></ul></li></ul><h2 id="四、完整操作流程案例"><a href="#四、完整操作流程案例" class="headerlink" title="四、完整操作流程案例"></a>四、完整操作流程案例</h2><h3 id="（一）开始一个新的项目"><a href="#（一）开始一个新的项目" class="headerlink" title="（一）开始一个新的项目"></a>（一）开始一个新的项目</h3><ol><li><strong>安装 Git</strong>：根据操作系统选择相应的安装方式。</li><li><strong>配置 Git</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;Your Name&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;your.email@example.com&quot;</span><br></code></pre></td></tr></table></figure><ol><li><strong>创建并初始化本地仓库</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> myproject<br><span class="hljs-built_in">cd</span> myproject<br>git init<br></code></pre></td></tr></table></figure><ol><li><strong>添加文件并提交</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello, Git!&quot;</span> &gt; README.md<br>git add README.md<br>git commit -m <span class="hljs-string">&quot;Initial commit&quot;</span><br></code></pre></td></tr></table></figure><ol><li><strong>创建远程仓库（以 GitHub 为例）</strong>：</li></ol><ul><li>在 GitHub 上创建一个新的仓库，获取仓库的 URL。</li></ul><ol><li><strong>关联远程仓库</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin &lt;https://github.com/yourusername/myproject.git&gt;<br></code></pre></td></tr></table></figure><ol><li><strong>将本地仓库推送到远程</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin master<br></code></pre></td></tr></table></figure><h3 id="（二）开发新功能"><a href="#（二）开发新功能" class="headerlink" title="（二）开发新功能"></a>（二）开发新功能</h3><ol><li><strong>创建新分支</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b feature/new-feature<br></code></pre></td></tr></table></figure><ol><li><strong>在新分支上开发</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is a new feature.&quot;</span> &gt; new_feature.txt<br>git add new_feature.txt<br>git commit -m <span class="hljs-string">&quot;Add new feature file&quot;</span><br></code></pre></td></tr></table></figure><ol><li><strong>更新远程分支</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin feature/new-feature<br></code></pre></td></tr></table></figure><ol><li><strong>合并新功能到主分支</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout master<br>git merge feature/new-feature<br>git push origin master<br></code></pre></td></tr></table></figure><h3 id="（三）修复-Bug"><a href="#（三）修复-Bug" class="headerlink" title="（三）修复 Bug"></a>（三）修复 Bug</h3><ol><li><strong>创建 Bug 修复分支</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b bugfix/issue-123<br></code></pre></td></tr></table></figure><ol><li><strong>修复 Bug 并提交</strong>:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 假设修改了文件 buggy_file.txt</span><br>git add buggy_file.txt<br>git commit -m <span class="hljs-string">&quot;Fix bug in buggy_file.txt&quot;</span><br></code></pre></td></tr></table></figure><ol><li><strong>更新远程分支</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin bugfix/issue-123<br></code></pre></td></tr></table></figure><ol><li><strong>合并 Bug 修复到主分支</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout master<br>git merge bugfix/issue-123<br>git push origin master<br></code></pre></td></tr></table></figure><h3 id="（四）更新本地仓库"><a href="#（四）更新本地仓库" class="headerlink" title="（四）更新本地仓库"></a>（四）更新本地仓库</h3><ul><li><p>定期使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git pull</span><br></code></pre></td></tr></table></figure><p>更新本地仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin master<br></code></pre></td></tr></table></figure></li></ul><p>通过以上操作流程和说明，你可以使用 Git 进行项目的版本控制、开发、协作等操作。根据不同的需求，灵活运用 Git 的各种功能可以帮助你更好地管理项目，提高开发效率和代码质量。</p><h3 id="五-查看和管理分支"><a href="#五-查看和管理分支" class="headerlink" title="(五) 查看和管理分支"></a>(五) 查看和管理分支</h3><ul><li><p>查看分支：</p><ul><li><p>查看本地分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch<br></code></pre></td></tr></table></figure></li><li><p>查看本地和远程分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -a<br></code></pre></td></tr></table></figure></li></ul></li><li><p>删除分支：</p><ul><li><p>删除本地分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -d branch-name<br></code></pre></td></tr></table></figure><ul><li>强制删除未合并的分支：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -D branch-name<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>在使用 Git 的过程中，根据不同的情况选择合适的操作，注意不同操作的使用场景和注意事项，避免因操作不当导致的问题。在协作开发时，尤其要注意合并和冲突的处理，确保代码的一致性和项目的顺利进行。</p><ul><li>在GitLab上克隆</li></ul><p><img src="/.com//image-20250422224803856.png" alt="image-20250422224803856"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/Docker/"/>
    <url>/2025/07/02/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-快速构建、运行、管理应用的工具"><a href="#Docker-快速构建、运行、管理应用的工具" class="headerlink" title="Docker-快速构建、运行、管理应用的工具"></a>Docker-快速构建、运行、管理应用的工具</h1><h1 id="1-入门"><a href="#1-入门" class="headerlink" title="1.入门"></a>1.入门</h1><h2 id="1-Docker安装"><a href="#1-Docker安装" class="headerlink" title="1.Docker安装"></a>1.Docker安装</h2><h3 id="Ubuntu-系统"><a href="#Ubuntu-系统" class="headerlink" title="Ubuntu 系统"></a>Ubuntu 系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 更新包列表</span><br>sudo apt update<br><span class="hljs-comment"># 安装依赖</span><br>sudo apt install apt-transport-https ca-certificates curl software-properties-common<br><span class="hljs-comment"># 添加 Docker官方 GPG 密钥</span><br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br><span class="hljs-comment">#或者阿里源（推荐使用阿里的gpg KEY）</span><br>curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg           <span class="hljs-comment">#添加 apt 源:</span><br><span class="hljs-comment"># 添加 Docker 稳定版</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null<br><span class="hljs-comment">#或者阿里apt源</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [arch=<span class="hljs-subst">$(dpkg --print-architecture)</span> signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt;/dev/null<br><span class="hljs-comment">#更新源</span><br>sudo apt<br> update<br>sudo apt-get<br> update      <br><span class="hljs-comment"># 安装 Docker Engine</span><br>sudo apt install docker-ce docker-ce-cli containerd.io<br><span class="hljs-comment"># 验证安装</span><br>sudo docker version<br><span class="hljs-comment">#查看Docker运行状态</span><br>sudo systemctl status docker<br></code></pre></td></tr></table></figure><h3 id="CentOS-系统"><a href="#CentOS-系统" class="headerlink" title="CentOS 系统"></a>CentOS 系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装依赖</span><br>sudo yum install -y yum-utils device-mapper-persistent-data lvm2<br><span class="hljs-comment"># 添加 Docker 仓库</span><br>sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<br><span class="hljs-comment"># 安装 Docker Engine</span><br>sudo yum install -y docker-ce docker-ce-cli containerd.io<br><span class="hljs-comment"># 启动并启用 Docker 服务</span><br>sudo systemctl start docker<br>sudo systemctl <span class="hljs-built_in">enable</span> docker<br><span class="hljs-comment"># 验证安装</span><br>sudo docker version<br></code></pre></td></tr></table></figure><h3 id="安装Docker命令补全工具"><a href="#安装Docker命令补全工具" class="headerlink" title="安装Docker命令补全工具"></a>安装Docker命令补全工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install bash-completion<br>sudo curl -L https://raw.githubusercontent.com/docker/docker-ce/master/components/cli/contrib/completion/bash/docker -o /etc/bash_completion.d/docker.sh<br><span class="hljs-built_in">source</span> /etc/bash_completion.d/docker.sh<br></code></pre></td></tr></table></figure><h3 id="使用阿里云镜像加速"><a href="#使用阿里云镜像加速" class="headerlink" title="使用阿里云镜像加速"></a>使用阿里云镜像加速</h3><ol><li><p>获取阿里云镜像加速地址</p><ul><li><p>登录 <a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">阿里云容器镜像服务</a>，在控制台找到你的专属镜像加速地址。</p></li><li><p>我的加速器</p><table><thead><tr><th>加速器地址</th></tr></thead><tbody><tr><td><a href="https://5vmnzx91.mirror.aliyuncs.com/">https://5vmnzx91.mirror.aliyuncs.com</a></td></tr></tbody></table></li></ul></li><li><p>配置镜像加速</p><ul><li>创建或编辑 Docker 配置文件 <code>/etc/docker/daemon.json</code>：</li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/docker/daemon.json<br></code></pre></td></tr></table></figure><ul><li>在文件中添加以下内容，将 <code>https://your-aliyun-mirror.com</code> 替换为你在阿里云获取的专属镜像加速地址：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;https://your-aliyun-mirror.com&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>最终使用的镜像：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span><br>&#123;<br>    <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>        <span class="hljs-string">&quot;https://do.nark.eu.org&quot;</span>,<br>        <span class="hljs-string">&quot;https://dc.j8.work&quot;</span>,<br>        <span class="hljs-string">&quot;https://docker.m.daocloud.io&quot;</span>,<br>        <span class="hljs-string">&quot;https://dockerproxy.com&quot;</span>,<br>        <span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,<br>        <span class="hljs-string">&quot;https://docker.nju.edu.cn&quot;</span><br>    ]<br>&#125;<br>EOF<br></code></pre></td></tr></table></figure><ul><li>保存并退出文件。</li></ul><ol><li><strong>重启 Docker 服务</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart docker<br></code></pre></td></tr></table></figure><h2 id="2-MySQL-Nginx安装"><a href="#2-MySQL-Nginx安装" class="headerlink" title="2.MySQL&#x2F;Nginx安装"></a>2.MySQL&#x2F;Nginx安装</h2><h3 id="1-MySQL"><a href="#1-MySQL" class="headerlink" title="1.MySQL"></a>1.MySQL</h3><ul><li>先停止mysql的服务</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bsah">systemctl stop mysql<br>systemctl status mysql<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 拉取 MySQL 镜像</span><br>sudo docker pull mysql:version<br><span class="hljs-comment"># 运行 MySQL 容器（示例：映射端口 3306，设置 root 密码，挂载数据卷）</span><br>sudo docker run -d \<br>  --name mysql-db \<br>  -p 3307:3306 \<br>  -e MYSQL_ROOT_PASSWORD=your_password \<br>  -v mysql-data:/var/lib/mysql \<br>  mysql:version<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker pull mysql:8<br>sudo docker run -d \<br>  --name mysql \<br>  -p 3307:3306 \<br>  -e TZ=Asia/Shanghai \<br>  -e MYSQL_ROOT_PASSWORD=052712 \<br>  mysql:8<br></code></pre></td></tr></table></figure><p><img src="/.com//image-20250325160535998.png" alt="image-20250325160535998"></p><ul><li>每个容器内部有独立的文件系统和网络环境ip地址，外部无法访问。</li><li>一个镜像可以多开多个不同的端口号和名字的容器，容器之间互不干扰</li></ul><h3 id="2-Nginx"><a href="#2-Nginx" class="headerlink" title="2.Nginx"></a>2.Nginx</h3><h4 id="拉取-Nginx-镜像"><a href="#拉取-Nginx-镜像" class="headerlink" title="拉取 Nginx 镜像"></a>拉取 Nginx 镜像</h4><p>在运行 Nginx 容器前，你得先从 Docker Hub 拉取 Nginx 镜像。在终端里输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull nginx<br></code></pre></td></tr></table></figure><p>若你需要特定版本的 Nginx，可在镜像名后面加上版本标签，例如拉取 1.25.3 版本的 Nginx：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull nginx:1.25.3<br>docker pull nginx:1.20.2<br></code></pre></td></tr></table></figure><h4 id="运行-Nginx-容器"><a href="#运行-Nginx-容器" class="headerlink" title="运行 Nginx 容器"></a>运行 Nginx 容器</h4><h5 id="简单运行"><a href="#简单运行" class="headerlink" title="简单运行"></a>简单运行</h5><p>下面的命令能让你以最简单的方式运行 Nginx 容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --name nginx -p 80:80 nginx:1.20.2<br></code></pre></td></tr></table></figure><p>命令解释：</p><ul><li><code>-d</code>：让容器在后台运行。</li><li><code>-p 80:80</code>：将主机的 80 端口映射到容器的 80 端口，这样就能通过主机的 80 端口访问 Nginx 服务。</li><li><code>--name nginx</code>：指定容器名称。</li><li><code>nginx:1.20.2</code>:指定镜像的名字、版本</li></ul><p>运行此命令后，你可以在浏览器里输入 <code>http://localhost</code> 来查看 Nginx 的默认欢迎页面。</p><h5 id="挂载配置文件和网页内容"><a href="#挂载配置文件和网页内容" class="headerlink" title="挂载配置文件和网页内容"></a>挂载配置文件和网页内容</h5><p>如果你想自定义 Nginx 的ngin配置和网页内容，可以通过挂载主机目录到容器的方式实现。以下是具体示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建本地配置文件和网页内容目录</span><br><span class="hljs-built_in">mkdir</span> -p ~/nginx/conf ~/nginx/html<br><br><span class="hljs-comment"># 在 ~/nginx/html 目录下创建一个简单的 HTML 文件</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;h1&gt;Hello, Docker Nginx!&lt;/h1&gt;&quot;</span> &gt; ~/nginx/html/index.html<br><br><span class="hljs-comment"># 在 ~/nginx/conf 目录下创建一个简单的 Nginx 配置文件</span><br><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF &gt; ~/nginx/conf/nginx.conf</span><br><span class="hljs-string">user  nginx;</span><br><span class="hljs-string">worker_processes  1;</span><br><span class="hljs-string"></span><br><span class="hljs-string">error_log  /var/log/nginx/error.log warn;</span><br><span class="hljs-string">pid        /var/run/nginx.pid;</span><br><span class="hljs-string"></span><br><span class="hljs-string">events &#123;</span><br><span class="hljs-string">    worker_connections  1024;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">http &#123;</span><br><span class="hljs-string">    include       /etc/nginx/mime.types;</span><br><span class="hljs-string">    default_type  application/octet-stream;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    log_format  main  &#x27;\$remote_addr - \$remote_user [\$time_local] &quot;\$request&quot; &#x27;</span><br><span class="hljs-string">                      &#x27;\$status \$body_bytes_sent &quot;\$http_referer&quot; &#x27;</span><br><span class="hljs-string">                      &#x27;&quot;\$http_user_agent&quot; &quot;\$http_x_forwarded_for&quot;&#x27;;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    access_log  /var/log/nginx/access.log  main;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    sendfile        on;</span><br><span class="hljs-string">    #tcp_nopush     on;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    keepalive_timeout  65;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    #gzip  on;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    server &#123;</span><br><span class="hljs-string">        listen       80;</span><br><span class="hljs-string">        server_name  localhost;</span><br><span class="hljs-string"></span><br><span class="hljs-string">        location / &#123;</span><br><span class="hljs-string">            root   /usr/share/nginx/html;</span><br><span class="hljs-string">            index  index.html index.htm;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">        error_page   500 502 503 504  /50x.html;</span><br><span class="hljs-string">        location = /50x.html &#123;</span><br><span class="hljs-string">            root   /usr/share/nginx/html;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-comment"># 运行 Nginx 容器并挂载目录</span><br>docker run -d -p 80:80 \<br>  -v ~/nginx/html:/usr/share/nginx/html \<br>  -v ~/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \<br>  nginx<br></code></pre></td></tr></table></figure><p>命令解释：</p><ul><li><code>-v ~/nginx/html:/usr/share/nginx/html</code>：把主机的 <code>~/nginx/html</code> 目录挂载到容器的 <code>/usr/share/nginx/html</code> 目录，这样主机上的网页内容就能在容器里被访问。</li><li><code>-v ~/nginx/conf/nginx.conf:/etc/nginx/nginx.conf</code>：将主机的 <code>~/nginx/conf/nginx.conf</code> 文件挂载到容器的 <code>/etc/nginx/nginx.conf</code> 文件，实现对 Nginx 配置的自定义。</li></ul><h4 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h4><p>在浏览器中输入 <code>http://localhost</code>，若看到 <code>Hello, Docker Nginx!</code> 字样，就表明 Nginx 已成功安装并运行。</p><h4 id="停止和删除容器"><a href="#停止和删除容器" class="headerlink" title="停止和删除容器"></a>停止和删除容器</h4><p>若你想停止并删除运行的 Nginx 容器，可使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看运行的容器 ID</span><br>docker ps<br><br><span class="hljs-comment"># 停止容器，假设容器 ID 是 abc123,也可以根据容器的名字</span><br>docker stop abc123<br>docker stop nginx<br><span class="hljs-comment"># 删除容器</span><br>docker <span class="hljs-built_in">rm</span> abc123<br>docker <span class="hljs-built_in">rm</span> nginx<br></code></pre></td></tr></table></figure><h2 id="3-命令解读"><a href="#3-命令解读" class="headerlink" title="3.命令解读"></a>3.命令解读</h2><ul><li><p><code>docker run</code>：创建运行一个容器（<code>-d</code> 表示后台运行，<code>-p</code> 映射端口，<code>-v</code> 挂载卷）。</p></li><li><p><code>docker ps</code>：查看正在运行的容器（<code>-a</code> 查看所有容器）。</p></li><li><p><code>docker start 容器名/ID</code>：运行容器。</p></li><li><p><code>docker stop 容器名/ID</code>：停止容器。</p></li><li><p><code>docker restart 容器名/ID</code>：重启容器。</p></li><li><p><code>docker rm 容器名/ID</code>：删除容器。</p></li><li><p><code>docker logs</code>:查看容器的运行日志（<code>-f</code>:实时刷新尾部的日志）</p></li><li><p><code>docker images</code>：查看本地镜像。</p></li><li><p><code>docker pull 镜像名/镜像名:版本</code>：拉取远程镜像。</p></li><li><p><code>docker push 镜像名/镜像名:版本</code>：推送镜像到仓库。</p></li><li><p><code>docker exec -it 容器名 bash</code>:进入容器交互终端的命令</p></li><li><p><code>exit</code>:退出容器终端返回宿主机</p></li></ul><h1 id="2-核心"><a href="#2-核心" class="headerlink" title="2.核心"></a>2.核心</h1><h2 id="1-常见命令"><a href="#1-常见命令" class="headerlink" title="1.常见命令"></a>1.常见命令</h2><ul><li><p>容器操作</p><p><img src="/.com//image-20250325161406317.png" alt="image-20250325161406317"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps <span class="hljs-comment">#查看正在运行的容器（`-a` 查看所有容器）。</span><br>docker start &lt;容器名/ID&gt;   <span class="hljs-comment"># 启动容器</span><br>docker stop &lt;容器名/ID&gt;    <span class="hljs-comment">#停止容器。</span><br>docker restart &lt;容器名/ID&gt; <span class="hljs-comment"># 重启容器</span><br>docker <span class="hljs-built_in">rm</span> &lt;容器名/ID&gt;       <span class="hljs-comment">#删除容器。</span><br>docker <span class="hljs-built_in">exec</span> -it &lt;容器名/ID&gt; bash <span class="hljs-comment"># 进入容器终端</span><br>docker inspect &lt;容器名/ID&gt;  <span class="hljs-comment">#查看容器详细信息</span><br><span class="hljs-built_in">exit</span> <span class="hljs-comment">#退出容器终端返回宿主机</span><br></code></pre></td></tr></table></figure></li><li><p>镜像操作</p><p><img src="/.com//image-20250325161056339.png" alt="image-20250325161056339"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t my-image . <span class="hljs-comment"># 根据当前目录的 Dockerfile 构建镜像</span><br>docker save -o nginx-1.20.2.tar nginx:1.20.2  <span class="hljs-comment">#将镜像保存为文件</span><br>docker load -i nginx-1.20.2.tar <span class="hljs-comment">#将文件恢复为镜像nginx:1.20.2</span><br>docker rmi &lt;镜像名/ID&gt;     <span class="hljs-comment"># 删除镜像</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-数据卷挂载"><a href="#2-数据卷挂载" class="headerlink" title="2.数据卷挂载"></a>2.数据卷挂载</h2><ul><li>容器内部目录 exec -it &lt;容器名&#x2F;容器Id&gt; bash  进入容器内部控制台  容器内部只有必须的系统函数，没有vi编辑器。</li><li>创建数据卷，容器创建时挂载该数据卷，则可以获取该数据卷的资源。-如nginx容器的静态资源</li></ul><p><img src="/.com//image-20250325164946522.png" alt="image-20250325164946522"></p><p><img src="/.com//image-20250325165008027.png" alt="image-20250325165008027"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建命名数据卷并挂载到容器</span><br>docker run -d \<br>  --name my-app \<br>  -v my-volume:/app/data \<br>  my-image<br></code></pre></td></tr></table></figure><p><img src="/.com//image-20250325165155393.png" alt="image-20250325165155393"></p><p><img src="/.com//image-20250522205642563.png" alt="image-20250522205642563"></p><h2 id="3-本地目录挂载"><a href="#3-本地目录挂载" class="headerlink" title="3.本地目录挂载"></a>3.本地目录挂载</h2><p><img src="/.com//image-20250325175646630.png" alt="image-20250325175646630"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将主机目录 /host/path 挂载到容器的 /container/path</span><br>docker run -d \<br>  --name my-app \<br>  -v /host/path:/container/path \<br>  my-image<br></code></pre></td></tr></table></figure><p><img src="/.com//image-20250325180040568.png" alt="image-20250325180040568"></p><p>data和conf为空，init存放数据库执行脚本，将这三个文件从window传入到linux创建的&#x2F;root&#x2F;mysql&#x2F;目录下，最后进行容器的创建和挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d \<br>--name mysql\<br> -p 3307:3306 \<br>  -e TZ=Asia/Shanghai \<br>  -e MYSQL_ROOT_PASSWORD=052712 \<br>  -v /root/mysql/data:/var/lib/mysql<br>  -v /root/mysql/init:/docker-entrypoint-initdb.d<br>  -v /root/mysql/conf:/etc/mysql/conf.d<br>  mysql:8<br></code></pre></td></tr></table></figure><h2 id="4-自定义镜像"><a href="#4-自定义镜像" class="headerlink" title="4.自定义镜像"></a>4.自定义镜像</h2><p><img src="/.com//image-20250325205844855.png" alt="image-20250325205844855"></p><p><img src="/.com//image-20250325210246223.png" alt="image-20250325210246223"></p><h3 id="编写-Dockerfile来描述镜像结构"><a href="#编写-Dockerfile来描述镜像结构" class="headerlink" title="编写 Dockerfile来描述镜像结构"></a>编写 Dockerfile来描述镜像结构</h3><p><img src="/.com//image-20250325210339406.png" alt="image-20250325210339406"></p><p><img src="/.com//image-20250326103306692.png" alt="image-20250326103306692"></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">22.04</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> jdk22.tar.gz /usr/local/</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> tar -xzf /usr/local/jdk22.tar.gz -C /usr/local/ &amp;&amp; <span class="hljs-built_in">rm</span> /usr/local/jdk22.tar.gz</span><br><span class="hljs-keyword">ENV</span> JAVA_HOME=/usr/local/jdk-<span class="hljs-number">22.0</span>.<span class="hljs-number">2</span><br><span class="hljs-keyword">ENV</span> PATH=$JAVA_HOME/bin:$PATH<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> -p /app</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> app.jar app.jar</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;app/app.&quot;</span>]</span><br></code></pre></td></tr></table></figure><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p><img src="/.com//image-20250326103329667.png" alt="image-20250326103329667"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t myImage:1.0 .<br></code></pre></td></tr></table></figure><p><img src="/.com//image-20250326103850999.png" alt="image-20250326103850999"></p><h2 id="5-网络-容器间通信"><a href="#5-网络-容器间通信" class="headerlink" title="5.网络 -容器间通信"></a>5.网络 -容器间通信</h2><p><img src="/.com//image-20250326105126284.png" alt="image-20250326105126284"></p><ul><li><p>容器之间通过Docker分配的IP地址实现通信。但是容器的IP地址是随机的，所以容器重新启动后要实现通信需要修改配置文件指定对应IP地址，操作繁琐。</p></li><li><p>通过自定义网络之间根据容器的名字来实现通信</p></li></ul><p><img src="/.com//image-20250326105439888.png" alt="image-20250326105439888"></p><ul><li>docker 容器默认三块网卡，创建的网络默认桥接模式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network create 网络名字<br></code></pre></td></tr></table></figure><p><img src="/.com//image-20250326120649144.png" alt="image-20250326120649144"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network connect 网络名字 容器名字<br></code></pre></td></tr></table></figure><p>如果先创建容器后再加入网络，对应的容器会有两个网络，一个是创建时分配的默认bridge，一个时后面加入的网络</p><p>在创建的时候指定网络</p><p><img src="/.com//image-20250326121245841.png" alt="image-20250326121245841"></p><h1 id="3-部署"><a href="#3-部署" class="headerlink" title="3.部署"></a>3.部署</h1><h2 id="1-服务端部署"><a href="#1-服务端部署" class="headerlink" title="1.服务端部署"></a>1.服务端部署</h2><p><img src="/.com//image-20250326105938622.png" alt="image-20250326105938622"></p><ul><li>本地目录挂载MySQL容器</li><li>修改Java应用的配置文件，数据库连接的url改为MySQL容器名字和容器内的的端口</li><li>修改Java应用的logback日志文件存放地址</li><li>打包成jar包，准备对应版本jdk安装包，编写Dockerfile文件，最后一并上传到指定的Linux系统的对应目录，在该目录构建Docker容器</li><li>部署Docker容器到创建好的docker网络</li></ul><blockquote><ul><li>Dockerfile模板</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">&gt;<span class="hljs-comment">#基础镜像</span><br>&gt;<span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">22.04</span><br><br>&gt;<span class="hljs-comment">#添加jdk 到镜像工作(从dockerfile文件所在目录)</span><br>&gt;<span class="hljs-comment">#一开始镜像工作目录默认在root目录下</span><br>&gt;<span class="hljs-keyword">COPY</span><span class="language-bash"> jdk22.tar.gz /usr/local/</span><br>&gt;<span class="hljs-keyword">RUN</span><span class="language-bash"> tar -xfz /usr/local/jdk22.tar.gz -C /usr/local/ &amp;&amp; <span class="hljs-built_in">rm</span> /usr/local/jdk.22.tar.gz</span><br><br>&gt;<span class="hljs-comment">#设置环境变量</span><br>&gt;<span class="hljs-keyword">ENV</span> JAVA_HOME=/usr/local/jdk-<span class="hljs-number">22.0</span>.<span class="hljs-number">4</span> <span class="hljs-comment">#解压后的jdk文件路径</span><br>&gt;<span class="hljs-keyword">ENV</span> PATH=$JAVA_HOME/bin:$PATH<br>&gt;<span class="hljs-comment">#配置OSS环境密钥</span><br>&gt;<span class="hljs-keyword">ENV</span> OSS_ACCESS_KEY_ID=...<br>&gt;<span class="hljs-keyword">ENV</span> OSS_ACCESS_KEY_SECRET=...<br>&gt;<span class="hljs-comment">#统一编码</span><br>&gt;<span class="hljs-keyword">ENV</span> LANG=en_US.UTF-<span class="hljs-number">8</span><br>&gt;<span class="hljs-keyword">ENV</span> LANGUAGE=en_US:en<br>&gt;<span class="hljs-keyword">ENV</span> LC_ALL=en_US.UTF-<span class="hljs-number">8</span><br><br>&gt;<span class="hljs-comment">#创建应用目录</span><br>&gt;<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> -p /tlias</span><br>&gt;<span class="hljs-comment">#切换工作目录</span><br>&gt;<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /tlias</span><br><br>&gt;<span class="hljs-comment">#复制jar文件到镜像(从dockerfile文件所在目录)</span><br>&gt;<span class="hljs-keyword">COPY</span><span class="language-bash"> tlias.jar tlias.jar</span><br><br>&gt;<span class="hljs-comment">#暴录端口信息</span><br>&gt;<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><br>&gt;<span class="hljs-comment">#运行命令</span><br>&gt;<span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;/tlias/tlias.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="2-前端部署"><a href="#2-前端部署" class="headerlink" title="2.前端部署"></a>2.前端部署</h2><p><img src="/.com//image-20250326113122869.png" alt="image-20250326113122869"></p><ul><li>本地编写nginx.conf文件，将反向代理指定为容器名字：容器端口</li><li>将编写好的nginx.conf文件和html静态资源目录一并放到Linux下的&#x2F;root&#x2F;tlias-nginx&#x2F;目录下</li><li>本地目录数据卷挂载创建容器</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts">dockerrun-d\<br>--name nginx-tlias\<br>v<span class="hljs-keyword">/root/</span>tlias-nginx/html:<span class="hljs-keyword">/usr/</span>share<span class="hljs-keyword">/nginx/</span>html\<br>v<span class="hljs-keyword">/root/</span>tlias-nginx<span class="hljs-keyword">/conf/</span>nginx.conf:<span class="hljs-keyword">/etc/</span>nginx/nginx.conf\<br>-networkitheima\<br>-p <span class="hljs-number">80</span>:<span class="hljs-number">80</span>\<br><span class="hljs-symbol">nginx:</span><span class="hljs-number">1.20</span><span class="hljs-number">.2</span><br></code></pre></td></tr></table></figure><h2 id="3-DockerCompose"><a href="#3-DockerCompose" class="headerlink" title="3.DockerCompose"></a>3.DockerCompose</h2><p><img src="/.com//image-20250326114352166.png" alt="image-20250326114352166"></p><p><img src="/.com//image-20250326114529244.png" alt="image-20250326114529244"></p><p><img src="/.com//image-20250326114720143.png" alt="image-20250326114720143"></p><ul><li>案例</li></ul><p><img src="/.com//image-20250326114736971.png" alt="image-20250326114736971"></p><p>注意networks:指定网络名字tlias-net </p><p>然后再services平级映射具体的网络</p><p><img src="/.com//image-20250326115616308.png" alt="image-20250326115616308"></p><p>服务端镜像需要自己构建，依赖指定后，会根据依赖关系先后构建容器</p><p><img src="/.com//image-20250326115707124.png" alt="image-20250326115707124"></p><p><img src="/.com//image-20250326115813781.png" alt="image-20250326115813781"></p><p>创建app目录把资源全部上传至该目录</p><p><img src="/.com//image-20250326120100395.png" alt="image-20250326120100395"></p><p><img src="/.com//image-20250326120002264.png" alt="image-20250326120002264"></p><p><img src="/.com//image-20250326120023269.png" alt="image-20250326120023269"></p><ul><li>DockerCompose命令</li></ul><p><img src="/.com//image-20250326120144615.png" alt="image-20250326120144615"></p><p>工作目录切换至&#x2F;usr&#x2F;local&#x2F;app&#x2F;</p><p><strong>目录一定要有docker-compose.yml文件</strong></p><p>在当前目录创建并且启动所有的service容器、网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker compose up -d<br></code></pre></td></tr></table></figure><p>在当前目录停止并移出所以容器、网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker compose down<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/07/02/cc++/"/>
    <url>/2025/07/02/cc++/</url>
    
    <content type="html"><![CDATA[<h1 id="c-c"><a href="#c-c" class="headerlink" title="c&#x2F;c++"></a>c&#x2F;c++</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1-C-中获取数组的长度"><a href="#1-C-中获取数组的长度" class="headerlink" title="1. C++ 中获取数组的长度"></a>1. C++ 中获取数组的长度</h3><p>在 C++ 里，获取数组长度的方法会因数组类型（普通数组、<code>std::array</code>、<code>std::vector</code>）而有所不同。</p><h4 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h4><p>对于普通数组，可借助 <code>sizeof</code> 运算符来计算数组长度。<code>sizeof</code> 能返回数组所占的总字节数，用总字节数除以单个元素的字节数，就能得到数组的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> length = <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;数组长度: &quot;</span> &lt;&lt; length &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a><code>std::array</code></h4><p><code>std::array</code> 是 C++ 标准库提供的固定大小数组容器，它有 <code>size()</code> 成员函数可直接获取数组长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::array&lt;<span class="hljs-type">int</span>, 5&gt; arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> length = arr.<span class="hljs-built_in">size</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;数组长度: &quot;</span> &lt;&lt; length &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="std-vector"><a href="#std-vector" class="headerlink" title="std::vector"></a><code>std::vector</code></h4><p><code>std::vector</code> 是动态数组容器，同样有 <code>size()</code> 成员函数来获取数组长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> length = vec.<span class="hljs-built_in">size</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;数组长度: &quot;</span> &lt;&lt; length &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-C-数组和-Java-数组的区别"><a href="#2-C-数组和-Java-数组的区别" class="headerlink" title="2. C++ 数组和 Java 数组的区别"></a>2. C++ 数组和 Java 数组的区别</h3><h4 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h4><ul><li><p>C++</p><p>：</p><ul><li>普通数组声明时要指定大小，也能在声明时进行初始化。</li><li><code>std::array</code> 需指定大小和元素类型。</li><li><code>std::vector</code> 可动态调整大小，初始化方式多样。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 普通数组</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">// std::array</span><br>std::array&lt;<span class="hljs-type">int</span>, 5&gt; arr2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">// std::vector</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>Java</strong>：数组声明和初始化有多种方式，且数组大小可在运行时确定。- java中一切都是引用对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明并初始化数组</span><br><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">// 先声明，再分配空间</span><br><span class="hljs-type">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><ul><li>**C++**：普通数组的内存分配在栈上，<code>std::vector</code> 和 <code>std::array</code> 的内存管理由标准库负责。若使用 <code>new</code> 动态分配数组，需用 <code>delete[]</code> 手动释放内存。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br><span class="hljs-comment">// 使用数组</span><br><span class="hljs-keyword">delete</span>[] arr; <span class="hljs-comment">// 手动释放内存</span><br></code></pre></td></tr></table></figure><ul><li><strong>Java</strong>：数组内存分配在堆上，Java 的垃圾回收机制会自动管理内存，无需手动释放。</li></ul><h4 id="边界检查"><a href="#边界检查" class="headerlink" title="边界检查"></a>边界检查</h4><ul><li>**C++**：普通数组不会进行边界检查，访问越界可能导致未定义行为。<code>std::vector</code> 和 <code>std::array</code> 可使用 <code>at()</code> 方法进行边界检查，越界时会抛出 <code>std::out_of_range</code> 异常。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">try</span> &#123;<br>    std::cout &lt;&lt; vec.<span class="hljs-built_in">at</span>(<span class="hljs-number">5</span>) &lt;&lt; std::endl;<br>&#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::out_of_range&amp; e) &#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;越界访问: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>Java</strong>：数组会进行边界检查，访问越界会抛出 <code>ArrayIndexOutOfBoundsException</code> 异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">try</span> &#123;<br>    System.out.println(arr[<span class="hljs-number">5</span>]);<br>&#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;<br>    System.err.println(<span class="hljs-string">&quot;越界访问: &quot;</span> + e.getMessage());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-C-字符串和-Java-字符串的区别"><a href="#3-C-字符串和-Java-字符串的区别" class="headerlink" title="3. C++ 字符串和 Java 字符串的区别"></a>3. C++ 字符串和 Java 字符串的区别</h3><h4 id="类型和表示"><a href="#类型和表示" class="headerlink" title="类型和表示"></a>类型和表示</h4><ul><li>**C++**：有 C 风格字符串（以 <code>&#39;\0&#39;</code> 结尾的字符数组）和 <code>std::string</code> 类。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C 风格字符串</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cstr = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-comment">// std::string</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br>std::string str = <span class="hljs-string">&quot;Hello&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li><strong>Java</strong>：字符串由 <code>String</code> 类表示，是不可变对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h4><ul><li>**C++**：<code>std::string</code> 是可变的，可通过成员函数修改字符串内容。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string str = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    str += <span class="hljs-string">&quot; World&quot;</span>;<br>    std::cout &lt;&lt; str &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>Java</strong>：<code>String</code> 类是不可变的，若要修改字符串，可使用 <code>StringBuilder</code> 或 <code>StringBuffer</code> 类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>sb.append(<span class="hljs-string">&quot; World&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sb.toString();<br>System.out.println(str);<br></code></pre></td></tr></table></figure><h4 id="操作和方法"><a href="#操作和方法" class="headerlink" title="操作和方法"></a>操作和方法</h4><ul><li>**C++**：<code>std::string</code> 类提供了丰富的成员函数，如 <code>length()</code>、<code>substr()</code>、<code>find()</code> 等。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string str = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;字符串长度: &quot;</span> &lt;&lt; str.<span class="hljs-built_in">length</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>Java</strong>：<code>String</code> 类也有很多方法，如 <code>length()</code>、<code>substring()</code>、<code>indexOf()</code> 等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>System.out.println(<span class="hljs-string">&quot;字符串长度: &quot;</span> + str.length());<br></code></pre></td></tr></table></figure><h4 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h4><ul><li>**C++**：<code>std::string</code> 的内存管理由标准库负责，会自动处理内存分配和释放。</li><li><strong>Java</strong>：<code>String</code> 对象的内存由 Java 虚拟机的垃圾回收机制管理。</li></ul><h2 id="c-enum-枚举"><a href="#c-enum-枚举" class="headerlink" title="c enum(枚举)"></a>c enum(枚举)</h2><p>枚举是c语言的一种基本数据类型，用于定义一组具有离散值得常量，它可以让数据更简洁，更易读。枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性。</p><p>定义一个枚举类型，需要使用 <code>enum</code>关键字，后面跟着枚举类型的名称，以及用大括号 <strong>{}</strong> 括起来的一组枚举常量。每个枚举常量可以用一个标识符来表示，也可以为它们指定一个整数值，如果没有指定，那么默认从 <strong>0</strong> 开始递增。</p><p>枚举语法定义格式为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">enum</span>　枚举名　&#123;枚举元素<span class="hljs-number">1</span>,枚举元素<span class="hljs-number">2</span>,……&#125;;<br></code></pre></td></tr></table></figure><p>接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MON 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TUe 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WED 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THU 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FRI 5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SAT 6</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SUN 7</span><br></code></pre></td></tr></table></figure><p>这个看起来代码量就比较多，接下来我们看看使用枚举的方式：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">enum DAY<br>&#123;<br>      <span class="hljs-attribute">MON</span>=1, TUE, WED, THU, FRI, SAT, SUN<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样看起来是不是更简洁了。</p><p><strong>注意：</strong>第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。</p><h3 id="枚举变量的定义"><a href="#枚举变量的定义" class="headerlink" title="枚举变量的定义"></a>枚举变量的定义</h3><p>前面我们只是声明了枚举类型，接下来我们看看如何定义枚举变量。</p><p>我们可以通过以下三种方式来定义枚举变量</p><p><strong>1、先定义枚举类型，再定义枚举变量</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">enum <span class="hljs-built_in">DAY</span><br>&#123;<br>      MON=<span class="hljs-number">1</span>, TUE, WED, THU, FRI, SAT, SUN<br>&#125;;<br>enum <span class="hljs-built_in">DAY</span> <span class="hljs-built_in">day</span>;<br></code></pre></td></tr></table></figure><p><strong>2、定义枚举类型的同时定义枚举变量</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">enum <span class="hljs-built_in">DAY</span><br>&#123;<br>      MON=<span class="hljs-number">1</span>, TUE, WED, THU, FRI, SAT, SUN<br>&#125; <span class="hljs-built_in">day</span>;<br></code></pre></td></tr></table></figure><p><strong>3、省略枚举名称，直接定义枚举变量</strong></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">enum</span><br>&#123;<br>      MON=<span class="hljs-number">1</span>, TUE, WED, THU, FRI, SAT, SUN<br>&#125; <span class="hljs-built_in">day</span>;<br></code></pre></td></tr></table></figure><p>一般直接用第三种</p><blockquote><p>在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 语言规范是没有办法遍历枚举类型的。</p><p>不过在一些特殊的情况下，枚举类型必须连续是可以实现有条件的遍历。</p></blockquote><p>以下实例使用 for 来遍历枚举的元素：</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>#include &lt;stdio.h&gt;  enum DAY {      MON&#x3D;1, TUE, WED, THU, FRI, SAT, SUN } day; int main() {    &#x2F;&#x2F; 遍历枚举元素    for (day &#x3D; MON; day &lt;&#x3D; SUN; day++) {        printf(“枚举元素：%d \n”, day);    } }</p><p>以上实例输出结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">枚举元素：1 <br>枚举元素：2 <br>枚举元素：3 <br>枚举元素：4 <br>枚举元素：5 <br>枚举元素：6 <br>枚举元素：7<br></code></pre></td></tr></table></figure><p>以下枚举类型不连续，这种枚举无法遍历。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">enum</span><br>&#123;<br>    ENUM_0,<br>    ENUM_10 = <span class="hljs-number">10</span>,<br>    ENUM_11<br>&#125;;<br></code></pre></td></tr></table></figure><p>枚举在 switch 中的使用：</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">color</span> &#123; red=<span class="hljs-number">1</span>, green, blue &#125;;<br> <br>    <span class="hljs-keyword">enum</span>  <span class="hljs-title class_">color</span> favorite_color;<br> <br>    <span class="hljs-comment">/* 用户输入数字来选择颜色 */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入你喜欢的颜色: (1. red, 2. green, 3. blue): &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%u&quot;</span>, &amp;favorite_color);<br> <br>    <span class="hljs-comment">/* 输出结果 */</span><br>    <span class="hljs-keyword">switch</span> (favorite_color)<br>    &#123;<br>    <span class="hljs-keyword">case</span> red:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你喜欢的颜色是红色&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> green:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你喜欢的颜色是绿色&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> blue:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你喜欢的颜色是蓝色&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你没有选择你喜欢的颜色&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><p>以上实例输出结果为：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs processing">请输入你喜欢的颜色: (<span class="hljs-number">1.</span> <span class="hljs-built_in">red</span>, <span class="hljs-number">2.</span> <span class="hljs-built_in">green</span>, <span class="hljs-number">3.</span> <span class="hljs-built_in">blue</span>): <span class="hljs-number">1</span><br>你喜欢的颜色是红色<br></code></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>在 C 和 C++ 中，指针是一种非常强大但也相对复杂的概念。以下是对指针的详细解释：</p><h3 id="一、指针的概念"><a href="#一、指针的概念" class="headerlink" title="一、指针的概念"></a><strong>一、指针的概念</strong></h3><p>指针是一个变量，它存储的是另一个变量的内存地址。通过指针，可以间接访问和操作所指向的变量。</p><p>例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> = <span class="hljs-number">10</span>; <br><span class="hljs-built_in">int</span> *ptr = &amp;<span class="hljs-built_in">num</span>;<br></code></pre></td></tr></table></figure><p>这里，<code>ptr</code>是一个指向<code>int</code>类型变量的指针，它存储了变量<code>num</code>的地址。</p><h3 id="二、指针的类型"><a href="#二、指针的类型" class="headerlink" title="二、指针的类型"></a><strong>二、指针的类型</strong></h3><p>指针的类型决定了它可以指向哪种类型的变量。例如，<code>int *</code>类型的指针只能指向<code>int</code>类型的变量，<code>char *</code>类型的指针只能指向<code>char</code>类型的变量等。</p><h3 id="三、指针的操作"><a href="#三、指针的操作" class="headerlink" title="三、指针的操作"></a><strong>三、指针的操作</strong></h3><ol><li>取地址（&amp;）运算符：用于获取变量的地址。例如，<code>&amp;num</code>返回变量<code>num</code>的地址。</li><li>解引用（*）运算符：用于访问指针所指向的变量。例如，<code>*ptr</code>表示访问指针<code>ptr</code>所指向的变量。</li><li>指针的赋值：可以将一个指针赋值给另一个同类型的指针。例如，<code>int *ptr2 = ptr;</code>。</li><li>指针的算术运算：可以对指针进行加法和减法运算。指针加上或减去一个整数，实际上是在内存中向前或向后移动相应数量的字节，具体移动的字节数取决于指针所指向的类型的大小。例如，如果<code>ptr</code>是一个指向<code>int</code>类型的指针，<code>ptr + 1</code>将指向内存中的下一个<code>int</code>类型的变量。</li></ol><h3 id="四、指针的作用"><a href="#四、指针的作用" class="headerlink" title="四、指针的作用"></a><strong>四、指针的作用</strong></h3><h4 id="4-1动态内存分配："><a href="#4-1动态内存分配：" class="headerlink" title="4.1动态内存分配："></a>4.1动态内存分配：</h4><p>通过指针，可以在程序运行时动态地分配内存。例如，使用<code>malloc</code>或<code>new</code>函数可以在堆上分配内存，并返回一个指向分配的内存的指针。</p><p>在 C 和 C++ 中，<code>malloc</code>和<code>new</code>确实可以在堆上分配内存并返回指向分配内存的指针。</p><h5 id="一、C-语言中的malloc"><a href="#一、C-语言中的malloc" class="headerlink" title="一、C 语言中的malloc"></a><strong>一、C 语言中的<code>malloc</code></strong></h5><ol><li><pre><code class="hljs">malloc<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>函数的原型是<br><br></code></pre></td></tr></table></figure>void *malloc(size_t size)<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>，它接受一个参数，表示要分配的字节数，并返回一个指向分配的内存的指针，类型为<br><br></code></pre></td></tr></table></figure>void *<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>   ，可以通过类型转换将其转换为任何所需的指针类型。<br><br>   - 例如：`<span class="hljs-type">int</span> *ptr = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));`，这里分配了足够存储一个整数的内存，并将指针转换为`<span class="hljs-type">int</span> *`类型。<br><br><span class="hljs-number">2.</span> 使用<br><br></code></pre></td></tr></table></figure>malloc<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br>   分配的内存不会自动初始化。内存中的内容是未定义的，在使用之前可能需要进行初始化。<br><br><span class="hljs-bullet">   -</span> 例如：<span class="hljs-code">`*ptr = 10;`</span>，在使用指针之前，将整数 10 存储在分配的内存中。<br><br><span class="hljs-bullet">3.</span> 当不再需要使用由<br><br></code></pre></td></tr></table></figure>malloc<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>分配的内存时，必须使用<br><br></code></pre></td></tr></table></figure>free<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>   函数释放内存，以避免内存泄漏。<br><br>   - 例如：`free(ptr)<span class="hljs-comment">;`，释放之前分配的内存。</span><br><br><br><br>##### **二、C++ 中的`new`**<br><br><br><br><span class="hljs-number">1</span>. ```<br>   <span class="hljs-keyword">new</span><br></code></pre></td></tr></table></figure>运算符有多种用法。可以使用<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">new</span><br></code></pre></td></tr></table></figure>来分配单个对象、数组或动态分配内存并调用构造函数进行初始化。- 例如：`int *ptr = new int;`，分配一个整数的内存，并调用默认构造函数进行初始化（如果有）。也可以使用`new int(10);`来初始化分配的整数为 10。- 对于数组：`int *arr = new int[5];`，分配一个包含 5 个整数的数组。</code></pre></li><li><p>与</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">malloc</span><br></code></pre></td></tr></table></figure><p>不同，</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">new</span><br></code></pre></td></tr></table></figure><p>在分配内存时会根据对象的类型自动调用适当的构造函数进行初始化。如果对象有构造函数参数，可以在</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">new</span><br></code></pre></td></tr></table></figure><p>表达式中提供这些参数。</p><ul><li>例如：<code>class MyClass &#123; public: MyClass(int value) &#123; /*... */ &#125; &#125;; MyClass *obj = new MyClass(10);</code>，创建一个<code>MyClass</code>对象并初始化为值 10。</li></ul></li><li><p>当使用</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">new</span><br></code></pre></td></tr></table></figure><p>分配的对象不再需要时，应该使用</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">delete</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">delete</span>[]<br></code></pre></td></tr></table></figure><p>来释放内存，具体取决于分配的是单个对象还是数组。</p><ul><li>例如：<code>delete ptr;</code>释放单个对象的内存。<code>delete[] arr;</code>释放数组的内存</li></ul></li></ol><h4 id="4-2函数参数传递："><a href="#4-2函数参数传递：" class="headerlink" title="4.2函数参数传递："></a>4.2函数参数传递：</h4><p>指针可以作为函数的参数传递，这样可以在函数内部修改外部变量的值。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">(<span class="hljs-type">int</span> *num)</span> &#123;<br>    (*num)++;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br>    increment(&amp;n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, n); <span class="hljs-comment">// 输出 11</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3数组和指针的关系："><a href="#4-3数组和指针的关系：" class="headerlink" title="4.3数组和指针的关系："></a>4.3数组和指针的关系：</h4><p>在 C 和 C++ 中，数组名实际上是一个指向数组第一个元素的指针。例如，对于数组<code>int arr[5]</code>，<code>arr</code>和<code>&amp;arr[0]</code>是等价的，都表示指向数组第一个元素的指针。可以使用指针来遍历数组。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> *ptr = arr;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *(ptr + i));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4数据结构："><a href="#4-4数据结构：" class="headerlink" title="4.4数据结构："></a>4.4数据结构：</h4><p>指针在实现各种数据结构（如链表、树、图等）中起着关键作用。通过指针，可以将不同的节点连接起来，构建复杂的数据结构。</p><h3 id="五、指针的注意事项"><a href="#五、指针的注意事项" class="headerlink" title="五、指针的注意事项"></a><strong>五、指针的注意事项</strong></h3><ol><li>空指针：指针可以被初始化为<code>NULL</code>（在 C++ 中是<code>nullptr</code>），表示它不指向任何有效的内存地址。在使用指针之前，应该检查它是否为<code>NULL</code>，以避免访问无效的内存地址。</li><li>内存泄漏：如果使用动态内存分配函数（如<code>malloc</code>或<code>new</code>）分配了内存，但在不再需要时没有释放，就会导致内存泄漏。应该在适当的时候使用<code>free</code>或<code>delete</code>函数释放动态分配的内存。</li><li>指针越界：访问指针所指向的内存范围之外的地址是危险的，可能会导致程序崩溃或产生不可预测的结果。在使用指针进行数组访问或其他操作时，要确保指针不越界。</li><li>指针的类型转换：在进行指针类型转换时要小心，确保转换是合法的并且不会导致错误的内存访问。</li></ol><p>指针是 C 和 C++ 中非常强大的工具，但也需要谨慎使用，以避免出现错误和安全问题。</p><h3 id="六-指针在-C-和-C-中有很多复杂的应用场景，以下是一些例子："><a href="#六-指针在-C-和-C-中有很多复杂的应用场景，以下是一些例子：" class="headerlink" title="六.指针在 C 和 C++ 中有很多复杂的应用场景，以下是一些例子："></a>六.指针在 C 和 C++ 中有很多复杂的应用场景，以下是一些例子：</h3><h4 id="一、指针与动态内存分配"><a href="#一、指针与动态内存分配" class="headerlink" title="一、指针与动态内存分配"></a><strong>一、指针与动态内存分配</strong></h4><ol><li><strong>动态数组</strong>：可以使用指针和动态内存分配来创建动态大小的数组。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Enter the size of the array: &quot;</span>;<br>std::cin &gt;&gt; n;<br><span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br><span class="hljs-comment">// 使用动态分配的数组</span><br><span class="hljs-keyword">delete</span>[] arr;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>链表</strong>：链表是一种数据结构，其中每个节点包含一个值和一个指向下一个节点的指针。通过指针操作，可以方便地添加、删除和遍历链表节点。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    ListNode* next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">value</span>(val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(ListNode*&amp; head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    ListNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val);<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>        head = newNode;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ListNode* current = head;<br>        <span class="hljs-keyword">while</span> (current-&gt;next!= <span class="hljs-literal">nullptr</span>) &#123;<br>            current = current-&gt;next;<br>        &#125;<br>        current-&gt;next = newNode;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode* current = head;<br>    <span class="hljs-keyword">while</span> (current!= <span class="hljs-literal">nullptr</span>) &#123;<br>        std::cout &lt;&lt; current-&gt;value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        current = current-&gt;next;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ListNode* head = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-built_in">addNode</span>(head, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">addNode</span>(head, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">addNode</span>(head, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">printList</span>(head);<br>    <span class="hljs-comment">// 释放链表内存</span><br>    <span class="hljs-keyword">while</span> (head!= <span class="hljs-literal">nullptr</span>) &#123;<br>        ListNode* temp = head;<br>        head = head-&gt;next;<br>        <span class="hljs-keyword">delete</span> temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二、指针与函数参数"><a href="#二、指针与函数参数" class="headerlink" title="二、指针与函数参数"></a><strong>二、指针与函数参数</strong></h4><ol><li><strong>传递指针以修改参数值</strong>：通过传递指针作为函数参数，可以在函数内部修改外部变量的值。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-type">int</span>* num)</span> </span>&#123;<br>    (*num)++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">increment</span>(&amp;value);<br>    std::cout &lt;&lt; value &lt;&lt; std::endl; <span class="hljs-comment">// 输出 11</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>指针作为函数返回值</strong>：函数可以返回一个指针，指向动态分配的内存或某个特定的变量。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">createArray</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> </span>&#123;<br>    <span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>* myArray = <span class="hljs-built_in">createArray</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-comment">// 使用动态分配的数组</span><br>    <span class="hljs-keyword">delete</span>[] myArray;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>在 C 和 C++ 中，<code>int *const a</code>、<code>const int *a</code>和<code>int const *a</code>这三种声明有不同的含义：</p><ol><li><pre><code class="hljs">int *const a<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><br>   ：<br><br>   - 这声明了一个指向整数的常量指针。<br>   - 意味着指针本身是常量，不能被重新赋值指向其他内存地址，但它所指向的整数可以被修改。<br>   - 例如：<br><br>```c++<br>     <span class="hljs-built_in">int</span> num1 = <span class="hljs-number">10</span>, num2 = <span class="hljs-number">20</span><span class="hljs-comment">;</span><br>     <span class="hljs-built_in">int</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">ptr</span> = &amp;num1<span class="hljs-comment">;</span><br>     // *<span class="hljs-built_in">ptr</span> = <span class="hljs-number">30</span><span class="hljs-comment">; // 可以修改所指向的整数的值</span><br>     // <span class="hljs-built_in">ptr</span> = &amp;num2<span class="hljs-comment">; // 错误，不能重新赋值指针</span><br></code></pre></td></tr></table></figure></code></pre></li><li><pre><code class="hljs">const int *a<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>和<br><br></code></pre></td></tr></table></figure>int const *a<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><br>   ：这两种声明在语义上是完全相同的。<br><br>   - 这声明了一个指向常量整数的指针。<br>   - 意味着指针可以被重新赋值指向其他内存地址，但它所指向的整数不能被修改。<br>   - 例如：<br><br>```c++<br>     <span class="hljs-built_in">int</span> num1 = <span class="hljs-number">10</span>, num2 = <span class="hljs-number">20</span><span class="hljs-comment">;</span><br>     <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> *<span class="hljs-built_in">ptr</span> = &amp;num1<span class="hljs-comment">;</span><br>     // <span class="hljs-built_in">ptr</span> = &amp;num2<span class="hljs-comment">; // 可以重新赋值指针</span><br>     // *<span class="hljs-built_in">ptr</span> = <span class="hljs-number">30</span><span class="hljs-comment">; // 错误，不能修改所指向的整数的值</span><br></code></pre></td></tr></table></figure></code></pre></li></ol></li></ol><h4 id="三、指针与多维数组"><a href="#三、指针与多维数组" class="headerlink" title="三、指针与多维数组"></a><strong>三、指针与多维数组</strong></h4><ol><li><strong>二维数组的指针表示</strong>：在 C 和 C++ 中，二维数组可以用指针的指针来表示。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>    &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;,<br>    &#123;<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;<br>&#125;;<br><span class="hljs-built_in">int</span>(*ptr)[<span class="hljs-number">4</span>] = arr;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++) &#123;<br>        std::cout &lt;&lt; (*ptr)[j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    ptr++;<br>    std::cout &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>动态分配多维数组</strong>：可以使用指针和动态内存分配来创建动态大小的多维数组。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>** <span class="hljs-title">createDynamic2DArray</span><span class="hljs-params">(<span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols)</span> </span>&#123;<br>    <span class="hljs-type">int</span>** arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>*[rows];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[cols];<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteDynamic2DArray</span><span class="hljs-params">(<span class="hljs-type">int</span>** arr, <span class="hljs-type">int</span> rows)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        <span class="hljs-keyword">delete</span>[] arr[i];<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] arr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> rows = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> cols = <span class="hljs-number">4</span>;<br>    <span class="hljs-type">int</span>** myArray = <span class="hljs-built_in">createDynamic2DArray</span>(rows, cols);<br>    <span class="hljs-comment">// 使用动态分配的二维数组</span><br>    <span class="hljs-built_in">deleteDynamic2DArray</span>(myArray, rows);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="四、指针与字符串"><a href="#四、指针与字符串" class="headerlink" title="四、指针与字符串"></a><strong>四、指针与字符串</strong></h4><ol><li><strong>字符指针与字符串字面量</strong>：在 C 和 C++ 中，字符串字面量实际上是一个以空字符结尾的字符数组，并且可以用字符指针来指向它。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>std::cout &lt;&lt; str &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>动态分配字符串</strong>：可以使用指针和动态内存分配来创建动态大小的字符串。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">readString</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Enter a string: &quot;</span>;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>    std::cin.<span class="hljs-built_in">getline</span>(buffer, <span class="hljs-number">100</span>);<br>    <span class="hljs-type">int</span> len = std::<span class="hljs-built_in">strlen</span>(buffer);<br>    <span class="hljs-type">char</span>* str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(str, buffer);<br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span>* myString = <span class="hljs-built_in">readString</span>();<br>    std::cout &lt;&lt; myString &lt;&lt; std::endl;<br>    <span class="hljs-keyword">delete</span>[] myString;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>指针的复杂应用需要谨慎处理，以避免内存泄漏、指针越界和其他错误。在使用指针时，要确保正确地管理内存，并遵循良好的编程实践。</p><h3 id="七-指针常见错误"><a href="#七-指针常见错误" class="headerlink" title="七.指针常见错误"></a>七.指针常见错误</h3><p>在 C 和 C++ 中使用指针时，容易出现以下一些常见错误：</p><h4 id="一、未初始化指针"><a href="#一、未初始化指针" class="headerlink" title="一、未初始化指针"></a><strong>一、未初始化指针</strong></h4><p>如果一个指针没有被初始化就被使用，它可能指向任意的内存地址，这会导致不可预测的行为甚至程序崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* ptr;<br>*ptr = <span class="hljs-number">10</span>; <span class="hljs-comment">// 错误，ptr 未初始化</span><br></code></pre></td></tr></table></figure><blockquote><p>未初始化的指针或者指向已经被释放内存的指针称为<code>野指针</code>，初始化指针赋值为空的指针为<code>空指针</code>，在 C 中，用 <code>NULL</code> 表示空指针，在 C++ 中，用 <code>nullptr</code> 表示空指针。</p></blockquote><h4 id="二、悬空指针"><a href="#二、悬空指针" class="headerlink" title="二、悬空指针"></a><strong>二、悬空指针</strong></h4><p>当一个指针所指向的内存被释放后，如果继续使用这个指针，就会产生悬空指针。这可能导致访问非法内存地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">delete</span>[] ptr;<br><span class="hljs-comment">// 以下代码可能导致错误，因为 ptr 成为悬空指针</span><br>std::cout &lt;&lt; *ptr;<br></code></pre></td></tr></table></figure><h4 id="三、内存泄漏"><a href="#三、内存泄漏" class="headerlink" title="三、内存泄漏"></a><strong>三、内存泄漏</strong></h4><p>如果动态分配了内存但没有在不再需要时释放，就会导致内存泄漏。随着程序的运行，可能会耗尽系统内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-comment">// 没有释放 ptr 所指向的内存</span><br></code></pre></td></tr></table></figure><h4 id="四、指针越界访问"><a href="#四、指针越界访问" class="headerlink" title="四、指针越界访问"></a><strong>四、指针越界访问</strong></h4><p>如果通过指针访问超出所指向的数组或内存范围的地址，可能会导致错误的结果或程序崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span>* ptr = arr;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123; <span class="hljs-comment">// 错误，i 可能超出数组范围</span><br>    std::cout &lt;&lt; ptr[i];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="五、错误的指针类型转换"><a href="#五、错误的指针类型转换" class="headerlink" title="五、错误的指针类型转换"></a><strong>五、错误的指针类型转换</strong></h4><p>进行不恰当的指针类型转换可能导致错误的内存访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span>* ptr = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">double</span>*&gt;(&amp;num);<br><span class="hljs-comment">// 错误的类型转换，可能导致不可预测的结果</span><br>std::cout &lt;&lt; *ptr;<br></code></pre></td></tr></table></figure><h4 id="六、混淆指针和引用"><a href="#六、混淆指针和引用" class="headerlink" title="六、混淆指针和引用"></a><strong>六、混淆指针和引用</strong></h4><p>指针和引用在某些方面相似，但也有不同之处。混淆它们可能导致错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* ptr = &amp;num;<br><span class="hljs-type">int</span>&amp; ref = num;<br>*ptr = <span class="hljs-number">20</span>;<br>ref = <span class="hljs-number">30</span>;<br><span class="hljs-comment">// 可能错误地认为指针和引用完全相同的用法</span><br></code></pre></td></tr></table></figure><h4 id="七、忘记释放动态分配的内存（C-中使用new）"><a href="#七、忘记释放动态分配的内存（C-中使用new）" class="headerlink" title="七、忘记释放动态分配的内存（C++ 中使用new）"></a><strong>七、忘记释放动态分配的内存（C++ 中使用<code>new</code>）</strong></h4><p>在 C++ 中，如果使用<code>new</code>分配了内存，应该使用<code>delete</code>来释放。如果忘记释放，会导致内存泄漏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><span class="hljs-comment">// 没有释放 ptr 所指向的内存</span><br></code></pre></td></tr></table></figure><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="1-pair"><a href="#1-pair" class="headerlink" title="1.pair"></a><strong>1.pair</strong></h3><ul><li>在 C++ 中，<code>std::pair</code> 是一个模板类，它定义在 <code>&lt;utility&gt;</code> 头文件里，可将两个不同类型的值组合成一个单元。以下是关于 <code>std::pair</code> 的详细用法介绍：</li></ul><h4 id="1-定义和初始化"><a href="#1-定义和初始化" class="headerlink" title="1. 定义和初始化"></a>1. 定义和初始化</h4><ul><li><strong>默认初始化</strong>：创建一个 <code>pair</code> 对象，其成员会进行默认初始化。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; p1;  <span class="hljs-comment">// 默认初始化，p1.first 和 p1.second 是默认值</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p1: (&quot;</span> &lt;&lt; p1.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p1.second &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>使用构造函数初始化</strong>：可以使用构造函数为 <code>pair</code> 的两个成员赋值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>)</span></span>;  <span class="hljs-comment">// 使用构造函数初始化</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p2: (&quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p2.second &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>使用 <code>std::make_pair</code> 函数初始化</strong>：<code>std::make_pair</code> 是一个模板函数，能根据传入的参数自动推导 <code>pair</code> 的类型。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> p3 = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2.71</span>);  <span class="hljs-comment">// 使用 std::make_pair 初始化</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p3: (&quot;</span> &lt;&lt; p3.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p3.second &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-访问-pair-的成员"><a href="#2-访问-pair-的成员" class="headerlink" title="2. 访问 pair 的成员"></a>2. 访问 <code>pair</code> 的成员</h4><p><code>pair</code> 有两个公共成员 <code>first</code> 和 <code>second</code>，可通过它们来访问 <code>pair</code> 中的两个值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, std::string&gt; <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p4.first: &quot;</span> &lt;&lt; p4.first &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p4.second: &quot;</span> &lt;&lt; p4.second &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-修改-pair-的成员"><a href="#3-修改-pair-的成员" class="headerlink" title="3. 修改 pair 的成员"></a>3. 修改 <code>pair</code> 的成员</h4><p>可以直接对 <code>pair</code> 的 <code>first</code> 和 <code>second</code> 成员进行赋值操作来修改它们的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;a&#x27;</span>)</span></span>;<br>    p5.first = <span class="hljs-number">15</span>;<br>    p5.second = <span class="hljs-string">&#x27;b&#x27;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p5: (&quot;</span> &lt;&lt; p5.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p5.second &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-pair-的比较操作"><a href="#4-pair-的比较操作" class="headerlink" title="4. pair 的比较操作"></a>4. <code>pair</code> 的比较操作</h4><p><code>pair</code> 支持比较运算符（如 <code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code> 等），比较时先比较 <code>first</code> 成员，若相等再比较 <code>second</code> 成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p6</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p7</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p6 &lt; p7: &quot;</span> &lt;&lt; (p6 &lt; p7) &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 1（true）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-在容器中使用-pair"><a href="#5-在容器中使用-pair" class="headerlink" title="5. 在容器中使用 pair"></a>5. 在容器中使用 <code>pair</code></h4><p><code>pair</code> 常被用于容器中，例如 <code>std::map</code> 和 <code>std::unordered_map</code> 内部就使用 <code>pair</code> 来存储键值对。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, std::string&gt;&gt; vec;<br>    vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>));<br>    vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;two&quot;</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; p : vec) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; p.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-作为函数的返回值"><a href="#6-作为函数的返回值" class="headerlink" title="6. 作为函数的返回值"></a>6. 作为函数的返回值</h4><p><code>pair</code> 可以作为函数的返回值，这样函数就能同时返回两个不同类型的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">getValues</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">100</span>, <span class="hljs-number">3.14159</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">getValues</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Result: (&quot;</span> &lt;&lt; result.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; result.second &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>综上所述，<code>std::pair</code> 是一个非常实用的工具，能方便地将两个值组合在一起，在很多场景下都能发挥作用。</p><h3 id="2-vector-stack-map-queue"><a href="#2-vector-stack-map-queue" class="headerlink" title="2.vector\stack\map\queue"></a>2.vector\stack\map\queue</h3><h4 id="1-C-vector-与-Java-ArrayList"><a href="#1-C-vector-与-Java-ArrayList" class="headerlink" title="1. C++ vector 与 Java ArrayList"></a>1. C++ <code>vector</code> 与 Java <code>ArrayList</code></h4><ul><li><p><strong>功能</strong></p></li><li><p>**C++ <code>vector</code>**：是一个动态数组，支持随机访问，能在尾部高效地插入和删除元素。</p></li><li><p>**Java <code>ArrayList</code>**：同样是动态数组，支持随机访问，在尾部添加元素效率较高，但在中间插入或删除元素可能需要移动后续元素。</p></li><li><p><strong>方法和属性对比</strong></p></li></ul><table><thead><tr><th>功能</th><th>C++ <code>vector</code></th><th>Java <code>ArrayList</code></th></tr></thead><tbody><tr><td>初始化</td><td><code>std::vector&lt;int&gt; vec;</code></td><td><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code></td></tr><tr><td>添加元素</td><td><code>vec.push_back(1);</code></td><td><code>list.add(1);</code></td></tr><tr><td>访问元素</td><td><code>int val = vec[0];</code> 或 <code>int val = vec.at(0);</code></td><td><code>int val = list.get(0);</code></td></tr><tr><td>修改元素</td><td><code>vec[0] = 2;</code></td><td><code>list.set(0, 2);</code></td></tr><tr><td>获取大小</td><td><code>size_t size = vec.size();</code></td><td><code>int size = list.size();</code></td></tr><tr><td>检查是否为空</td><td><code>bool empty = vec.empty();</code></td><td><code>boolean empty = list.isEmpty();</code></td></tr><tr><td>删除元素</td><td><code>vec.pop_back();</code>（删除尾部元素） <code>vec.erase(vec.begin());</code>（删除指定位置元素）</td><td><code>list.remove(0);</code>（删除指定位置元素）</td></tr></tbody></table><h4 id="2-C-stack-与-Java-Stack"><a href="#2-C-stack-与-Java-Stack" class="headerlink" title="2. C++ stack 与 Java Stack"></a>2. C++ <code>stack</code> 与 Java <code>Stack</code></h4><ul><li><p>功能</p></li><li><p>**C++ <code>stack</code>**：是一种后进先出（LIFO）的数据结构，提供了基本的栈操作。</p></li><li><p>**Java <code>Stack</code>**：也是后进先出的数据结构，不过在 Java 中更推荐使用 <code>Deque</code> 接口的实现类（如 <code>ArrayDeque</code>）来模拟栈。</p></li><li><p>方法和属性对比</p></li></ul><table><thead><tr><th>功能</th><th>C++ <code>stack</code></th><th>Java <code>Stack</code>（或 <code>ArrayDeque</code>）</th></tr></thead><tbody><tr><td>初始化</td><td><code>std::stack&lt;int&gt; st;</code></td><td><code>Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</code> 或 <code>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();</code></td></tr><tr><td>入栈</td><td><code>st.push(1);</code></td><td><code>stack.push(1);</code></td></tr><tr><td>出栈</td><td><code>st.pop();</code></td><td><code>stack.pop();</code></td></tr><tr><td>获取栈顶元素</td><td><code>int top = st.top();</code></td><td><code>int top = stack.peek();</code></td></tr><tr><td>检查是否为空</td><td><code>bool empty = st.empty();</code></td><td><code>boolean empty = stack.isEmpty();</code></td></tr><tr><td>获取栈的大小</td><td><code>size_t size = st.size();</code></td><td><code>int size = stack.size();</code></td></tr></tbody></table><h4 id="3-C-map-与-Java-TreeMap"><a href="#3-C-map-与-Java-TreeMap" class="headerlink" title="3. C++ map 与 Java TreeMap"></a>3. C++ <code>map</code> 与 Java <code>TreeMap</code></h4><ul><li><p>功能</p></li><li><p>**C++ <code>map</code>**：是基于红黑树实现的关联容器，存储键值对，键是唯一的，且元素会按照键的顺序自动排序。</p></li><li><p>**Java <code>TreeMap</code>**：同样基于红黑树实现，存储键值对，键唯一且按自然顺序或指定的比较器排序。</p></li><li><p>方法和属性对比</p></li></ul><table><thead><tr><th>功能</th><th>C++ <code>map</code></th><th>Java <code>TreeMap</code></th></tr></thead><tbody><tr><td>初始化</td><td><code>std::map&lt;int, std::string&gt; myMap;</code></td><td><code>TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;();</code></td></tr><tr><td>插入元素</td><td><code>myMap[1] = &quot;one&quot;;</code> 或 <code>myMap.insert(&#123;1, &quot;one&quot;&#125;);</code></td><td><code>treeMap.put(1, &quot;one&quot;);</code></td></tr><tr><td>访问元素</td><td><code>std::string val = myMap[1];</code> 或 <code>auto it = myMap.find(1); if (it != myMap.end()) &#123; val = it-&gt;second; &#125;</code></td><td><code>String val = treeMap.get(1);</code></td></tr><tr><td>修改元素</td><td><code>myMap[1] = &quot;new one&quot;;</code></td><td><code>treeMap.put(1, &quot;new one&quot;);</code></td></tr><tr><td>删除元素</td><td><code>myMap.erase(1);</code></td><td><code>treeMap.remove(1);</code></td></tr><tr><td>检查键是否存在</td><td><code>auto it = myMap.find(1); bool exists = (it != myMap.end());</code></td><td><code>boolean exists = treeMap.containsKey(1);</code></td></tr><tr><td>获取大小</td><td><code>size_t size = myMap.size();</code></td><td><code>int size = treeMap.size();</code></td></tr></tbody></table><ul><li>遍历</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//c++</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : myMap) &#123;<br>    std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java</span><br><span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : treeMap.entrySet()) &#123;<br>    System.out.println(entry.getKey() + <span class="hljs-string">&quot;: &quot;</span> + entry.getValue());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="C-中的-queue-容器和-Java-中的-Queue-接口及其实现类"><a href="#C-中的-queue-容器和-Java-中的-Queue-接口及其实现类" class="headerlink" title="C++ 中的 queue 容器和 Java 中的 Queue 接口及其实现类"></a>C++ 中的 <code>queue</code> 容器和 Java 中的 <code>Queue</code> 接口及其实现类</h4><ul><li><p>功能</p></li><li><p>**C++ <code>queue</code>**：是一种先进先出（FIFO）的数据结构，它基于其他容器（默认是 <code>deque</code>）实现，提供了标准的队列操作。</p></li><li><p>**Java <code>Queue</code>**：是一个接口，<code>LinkedList</code> 是其常用的实现类，同样遵循先进先出原则，提供了队列的基本操作。</p></li><li><p>方法和属性对比</p></li></ul><table><thead><tr><th>功能</th><th>C++ <code>queue</code></th><th>Java <code>Queue</code>（以 <code>LinkedList</code> 为例）</th></tr></thead><tbody><tr><td>初始化</td><td><code>std::queue&lt;int&gt; q;</code></td><td><code>Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</code></td></tr><tr><td>入队</td><td><code>q.push(1);</code></td><td><code>queue.add(1);</code> 或 <code>queue.offer(1);</code> <code>add()</code> 方法在队列满时会抛出异常，<code>offer()</code> 会返回 <code>false</code></td></tr><tr><td>出队</td><td><code>q.pop();</code></td><td><code>Integer removed = queue.remove();</code> 或 <code>Integer removed = queue.poll();</code> <code>remove()</code> 方法在队列为空时会抛出异常，<code>poll()</code> 会返回 <code>null</code></td></tr><tr><td>获取队首元素</td><td><code>int front = q.front();</code></td><td><code>Integer front = queue.element();</code> 或 <code>Integer front = queue.peek();</code> <code>element()</code> 方法在队列为空时会抛出异常，<code>peek()</code> 会返回 <code>null</code></td></tr><tr><td>检查是否为空</td><td><code>bool empty = q.empty();</code></td><td><code>boolean empty = queue.isEmpty();</code></td></tr><tr><td>获取队列大小</td><td><code>size_t size = q.size();</code></td><td><code>int size = queue.size();</code></td></tr></tbody></table><h3 id="map和unordered-map对比"><a href="#map和unordered-map对比" class="headerlink" title="map和unordered_map对比"></a>map和unordered_map对比</h3><p>在 C++ 中，<code>std::map</code> 和 <code>std::unordered_map</code> 都是常用的关联容器，但它们的实现和特性不同，因此适用场景也不同：</p><ol><li><p><strong><code>std::map</code></strong></p><ul><li><p><strong>实现</strong>：基于红黑树（一种平衡二叉搜索树），因此元素按键的 <strong>有序性</strong>（默认按升序）存储。</p></li><li><p>特性</p><p>：</p><ul><li>插入、删除、查找的时间复杂度为 (O(\log n))。</li><li>可以按键的顺序遍历元素（如使用迭代器从小到大访问）。</li></ul></li><li><p><strong>适用场景</strong>：需要元素有序、或需要范围查询（如查找某个区间内的所有键）时更适合。</p></li></ul></li><li><p><strong><code>std::unordered_map</code></strong></p><ul><li><p><strong>实现</strong>：基于哈希表，元素按键的哈希值存储，因此元素是 <strong>无序的</strong>。</p></li><li><p>特性</p><p>：</p><ul><li>插入、删除、查找的平均时间复杂度为 (O(1))（依赖哈希函数的质量和负载因子）。</li><li>不支持按键的顺序遍历。</li></ul></li><li><p><strong>适用场景</strong>：需要快速查找、插入和删除，且不关心元素顺序时更高效。</p></li></ul></li></ol><ul><li>**<code>std::map</code>**：在需要有序性或范围操作时（如日志分析、统计排序后的结果）是首选。</li><li>**<code>std::unordered_map</code>**：在追求高性能的场景（如缓存、哈希表统计）中更常用，尤其是数据量较大时。</li></ul><h4 id="示例对比"><a href="#示例对比" class="headerlink" title="示例对比"></a>示例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用 std::map（有序）</span><br>    std::map&lt;<span class="hljs-type">int</span>, std::string&gt; orderedMap;<br>    orderedMap[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;apple&quot;</span>;<br>    orderedMap[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;banana&quot;</span>;<br>    orderedMap[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;orange&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;std::map (ordered): &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : orderedMap) &#123;<br>        std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 输出：1-&gt;banana 2-&gt;orange 3-&gt;apple</span><br><br>    <span class="hljs-comment">// 使用 std::unordered_map（无序）</span><br>    std::unordered_map&lt;<span class="hljs-type">int</span>, std::string&gt; unorderedMap;<br>    unorderedMap[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;apple&quot;</span>;<br>    unorderedMap[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;banana&quot;</span>;<br>    unorderedMap[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;orange&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\nstd::unordered_map (unordered): &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : unorderedMap) &#123;<br>        std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 输出顺序不固定，例如：3-&gt;apple 1-&gt;banana 2-&gt;orange</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因此，两者是否 “常用” 取决于具体需求。如果需要有序性，<code>std::map</code> 更合适；如果追求速度且无需有序性，<code>std::unordered_map</code> 更优。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
