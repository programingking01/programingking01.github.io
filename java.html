<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>hlx的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="java（有c&#x2F;c++基础）1.初识java1.1.java的体系结构 javaSE :标准版，个人计算机上的应用（重点） JavaEE：企业版，服务器端的应用（重点） JavaME：微型版，定位在消费性产品  1.2.Java的特性与优势 Java就是c++语法的简化版，相当于将c++的一些内容去除；比如：头文件，指针运算，结构，联合，操作符重载，虚基类等等。同时，语法基于C语言。 高">
<meta property="og:type" content="website">
<meta property="og:title" content="hlx的个人博客">
<meta property="og:url" content="http://example.com/java.html">
<meta property="og:site_name" content="hlx的个人博客">
<meta property="og:description" content="java（有c&#x2F;c++基础）1.初识java1.1.java的体系结构 javaSE :标准版，个人计算机上的应用（重点） JavaEE：企业版，服务器端的应用（重点） JavaME：微型版，定位在消费性产品  1.2.Java的特性与优势 Java就是c++语法的简化版，相当于将c++的一些内容去除；比如：头文件，指针运算，结构，联合，操作符重载，虚基类等等。同时，语法基于C语言。 高">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/java.assets/image-20241015175105864.png">
<meta property="og:image" content="http://example.com/java.assets/image-20241015175622423.png">
<meta property="og:image" content="http://example.com/java.assets/image-20241015175759664.png">
<meta property="og:image" content="http://example.com/java.assets/image-20241023144932770.png">
<meta property="og:image" content="http://example.com/java.assets/image-20241023150558249.png">
<meta property="og:image" content="http://example.com/java.assets/image-20241102161403029.png">
<meta property="og:image" content="http://example.com/java.assets/image-20241103174048966.png">
<meta property="og:image" content="http://example.com/java.assets/image-20241104182403532.png">
<meta property="og:image" content="http://example.com/java.assets/image-20241112190146403.png">
<meta property="og:image" content="http://example.com/java.assets/image-20241127200033060.png">
<meta property="og:image" content="http://example.com/java.assets/image-20241127202555955.png">
<meta property="og:image" content="http://example.com/java.assets/image-20241104155653318.png">
<meta property="og:image" content="http://example.com/java.assets/image-20241222155322256.png">
<meta property="og:image" content="http://example.com/java.assets/image-20241221192020851.png">
<meta property="og:image" content="http://example.com/java.assets/image-20241128182621673.png">
<meta property="og:image" content="http://example.com/java.assets/image-20241202172933438.png">
<meta property="og:image" content="http://example.com/java.assets%5Cimage-20241202202113494.png">
<meta property="og:image" content="http://example.com/java.assets/image-20241212082603810.png">
<meta property="og:image" content="http://example.com/java.assets/image-20241212092517979.png">
<meta property="og:image" content="http://example.com/java.assets/image-20241212093923345.png">
<meta property="article:published_time" content="2024-12-23T05:59:02.897Z">
<meta property="article:modified_time" content="2024-12-23T05:59:02.897Z">
<meta property="article:author" content="hlx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/java.assets/image-20241015175105864.png">
  
    <link rel="alternate" href="/atom.xml" title="hlx的个人博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">hlx的个人博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="page-" class="h-entry article article-type-page" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/java.html" class="article-date">
  <time class="dt-published" datetime="2024-12-23T05:59:02.897Z" itemprop="datePublished">2024-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="java（有c-c-基础）"><a href="#java（有c-c-基础）" class="headerlink" title="java（有c&#x2F;c++基础）"></a>java（有c&#x2F;c++基础）</h1><h2 id="1-初识java"><a href="#1-初识java" class="headerlink" title="1.初识java"></a>1.初识java</h2><h3 id="1-1-java的体系结构"><a href="#1-1-java的体系结构" class="headerlink" title="1.1.java的体系结构"></a>1.1.java的体系结构</h3><ul>
<li>javaSE :标准版，个人计算机上的应用（重点）</li>
<li>JavaEE：企业版，服务器端的应用（重点）</li>
<li>JavaME：微型版，定位在消费性产品</li>
</ul>
<h3 id="1-2-Java的特性与优势"><a href="#1-2-Java的特性与优势" class="headerlink" title="1.2.Java的特性与优势"></a>1.2.Java的特性与优势</h3><ul>
<li>Java就是c++语法的简化版，相当于将c++的一些内容去除；比如：头文件，指针运算，结构，联合，操作符重载，虚基类等等。同时，语法基于C语言。</li>
<li>高性能：通过虚拟机优化提升速度</li>
<li>分布式</li>
<li>多线程</li>
<li>健壮性</li>
</ul>
<h3 id="1-3-核心机制"><a href="#1-3-核心机制" class="headerlink" title="1.3.核心机制"></a>1.3.核心机制</h3><ul>
<li><p>垃圾收集机制</p>
</li>
<li><p>跨平台原理</p>
</li>
</ul>
<p>Java的跨平台原理</p>
<p><img src="/java.assets/image-20241015175105864.png" alt="image-20241015175105864"></p>
<p>C语言的跨平台原理</p>
<p><img src="/java.assets/image-20241015175622423.png" alt="image-20241015175622423"></p>
<p>比较：</p>
<p><img src="/java.assets/image-20241015175759664.png" alt="image-20241015175759664"></p>
<h3 id="1-4-常用的DOS命令"><a href="#1-4-常用的DOS命令" class="headerlink" title="1.4.常用的DOS命令"></a>1.4.常用的DOS命令</h3><blockquote>
<p>win+r+cmd</p>
</blockquote>
<p>打开控制台</p>
<ol>
<li>切换盘符：c:  ,   d:    ,  e:   不用区分大小写</li>
<li>显示详细信息：dir   相当于Linux中的ls</li>
<li>改变当前目录：  cd   和Linux中的一样</li>
<li>.  当前目录   和  ..  上级目录  ：和Linux里一样</li>
<li>清屏cls</li>
<li>上下箭头切换历史命令</li>
<li>tab键补齐</li>
<li>创建目录和删除目录：md 和rd 后面加文件   对应Linux中的mkdir和rm</li>
<li>copy复制文件：和Linux中的cp一样</li>
</ol>
<h3 id="1-5-快捷总结"><a href="#1-5-快捷总结" class="headerlink" title="1.5.快捷总结"></a>1.5.快捷总结</h3><p>CTRL+ALT+L：自动对齐</p>
<p>CTRL+ALT+T:对代码块进行包围操作（异常、同步锁）</p>
<h2 id="2-数据类型——常量、变量、输入输出"><a href="#2-数据类型——常量、变量、输入输出" class="headerlink" title="2.数据类型——常量、变量、输入输出"></a>2.数据类型——常量、变量、输入输出</h2><h3 id="2-1-常量、变量"><a href="#2-1-常量、变量" class="headerlink" title="2.1.常量、变量"></a>2.1.常量、变量</h3><ul>
<li>字面常量</li>
</ul>
<blockquote>
<p>整型常量、字符常量、逻辑常量、字符串常量</p>
</blockquote>
<p>null常量：可以赋值给任何类型的变量。</p>
<ul>
<li>变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="keyword">class</span> <span class="title class_">value</span>()&#123;</span><br><span class="line">    pubilc <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">byte</span> mybyte=<span class="number">120</span>;<span class="comment">//  byte变量（-127，128）一个字节</span></span><br><span class="line">        <span class="type">short</span> myshort=<span class="number">120</span>;<span class="comment">// short变量 两个字节</span></span><br><span class="line">        <span class="type">int</span> myint=<span class="number">120</span>; <span class="comment">//int变量 4个字节</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">mylong</span> <span class="operator">=</span><span class="number">12123L</span>;<span class="comment">// long变量 8个字节  最后加上L来标识</span></span><br><span class="line">        <span class="type">float</span> myfloat=<span class="number">3.14f</span>;<span class="comment">//float变量 4个字节  最后加上f来标识</span></span><br><span class="line">        <span class="type">double</span> mydouble=<span class="number">3.1415926</span>;<span class="comment">// double变量 8个字节</span></span><br><span class="line">        <span class="type">char</span> mychar=<span class="string">&#x27;A&#x27;</span>; <span class="comment">//char变量 2个字节</span></span><br><span class="line">        <span class="type">boolean</span> myboolean=ture;<span class="comment">//false 布尔变量理论上只要一位，Java中占一个字节</span></span><br><span class="line">        <span class="type">int</span>[] myarray=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];<span class="comment">//int数组型变量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;myarray.length;i++)&#123;<span class="comment">//赋值</span></span><br><span class="line">            myarray[i]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> element :myarray)&#123;</span><br><span class="line">            System.out.println(element+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;<span class="comment">//输出</span></span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">Season</span>&#123;<span class="comment">//枚举型变量</span></span><br><span class="line">            spring,summer,autumn,winter</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>字符常量<code>final</code></li>
</ul>
<p>和c++中的const性质类似，被final修饰的字符变量变成常量不可修改</p>
<p>在Java中final可以用来修饰类和方法</p>
<p><code>被final修饰的类不能被继承，方法不能被子类重写。</code></p>
<p><code>final修饰引用类型地址值不能改变</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final Dog d=new Dog();</span><br><span class="line">//d=new Dog();---&gt;地址值不能改</span><br><span class="line">//d对象的属性依然可以改变</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="2-2-类型转换"><a href="#2-2-类型转换" class="headerlink" title="2.2. 类型转换"></a>2.2. 类型转换</h3><h4 id="2-2-1隐式转换"><a href="#2-2-1隐式转换" class="headerlink" title="2.2.1隐式转换"></a>2.2.1隐式转换</h4><ul>
<li><strong>字节数从小到大</strong>：byte-&gt;short-&gt;char-&gt;int-&gt;long-&gt;float-&gt;double</li>
</ul>
<p>long比float字节多所以转换可能存在丢失</p>
<ul>
<li><strong>字符类型与整数类型</strong>：<code>char可以自动转换为int</code>,因为char在Java中是2字节的无符号整数，其本质上可以看成是一种特殊的整数类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> b=<span class="number">120</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>b;<span class="comment">//byte 自动转换为int</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">int</span> code=ch;<span class="comment">//char自动转换为int，得到字符‘A’的码值</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-2强制转换（显式转换）"><a href="#2-2-2强制转换（显式转换）" class="headerlink" title="2.2.2强制转换（显式转换）"></a>2.2.2强制转换（显式转换）</h4><ul>
<li>当需要将大的数据类型转换为小的数据类型时，需要进行强制类型转换。可能会导致数据精度的损失。</li>
<li>targetType v&#x3D;(tergetType)value</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d=<span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> j=(<span class="type">int</span>)d;<span class="comment">//得到3，小数部分被截断</span></span><br><span class="line"><span class="type">long</span> l=<span class="number">121892364819236412793L</span>;</span><br><span class="line"><span class="type">int</span> k=(<span class="type">int</span>)l; <span class="comment">//长整型强制转换为整型，可能出现数据溢出</span></span><br></pre></td></tr></table></figure>



<h4 id="2-2-3特殊的类型转换"><a href="#2-2-3特殊的类型转换" class="headerlink" title="2.2.3特殊的类型转换"></a>2.2.3特殊的类型转换</h4><p>字符串与基本数据结构的转换</p>
<ul>
<li><p>基本数据类型转字符串</p>
<ul>
<li>可以使用连接操作（<code>+</code>） 或相应的字符串转换方法。</li>
<li>使用<code>String.valueOf()</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用+连接操作</span></span><br><span class="line"><span class="type">int</span> num=<span class="number">456</span>;</span><br><span class="line">String str1=<span class="string">&quot;&quot;</span>+num;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用String.valueOf()方法：</span></span><br><span class="line"><span class="type">int</span> num2=<span class="number">456</span>;</span><br><span class="line">String str2=String.valueOf(num2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串转基本数据类型</p>
<ul>
<li>使用相应的包装类的parsexxx()方法（xxx表示具体的数据类型，如Integer.parseInt()、Double.parseDouble()等）。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str3=<span class="string">&quot;123356&quot;</span>;</span><br><span class="line"><span class="type">int</span> num3=Integer.parseInt(str3);</span><br></pre></td></tr></table></figure>

<p>如果字符串的内容不符合数字格式，会抛出NumberFormatException异常。</p>
<h3 id="2-3-Scanner基础用法"><a href="#2-3-Scanner基础用法" class="headerlink" title="2.3.Scanner基础用法"></a>2.3.<code>Scanner</code>基础用法</h3><ul>
<li>读取基本数据类型</li>
</ul>
<blockquote>
<p>nextInt()-读取整数</p>
<p>nextDouble()-读取双精度浮点数</p>
<p>nextBoolean()-读取布尔值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line">Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> age=sc.nextInt();<span class="comment">//键盘录入年龄</span></span><br><span class="line"><span class="type">double</span> hign=sc.nextDouble();<span class="comment">//键盘录入身高</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>读取字符串&#x2F;字符</li>
</ul>
<blockquote>
<p>next()-读取下一个单词</p>
<p>nextLine()-读取一行字符串</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">String word=sc.next();<span class="comment">//读取一个单词</span></span><br><span class="line">String str=sc.nextLine();<span class="comment">//读取一行</span></span><br><span class="line"><span class="type">char</span> ch=word.charAt();<span class="comment">//读取一个字符</span></span><br></pre></td></tr></table></figure>



<ul>
<li>其它方法</li>
</ul>
<blockquote>
<p>hasNext()-判断是否还有下一个输入项</p>
<p>hasNextInt、hasNextDouble等等</p>
</blockquote>
<h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3.运算符"></a>3.运算符</h2><h3 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1.算术运算符"></a>3.1.算术运算符</h3><ol>
<li><strong>基本算术运算符</strong><ul>
<li>加法（+）<ul>
<li>用于计算两个数值的和。例如：<code>int a = 3 + 5;</code>，结果<code>a</code>为 8。</li>
<li>当用于字符串时，它起到连接字符串的作用，如<code>String s1 = &quot;Hello&quot; + &quot;World&quot;;</code>，结果<code>s1</code>为<code>&quot;HelloWorld&quot;</code>。</li>
</ul>
</li>
<li>减法（-）<ul>
<li>用于计算两个数值的差。例如：<code>int b = 7 - 4;</code>，结果<code>b</code>为 3。</li>
</ul>
</li>
<li>乘法（*）<ul>
<li>用于计算两个数值的乘积。例如：<code>int c = 2 * 6;</code>，结果<code>c</code>为 12。</li>
</ul>
</li>
<li>除法（&#x2F;）<ul>
<li>当用于整数时，它执行整除操作。例如：<code>int d = 10 / 3;</code>，结果<code>d</code>为 3。</li>
<li>当用于浮点数时，执行常规的除法运算，得到带有小数的结果，如<code>double e = 10.0 / 3.0;</code>，结果<code>e</code>约为 3.3333。</li>
</ul>
</li>
<li>取余（%）<ul>
<li>用于计算两个数相除的余数。例如：<code>int f = 10 % 3;</code>，结果<code>f</code>为 1。</li>
</ul>
</li>
</ul>
</li>
<li><strong>自增（++）和自减（–）运算符</strong><ul>
<li>自增（++）<ul>
<li>分为前置自增和后置自增。</li>
<li>前置自增（<code>++i</code>）：先将变量的值加 1，然后再使用变量的值。例如：</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> ++i;</span><br><span class="line"><span class="comment">// 此时i的值为4，j的值也为4</span></span><br></pre></td></tr></table></figure>



<ul>
<li>后置自增（<code>i++</code>）：先使用变量的值，然后再将变量的值加 1。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> m++;</span><br><span class="line"><span class="comment">// 此时m的值为4，n的值为3</span></span><br></pre></td></tr></table></figure>



<ul>
<li>自减（–）<ul>
<li>与自增类似，分为前置自减和后置自减。</li>
<li>前置自减（<code>--k</code>）：先将变量的值减 1，然后再使用变量的值。</li>
<li>后置自减（<code>k--</code>）：先使用变量的值，然后再将变量的值减 1。</li>
</ul>
</li>
</ul>
<h3 id="3-2-关系运算符"><a href="#3-2-关系运算符" class="headerlink" title="3.2.关系运算符"></a>3.2.关系运算符</h3><ol>
<li>比较大小关系<ul>
<li>等于（&#x3D;&#x3D;）<ul>
<li>用于判断两个值是否相等。例如：<code>boolean b1 = (3 == 3);</code>，结果<code>b1</code>为<code>true</code>；<code>boolean b2 = (3 == 4);</code>，结果<code>b2</code>为<code>false</code>。</li>
</ul>
</li>
<li>不等于（!&#x3D;）<ul>
<li>用于判断两个值是否不相等。例如：<code>boolean c1 = (3!= 4);</code>，结果<code>c1</code>为<code>true</code>。</li>
</ul>
</li>
<li>大于（&gt;）<ul>
<li>用于判断左边的值是否大于右边的值。例如：<code>boolean d1 = (5 &gt; 3);</code>，结果<code>d1</code>为<code>true</code>。</li>
</ul>
</li>
<li>小于（&lt;）<ul>
<li>用于判断左边的值是否小于右边的值。例如：<code>boolean e1 = (2 &lt; 3);</code>，结果<code>e1</code>为<code>true</code>。</li>
</ul>
</li>
<li>大于等于（&gt;&#x3D;）<ul>
<li>用于判断左边的值是否大于等于右边的值。例如：<code>boolean f1 = (3 &gt;= 3);</code>，结果<code>f1</code>为<code>true</code>。</li>
</ul>
</li>
<li>小于等于（&lt;&#x3D;）<ul>
<li>用于判断左边的值是否小于等于右边的值。例如：<code>boolean g1 = (2 &lt;= 3);</code>，结果<code>g1</code>为<code>true</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-3-逻辑运算符"><a href="#3-3-逻辑运算符" class="headerlink" title="3.3.逻辑运算符"></a>3.3.逻辑运算符</h3><ol>
<li>逻辑与（&amp;&amp;）和逻辑或（||）<ul>
<li>逻辑与（&amp;&amp;）<ul>
<li>当且仅当两个操作数都为<code>true</code>时，结果才为<code>true</code>。例如：<code>boolean a = (3 &gt; 2) &amp;&amp; (4 &lt; 5);</code>，结果<code>a</code>为<code>true</code>；<code>boolean b = (3 &gt; 2) &amp;&amp; (4 &gt; 5);</code>，结果<code>b</code>为<code>false</code>。</li>
<li>逻辑与具有短路特性，即当第一个操作数为<code>false</code>时，不会再计算第二个操作数。</li>
</ul>
</li>
<li>逻辑或（||）<ul>
<li>只要两个操作数中有一个为<code>true</code>，结果就为<code>true</code>。例如：<code>boolean c = (3 &gt; 2) || (4 &gt; 5);</code>，结果<code>c</code>为<code>true</code>；<code>boolean d = (3 &lt; 2) || (4 &lt; 5);</code>，结果<code>d</code>为<code>true</code>；<code>boolean e = (3 &lt; 2) || (4 &gt; 5);</code>，结果<code>e</code>为<code>false</code>。</li>
<li>逻辑或也具有短路特性，即当第一个操作数为<code>true</code>时，不会再计算第二个操作数。</li>
</ul>
</li>
</ul>
</li>
<li>逻辑非（!）<ul>
<li>用于对操作数取反。例如：<code>boolean f =!(3 &gt; 2);</code>，结果<code>f</code>为<code>false</code>。</li>
</ul>
</li>
</ol>
<h3 id="3-4-位运算符"><a href="#3-4-位运算符" class="headerlink" title="3.4.位运算符"></a>3.4.位运算符</h3><ol>
<li><p>按位与（&amp;）、按位或（|）、按位异或（^）和取反（~）</p>
<ul>
<li><p>按位与（&amp;）</p>
<ul>
<li>对两个操作数的每一位进行与操作。例如：<code>int a = 5 &amp; 3;</code>，5 的二进制是<code>101</code>，3 的二进制是<code>011</code>，按位与后得到<code>001</code>，即<code>a</code>为 1。</li>
</ul>
</li>
<li><p>按位或（|）</p>
<ul>
<li>对两个操作数的每一位进行或操作。例如：<code>int b = 5 | 3;</code>，得到<code>111</code>，即<code>b</code>为 7。</li>
</ul>
</li>
<li><p>按位异或（^）</p>
<ul>
<li>对两个操作数的每一位进行异或操作。相同为 0，不同为 1。例如：<code>int c = 5 ^ 3;</code>，得到<code>110</code>，即<code>c</code>为 6。</li>
</ul>
</li>
<li><p>取反（~）</p>
<ul>
<li>对操作数的每一位进行取反操作。例如：<code>int d = ~5;</code>，5 的二进制是<code>00000101</code>，取反后得到<code>11111010</code>，即<code>d</code>为 - 6（在有符号二进制表示中）。</li>
</ul>
<p>计算机中负数使用补码表示：</p>
<p>6：00000000 00000000 00000000 00000110</p>
<p>取反：11111111 11111111 11111111 11111001</p>
<p>加1：11111111 11111111 11111111 11111010    —–》-6</p>
</li>
</ul>
</li>
<li><p>左移（&lt;&lt;）、右移（&gt;&gt;）和无符号右移（&gt;&gt;&gt;）</p>
<ul>
<li>左移（&lt;&lt;）<ul>
<li>将操作数的二进制位向左移动指定的位数，右边补 0。例如：<code>int e = 2 &lt;&lt; 1;</code>，2 的二进制是<code>00000010</code>，左移 1 位后得到<code>00000100</code>，即<code>e</code>为 4。</li>
</ul>
</li>
<li>右移（&gt;&gt;）<ul>
<li>将操作数的二进制位向右移动指定的位数，左边补符号位。例如：<code>int f = 4 &gt;&gt; 1;</code>，4 的二进制是<code>00000100</code>，右移 1 位后得到<code>00000010</code>，即<code>f</code>为 2。</li>
</ul>
</li>
<li>无符号右移（&gt;&gt;&gt;）<ul>
<li>将操作数的二进制位向右移动指定的位数，左边补 0。例如：<code>int g = -4 &gt;&gt;&gt; 1;</code>，-4 的二进制是<code>11111100</code>，无符号右移 1 位后得到<code>01111110</code>，即<code>g</code>为 126。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-5-赋值运算符"><a href="#3-5-赋值运算符" class="headerlink" title="3.5.赋值运算符"></a>3.5.赋值运算符</h3><ol>
<li>基本赋值运算符（&#x3D;）和复合赋值运算符<ul>
<li>基本赋值运算符（&#x3D;）<ul>
<li>用于将一个值赋给一个变量。例如：<code>int x = 5;</code>，将 5 赋给变量<code>x</code>。</li>
</ul>
</li>
<li>复合赋值运算符<ul>
<li>包括<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>等。例如：<code>int y = 3; y += 2;</code>等价于<code>y = y + 2;</code>，结果<code>y</code>为 5。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-6-条件运算符（-）-三元运算符"><a href="#3-6-条件运算符（-）-三元运算符" class="headerlink" title="3.6.条件运算符（?:）&#x2F;三元运算符"></a>3.6.条件运算符（?:）&#x2F;三元运算符</h3><ol>
<li>语法和示例<ul>
<li>语法为<code>condition? expression1 : expression2</code>。当<code>condition</code>为<code>true</code>时，返回<code>expression1</code>的值；当<code>condition</code>为<code>false</code>时，返回<code>expression2</code>的值。例如：<code>int a = (3 &gt; 2)? 5 : 10;</code>，结果<code>a</code>为 5。</li>
</ul>
</li>
</ol>
<h2 id="4-随机数"><a href="#4-随机数" class="headerlink" title="4.随机数"></a>4.随机数</h2><h3 id="4-1-Math-random-方法"><a href="#4-1-Math-random-方法" class="headerlink" title="4.1.Math.random()方法"></a>4.1.<code>Math.random()</code>方法</h3><ol>
<li>基本原理<ul>
<li><code>Math.random()</code>是<code>java.lang.Math</code>类中的一个静态方法，它会返回一个大于等于 0.0 且小于 1.0 的双精度随机浮点数。</li>
<li>每次调用<code>Math.random()</code>都会生成一个新的随机数。它的实现基于伪随机数生成器（Pseudo - Random Number Generator，简称 PRNG），在内部会维护一个种子值，通过特定的算法根据种子值生成随机数序列。</li>
</ul>
</li>
<li>使用方法<ul>
<li>例如，要生成一个 0 到 9 之间的随机整数，可以使用以下代码：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">randomNumber</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * <span class="number">10</span>);</span><br></pre></td></tr></table></figure>



<ul>
<li>这里首先<code>Math.random()</code>生成一个 0 到 1 之间的浮点数，然后乘以 10 得到一个 0 到 10 之间（不包含 10）的浮点数，最后通过强制类型转换<code>(int)</code>将其转换为整数，得到 0 到 9 之间的随机整数。</li>
<li>如果要生成一个指定范围内的随机整数，例如<code>min</code>到<code>max</code>（包含<code>min</code>和<code>max</code>），可以使用以下公式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">randomInRange</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * (max - min + <span class="number">1</span>)) + min;</span><br></pre></td></tr></table></figure>



<h3 id="4-2-java-util-Random类"><a href="#4-2-java-util-Random类" class="headerlink" title="4.2.java.util.Random类"></a>4.2.<code>java.util.Random</code>类</h3><ol>
<li>创建对象<ul>
<li>可以通过<code>new</code>关键字创建<code>Random</code>类的实例，例如：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="comment">// 使用random对象生成随机数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><code>Random</code>类也有一个可以传入种子值的构造函数，例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">seededRandom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">12345</span>);</span><br></pre></td></tr></table></figure>



<ul>
<li>当使用相同的种子值创建<code>Random</code>对象时，它们会生成相同的随机数序列，这在需要重现随机数序列的场景中很有用。</li>
</ul>
<ol>
<li>常用方法<ul>
<li><code>nextInt()</code>方法<ul>
<li>该方法有两种形式：<ul>
<li>无参数形式：<code>nextInt()</code>会返回一个随机的整数，其范围是整个整数范围（负无穷到正无穷，但实际上受限于<code>int</code>类型的范围）。例如：</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">randomInt</span> <span class="operator">=</span> random.nextInt();</span><br></pre></td></tr></table></figure>



<ul>
<li>有参数形式：<code>nextInt(int n)</code>会返回一个大于等于 0 且小于<code>n</code>的随机整数。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">randomInRange</span> <span class="operator">=</span> random.nextInt(<span class="number">10</span>); <span class="comment">// 生成0到9之间的随机整数</span></span><br></pre></td></tr></table></figure>



<ul>
<li><code>nextDouble()</code>方法<ul>
<li>它返回一个大于等于 0.0 且小于 1.0 的随机双精度浮点数，与<code>Math.random()</code>类似，但使用<code>Random</code>类可以更方便地结合其他随机数生成方法使用。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">double</span> <span class="variable">randomDouble</span> <span class="operator">=</span> random.nextDouble();</span><br></pre></td></tr></table></figure>



<ul>
<li><code>nextBoolean()</code>方法<ul>
<li>用于生成一个随机的布尔值（<code>true</code>或<code>false</code>）。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">randomBoolean</span> <span class="operator">=</span> random.nextBoolean();</span><br></pre></td></tr></table></figure>



<h3 id="4-3-java-security-SecureRandom类"><a href="#4-3-java-security-SecureRandom类" class="headerlink" title="4.3. java.security.SecureRandom类"></a>4.3. <code>java.security.SecureRandom</code>类</h3><ol>
<li>安全性特点<ul>
<li><code>SecureRandom</code>类用于生成安全的随机数，适用于加密、安全协议等对随机数质量要求较高的场景。它基于更复杂的随机源（如操作系统的随机事件）来生成随机数，相比<code>Math.random()</code>和<code>Random</code>类，具有更高的随机性和不可预测性。</li>
</ul>
</li>
<li>使用方法<ul>
<li>与<code>Random</code>类类似，也可以通过<code>new</code>关键字创建<code>SecureRandom</code>类的实例，例如：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecureRandomExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SecureRandom</span> <span class="variable">secureRandom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">        <span class="comment">// 使用secureRandom对象生成安全随机数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><pre><code>SecureRandom
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  类也有一些方法用于生成不同类型的随机数，例如：</span><br><span class="line"></span><br><span class="line">  - `nextInt()`方法</span><br><span class="line">    - 与`Random`类的`nextInt`方法类似，例如：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">         SecureRandom secureRandom = new SecureRandom();</span><br><span class="line">         int secureRandomInt = secureRandom.nextInt(10); // 生成0到9之间的安全随机整数</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li><p><code>nextBytes(byte[] bytes)</code>方法</p>
<ul>
<li>用于填充一个字节数组，使其包含随机字节数据。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] randomBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line"><span class="type">SecureRandom</span> <span class="variable">secureRandom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">secureRandom.nextBytes(randomBytes);</span><br></pre></td></tr></table></figure>



<ul>
<li>这种生成随机字节数组的功能在加密算法（如生成密钥、初始化向量等）中非常有用。</li>
</ul>
<h2 id="5-流程控制（复习）"><a href="#5-流程控制（复习）" class="headerlink" title="5.流程控制（复习）"></a>5.流程控制（复习）</h2><h3 id="5-1-分支的嵌套使用"><a href="#5-1-分支的嵌套使用" class="headerlink" title="5.1.分支的嵌套使用"></a>5.1.分支的嵌套使用</h3><p>会员积分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>&#123;</span><br><span class="line"><span class="comment">//会员积分</span></span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入会员积分：&quot;</span>);</span><br><span class="line"><span class="comment">//int score=sc.nextInt();//输入浮点型、负数、字符会报错，使用hasNextInt()来防止错误输入</span></span><br><span class="line">        <span class="keyword">if</span>(sc.hasNextDouble()) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line">            <span class="keyword">if</span>(score&gt;=<span class="number">8000</span>) System.out.println(<span class="string">&quot;会员六折&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">4000</span>) System.out.println(<span class="string">&quot;会员七折&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">2000</span>) System.out.println(<span class="string">&quot;会员八折&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">0</span>) System.out.println(<span class="string">&quot;会员九折&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> System.out.println(<span class="string">&quot;无折扣&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> System.out.println(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line"><span class="comment">//**if判断失败进入下一个else；**</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小朋友搬桌子：年龄大于7，可以搬</p>
<p>大于5岁，性别是男，可以搬</p>
<p>否则不可搬</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入年龄：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> age=sc.nextInt();</span><br><span class="line">        <span class="keyword">if</span>(age&gt;=<span class="number">7</span>) System.out.println(<span class="string">&quot;可以搬&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(age&gt;=<span class="number">5</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入性别&quot;</span>);</span><br><span class="line">            String sex=sc.next();</span><br><span class="line">            <span class="type">char</span> s=sex.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(s==<span class="string">&#x27;男&#x27;</span>)System.out.println(<span class="string">&quot;可以搬&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> System.out.println(<span class="string">&quot;不能搬&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> System.out.println(<span class="string">&quot;不能搬&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//String类的charAt(n);方法用于获得字符串的单个字符</span></span><br></pre></td></tr></table></figure>

<p>根据学生分数判断等级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生成绩：&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(sc.hasNextInt())&#123;</span><br><span class="line">            <span class="type">int</span> score=sc.nextInt();</span><br><span class="line">            <span class="keyword">switch</span>(score/<span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">10</span>: <span class="comment">//System.out.println(&quot;A&quot;);break;</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">9</span>: System.out.println(<span class="string">&quot;A&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">8</span>: System.out.println(<span class="string">&quot;B&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">7</span>: System.out.println(<span class="string">&quot;C&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span>: System.out.println(<span class="string">&quot;D&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:  System.out.println(<span class="string">&quot;E&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// System.out.println(&quot;E&quot;);break;</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// System.out.println(&quot;E&quot;);break;</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// System.out.println(&quot;E&quot;);break;</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// System.out.println(&quot;E&quot;);break;</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// System.out.println(&quot;E&quot;);break;</span></span><br><span class="line"></span><br><span class="line">                    defalut: System.out.println(<span class="string">&quot;无效成绩&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> System.out.println(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//case下的操作一样可以省略</span></span><br><span class="line">模板：</span><br><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 值:操作;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值:操作;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值:操作;<span class="keyword">break</span>;</span><br><span class="line">    ....</span><br><span class="line">        defalut: 操作;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>



<h3 id="5-2循环"><a href="#5-2循环" class="headerlink" title="5.2循环"></a>5.2循环</h3><h4 id="5-2-1for"><a href="#5-2-1for" class="headerlink" title="5.2.1for"></a>5.2.1for</h4><ol>
<li>基本语法<ul>
<li>基本形式为<code>for(初始化表达式; 布尔表达式; 更新表达式) &#123;循环体&#125;</code>。</li>
<li>例如：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>这里初始化表达式<code>int i = 0</code>定义并初始化循环变量，布尔表达式<code>i &lt; 5</code>用于判断循环是否继续，更新表达式<code>i++</code>在每次循环后更新循环变量。</li>
</ul>
<ol start="2">
<li>增强 for 循环（foreach）</li>
</ol>
<ul>
<li>语法为<code>for(元素类型 元素变量 : 数组或集合) &#123;循环体&#125;</code>。</li>
<li>用于遍历数组或集合。例如，遍历数组：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> number : numbers) &#123;</span><br><span class="line">    System.out.println(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>这里<code>number</code>依次代表数组<code>numbers</code>中的每个元素。</li>
<li>遍历集合（以<code>ArrayList</code>为例）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">names.add(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(String name : names) &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-2-2-while-循环"><a href="#5-2-2-while-循环" class="headerlink" title="5.2.2.while 循环"></a>5.2.2.while 循环</h4><ol>
<li>基本语法<ul>
<li>语法为<code>while(布尔表达式) &#123;循环体&#125;</code>。</li>
<li>例如：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(j &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    System.out.println(j);</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>只要布尔表达式<code>j &lt; 3</code>为真，循环体就会执行，并且在循环体中通过<code>j++</code>更新循环变量。</li>
</ul>
<ol start="2">
<li>do - while 循环</li>
</ol>
<ul>
<li>语法为<code>do &#123;循环体&#125; while(布尔表达式);</code>。</li>
<li>与 while 循环不同的是，do - while 循环先执行一次循环体，再判断布尔表达式。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(k);</span><br><span class="line">    k++;</span><br><span class="line">&#125; <span class="keyword">while</span>(k &lt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure>



<ul>
<li>这里即使布尔表达式一开始不成立，循环体也会执行一次。</li>
</ul>
<h4 id="5-2-3-循环控制语句"><a href="#5-2-3-循环控制语句" class="headerlink" title="5.2.3.循环控制语句"></a>5.2.3.循环控制语句</h4><ol>
<li>break 语句<ul>
<li>用于跳出当前循环。</li>
<li>在 for 循环中的应用：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>当<code>i</code>等于 5 时，执行<code>break</code>，循环立即结束，只会输出 0 到 4。</li>
<li>在 while 循环中的应用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(m);</span><br><span class="line">    m++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>这里通过<code>while(true)</code>创建一个无限循环，但当<code>m</code>等于 3 时，<code>break</code>语句<code>跳出循环</code>。</li>
</ul>
<ol start="2">
<li>continue 语句</li>
</ol>
<ul>
<li>用于<code>跳过当前循环的剩余语句，直接进入下一次循环</code>。</li>
<li>在 for 循环中的应用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n &lt; <span class="number">5</span>; n++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>当<code>n</code>等于 2 时，执行<code>continue</code>，跳过本次循环中<code>System.out.println(n);</code>这一语句，直接进入下一次循环，会输出 0、1、3、4。</li>
<li>在 while 循环中的应用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>当<code>p</code>等于 3 时，执行<code>continue</code>，跳过本次循环的输出语句，会输出 1、2、4、5。</li>
</ul>
<ol start="3">
<li>return</li>
</ol>
<ul>
<li><code>直接结束程序</code></li>
</ul>
<h4 id="5-2-4-多重循环嵌套"><a href="#5-2-4-多重循环嵌套" class="headerlink" title="5.2.4.多重循环嵌套"></a>5.2.4.多重循环嵌套</h4><ol>
<li>乘法口诀</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                System.out.print(j+<span class="string">&quot;*&quot;</span>+i+<span class="string">&quot;=&quot;</span>+i*j+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">while</span> (j&lt;=i);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>百钱买百鸡</li>
</ol>
<p>公鸡5文钱一只，母鸡3文钱一只，小鸡3只一文钱，用100文钱买一百只鸡，其中公鸡，母鸡，小鸡都必须要有，问公鸡，母鸡，小鸡要买多少只刚好凑足100文钱。</p>
<p>公鸡：x,</p>
<p>母鸡：y,</p>
<p>小鸡：z</p>
<p>x+y+z&#x3D;100;</p>
<p>5x+3y+z&#x2F;3&#x3D;100;</p>
<p><code>暴力</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=<span class="number">100</span>;x++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">1</span>;y&lt;=<span class="number">100</span>;y++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> z=<span class="number">1</span>;z&lt;=<span class="number">100</span>;z++)&#123;</span><br><span class="line"><span class="keyword">if</span>((x+y+z==<span class="number">100</span>)&amp;&amp;(<span class="number">5</span>*x+<span class="number">3</span>*y+z/<span class="number">3</span>==<span class="number">100</span>)&amp;&amp;(z%<span class="number">3</span>==<span class="number">0</span>))</span><br><span class="line">System.out.println(x+<span class="string">&quot;\t&quot;</span>+y+<span class="string">&quot;\t&quot;</span>+z+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>优化</code></p>
<p>循环的最的值考虑最多能买多少只；把z的循环去除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=<span class="number">19</span>;x++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">1</span>;y&lt;=<span class="number">31</span>;y++)&#123;</span><br><span class="line"><span class="type">int</span> z=<span class="number">100</span>-x-y;</span><br><span class="line"><span class="keyword">if</span>((<span class="number">5</span>*x+<span class="number">3</span>*y+z/<span class="number">3</span>==<span class="number">100</span>)&amp;&amp;(z%<span class="number">3</span>==<span class="number">0</span>))</span><br><span class="line">System.out.println(x+<span class="string">&quot;\t&quot;</span>+y+<span class="string">&quot;\t&quot;</span>+z+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="6-方法、数组"><a href="#6-方法、数组" class="headerlink" title="6.方法、数组"></a>6.方法、数组</h2><h3 id="6-1-方法"><a href="#6-1-方法" class="headerlink" title="6.1.方法"></a>6.1.方法</h3><ul>
<li>和c\c++中的函数性质一样</li>
</ul>
<ol>
<li>面试题：两个数是否交换成功</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;输出交换前的两个数：&quot;</span>+a+<span class="string">&quot;---&quot;</span>+b);</span><br><span class="line">changeNum(a,b);</span><br><span class="line">System.out.println(<span class="string">&quot;输出交换后的两个数：&quot;</span>+a+<span class="string">&quot;---&quot;</span>+b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changeNum</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t=num1;</span><br><span class="line">num1=num2;</span><br><span class="line">num2=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>答案：不一样，<code>Java中一切都是值传递</code>，交换的只是形参。</p>
</blockquote>
<ol start="2">
<li><code>方法重载Overload</code></li>
</ol>
<p>定义：</p>
<ul>
<li>在同一个类中，方法签名（Method Signature）不同,即方法名相同，形参列表不同，构成了方法的重载</li>
<li>方法的重载只和方法的<code>形参列表</code>和<code>方法名</code>有关，与<code>修饰符</code>，<code>返回值类型</code>无关</li>
</ul>
<ol start="3">
<li><code>方法重写Override</code></li>
</ol>
<p>定义：</p>
<ul>
<li>在子类中对于父类方法的重写，方法签名（Method Signature）相同，即修饰符，返回值类型，方法名，形参列表都相同，构成了方法的重写。</li>
</ul>
<ol start="4">
<li><code>静态绑定和动态绑定</code></li>
</ol>
<ul>
<li>静态绑定（编译时绑定）：</li>
<li><ul>
<li>编译代码时就确定调用的方法</li>
<li>常见于重载的方法，private，static，final修饰的方法以及构造方法默认静态绑定</li>
</ul>
</li>
<li>动态绑定（运行时绑定）：</li>
<li><ul>
<li>运行中才能确定调用的是哪个方法</li>
<li>常见于重写的方法，private，static，final修饰的方法以及构造方法以外的方法。</li>
</ul>
</li>
</ul>
<h3 id="6-2-数组"><a href="#6-2-数组" class="headerlink" title="6.2.数组"></a>6.2.数组</h3><h4 id="6-2-1数组的初始化以及常用操作"><a href="#6-2-1数组的初始化以及常用操作" class="headerlink" title="6.2.1数组的初始化以及常用操作"></a>6.2.1数组的初始化以及常用操作</h4><ol>
<li>声明数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr;</span><br><span class="line"><span class="type">int</span> arr2[];</span><br><span class="line"><span class="type">int</span>[] arr3=<span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果数组只声明，没有后续操作相当于没定义。</p>
<p>在反编译代码中没有相应操作</p>
<p>辨别：数组赋值为null和什么都没有赋值 不一样</p>
</blockquote>
<ol start="2">
<li>创建</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr =<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];<span class="comment">//给数组开辟了一个长度为4的空间</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译期声明和创建会被合为一句话</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int[] arr=new int[4];</span><br><span class="line">//java;java中的数组是对象，在创建时会自动初始化为默认值；Java有自动垃圾回收机制（Garbage Collection，GC），程序员不需要显示的释放内存。有严格的边界检查机制，越界访问时会抛出异常</span><br><span class="line"></span><br><span class="line">int* arr=new int[4]; </span><br><span class="line">delete[] arr;</span><br><span class="line">//c++ new会调用相应的构造函数来初始化对象；使用完后需要程序员使用delete[]来释放内存。没有数组边界检查机制，越界访问会使程序崩溃或产生未定义行为</span><br><span class="line"></span><br><span class="line">int n=4;</span><br><span class="line">int* arr=(int*)malloc(n*sizeof(int));</span><br><span class="line">free(arr);</span><br><span class="line">//malloc分配的内存是未初始化的，使用之前需要自行初始化。使用后需要程序员使用free（）来释放内存。没有数组边界检查机制，越界访问会使程序崩溃或产生未定义行为</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在c&#x2F;c++&#x2F;java中分配的内存都在堆区</p>
</blockquote>
<ol start="3">
<li>使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">0</span>]=<span class="number">12</span>;</span><br><span class="line">arr[<span class="number">1</span>]=<span class="number">47</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]+<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过数组一个属性来获取  length 长度</p>
</blockquote>
<p><code> arr.length</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;数组的长度使：&quot;</span>+arr.length);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>数组的三种初始化</p>
<ul>
<li>静态初始化&#x2F;&#x2F;直接赋值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr=&#123;<span class="number">12</span>,<span class="number">23</span>,<span class="number">45</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">12</span>,<span class="number">23</span>,<span class="number">45</span>&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ol>
<li><pre><code class="java">int[] arr=new int[3]&#123;12,23,45&#125;;---》;错误
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ~~~Java</span><br><span class="line">   int[] arr;</span><br><span class="line">   arr=&#123;12,23,34&#125;;---&gt;错误</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</blockquote>
<ul>
<li>动态初始化&#x2F;&#x2F;定义和赋值分开</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr;</span><br><span class="line">arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];<span class="comment">//int[] arr=new int[3];</span></span><br><span class="line">arr[<span class="number">0</span>]=<span class="number">12</span>;</span><br><span class="line">arr[<span class="number">1</span>]=<span class="number">23</span>;</span><br><span class="line">arr[<span class="number">2</span>]=<span class="number">45</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>默认初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];<span class="comment">//每个里面都是0</span></span><br><span class="line">Boolean[] b=<span class="keyword">new</span> <span class="title class_">Boolean</span>[<span class="number">3</span>];<span class="comment">//每个里面都是false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code> 最值问题</code>&#x2F;&#x2F;冒泡排序&#x2F;&#x2F;<code> 数组的复制</code></p>
</li>
</ol>
<ul>
<li><p>给定一个数组求数组的最大值并且排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr=&#123;<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">125</span>,<span class="number">9</span>,<span class="number">45</span>&#125;;</span><br><span class="line">        <span class="type">int</span> maxNum=arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span>[] arr1=<span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        <span class="type">int</span>[] arr2=<span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        System.arraycopy(arr,<span class="number">0</span>,arr1,<span class="number">0</span>,arr.length);</span><br><span class="line">        System.arraycopy(arr,<span class="number">0</span>,arr2,<span class="number">0</span>,arr.length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:arr)<span class="comment">//找出最大值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;maxNum)</span><br><span class="line">                maxNum=x;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最大值：&quot;</span>+maxNum);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr1.length-<span class="number">1</span>;i++)<span class="comment">//冒泡排序，从大到小</span></span><br><span class="line">        &#123;<span class="comment">//遍历数组，比当前大就互换</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;arr1.length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr1[i]&lt;arr1[j]) &#123;</span><br><span class="line">                    temp=arr1[i];</span><br><span class="line">                    arr1[i]=arr1[j];</span><br><span class="line">                    arr1[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;从大到小：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:arr1)</span><br><span class="line">            System.out.print(x+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr2.length-<span class="number">1</span>;i++)&#123;<span class="comment">//冒泡排序，从小到大；</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;arr2.length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr2[i]&gt;arr2[j])&#123;</span><br><span class="line">                    temp=arr2[i];</span><br><span class="line">                    arr2[i]=arr2[j];</span><br><span class="line">                    arr2[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;\n从小到大：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y:arr2)</span><br><span class="line">            System.out.print(y+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;\n原数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> z:arr)</span><br><span class="line">            System.out.print(z+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/java.assets/image-20241023144932770.png" alt="image-20241023144932770"></p>
</li>
</ul>
<blockquote>
<p>注意点：-</p>
<ul>
<li>冒泡排序的边界问题</li>
</ul>
<blockquote>
<p>两个指针参数i，j,一个【0，length-1）；一个【1，length）</p>
</blockquote>
<p>注：j&#x3D;(i+1)</p>
<p><img src="/java.assets/image-20241023150558249.png" alt="image-20241023150558249"></p>
</blockquote>
<blockquote>
<ul>
<li>复制数组的方式</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1=arr;</span><br><span class="line"><span class="type">int</span>[] arr2=arr;<span class="comment">//这种复制方式只是让arr1和arr2指向了与arr相同的数组对象</span></span><br></pre></td></tr></table></figure>

<p>这种方式属于<code> arr对象的引用</code>，在Java中数组是对象</p>
<p>想要不改变原数组并且独立的对数组进行不同排序应该使用<code> System.arraycopy(sourceArray,sourcepos,destinationArray,destinationpos,length)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1=<span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line"><span class="type">int</span>[] arr2=<span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">System.arraycopy(arr,<span class="number">0</span>,arr1,<span class="number">0</span>,length);</span><br><span class="line">System.arraycopy(arr,<span class="number">0</span>,arr1,<span class="number">0</span>,length);</span><br></pre></td></tr></table></figure>


</blockquote>
</blockquote>
<h4 id="6-2-2数组-详述-main方法"><a href="#6-2-2数组-详述-main方法" class="headerlink" title="6.2.2数组_详述 main方法"></a>6.2.2数组_详述<code> main</code>方法</h4><ol>
<li>main方法：程序的入口，在同一个类中，如果有多个方法，那么虚拟机就会识别main方法，从这个方法作为程序的入口</li>
<li>main方法格式严格要求：</li>
</ol>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>public static —&gt;修饰符  &#x2F;&#x2F;面对对象的知识</p>
<p>void —&gt;代表方法没有返回值</p>
<p>String[] args —&gt;形参—》不确定因素</p>
</blockquote>
<ol start="3">
<li>问题：程序中是否可以有其它的方法也叫main方法？</li>
</ol>
<blockquote>
<p>可以，构成了函数的重载</p>
<ul>
<li><p>在 Java 中，一个类中只能有一个<code>public static void main(String[] args)</code>方法作为程序的入口点。</p>
</li>
<li><p>如果在一个类中定义了多个<code>main</code>方法，并且其中只有一个是<code>public static void main(String[] args)</code>这种形式，那么只有这个符合规定的<code>main</code>方法会被 Java 虚拟机（JVM）识别并作为程序启动的入口。</p>
</li>
<li><p><code> c/c++</code>中只能有一个<code> main</code>函数作为程序的入口，如果有多个链接器不知道哪个才是程序的入口。</p>
</li>
</ul>
</blockquote>
<ol start="4">
<li>String[] args实参到底是什么</li>
</ol>
<blockquote>
<p>可以手动传入实参，参数是String[],实参是 new String[0]  </p>
<p>默认情况下，虚拟机在调用main方法的时候就是传入了一个长度为0的数组</p>
</blockquote>
<h4 id="6-2-3数组-可变参数"><a href="#6-2-3数组-可变参数" class="headerlink" title="6.2.3数组__可变参数"></a>6.2.3数组__<code>可变参数</code></h4><ol>
<li>可变参数：作用提供了一个方法，参数的个数是可变的(jdk1.5之后的版本)</li>
</ol>
<blockquote>
<p>解决了部分方法重载的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    method01(<span class="number">10</span>);</span><br><span class="line">    method01();</span><br><span class="line">    method01(<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>);</span><br><span class="line">    method01(<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>);</span><br><span class="line">    method01(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">meyhod01</span><span class="params">(<span class="type">int</span>...num)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;---1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="2">
<li>对于参数的处理</li>
</ol>
<blockquote>
<p>方法的内部对可变参数的处理跟数组是一样（内部隐式创建一个数组来存储这些参数）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method01</span><span class="params">(<span class="type">int</span>...num)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;---1&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i:num)&#123;</span><br><span class="line">System.out.println(i+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依次输出参数</p>
</blockquote>
<ol start="3">
<li>在可变参数的基础上再加一个参数</li>
</ol>
<blockquote>
<ul>
<li><p>可变参数一定要放在最后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static void method01(int num2,int...num)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<ol start="4">
<li>可变参数不建议使用</li>
</ol>
<h4 id="6-2-4数组-Arrays类的使用"><a href="#6-2-4数组-Arrays类的使用" class="headerlink" title="6.2.4数组 Arrays类的使用"></a>6.2.4数组<code> Arrays类</code>的使用</h4><blockquote>
<p><code> import java.util.Arrays;</code></p>
</blockquote>
<ol>
<li><code>toString</code>方法</li>
</ol>
<blockquote>
<ul>
<li>数组转化为字符串，返回字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr =<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>,<span class="number">26</span>,<span class="number">27</span>&#125;;</span><br><span class="line">        String str=Arrays.toString(arr);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>,<span class="number">26</span>,<span class="number">27</span>]</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="2">
<li><code> binarySearch二分法查找</code></li>
</ol>
<blockquote>
<ul>
<li>找出指定<code> 有序</code>数组的指定元素对应的索引，返回int</li>
<li>binarysearch(arr,value);</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr =<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>,<span class="number">26</span>,<span class="number">27</span>&#125;;</span><br><span class="line">        <span class="type">int</span> index=Arrays.binarySearch(arr,<span class="number">26</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">        <span class="comment">//String str=Arrays.toString(arr);</span></span><br><span class="line">        <span class="comment">//System.out.println(str);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意：</p>
<blockquote>
<p><code> binarysearch</code>只能对有序数组进行查找，无序数组使用前应该进行<code>sort</code>排序</p>
</blockquote>
</li>
</ul>
</blockquote>
<ol start="3">
<li><code> sort排序</code></li>
</ol>
<blockquote>
<ul>
<li>对指定数组进行升序排序（从小到大）</li>
<li>sort(arr)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr =<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">22</span>,<span class="number">21</span>,<span class="number">26</span>,<span class="number">20</span>,<span class="number">29</span>,<span class="number">27</span>&#125;;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:arr)</span><br><span class="line">            System.out.print(x+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>	<span class="number">21</span>	<span class="number">22</span>	<span class="number">26</span>	<span class="number">27</span>	<span class="number">29</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="4">
<li><code> copyOf复制</code>&#x2F;<code> copyOfRange区间复制</code></li>
</ol>
<blockquote>
<ul>
<li>将老数组按新的长度进行复制得到一个新数组</li>
<li>copyOf(arr,newlength)</li>
<li>copyOfRange(arr,pos1,pos2)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr =<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">22</span>,<span class="number">21</span>,<span class="number">26</span>,<span class="number">20</span>,<span class="number">29</span>,<span class="number">27</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] arr1=Arrays.copyOf(arr,<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:arr1)</span><br><span class="line">            System.out.print(x+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">int</span>[] arr2=Arrays.copyOfRange(arr,<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y:arr2)</span><br><span class="line">        System.out.print(y+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span>	<span class="number">21</span>	<span class="number">26</span>	<span class="number">20</span>	</span><br><span class="line"><span class="number">26</span>	<span class="number">20</span>	<span class="number">29</span>	</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意：</p>
<blockquote>
<p>copyOfRange(arr,pos1,pos2),复制的区间为索引[pos1,pos2);</p>
<p>pos1取，pos2不取</p>
<p>和随机数一样左包含右不包含</p>
</blockquote>
</li>
</ul>
</blockquote>
<ol start="5">
<li><code> equals比较</code></li>
</ol>
<blockquote>
<ul>
<li>比较两个数组的值是否一样</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arr2=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">System.out.println(Arrays.equals(arr1,arr2));<span class="comment">//true</span></span><br><span class="line">System.out.println(arr1==arr2);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<ul>
<li><pre><code class="Java">System.out.println(arr1==arr2);//比较的是两个数组的地址
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6. 填充（`fill`）</span><br><span class="line"></span><br><span class="line">- `Arrays.fill(int[] a, int val)`用于将数组`a`中的所有元素填充为`val`。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">       import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">       public class Main &#123;</span><br><span class="line">           public static void main(String[] args) &#123;</span><br><span class="line">               int[] arr = new int[5];</span><br><span class="line">               Arrays.fill(arr, 10);</span><br><span class="line">               for (int num : arr) &#123;</span><br><span class="line">                   System.out.print(num + &quot; &quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">上述代码会将长度为 5 的数组`arr`的所有元素填充为 10</span><br><span class="line"></span><br><span class="line">#### 6.2.5二维数组</span><br><span class="line"></span><br><span class="line">##### 1. 定义（Java）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- **语法**：数据类型[][] 数组名; 或者 数据类型 数组名[][];</span><br><span class="line"></span><br><span class="line">- 示例</span><br><span class="line"></span><br><span class="line"> ：</span><br><span class="line"></span><br><span class="line"> - `int[][] matrix;`</span><br><span class="line"> - `String arrays[][];`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 2. 初始化（Java）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 静态初始化</span><br><span class="line"></span><br><span class="line"> - **语法**：数据类型[][] 数组名 = &#123;&#123;值1, 值2,...&#125;, &#123;值3, 值4,...&#125;,...&#125;;</span><br><span class="line"></span><br><span class="line"> - 示例</span><br><span class="line"></span><br><span class="line">   ：</span><br><span class="line"></span><br><span class="line">   - `int[][] matrix = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;;`</span><br><span class="line">   - 这里定义并初始化了一个3×3的二维整数数组。</span><br><span class="line"></span><br><span class="line">- 动态初始化</span><br><span class="line"></span><br><span class="line"> - **语法**：数据类型[][] 数组名 = new 数据类型[行数] [列数];</span><br><span class="line"></span><br><span class="line"> - 示例</span><br><span class="line"></span><br><span class="line">   ：</span><br><span class="line"></span><br><span class="line">   - `int[][] matrix = new int[3][4];`</span><br><span class="line">   - 这创建了一个3行4列的二维整数数组，数组中的元素会被初始化为对应数据类型的默认值（对于`int`，默认值是0）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 3. 遍历（Java）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 使用嵌套的for循环（普通for循环）</span><br><span class="line"></span><br><span class="line"> - 示例</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   public class Main &#123;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">           int[][] matrix = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;;</span><br><span class="line">           for (int i = 0; i &lt; matrix.length; i++) &#123;</span><br><span class="line">               for (int j = 0; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">                   System.out.print(matrix[i][j] + &quot; &quot;);</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ```</span><br><span class="line"></span><br><span class="line">   - 外层`for`循环控制行数，`matrix.length`表示二维数组的行数。内层`for`循环控制列数，`matrix[i].length`表示第`i`行的列数。</span><br><span class="line"></span><br><span class="line">- 使用增强for循环</span><br><span class="line"></span><br><span class="line"> - 示例</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   public class Main &#123;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">           int[][] matrix = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;;</span><br><span class="line">           for (int[] row : matrix) &#123;</span><br><span class="line">               for (int element : row) &#123;</span><br><span class="line">                   System.out.print(element + &quot; &quot;);</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ```</span><br><span class="line"></span><br><span class="line">   - 外层增强`for`循环遍历二维数组的每一行（`row`是一个一维数组，表示二维数组中的一行），内层增强`for`循环遍历每一行中的元素。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 1. 定义/c++</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- **语法**：数据类型 数组名[行数][列数];</span><br><span class="line"></span><br><span class="line">- 示例</span><br><span class="line"></span><br><span class="line"> ：</span><br><span class="line"></span><br><span class="line"> - `int matrix[3][4];`</span><br><span class="line"> - 这定义了一个3行4列的二维整数数组。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 2. 初始化/c++</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 静态初始化</span><br><span class="line"></span><br><span class="line"> - **语法**：数据类型 数组名[行数][列数] = &#123;&#123;值1, 值2,...&#125;, &#123;值3, 值4,...&#125;,...&#125;;</span><br><span class="line"></span><br><span class="line"> - 示例</span><br><span class="line"></span><br><span class="line">   ：</span><br><span class="line"></span><br><span class="line">   - `int matrix[3][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;;`</span><br><span class="line">   - 定义并初始化了一个3×3的二维整数数组。</span><br><span class="line"></span><br><span class="line">- 动态初始化（C++11及以后版本可以使用更灵活的初始化方式）</span><br><span class="line"></span><br><span class="line"> - **语法（传统方式）**：数据类型** 数组名 = new 数据类型[行数][列数];</span><br><span class="line"></span><br><span class="line"> - 示例</span><br><span class="line"></span><br><span class="line">   ：</span><br><span class="line"></span><br><span class="line">   - `int** matrix = new int*[3];`</span><br><span class="line">   - `for (int i = 0; i &lt; 3; i++) &#123;`</span><br><span class="line">   - `matrix[i] = new int[4];`</span><br><span class="line">   - `&#125;`</span><br><span class="line">   - 这里创建了一个3行4列的二维整数数组，并且使用`new`在堆上动态分配内存。注意，使用完后需要手动释放内存。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 3. 遍历c++</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 使用嵌套的for循环（普通for循环）</span><br><span class="line"></span><br><span class="line"> - 示例</span><br><span class="line"></span><br><span class="line">   ```cpp</span><br><span class="line">   #include &lt;iostream&gt;</span><br><span class="line">   int main() &#123;</span><br><span class="line">       int matrix[3][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;;</span><br><span class="line">       for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">           for (int j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">               std::cout &lt;&lt; matrix[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">           &#125;</span><br><span class="line">           std::cout &lt;&lt; std::endl;</span><br><span class="line">       &#125;</span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br><span class="line">   ```</span><br><span class="line"></span><br><span class="line">   - 外层`for`循环控制行数，内层`for`循环控制列数。</span><br><span class="line"></span><br><span class="line">- 使用基于范围的for循环（C++11及以后版本）</span><br><span class="line"></span><br><span class="line"> - 示例</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   ```cpp</span><br><span class="line">   #include &lt;iostream&gt;</span><br><span class="line">   int main() &#123;</span><br><span class="line">       int matrix[3][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;;</span><br><span class="line">       for (auto&amp; row : matrix) &#123;</span><br><span class="line">           for (int element : row) &#123;</span><br><span class="line">               std::cout &lt;&lt; element + &quot; &quot;;</span><br><span class="line">           &#125;</span><br><span class="line">           std::cout &lt;&lt; std::endl;</span><br><span class="line">       &#125;</span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br><span class="line">   ```</span><br><span class="line"></span><br><span class="line">   - 外层基于范围的`for`循环遍历二维数组的每一行（`row`是一个一维数组，表示二维数组中的一行），内层基于范围的`for`循环遍历每一行中的元素。这里使用`auto`关键字自动推断类型。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 7.面对对象</span><br><span class="line"></span><br><span class="line">- 万事万物皆对象</span><br><span class="line"></span><br><span class="line">- 对象：具体的事物，实体</span><br><span class="line"></span><br><span class="line">- 类：对对象向上抽取的部分，形成类，类是抽象的，一个模板</span><br><span class="line"></span><br><span class="line">- &gt;  权限修饰符：private（本身类中）&lt;defalut(默认)同一个包&lt;protect（类中，子类中）&lt;public（全都可以）</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; java中私有属性不能被直接继承</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- 先有父类再有子类---》继承；先有子类再有父类----》泛化</span><br><span class="line"></span><br><span class="line">- 类是一个引用变量指向堆中的实例</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### **7.1、面向对象编程的基本概念**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 7.1.1.类（Class）---》引用数据类型</span><br><span class="line"></span><br><span class="line">- 类是 Java 中面向对象编程的核心概念之一。它是一种模板或蓝图，用于定义对象的属性和行为。例如，我们可以定义一个`Car`类：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">  public class Car &#123;</span><br><span class="line">      // 成员变量（属性）</span><br><span class="line">      private String color;</span><br><span class="line">      private int speed;</span><br><span class="line">      // 构造方法</span><br><span class="line">      public Car(String color, int speed) &#123;</span><br><span class="line">          this.color = color;</span><br><span class="line">          this.speed = speed;</span><br><span class="line">      &#125;</span><br><span class="line">      // 成员方法（行为）</span><br><span class="line">      public void drive() &#123;</span><br><span class="line">          System.out.println(&quot;The &quot; + color + &quot; car is driving at &quot; + speed + &quot; mph.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 在这个`Car`类中，`color`和`speed`是属性，`drive`是行为，而构造方法用于创建`Car`类的对象。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 7.1.2.对象（Object）</span><br><span class="line"></span><br><span class="line">- 对象是类的实例。通过使用类的构造方法，我们可以创建对象。例如，使用上面定义的`Car`类创建对象：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">  public class Main &#123;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          Car myCar = new Car(&quot;red&quot;, 60);</span><br><span class="line">          myCar.drive();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 这里`myCar`就是`Car`类的一个对象，它具有`Car`类定义的属性和行为。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 7.1.3.封装（Encapsulation）</span><br><span class="line"></span><br><span class="line">- 封装是将数据（属性）和操作数据的方法（行为）捆绑在一起，并对数据的访问进行限制。在 Java 中，通常使用`private`关键字来限制属性的直接访问，然后通过公共的方法（getter 和 setter 方法）来访问和修改属性。例如，在`Car`类中：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">  public class Car &#123;</span><br><span class="line">      private String color;</span><br><span class="line">      // 获取颜色的getter方法</span><br><span class="line">      public String getColor() &#123;</span><br><span class="line">          return color;</span><br><span class="line">      &#125;</span><br><span class="line">      // 设置颜色的setter方法</span><br><span class="line">      public void setColor(String color) &#123;</span><br><span class="line">          this.color = color;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 这样可以隐藏内部数据的实现细节，提高代码的安全性和可维护性。</span><br><span class="line"></span><br><span class="line">- &gt; 高内聚：类的内部数据操作细节自己完成，不允许外部干涉；</span><br><span class="line"></span><br><span class="line">- 低耦合：仅对外部暴露少量的方法用于使用</span><br><span class="line"></span><br><span class="line">#### 7.1.4.继承（Inheritance）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
Java：
class B  extends   A &#123;&#125;
@override
public void method（）&#123;&#125;
</code></pre>
</li>
</ul>
</blockquote>
<p>c++：<br>class B ：public A{}<br>void method() override {}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; `java中：`</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 继承允许一个类（子类）继承另一个类（父类）的属性和行为。子类可以在父类的基础上添加新的属性和行为，或者重写父类的方法。例如：</span><br><span class="line">&gt;</span><br><span class="line">&gt; ```java</span><br><span class="line">&gt;    class Vehicle &#123;</span><br><span class="line">&gt;        protected int wheels;</span><br><span class="line">&gt;        public Vehicle(int wheels) &#123;</span><br><span class="line">&gt;            this.wheels = wheels;</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;        public void move() &#123;</span><br><span class="line">&gt;            System.out.println(&quot;The vehicle is moving.&quot;);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    class Car extends Vehicle &#123;</span><br><span class="line">&gt;        private String brand;</span><br><span class="line">&gt;        public Car(int wheels, String brand) &#123;</span><br><span class="line">&gt;            super(wheels);</span><br><span class="line">&gt;            this.brand = brand;</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;        @Override</span><br><span class="line">&gt;        public void move() &#123;</span><br><span class="line">&gt;            System.out.println(&quot;The car is moving.&quot;);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt; ```</span><br><span class="line">&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br><span class="line">&gt; - 这里`Car`类继承自`Vehicle`类，它继承了`wheels`属性和`move`方法，并且可以添加自己的`brand`属性和重写`move`方法。</span><br><span class="line">&gt;</span><br><span class="line">&gt; `protected`常用于在继承关系中，允许子类访问和扩展父类的部分功能。</span><br><span class="line">&gt;</span><br><span class="line">&gt; &gt; ```java</span><br><span class="line">&gt; &gt; class ParentClass &#123;</span><br><span class="line">&gt; &gt;        protected int protectedVar;</span><br><span class="line">&gt; &gt;        protected void protectedMethod() &#123;</span><br><span class="line">&gt; &gt;            protectedVar = 20;</span><br><span class="line">&gt; &gt;        &#125;</span><br><span class="line">&gt; &gt;    &#125;</span><br><span class="line">&gt; &gt;    package anotherpackage;</span><br><span class="line">&gt; &gt;    import mypackage.ParentClass;</span><br><span class="line">&gt; &gt;    class ChildClass extends ParentClass &#123;</span><br><span class="line">&gt; &gt;        void accessProtected() &#123;</span><br><span class="line">&gt; &gt;            // 可以访问父类的protectedVar和protectedMethod</span><br><span class="line">&gt; &gt;            protectedVar = 30;</span><br><span class="line">&gt; &gt;            protectedMethod();</span><br><span class="line">&gt; &gt;        &#125;</span><br><span class="line">&gt; &gt;    &#125;</span><br><span class="line">&gt; &gt; ```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; ` c++中：`</span><br><span class="line">&gt;</span><br><span class="line">&gt; - C++ 支持类的继承。例如，定义一个`Square`类继承自`Rectangle`类：</span><br><span class="line">&gt;</span><br><span class="line">&gt; ```cpp</span><br><span class="line">&gt;    class Square : public Rectangle &#123;</span><br><span class="line">&gt;    public:</span><br><span class="line">&gt;        Square(int side) : Rectangle(side, side) &#123;&#125;</span><br><span class="line">&gt;    &#125;;</span><br><span class="line">&gt; ```</span><br><span class="line">&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br><span class="line">&gt; - 这里`Square`类继承了`Rectangle`类的属性和方法，并且在构造函数中通过调用父类的构造函数来初始化对象。</span><br><span class="line">&gt; - 还可以重写父类的方法，例如重写`area`方法（如果有特殊需求）：</span><br><span class="line">&gt;</span><br><span class="line">&gt; ```cpp</span><br><span class="line">&gt;    class Square : public Rectangle &#123;</span><br><span class="line">&gt;    public:</span><br><span class="line">&gt;        Square(int side) : Rectangle(side, side) &#123;&#125;</span><br><span class="line">&gt;        int area() &#123;</span><br><span class="line">&gt;            int l = getLength();</span><br><span class="line">&gt;            return l * l;</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;;</span><br><span class="line">&gt; ```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 7.1.5.多态（Polymorphism）</span><br><span class="line"></span><br><span class="line">&gt; `java中：`</span><br><span class="line">&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br><span class="line">&gt; - 多态有两种主要形式：方法重载（Overloading）和方法重写（Overriding）。</span><br><span class="line">&gt; - 方法重载是指在一个类中定义多个方法名相同但参数列表不同的方法。例如：</span><br><span class="line">&gt;</span><br><span class="line">&gt; ```java</span><br><span class="line">&gt;    public class Calculator &#123;</span><br><span class="line">&gt;        public int add(int a, int b) &#123;</span><br><span class="line">&gt;            return a + b;</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;        public double add(double a, double b) &#123;</span><br><span class="line">&gt;            return a + b;</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt; ```</span><br><span class="line">&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br><span class="line">&gt; - 方法重写是指子类重写父类中定义的方法，如上面`Car`类重写`Vehicle`类的`move`方法。多态性使得程序可以根据对象的实际类型来调用相应的方法，增强了代码的灵活性和可扩展性。</span><br><span class="line">&gt;</span><br><span class="line">&gt; ~~~java</span><br><span class="line">&gt; public class animal&#123;</span><br><span class="line">&gt; public void shut()&#123;&#125;;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; public class cat extends animal&#123;</span><br><span class="line">&gt; public void shut()&#123;&#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; public class dog extends animal&#123;</span><br><span class="line">&gt; @Override </span><br><span class="line">&gt; public void shut()&#123;&#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; public class girl &#123;</span><br><span class="line">&gt; @Override    </span><br><span class="line">&gt; public void play(class animal)&#123;&#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; public class test&#123;</span><br><span class="line">&gt; public static void main(String[] args)&#123;</span><br><span class="line">&gt; girl pp=new girl();</span><br><span class="line">&gt; cat c=new cat();</span><br><span class="line">&gt; dog d=new dog();</span><br><span class="line">&gt; animal an=c;</span><br><span class="line">&gt; pp.play(c);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<blockquote>
<p><code> c++中：</code></p>
<ul>
<li>函数重载是 C++ 实现多态的一种方式。例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MathUtils</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>另一种多态是通过虚函数实现的动态多态。定义一个基类<code>Shape</code>和派生类<code>Circle</code>和<code>Rectangle</code>：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">int</span> r) : <span class="built_in">radius</span>(r) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">area</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">int</span> l, <span class="type">int</span> w) : <span class="built_in">length</span>(l), <span class="built_in">width</span>(w) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">area</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length * width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>这里<code>Shape</code>类中的<code>area</code>函数是虚函数，派生类<code>Circle</code>和<code>Rectangle</code>重写了<code>area</code>函数。当通过基类指针或引用调用<code>area</code>函数时，会根据对象的实际类型调用相应的函数，实现动态多态。</li>
</ul>
</blockquote>
<h4 id="7-1-6-局部变量和成员变量"><a href="#7-1-6-局部变量和成员变量" class="headerlink" title="7.1.6.局部变量和成员变量"></a>7.1.6.局部变量和成员变量</h4><ul>
<li>局部变量：方法体（函数）中定义的变量，类外定义的变量，需要手动初始化</li>
<li>成员变量：类中定义且方法体外的变量，可以由类的构造函数自动初始化</li>
<li>static静态成员变量：类中定义且方法体外的变量，可供类的所以实例使用</li>
</ul>
<h4 id="7-1-7-c-和Java中的静态成员变量之间的区别："><a href="#7-1-7-c-和Java中的静态成员变量之间的区别：" class="headerlink" title="7.1.7.c++和Java中的静态成员变量之间的区别："></a>7.1.7.c++和Java中的静态成员变量之间的区别：</h4><blockquote>
<p>在静态的方法里不能访问非静态的属性；在非静态的方法里都可以访问。</p>
</blockquote>
<h5 id="7-1-7-1-定义方式"><a href="#7-1-7-1-定义方式" class="headerlink" title="7.1.7.1.定义方式"></a>7.1.7.1.定义方式</h5><blockquote>
<ol>
<li>C++<ul>
<li>在 C++ 中，类的静态成员变量需要先在类中声明，然后在类外进行定义和初始化。例如：</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> MyClass::staticVar = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>这里先在<code>MyClass</code>类中声明了<code>staticVar</code>这个静态成员变量，然后在类外通过<code>int MyClass::staticVar = 0;</code>进行定义和初始化。</li>
</ul>
<ol start="2">
<li>Java</li>
</ol>
<ul>
<li>在 Java 中，可以在声明静态成员变量时直接初始化，或者通过静态代码块初始化。例如：</li>
<li>直接初始化：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyJavaClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVar</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>通过静态代码块初始化：&#x2F;&#x2F;在类加载的时候直接执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyJavaClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> staticVar;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        staticVar = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</blockquote>
<h5 id="7-1-7-2内存分配和生命周期"><a href="#7-1-7-2内存分配和生命周期" class="headerlink" title="7.1.7.2内存分配和生命周期"></a>7.1.7.2内存分配和生命周期</h5><blockquote>
<ol>
<li>C++</li>
</ol>
<ul>
<li>静态成员变量在程序启动时分配内存，在整个程序运行期间都存在。它在内存中的存储位置与全局变量类似，在数据段。当类的第一个对象被创建之前，静态成员变量就已经存在了。</li>
<li>例如，当有多个<code>MyClass</code>对象时，它们共享同一个静态成员变量<code>staticVar</code>的存储空间。无论创建多少个<code>MyClass</code>对象，<code>staticVar</code>在内存中只有一份。</li>
</ul>
<ol start="2">
<li>Java</li>
</ol>
<ul>
<li>在 Java 中，静态成员变量在类加载时被分配内存。当类加载器将类加载到 JVM（Java Virtual Machine）中时，静态成员变量就会被初始化并占用内存空间。</li>
<li>其生命周期从类加载开始，直到类被卸载。只要类存在于 JVM 中，静态成员变量就一直存在。例如，对于<code>MyJavaClass</code>类，一旦<code>MyJavaClass</code>被加载，其静态变量<code>staticVar</code>就会存在，与是否创建<code>MyJavaClass</code>的对象无关。</li>
</ul>
</blockquote>
<h5 id="7-1-7-3访问方式"><a href="#7-1-7-3访问方式" class="headerlink" title="7.1.7.3访问方式"></a>7.1.7.3访问方式</h5><blockquote>
<p><code> 类名.静态变量/方法</code></p>
</blockquote>
<blockquote>
<ol>
<li>C++</li>
</ol>
<ul>
<li>在 C++ 中，可以通过类名直接访问静态成员变量，也可以通过类的对象来访问。例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj;</span><br><span class="line"><span class="comment">// 通过类名访问</span></span><br><span class="line">std::cout &lt;&lt; MyClass::staticVar &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 通过对象访问</span></span><br><span class="line">std::cout &lt;&lt; obj.staticVar &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>



<ul>
<li>不过，通过类名访问是更符合规范的方式。</li>
</ul>
<ol>
<li>Java</li>
</ol>
<ul>
<li>在 Java 中，同样可以通过类名直接访问静态成员变量。通过对象访问静态成员变量在语法上是允许的，但不被推荐，因为这容易让人误解静态成员变量与对象相关。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyJavaClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVar</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过类名访问</span></span><br><span class="line">        System.out.println(MyJavaClass.staticVar);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="type">MyJavaClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyJavaClass</span>();</span><br><span class="line">        <span class="comment">// 通过对象访问（不推荐）</span></span><br><span class="line">        System.out.println(obj.staticVar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</blockquote>
<h5 id="7-1-7-4继承中的表现"><a href="#7-1-7-4继承中的表现" class="headerlink" title="7.1.7.4继承中的表现"></a>7.1.7.4继承中的表现</h5><blockquote>
<ol>
<li>C++<ul>
<li>在 C++ 中，子类可以继承父类的静态成员变量。如果子类重新定义了父类的同名静态成员变量，那么子类的静态成员变量会隐藏父类的同名静态成员变量。</li>
<li>例如：</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Parent::staticVar = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Child::staticVar = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 访问父类的静态成员变量</span></span><br><span class="line">    std::cout &lt;&lt; Parent::staticVar &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 访问子类的静态成员变量</span></span><br><span class="line">    std::cout &lt;&lt; Child::staticVar &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>在这个例子中，<code>Child</code>类中的<code>staticVar</code>隐藏了<code>Parent</code>类中的<code>staticVar</code>。</li>
</ul>
<ol>
<li>Java<ul>
<li>在 Java 中，子类也可以继承父类的静态成员变量。但是，由于静态成员变量属于类本身，所以通过子类访问父类的静态成员变量时，不存在多态性。</li>
<li>例如：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVar</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span> <span class="keyword">extends</span> <span class="title class_">ParentClass</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过父类访问静态成员变量</span></span><br><span class="line">        System.out.println(ParentClass.staticVar);</span><br><span class="line">        <span class="comment">// 通过子类访问静态成员变量</span></span><br><span class="line">        System.out.println(ChildClass.staticVar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>这里<code>ChildClass</code>继承了<code>ParentClass</code>的静态成员变量<code>staticVar</code>，通过<code>ChildClass</code>和<code>ParentClass</code>访问到的是同一个变量。</li>
</ul>
</blockquote>
<h3 id="7-2-static代码块"><a href="#7-2-static代码块" class="headerlink" title="7.2.static代码块"></a>7.2.static代码块</h3><ul>
<li><p>代码块执行顺序：</p>
</li>
<li><blockquote>
<p>静态块:在类加载的时候执行一次，用于一些全局性的初始化操作</p>
<ul>
<li>构造块</li>
<li>构造器</li>
<li>普通块</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> sa;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span>&#123;<span class="comment">//构造块</span></span><br><span class="line">        <span class="built_in">this</span>.a=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.a);<span class="comment">//普通块</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(sa);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        sa=<span class="number">10</span>;</span><br><span class="line">        System.out.println(sa);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-3-导包import"><a href="#7-3-导包import" class="headerlink" title="7.3.导包import"></a>7.3.导包import</h3><h4 id="7-3-1在-Java-中的包（package）和导入（import）"><a href="#7-3-1在-Java-中的包（package）和导入（import）" class="headerlink" title="7.3.1在 Java 中的包（package）和导入（import）"></a>7.3.1在 Java 中的包（package）和导入（import）</h4><blockquote>
<ul>
<li>包的创建：名字小写，中间用点隔开，不能用系统的关键字，对应目录路径</li>
<li>在Java中的导包没有包含和被包含的关系</li>
</ul>
</blockquote>
<ol>
<li>包（package）的概念与作用<ul>
<li>概念<ul>
<li>包是 Java 中用于组织类和接口的一种机制。它类似于文件系统中的文件夹，将相关的类和接口分组在一起。例如，<code>java.util</code>就是一个包，它包含了许多实用工具类，如<code>ArrayList</code>、<code>HashMap</code>等。</li>
</ul>
</li>
<li>作用<ul>
<li><strong>解决命名冲突</strong>：在大型项目中，不同的开发人员可能会创建同名的类。通过将类放在不同的包中，可以避免这种命名冲突。例如，公司 A 和公司 B 可能都有一个名为<code>Employee</code>的类，但如果公司 A 将其类放在<code>com.companyA</code>包中，公司 B 将其类放在<code>com.companyB</code>包中，就不会产生冲突。</li>
<li><strong>管理代码结构</strong>：有助于更好地组织和管理代码。例如，与图形相关的类可以放在<code>com.graphics</code>包中，与数据库操作相关的类可以放在<code>com.database</code>包中，使项目的代码结构更加清晰。</li>
</ul>
</li>
</ul>
</li>
<li>包的定义与使用<ul>
<li>定义包<ul>
<li>在 Java 源文件的开头使用<code>package</code>关键字来定义包。例如：</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myproject;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 类的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>上述代码将<code>MyClass</code>类放在了<code>com.example.myproject</code>包中。源文件所在的目录结构应该与包名的层次结构相对应，即上述类文件应该放在<code>com/example/myproject</code>目录下（在实际的文件系统中，目录用<code>/</code>分隔）。</li>
<li>访问包中的类<ul>
<li>要在其他类中访问另一个包中的类，有以下几种方式：</li>
<li><strong>使用全限定名</strong>：例如，如果要在<code>com.anotherpackage</code>包中的类中使用<code>com.example.myproject.MyClass</code>，可以这样写：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.anotherpackage;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnotherClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        com.example.myproject.<span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.example.myproject.MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>这种方式比较繁琐，但在没有导入包的情况下是可行的。</li>
</ul>
<ol start="3">
<li>导入（import）语句</li>
</ol>
<ul>
<li>作用<ul>
<li>为了避免每次使用其他包中的类时都要写全限定名，Java 提供了<code>import</code>语句来导入包中的类。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.anotherpackage;</span><br><span class="line"><span class="keyword">import</span> com.example.myproject.MyClass;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnotherClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>通过<code>import</code>语句，就可以直接使用<code>MyClass</code>类名，而不需要写全限定名。</li>
<li>通配符导入（*）<ul>
<li>除了导入单个类，还可以使用通配符<code>*</code>来导入一个包中的所有类。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这将导入<code>java.util</code>包中的所有类。不过需要注意的是，这种导入方式并不会提高程序的运行效率，只是在编写代码时更加方便，但可能会导致命名冲突（如果导入的多个包中有同名类），所以在实际使用中要谨慎。</p>
</li>
<li><p>静态导入：<code> static</code>搭配通配符可以导入类中的所有的静态内容</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br></pre></td></tr></table></figure>

<ul>
<li>在静态导入以后同一个类中有相同的方法时会优先走自己定义的方法。</li>
</ul>
<h4 id="7-3-2-在-C-中的命名空间（namespace）类似概念"><a href="#7-3-2-在-C-中的命名空间（namespace）类似概念" class="headerlink" title="7.3.2.在 C++ 中的命名空间（namespace）类似概念"></a>7.3.2.在 C++ 中的命名空间（namespace）类似概念</h4><ol>
<li>命名空间（namespace）的概念与作用<ul>
<li>概念<ul>
<li>命名空间是 C++ 中用于避免命名冲突的一种机制。它将相关的类型、函数、变量等封装在一个命名空间内。例如：</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">        <span class="comment">// 类的内容</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 函数内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>作用<ul>
<li>与 Java 中的包类似，主要用于解决命名冲突问题。在 C++ 库和大型项目中，不同的模块可能会定义相同名字的函数或类型，通过命名空间可以将它们区分开来。例如，<code>std</code>是 C++ 标准库的命名空间，其中包含了<code>cout</code>、<code>vector</code>等众多标准类型和函数。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>命名空间的使用</li>
</ol>
<ul>
<li>访问命名空间中的成员<ul>
<li>有以下几种方式访问命名空间中的成员：</li>
<li><strong>使用全限定名（::）</strong>：例如：</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mynamespace::MyClass obj;</span><br><span class="line">    mynamespace::<span class="built_in">myFunction</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>这种方式每次都要写出命名空间名和作用域解析运算符<code>::</code>，比较麻烦。</li>
<li><strong>使用<code>using</code>声明</strong>：例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> mynamespace::MyClass;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    mynamespace::<span class="built_in">myFunction</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>通过<code>using</code>声明，可以在当前作用域内直接使用<code>MyClass</code>，而不需要写出命名空间名，但对于<code>myFunction</code>，如果要使用，还是需要写出命名空间名，除非也对<code>myFunction</code>进行<code>using</code>声明。</li>
<li><strong>使用<code>using namespace</code>指令（不推荐在头文件中使用）</strong>：例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> mynamespace;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="built_in">myFunction</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>这种方式将命名空间中的所有成员都引入到当前作用域，使用起来最方便，但可能会导致命名冲突。如果在头文件中使用<code>using namespace</code>指令，可能会在包含该头文件的多个源文件中产生意外的命名冲突，所以在头文件中一般不建议使用这种方式。</li>
</ul>
<h3 id="7-4-super修饰符"><a href="#7-4-super修饰符" class="headerlink" title="7.4.super修饰符"></a>7.4.super修饰符</h3><h4 id="7-4-1调用父类的构造方法"><a href="#7-4-1调用父类的构造方法" class="headerlink" title="7.4.1调用父类的构造方法"></a>7.4.1调用父类的构造方法</h4><ul>
<li>当子类的构造方法需要调用父类的构造方法时，可以使用super（).</li>
<li>如果父类有默认构造方法（无参构造方法），在子类构造方法中不写super（）时，编译器会自动添加一个super（）调用。</li>
<li>例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;parent constructor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Child</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//编译器会自动添加super（）</span></span><br><span class="line">System.out.println(<span class="string">&quot;Child constructor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>但如果父类没有默认构造方法，子类构造方法必须显示的调用父类的某个构造方法，此时就要有super（参数列表）。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Parent constructor with value:&quot;</span>+value);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Child</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">super</span>(<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Child constructor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-4-2访问父类的成员（方法和变量）"><a href="#7-4-2访问父类的成员（方法和变量）" class="headerlink" title="7.4.2访问父类的成员（方法和变量）"></a>7.4.2访问父类的成员（方法和变量）</h4><ul>
<li><p>访问父类的方法</p>
<ul>
<li>当子类重写了父类的方法以后，如果子类想要调用父类被重写的方法，可以用<code> super.方法名（参数列表）。</code>例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">System.outprintln(<span class="string">&quot;Parent print method&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Child print method&quot;</span>);</span><br><span class="line"><span class="built_in">super</span>.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
<li><p>在<code>Child</code>类的<code>print</code>方法中，先执行了自己的打印语句，然后通过<code>super.print()</code>调用了父类的<code>print</code>方法。</p>
</li>
</ul>
<h4 id="7-4-3访问父类的变量"><a href="#7-4-3访问父类的变量" class="headerlink" title="7.4.3访问父类的变量"></a>7.4.3访问父类的变量</h4><ul>
<li>类似地，当子类和父类有同名变量时，在子类中可以用<code>super.变量名</code>来访问父类的变量。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showValues</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child value: &quot;</span> + <span class="built_in">this</span>.value);</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent value: &quot;</span> + <span class="built_in">super</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="7-5-Object类"><a href="#7-5-Object类" class="headerlink" title="7.5 Object类"></a>7.5 Object类</h3><ol>
<li>概述<ul>
<li>在 Java 中，<code>Object</code>类是所有类的根类。这意味着，所有的 Java 类都直接或间接地继承自<code>Object</code>类。它位于<code>java.lang</code>包中，无需显式导入。</li>
</ul>
</li>
<li>主要方法<ul>
<li><code>equals(Object obj)</code>方法<ul>
<li>该方法用于比较两个对象是否相等。在<code>Object</code>类中，<code>equals</code>方法默认的实现是比较两个对象的引用是否相同，即<code>==</code>操作。例如：</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">             <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">             <span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">             System.out.println(obj1==obj2);<span class="comment">//一定是false，比较的是地址值</span></span><br><span class="line">             System.out.println(obj1.equals(obj2)); <span class="comment">// 通常返回false，因为是不同对象的引用，比较的也是地址值</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">源码：<span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;<span class="comment">//比较地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>==obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">通常重写为比较两个类的属性是否相同</span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> xxx)&#123;<span class="comment">//判断obj是否是xxx的实例</span></span><br><span class="line">        <span class="comment">//将obj转为同类型</span></span><br><span class="line">    <span class="type">XXX</span> <span class="variable">other</span> <span class="operator">=</span>(XXX)obj;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.getXXX()==other.getXXX()&amp;&amp;...)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<ul>
<li>很多类会重写<code>equals</code>方法来实现基于对象内容的比较。例如，<code>String</code>类重写了<code>equals</code>方法，用于比较字符串的内容：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">// 返回true，因为内容相同</span></span><br></pre></td></tr></table></figure>



<ul>
<li><code>hashCode()</code>方法<ul>
<li><code>hashCode</code>方法返回对象的哈希码值。哈希码在哈希表等数据结构中用于快速查找。在<code>Object</code>类中，<code>hashCode</code>方法返回的是对象的内部地址的某种转换值（通常与内存地址相关）。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">System.out.println(obj.hashCode());</span><br></pre></td></tr></table></figure>



<ul>
<li>当重写<code>equals</code>方法时，通常也需要重写<code>hashCode</code>方法，以保证相等的对象具有相同的哈希码。例如，在自定义类中：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass()!= o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">myClass</span> <span class="operator">=</span> (MyClass) o;</span><br><span class="line">        <span class="keyword">return</span> value == myClass.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><code>toString()</code>方法<ul>
<li><code>toString</code>方法返回对象的字符串表示。在<code>Object</code>类中，<code>toString</code>方法返回的是对象的类名加上哈希码的十六进制表示。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">     System.out.println(obj.toString());</span><br><span class="line"><span class="comment">//原理</span></span><br><span class="line">getClass().getName()+<span class="string">&#x27;@&#x27;</span>+Integer.toHexString(hashCode())<span class="comment">//</span></span><br><span class="line">    全限定路径：包名+类名的完整表示</span><br></pre></td></tr></table></figure>



<ul>
<li>很多类会重写<code>toString</code>方法来提供更有意义的字符串表示。例如，<code>Date</code>类重写了<code>toString</code>方法来返回日期的字符串形式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(date.toString());</span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以在类中重写为介绍类的信息的方法。</p>
</li>
<li><p><code>getClass()</code>方法</p>
<ul>
<li>该方法返回对象的运行时类。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">System.out.println(obj.getClass()); <span class="comment">// 输出java.util.ArrayList</span></span><br></pre></td></tr></table></figure>



<ul>
<li>这个方法在反射等机制中非常有用，可以用来获取对象所属的类的相关信息，如类名、方法、字段等。</li>
<li><code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>方法<ul>
<li>这些方法用于线程间的协作，实现线程的等待和唤醒机制。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 1 is waiting&quot;</span>);</span><br><span class="line">                    lock.wait();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 1 is awakened&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 2 is notifying&quot;</span>);</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>在这个例子中，<code>thread1</code>等待，<code>thread2</code>唤醒<code>thread1</code>。</li>
</ul>
<h3 id="7-6-向上（下）转型"><a href="#7-6-向上（下）转型" class="headerlink" title="7.6.向上（下）转型"></a>7.6.向上（下）转型</h3><ul>
<li>在 Java 中，向上转型（upcasting）和向下转型（downcasting）是与多态相关的重要概念。</li>
</ul>
<h4 id="7-6-1-向上转型"><a href="#7-6-1-向上转型" class="headerlink" title="7.6.1.向上转型"></a>7.6.1.向上转型</h4><blockquote>
<ul>
<li>定义和作用</li>
<li>向上转型是指将一个子类对象赋值给一个父类类型的引用。这是自动进行的，不需要显式的类型转换。 作用：实现多态性，使代码更加灵活和可维护。通过父类引用可以调用子类重写的方法，从而实现不同的行为。</li>
</ul>
</blockquote>
<p> 示例:</p>
<p> 考虑以下代码： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;      </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;             </span><br><span class="line">System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);  </span><br><span class="line">&#125; </span><br><span class="line">&#125;     </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123; </span><br><span class="line"><span class="meta">@Override</span>         </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;             </span><br><span class="line">System.out.println(<span class="string">&quot;Meow&quot;</span>); </span><br><span class="line">&#125;    </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;             </span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();             </span><br><span class="line">animal.makeSound(); <span class="comment">// 输出 &quot;Meow&quot;    </span></span><br><span class="line">&#125;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>在这个例子中，将 Cat 类的对象赋值给 Animal 类型的变量 animal，这就是向上转型。此时，通过 animal 引用调用 makeSound() 方法，实际上调用的是 Cat 类中重写的方法。</li>
</ul>
<h4 id="7-6-2向下转型"><a href="#7-6-2向下转型" class="headerlink" title="7.6.2向下转型"></a>7.6.2向下转型</h4><blockquote>
<p>定义和作用:父类的引用类型无法调用子类特殊的方法得通过向下转型，变成子类引用后才能调用子类得特殊方法</p>
<ul>
<li>向下转型是指将一个父类对象的引用强制转换为一个子类类型的引用。这是显式的类型转换，需要小心进行，因为如果转换不正确可能会导致 ClassCastException。 作用：当需要访问子类特有的方法或属性时，可以进行向下转型。</li>
</ul>
</blockquote>
<p>示例 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;         </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;        </span><br><span class="line">System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">&#125;     &#125;     </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;       </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scratch</span><span class="params">()</span> &#123;             </span><br><span class="line">System.out.println(<span class="string">&quot;Cat is scratching&quot;</span>);         &#125;     </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;             </span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();             </span><br><span class="line"><span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Cat) &#123;            </span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) animal;               </span><br><span class="line">cat.scratch(); <span class="comment">// 输出 &quot;Cat is scratching&quot;             </span></span><br><span class="line">&#125;        </span><br><span class="line">&#125;    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>在这个例子中，首先进行向上转型，将 Cat 对象赋值给 Animal 引用。然后，通过 instanceof 运算符检查 animal 是否是 Cat 类型的实例，如果是，进行向下转型，将 animal 强制转换为 Cat 类型的变量 cat，这样就可以调用 Cat 类特有的 scratch() 方法。 总之，向上转型和向下转型在 Java 编程中是非常有用的技术，但需要谨慎使用，特别是在进行向下转型时，要确保转换的正确性，以避免运行时错误。</li>
<li><code>编译看左边，运行看右边</code>：编译的时候如果用向上转型（父类对象指向子类的实例）调用方法必须是父类中有的，不然编译出错，运行的时候根据右边具体子类对应的重写的方法来执行。</li>
</ul>
<h2 id="8-抽象类-方法和内部类"><a href="#8-抽象类-方法和内部类" class="headerlink" title="8.抽象类_方法和内部类"></a>8.抽象类_方法和内部类</h2><h3 id="8-1-抽象类"><a href="#8-1-抽象类" class="headerlink" title="8.1.抽象类"></a><strong>8.1.抽象类</strong></h3><p>在 Java 中，抽象类和抽象方法是实现抽象概念和多态性的重要工具。</p>
<ol>
<li>定义和特点<ul>
<li>抽象类是使用 <code>abstract</code> 关键字修饰的类。它可以包含抽象方法和非抽象方法，也可以包含成员变量和构造方法。</li>
<li>抽象类不能被实例化，即<code>不能使用 new</code>关键字创建抽象类的对象。它的存在主要是为了被其他类继承，提供一个通用的模板或框架。</li>
</ul>
</li>
<li>作用<ul>
<li>抽象类可以作为其他类的基类，定义一些通用的属性和方法，供子类继承和实现。它可以强制子类实现某些特定的方法，确保代码的一致性和可维护性。</li>
<li>抽象类可以包含抽象方法，这些方法只有方法签名，没有具体的实现。子类必须实现这些抽象方法，否则子类也必须声明为抽象类。</li>
</ul>
</li>
</ol>
<p><strong>二、抽象方法</strong></p>
<ol>
<li>定义和特点<ul>
<li>抽象方法是使用 <code>abstract</code> 关键字修饰的方法，只有方法签名，没有方法体。例如：<code>public abstract void doSomething();</code>。</li>
<li>抽象方法必须在抽象类中声明。如果一个类包含抽象方法，那么这个类必须声明为抽象类。</li>
</ul>
</li>
<li>作用<ul>
<li>抽象方法定义了一种行为规范，子类必须实现这些方法来提供具体的行为。这使得代码更加灵活和可扩展，不同的子类可以根据自己的需求实现不同的行为。</li>
</ul>
</li>
</ol>
<p><strong>三、示例</strong></p>
<p>以下是一个使用抽象类和抽象方法的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printColor</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Color: &quot;</span> + color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(String color, <span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(color);</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(String color, <span class="type">double</span> width, <span class="type">double</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(color);</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="string">&quot;Red&quot;</span>, <span class="number">5.0</span>);</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="string">&quot;Blue&quot;</span>, <span class="number">4.0</span>, <span class="number">6.0</span>);</span><br><span class="line"></span><br><span class="line">        circle.printColor();</span><br><span class="line">        System.out.println(<span class="string">&quot;Circle area: &quot;</span> + circle.getArea());</span><br><span class="line"></span><br><span class="line">        rectangle.printColor();</span><br><span class="line">        System.out.println(<span class="string">&quot;Rectangle area: &quot;</span> + rectangle.getArea());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这个示例中，<code>Shape</code> 是一个抽象类，它定义了一个抽象方法 <code>getArea()</code> 和一个非抽象方法 <code>printColor()</code>。<code>Circle</code> 和 <code>Rectangle</code> 类继承自 <code>Shape</code> 类，并实现了 <code>getArea()</code> 方法。通过这种方式，不同的形状类可以根据自己的特点实现计算面积的方法，同时共享通用的属性和方法。</p>
<p>总之，抽象类和抽象方法在 Java 编程中提供了一种强大的方式来实现代码的复用、多态性和可维护性。它们可以帮助开发者更好地组织和设计代码，提高代码的质量和可读性。</p>
<h3 id="8-2-内部类"><a href="#8-2-内部类" class="headerlink" title="8.2.内部类"></a>8.2.内部类</h3><p>在 Java 中，内部类是定义在另一个类内部的类。它可以访问外部类的成员，包括私有成员，并且可以实现更好的封装和代码组织。</p>
<p><strong>一、内部类的类型</strong></p>
<ol>
<li>成员内部类<ul>
<li>定义在外部类的成员位置，就像外部类的成员变量和成员方法一样。它可以访问外部类的所有成员，包括私有成员。</li>
<li>示例：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">outerVariable</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printOuterVariable</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Outer variable: &quot;</span> + outerVariable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>局部内部类</li>
</ol>
<ul>
<li>定义在外部类的方法内部，只能在该方法内部使用。局部内部类可以访问外部类的成员以及方法中的局部变量，但局部变量必须是 final 或 effectively final 的。</li>
<li>示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">localVariable</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalInnerClass</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLocalVariable</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Local variable: &quot;</span> + localVariable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalInnerClass</span> <span class="variable">localInner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalInnerClass</span>();</span><br><span class="line">        localInner.printLocalVariable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>匿名内部类</li>
</ol>
<ul>
<li>没有名字的内部类，通常用于创建接口或抽象类的实现，或者继承一个类并重写其中的方法。它通常在需要一次性使用一个类的情况下使用。</li>
<li>示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MyInterface</span> <span class="variable">myInterface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterface</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Doing something.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        myInterface.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>二、内部类的优点</strong></p>
<ol>
<li>实现更好的封装<ul>
<li>内部类可以隐藏在外部类内部，对外界不可见，只有外部类可以访问它。这有助于提高代码的安全性和可维护性。</li>
</ul>
</li>
<li>访问外部类的成员<ul>
<li>内部类可以访问外部类的所有成员，包括私有成员。这使得在某些情况下实现特定的功能更加方便。</li>
</ul>
</li>
<li>代码组织和可读性<ul>
<li>内部类可以将相关的代码放在一起，使代码结构更清晰，提高可读性。</li>
</ul>
</li>
</ol>
<p><strong>三、内部类的注意事项</strong></p>
<ol>
<li>命名冲突<ul>
<li>内部类的名称不能与外部类或其他内部类的名称相同，否则会导致编译错误。</li>
</ul>
</li>
<li>访问权限<ul>
<li>内部类的访问权限受到外部类的限制。如果外部类是私有的，内部类也只能在外部类内部访问。</li>
</ul>
</li>
<li>内存管理<ul>
<li>内部类的对象会持有外部类对象的引用，这可能会导致内存泄漏问题。在使用内部类时，要注意及时释放资源，避免内存泄漏。</li>
</ul>
</li>
</ol>
<p>总之，内部类是 Java 中一种强大的特性，它可以帮助开发者实现更好的封装、代码组织和可读性。在使用内部类时，要注意命名冲突、访问权限和内存管理等问题，以确保代码的正确性和性能。</p>
<h3 id="8-3-简单工厂设计模式"><a href="#8-3-简单工厂设计模式" class="headerlink" title="8.3.简单工厂设计模式"></a>8.3.简单工厂设计模式</h3><ul>
<li><p>不仅可以使用父类的形参，还可以使用父类左方法的返回值类型，真是返回的对象可以是该类的任意一个子类对象。</p>
</li>
<li><p>简单工厂模式的实现，它是解决大量对象创建问题的一个解决方案，将创建和使用分开，公厂负责创建，使用者直接调用即可，简单工厂模式的基本要求是（<code> 定义一个创建对象的类并且通过静态方法来实现创建</code>）</p>
<blockquote>
<ul>
<li>定义一个static方法，通过类名直接实现</li>
<li>返回值类型是父类类型，返回的可以是其任意子类类型</li>
<li>传入一个字符串类型的参数，工厂根据参数创建对应的子类产品</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;<span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">shut</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;<span class="comment">//子类猫</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shut</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;喵喵喵&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;<span class="comment">//子类狗</span></span><br><span class="line"><span class="meta">@Overrride</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shut</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;汪汪汪&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PetStore</span>&#123;<span class="comment">//宠物店  单例模式</span></span><br><span class="line"><span class="comment">//私有构造函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">PetStore</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//方法提供动物</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title function_">getanimal</span><span class="params">(String petname)</span>&#123;</span><br><span class="line">Animal an=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;猫&quot;</span>.equals(petname)) an=<span class="keyword">new</span> <span class="title class_">cat</span>();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;狗&quot;</span>.equals(petname)) an=<span class="keyword">new</span> <span class="title class_">dog</span>();</span><br><span class="line">    <span class="keyword">return</span> an;</span><br><span class="line">&#125;<span class="comment">//petname.equals(&quot;猫&quot;)  当petname为空时会报空指针异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">girl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(Animal an)</span>&#123;</span><br><span class="line">        an.shut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        girl g=<span class="keyword">new</span> <span class="title class_">girl</span>();</span><br><span class="line">        Animal an=PetStore.getanimal(<span class="string">&quot;狗&quot;</span>);</span><br><span class="line">        g.play(an);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-接口"><a href="#9-接口" class="headerlink" title="9.接口"></a>9.接口</h2><h3 id="9-1-接口的基本概念"><a href="#9-1-接口的基本概念" class="headerlink" title="9.1.接口的基本概念"></a>9.1.接口的基本概念</h3><ol>
<li>类是类，接口是接口，属于同一层次的概念。</li>
<li>接口中没有构造器。接口声明使用 <code>interface</code>关键字。</li>
<li>在 JDK 1.8 之前，接口主要有两部分：<ul>
<li>常量：固定修饰符为 <code>public static final</code>，可不写系统默认补全。</li>
<li>抽象方法：固定修饰符为 <code>public abstract</code>。</li>
</ul>
</li>
</ol>
<h3 id="9-2-类和接口的关系"><a href="#9-2-类和接口的关系" class="headerlink" title="9.2.类和接口的关系"></a>9.2.类和接口的关系</h3><ol>
<li>实现关系：类通过 <code>implements</code>关键字实现接口。</li>
<li>一旦实现一个接口，实现类必须重写接口的全部抽象方法。如果没有全部重写，可以把类变成抽象类。</li>
<li>Java 只有单继承，但可以多实现（类只能有一个直接父类，但可以实现多个接口），一般先继承再实现。</li>
<li>接口不能创建对象，但接口可以指向实现类，如 <code>test_interface t = new Student();</code>。</li>
</ol>
<h3 id="9-3-接口的常量访问"><a href="#9-3-接口的常量访问" class="headerlink" title="9.3.接口的常量访问"></a>9.3.接口的常量访问</h3><ol>
<li>接口.常量，如 <code>test_interface.Num</code>。</li>
<li>通过实现接口的类来访问，接口中的属性都是静态常量，可直接通过类名.常量（如 <code>Student.num</code>）或通过实例（如 <code>s.Num</code>）。</li>
</ol>
<h3 id="9-4-接口的作用"><a href="#9-4-接口的作用" class="headerlink" title="9.4.接口的作用"></a>9.4.接口的作用</h3><ol>
<li>接口定义规则与类不同，实现类负责实现接口定义的规则即可。</li>
<li>用类继承侧重属性的本质，用接口实现不追寻本质，只是实现特定功能（如 -able）。例如手机和照相机不同根无法继承，但手机可拍照，可通过接口实现拍照功能。</li>
</ol>
<h3 id="9-5-增加多态的应用场合"><a href="#9-5-增加多态的应用场合" class="headerlink" title="9.5.增加多态的应用场合"></a>9.5.增加多态的应用场合</h3><ol>
<li>父类当作方法的形参，传入具体的子类对象。</li>
<li>父类当作方法的返回值，返回的是具体的子类对象。</li>
<li>接口当作方法的形参，传入具体的实现类的对象。</li>
<li>接口当作方法的返回值，返回的是具体的实现类的对象。</li>
</ol>
<h3 id="9-6-接口和抽象类的区别"><a href="#9-6-接口和抽象类的区别" class="headerlink" title="9.6.接口和抽象类的区别"></a>9.6.接口和抽象类的区别</h3><ol>
<li>JDK 1.8 之后，接口新增非抽象方法：<ul>
<li>被 <code>public default</code>修饰的非抽象方法，加上 <code>default</code>后不能被重写，其它修饰符可默认不加。</li>
<li>静态方法。</li>
</ul>
</li>
<li>在接口中加入非抽象方法的原因：如果接口中只能定义抽象方法，修改接口内容对实现类影响太大，加入非抽象方法可供某些实现类调用。</li>
</ol>
<h3 id="9-7-示例代码"><a href="#9-7-示例代码" class="headerlink" title="9.7.示例代码"></a>9.7.示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">test_interface</span> &#123;</span><br><span class="line">    <span class="comment">//常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">Num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line">    <span class="comment">//非抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---&gt;method c非抽象方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">d</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---&gt;static方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">test_interface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------默认抽象方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---num:&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testc_d</span><span class="params">()</span> &#123;</span><br><span class="line">        c(); <span class="comment">//可以</span></span><br><span class="line">        <span class="comment">// super.c();不可以</span></span><br><span class="line">        test_interface.<span class="built_in">super</span>.c(); <span class="comment">//可以</span></span><br><span class="line">        test_interface.d(); <span class="comment">//调用静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">test_interface</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.a();</span><br><span class="line">        s.b(test_interface.Num);</span><br><span class="line">        System.out.println(Student.Num);</span><br><span class="line">        System.out.println(s.Num);</span><br><span class="line">        s.testc_d();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-8-接口与Lambda表达式"><a href="#9-8-接口与Lambda表达式" class="headerlink" title="9.8.接口与Lambda表达式"></a>9.8.接口与Lambda表达式</h3><ul>
<li><p>Lambda表达式就是一个只写参数列表和方法体的匿名方法（参数列表和方法体之间的符号是-&gt;)</p>
</li>
<li><pre><code class="java">(a,b)-&gt;&#123;
return a+b;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- java中的Lambda表达式主要用于在给单接口变量（接口中有且只有一个abstract方法）赋值，让代码更简洁。</span><br><span class="line"></span><br><span class="line">- ~~~java</span><br><span class="line">  interface ShowMessage&#123;</span><br><span class="line">  void print(String s);</span><br><span class="line">  &#125;</span><br><span class="line">  public class test&#123;</span><br><span class="line">  public static void main(String args[])&#123;</span><br><span class="line">  ShowMessage sm;//声明接口变量</span><br><span class="line">  sm= (s)-&gt;&#123;     //接口变量中存放Lambda表达式的值,把一整个Lambda表达式看作右值，所以结尾加&#x27;;&#x27;</span><br><span class="line">  System.out.println(&quot;tvtvtv&quot;);</span><br><span class="line">  System.out.println(s);</span><br><span class="line">  System.out.println(&quot;tvtvtv&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">  sm.print(&quot;长城牌电视机&quot;)//接口回调Lambda表达式实现的接口方法</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li></li>
</ul>
<h2 id="10-异常（Exception）处理"><a href="#10-异常（Exception）处理" class="headerlink" title="10.异常（Exception）处理"></a>10.异常（Exception）处理</h2><h3 id="10-1捕获异常"><a href="#10-1捕获异常" class="headerlink" title="10.1捕获异常"></a>10.1捕获异常</h3><ul>
<li><p>1.基于if-else处理异常缺点太多，所以Java中专门出了一个异常处理机制：</p>
</li>
<li><blockquote>
<p>异常三连：try-catch-finally</p>
</blockquote>
</li>
<li><p>2.异常出现了以后怎么看：</p>
</li>
<li><p>第一行提示异常的类型，最后一行提示异常出现的位置</p>
</li>
<li><p><img src="/java.assets/image-20241102161403029.png" alt="image-20241102161403029"></p>
</li>
<li><p>3.捕获异常： <code> try-catch</code></p>
</li>
<li><blockquote>
<pre><code class="Java">public class test&#123;
public static void main(String[]args)&#123;
//录入两个数求商
try&#123;
Scanner sc=new Scanner(System.in);
System.out.println(&quot;请输入第一个数:&quot;);
int num1=sc.nextInt();
System.out.println(&quot;请输入第二个数：&quot;);
int num2=sc.nextInt();
System.out.println(&quot;商：&quot;+num1/num2);
&#125;
catch(Exception ex)&#123;//Exception是所有异常的父类
System.out.println(&quot;对不起，程序出现异常！&quot;)；
&#125;
    System.out.println(&quot;------enjoy(o.o)&quot;);
&#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 原理：把可能会出现的异常放入try代码块中，然后将异常封装成对象，被catch后面的（）中的异常对象接受，接受以后执行catch后面的&#123;&#125;里面的代码。</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 1. try中没有异常，catch中代码不执行</span><br><span class="line">&gt;   2. try中有异常，catch进行捕获：</span><br><span class="line">&gt;</span><br><span class="line">&gt;   如果异常匹配，走catch中的代码块</span><br><span class="line">&gt;</span><br><span class="line">&gt;   如果异常不匹配，不走catch中的代码，异常中断</span><br><span class="line">&gt;</span><br><span class="line">&gt;   注意：（1）try中如果出现异常，然后用catch捕获成功的话，那么try中后续的代码是不会执行的</span><br><span class="line">&gt;</span><br><span class="line">&gt;   （2）如果catch捕获异常成功，那么try-catch后面的代码该执行还是继续执行无影响</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 10.2.异常处理</span><br><span class="line"></span><br><span class="line"> - 打印异常信息：</span><br><span class="line"></span><br><span class="line">调用toString方法，显示异常的类名（全限定路径）</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">System.out.println(ex);</span><br><span class="line">System.out.println(ex.toString());</span><br></pre></td></tr></table></figure>

显示异常描述信息对应的字符串,如果没有就显示null

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ex.getMessage());</span><br></pre></td></tr></table></figure>

显示异常的堆栈信息：将异常的信息在控制台打印而不中断程序

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ex.printStackTrace();</span><br></pre></td></tr></table></figure>

抛出异常，程序中断（异常两次）

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> ex;</span><br></pre></td></tr></table></figure>
</code></pre>
</blockquote>
</li>
</ul>
<h3 id="10-3finally"><a href="#10-3finally" class="headerlink" title="10.3finally"></a>10.3finally</h3><ul>
<li>（1）什么情况下，try-catch后面的代码不执行？</li>
</ul>
<ol>
<li>throw抛出异常的情况</li>
<li>异常捕获失败（与捕获的异常类型不相容，直接中断）</li>
<li>在try中遇到return</li>
</ol>
<ul>
<li>（2）如何将try-catch后面的代码必须执行？</li>
</ul>
<blockquote>
<p>只要将必须执行的代码放入finally中，那么这代码无论如何一定执行</p>
</blockquote>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"><span class="comment">//录入两个数求商</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入第一个数:&quot;</span>);</span><br><span class="line"><span class="type">int</span> num1=sc.nextInt();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入第二个数：&quot;</span>);</span><br><span class="line"><span class="type">int</span> num2=sc.nextInt();</span><br><span class="line">System.out.println(<span class="string">&quot;商：&quot;</span>+num1/num2);</span><br><span class="line">    <span class="comment">//System.exit(0);//终止当前的虚拟器执行</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception ex)&#123;<span class="comment">//Exception是所有异常的父类</span></span><br><span class="line"><span class="comment">//throw ex;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;<span class="comment">//一定执行</span></span><br><span class="line">System.out.println(<span class="string">&quot;----enjoy(o.o)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>（3）先执行finally再执行return</p>
</li>
<li><p>（4）什么代码会放在finally中？</p>
</li>
<li><blockquote>
<p>关闭数据库资源、关闭IO流资源、关闭socket资源。</p>
<p>如果把资源放<code>try(&quot;资源&quot;)&#123;&#125;</code>，如此会自动释放。不需要在finally中手动释放。</p>
</blockquote>
</li>
<li><p>（5）finally代码块不执行的情况：</p>
</li>
<li><blockquote>
<pre><code class="Java">System.exit(0);//终止当前的虚拟器执行
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"> -   (6)带有close的语法糖try(IO流对象)&#123;&#125;     自动关闭文件流，不需要使用finally代码块</span><br><span class="line"></span><br><span class="line"> - &gt; ~~~java</span><br><span class="line">public class BufferedTset&#123;</span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line">     try( BufferedReader br=new BufferedReader(new FileReader(&quot;path&quot;));</span><br><span class="line">           BufferedWriter bw=new bufferedWriter(new FlieWriter(&quot;path1&quot;));</span><br><span class="line">          )//资源放在try-catch块中，自动刷新关闭释放</span><br><span class="line">         &#123;</span><br><span class="line">             List&lt;String&gt; data=new ArrayList&lt;&gt;();</span><br><span class="line">             String line;//读出加入到List容器</span><br><span class="line">             while((line=br.readline())!=null) data.add(line);</span><br><span class="line">         &#125;</span><br><span class="line">     Collection.sort(data);//排序</span><br><span class="line">     System.out.println(adta);</span><br><span class="line">     //写入</span><br><span class="line">     for(String s:data)&#123;</span><br><span class="line">         bw.Writer(s);</span><br><span class="line">         bw.newLine;//换行</span><br><span class="line">     &#125;catch(Exception e)&#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</blockquote>
</li>
</ul>
<h3 id="10-4-多重catch"><a href="#10-4-多重catch" class="headerlink" title="10.4.多重catch"></a>10.4.多重catch</h3><ul>
<li><p>（1）try中出现异常以后，将异常类型跟catch后面的类型依次匹配，执行第一个与异常类型匹配的catch语句，后面的catch语句就会被忽略</p>
</li>
<li><p>（2）将特殊异常放前面；（先写子类异常再写父类异常）</p>
</li>
<li><p>（3）在jdk1.7以后，异常处理方式：可以并列用|符号连接：</p>
</li>
<li><pre><code class="java">public static Integer getInteger(String nm,Integer val)&#123;
String v=null;
try&#123;
v=System.getProperty(nm);
&#125;catch(IllegalArgumentException|NullPointerException e)&#123;

&#125;if(v!=null)&#123;
try&#123;
return Integer.decode(v);
&#125;catch(NumberFormatException e)&#123;&#125;
&#125;
return val;
&#125;

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 10.5.异常分类</span><br><span class="line"></span><br><span class="line">- &gt; Object类--》Throwable类--》</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; &gt; Error(错误)、Exception(异常)     //Error错误不用关注，一般靠程序本身无法解决</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; &gt; Exception---》检查异常、运行时异常</span><br><span class="line"></span><br><span class="line">  注意：程序中语法错、逻辑错误都不属于上面的error、Exception</span><br><span class="line"></span><br><span class="line">1. 运行时异常（免检异常unchecked exception）Error和RuntimeException</span><br><span class="line"></span><br><span class="line">- 写代码的时候，不用特意对异常进行处理，在程序运行以后系统自动检测，然后报出异常</span><br><span class="line"></span><br><span class="line">2. 检查异常(必检异常checked exception)</span><br><span class="line"></span><br><span class="line">- 写代码的时候，就要对代码进行异常处理：throws向外抛或者try-catch捕获异常</span><br><span class="line"></span><br><span class="line">常见的必检异常：（继承自Exception)</span><br><span class="line"></span><br><span class="line">&gt;SQLException、IOException、ClassnotFindexception、InterruptException</span><br><span class="line"></span><br><span class="line">常见的免检异常：(继承自RuntimeException)</span><br><span class="line"></span><br><span class="line">&gt;NullPointerException（空指针）、ArrthmaticException、ClassCastException（类转换）、IndexOutOfBandException(越界)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; ALT+enter用idea生成try-catch</span><br><span class="line">&gt;</span><br><span class="line">&gt; CTRL+ALT+T生成try-catch</span><br><span class="line"></span><br><span class="line">1. try-catch嵌套</span><br><span class="line">2. 多重catch</span><br><span class="line">3. throws</span><br><span class="line"></span><br><span class="line">- **throw和throws**的区别</span><br><span class="line"></span><br><span class="line">  &gt;~~~java</span><br><span class="line">  &gt;package com.fortest1;</span><br><span class="line">  &gt;import java.util.Scanner;</span><br><span class="line">  &gt;public class test01 &#123;</span><br><span class="line">  &gt;public static void main(String[] args) throws Exception //把异常抛给方法名</span><br><span class="line">  &gt;&#123;</span><br><span class="line">  &gt;   Scanner sc=new Scanner(System.in);</span><br><span class="line">  &gt;   System.out.println(&quot;请输入第一个数:&quot;);</span><br><span class="line">  &gt;   int num1=sc.nextInt();</span><br><span class="line">  &gt;   System.out.println(&quot;请输入第二个数：&quot;);</span><br><span class="line">  &gt;   int num2=sc.nextInt();</span><br><span class="line">  &gt;if(num2==0)&#123;//除数为0，制造异常</span><br><span class="line">  &gt;//制造运行时异常：</span><br><span class="line">  &gt;//throw new RuntimeException();</span><br><span class="line">  &gt;//制造检查异常</span><br><span class="line">  &gt;/*  try &#123;</span><br><span class="line">  &gt;   throw new Exception();</span><br><span class="line">  &gt;&#125; catch (Exception e) &#123;</span><br><span class="line">  &gt;   e.printStackTrace();</span><br><span class="line">  &gt;&#125;</span><br><span class="line">  &gt;*/</span><br><span class="line">  &gt;throw new Exception();</span><br><span class="line">  &gt;&#125;</span><br><span class="line">  &gt;else System.out.println(&quot;商：&quot;+num1/num2);</span><br><span class="line">  &gt;   &#125;</span><br><span class="line">  &gt;&#125;</span><br></pre></td></tr></table></figure>
&gt;
&gt;&gt; 1. 位置不同：throw：在方法内部；throws:方法的声明处，谁调用谁处理或者继续往外抛出
&gt;&gt; 2. 内容不同：throw+异常对象（检查异常、运行时异常）；throws+异常的类型（可以多个类型，用&quot;,&quot;拼接）
&gt;&gt; 3. 作用不同：throw:异常出现的源头，制造异常；throws：在方法的声明处，告诉方法的调用者，这个方法中可能存在异常，要么自己处理要么在继续向外抛出异常
</code></pre>
</li>
</ul>
<h3 id="10-6-异常-重载和重写以及自定义异常"><a href="#10-6-异常-重载和重写以及自定义异常" class="headerlink" title="10.6.异常_重载和重写以及自定义异常"></a>10.6.异常_重载和重写以及自定义异常</h3><h4 id="10-6-1异常重载和重写"><a href="#10-6-1异常重载和重写" class="headerlink" title="10.6.1异常重载和重写"></a>10.6.1异常重载和重写</h4><ul>
<li>重载：方法名相同，形参列表不同(与异常无关)</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo&#123;</span><br><span class="line">public void a()throws Exception&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public void a(int age)throws ArithmeticException&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>重写：子类继承；接口实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;父类方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> exdents Person&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span><span class="keyword">throws</span> RunTimeException&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;子类方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><blockquote>
<p>子类的异常范围&lt;&#x3D;父类的异常；即子类的异常不能是父类异常的父类</p>
</blockquote>
</li>
</ul>
<h4 id="10-6-2自定义异常"><a href="#10-6-2自定义异常" class="headerlink" title="10.6.2自定义异常"></a>10.6.2自定义异常</h4><ul>
<li><p>创建一个类：</p>
</li>
<li><blockquote>
<p>该类可以继承自运行时异常RuntimeException为免检异常</p>
<p>也可以继承检查异常Exception为必检异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">package</span> com.fortest1;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> extends <span class="comment">//Exception RuntimeException </span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">790745766939L</span>;</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span>&#123;</span><br><span class="line"> <span class="built_in">super</span>(msg);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过throw new MyException(“sdasdsad”);抛出异常不强调额外处理，也可以用try-catch捕获</p>
<p>如果继承的是检查异常需要捕获异常或者throws向上抛出</p>
</blockquote>
</li>
<li><p><strong>搞清楚五个关键词</strong>：try-catch-finally-throw-throws</p>
</li>
</ul>
<h3 id="10-7-断言"><a href="#10-7-断言" class="headerlink" title="10.7.断言"></a>10.7.断言</h3><ul>
<li><p>断言语句在调试代码阶段非常有用，断言语句一般用于程序不准备通过捕获异常来处理的错误，例如：当发生某个错误时要求程序必须立即停止执行。</p>
</li>
<li><p>语法结构：</p>
</li>
<li><pre><code>assert number&gt;10;//number&gt;10的值为true，程序继续执行，否则程序立即结束执行
assert booleanExpression;//true继续执行，否则程序立即结束执行
assert booleanExpression:messageExcept;//booleanExpression为true继续执行，为false，停止执行，并且输出messageExcept表达式的值
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">## 11.常用类</span><br><span class="line"></span><br><span class="line">### 11.1.包装类</span><br><span class="line"></span><br><span class="line">- （1）什么是包装类？</span><br><span class="line"></span><br><span class="line">- &gt; 将基本数据类型对应进行了一个封装，产生了一个新的类，---》**包装类**</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 基本数据类型：boolean(1)-&gt;byte(1)-&gt;char(2)-&gt;short(2)-&gt;int(4)-&gt;long(8L)-&gt;float(4f)-&gt;double(8)</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 包装类---&gt;引用数据类型</span><br><span class="line"></span><br><span class="line">  &gt;（2）对应关系：</span><br><span class="line">  &gt;</span><br><span class="line">  &gt;基本数据类型                包装类     继承关系</span><br><span class="line">  &gt;</span><br><span class="line">  &gt;byte                               Byte    ---》Number--》Object    </span><br><span class="line">  &gt;</span><br><span class="line">  &gt;short                             Short   ---》Number--》Object</span><br><span class="line">  &gt;</span><br><span class="line">  &gt;int                                  Integer  ---》Number--》Object</span><br><span class="line">  &gt;</span><br><span class="line">  &gt;long                               Long     ---》Number--》Object</span><br><span class="line">  &gt;</span><br><span class="line">  &gt;float                               Float    ---》Number--》Object</span><br><span class="line">  &gt;</span><br><span class="line">  &gt;double                           Double   ---》Number--》Object</span><br><span class="line">  &gt;</span><br><span class="line">  &gt;char                               Character    ---》Object</span><br><span class="line">  &gt;</span><br><span class="line">  &gt;boolean                         Boolean    ---》Object</span><br><span class="line"></span><br><span class="line">- （3）已经有数据类型了为什么要使用包装类？</span><br><span class="line"></span><br><span class="line">&gt; 把基本数据类型封装成包装类便于引用数据类型操作</span><br><span class="line"></span><br><span class="line">- **类Integer**</span><br><span class="line"></span><br><span class="line">- &gt; 1. 直接使用无需导包  Java.Lang下</span><br><span class="line">  &gt; 2. 类的继承关系   ---&gt;Number---&gt;Object</span><br><span class="line">  &gt; 3. 实现接口：  Serializable,Comparable&lt;Integer&gt;</span><br><span class="line">  &gt; 4. 这个类被final修饰不能被继承：</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; &gt; ~~~java</span><br><span class="line">  &gt; &gt; public final class Integer </span><br><span class="line">  &gt; &gt; extends Number</span><br><span class="line">  &gt; &gt; implements Comparable&lt;Integer&gt;</span><br></pre></td></tr></table></figure>
&gt;
&gt; 5. 对int类型进行包装
&gt; 6. 属性：共有静态字符常量通过类名调用public static final
&gt;
&gt; &gt; <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.MAX_VALUE);<span class="comment">//int的最大值</span></span><br><span class="line">System.out.println(Integer.MIN_VALUE);<span class="comment">//int的最小值</span></span><br></pre></td></tr></table></figure>
&gt; &gt;
&gt; &gt; 注意：最大值+1=最小值；最小值-1=最大值
&gt;
&gt; 7. 构造方法：(无空参)
&gt;
&gt; &gt; <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i1=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">12</span>);<span class="comment">//12--&gt;private final value</span></span><br><span class="line">Integer i2=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;12&quot;</span>);<span class="comment">//转为12--&gt;private final value</span></span><br><span class="line">Integer i3=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//NumFormatException异常</span></span><br></pre></td></tr></table></figure>
&gt;
&gt; 8. 包装类的自动类型转化
&gt;
&gt; &gt; <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i=<span class="number">12</span>;<span class="comment">//Integer---&gt;int通过Integer.ValeuOf()</span></span><br><span class="line">Integer i2=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">12</span>);</span><br><span class="line"><span class="type">int</span> num=i2;<span class="comment">//int---&gt;Integer 通过Integer.intValue()</span></span><br></pre></td></tr></table></figure>
&gt;
&gt; 9. 常用方法：
&gt;
&gt; &gt;i1.compareTo(i2) ;  //返回-1，0，1   
&gt; &gt;
&gt; &gt;i1.equals（i2）;   //返回true，false
&gt; &gt;
&gt; &gt;int num = Integer.parseInt(&quot;123&quot;);//将字符串转化为int
&gt; &gt;
&gt; &gt;int value = i1.intValue(); //返回Integer对象的int值
&gt; &gt;
&gt; &gt;String str=i1.toString();//以字符串方式返回Integer的值
</code></pre>
</li>
</ul>
<h3 id="11-2-日期相关"><a href="#11-2-日期相关" class="headerlink" title="11.2.日期相关"></a>11.2.日期相关</h3><ul>
<li><p>Java.util.Date</p>
</li>
<li><blockquote>
<pre><code class="java">//Date类的使用  java.util.Date
Date d=new Date();  //初始化一个Date对象
    //获取当前时间
    System.out.println(d);
System.out.println(d.toString());
//返回自1970年1月1日00.00.00GMT以来的毫秒数
    System.out.println(d.getTime());
    System.out.println(System.currentTimeMillis());
//System.currentTimeMillis()更方便直接静态调用无需创建对象
//public static native long currentTimeMillis();本地方法没有方法体
//该时间差的作用：用于衡量一些算法的时间：
    long startTime=System.currentTimeMillis();
    for(int i=0;i&lt;10000;i++)
    &#123;
        System.out.print(i);
    &#125;
    System.out.println();
    long endTime=System.currentTimeMillis();
    System.out.println(endTime-startTime);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- java.sql.Date</span><br><span class="line"></span><br><span class="line">- &gt; ~~~~java</span><br><span class="line">//java.sql.Date   需要传入long型参数 1970年1月1日00.00.00到所要表示的时间的毫秒数</span><br><span class="line">    Date d=new Date(System.currentTimeMillis());</span><br><span class="line">    System.out.println(d);</span><br><span class="line">//区别：sql.Date只返回年月日；util.Date包括时分秒</span><br><span class="line">    //联系：sql.Date(子) exdents util.Date（父）</span><br><span class="line">    //相互转换：//向上转型：子类对象赋值给父类的引用   //父类的引用类型无法调用子类特殊的方法得通过向下转型，变成子类引用后才能调用子类得特殊方法</span><br><span class="line">                   java.util.Date date_fa=new java.sql.Date(System.currentTimeMillis());</span><br><span class="line">    System.out.println(date_fa.getTime());</span><br><span class="line">//向下转型：</span><br><span class="line">    java.util.Date date_fa1=new java.sql.Date(System.currentTimeMillis());</span><br><span class="line">if(date_fa1 instanceof java.sql.Date)&#123;</span><br><span class="line">    Date date_son1=(Date) date_fa1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~~~~</span><br><span class="line"></span><br><span class="line">- SimpleDateFormat（少用）</span><br><span class="line"></span><br><span class="line"> - &gt; String---&gt;java.util.Date类型转换</span><br><span class="line"></span><br><span class="line">&gt; String---&gt;java.sql.Date</span><br><span class="line">&gt;</span><br><span class="line">&gt; java.sql.Date---&gt;java.util.Date</span><br><span class="line">&gt;</span><br><span class="line">&gt; ~~~java</span><br><span class="line">&gt; Date date3=Date.valueOf(&quot;2024-11-03&quot;);</span><br><span class="line">&gt;     java.util.Date date_3= (java.util.Date) date3;</span><br><span class="line">&gt;     System.out.println(date_3.toString());</span><br></pre></td></tr></table></figure>

- 缺点：字符串只能是年-月-日；
- 引入DateFormat(抽象类)无法初始化，SimpleDateFormat作为子类可以初始化

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//日期转换</span></span><br><span class="line">    <span class="comment">//String---&gt;Date</span></span><br><span class="line">    <span class="comment">//SimpleDateFormat extends DateFormat(抽象类)</span></span><br><span class="line">    DateFormat df=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<span class="comment">//自己定义的日期格式年y,月M,日d,时H(24)/h(12),分m,秒s,毫秒S</span></span><br><span class="line"><span class="comment">//定义好了格式化标准</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       Date date= df.parse(<span class="string">&quot;2024-11-03 17:25:55&quot;</span>);</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//Date---&gt;String</span></span><br><span class="line">   String df_now= df.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">System.out.println(df_now);</span><br></pre></td></tr></table></figure>

- parse（接受字符串返回Date），format（接受Date返回字符串）
</code></pre>
</blockquote>
</li>
<li><p>日历Calendar(抽象类)(少用)</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Calendar是一个抽象类，不可以直接创建对象</span></span><br><span class="line"><span class="comment">//GregorianCalendar()子类extends Calendar</span></span><br><span class="line">Calendar cal=<span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>();</span><br><span class="line">Calendar cal2=Calendar.getInstance();</span><br><span class="line">System.out.println(cal2);</span><br><span class="line"><span class="comment">//常用的方法  get方法；传入Calendar中定义的常量</span></span><br><span class="line">   System.out.println(cal2.get(Calendar.YEAR));<span class="comment">//年</span></span><br><span class="line">    System.out.println(cal2.get(Calendar.MONTH));<span class="comment">//月</span></span><br><span class="line">    System.out.println(cal2.get(Calendar.DATE));<span class="comment">//日</span></span><br><span class="line">    System.out.println(cal2.get(Calendar.DAY_OF_WEEK));<span class="comment">//按国外星期日第一天</span></span><br><span class="line">    System.out.println(cal2.getActualMaximum(Calendar.DATE));<span class="comment">//获取最大</span></span><br><span class="line">    System.out.println(cal2.getActualMinimum(Calendar.DATE));<span class="comment">//获取最小</span></span><br><span class="line"> <span class="comment">//set方法：可以改变Calendar的内容</span></span><br><span class="line"> cal2.set(Calendar.YEAR,<span class="number">2025</span>);</span><br><span class="line">cal2.set(Calendar.DATE,<span class="number">6</span>);</span><br><span class="line"><span class="comment">//setTime方法：</span></span><br><span class="line"> java.sql.Date date=java.sql.Date.valueOf(<span class="string">&quot;2026-11-03&quot;</span>);</span><br><span class="line">cal2.setTime(date);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>完成需求:</p>
</li>
<li><p><img src="/java.assets/image-20241103174048966.png" alt="image-20241103174048966"></p>
</li>
<li><blockquote>
<pre><code class="java"> //String--》Calendar
//录入日期的字符串
    Scanner sc=new Scanner(System.in);
    System.out.println(&quot;请输入你要查看的日期：（提示：请按照年-月-日的格式）&quot;);
String strDate=sc.next();
//String --&gt;Calendar
//1.String--&gt;Date
    java.sql.Date date=java.sql.Date.valueOf(strDate);
//2.Date--&gt;Caendar
    Calendar cal=Calendar.getInstance();
cal.setTime(date);
//
    System.out.println(&quot;日\t一\t二\t三\t四\t五\t六&quot;);
//获取本月的最大天数
int maxDay=cal.getActualMaximum(Calendar.DATE);
//获取当前日期的日
    int now_Day=cal.get(Calendar.DATE);
    //将当前日期中的日调为本月的1号,在看1号是星期几
    cal.set(Calendar.DATE,1);
   int num= cal.get(Calendar.DAY_OF_WEEK);
int count=0;
for(int i=1;i&lt;=num-1;i++)&#123;
    System.out.print(&quot;\t&quot;);
    count++;
&#125;
for(int i=1 ;i&lt;=maxDay;i++)&#123;
    if (i==now_Day)&#123;
    System.out.print(i+&quot;*&quot;+&quot;\t&quot;);
&#125;
else &#123;
    System.out.print(i+&quot;\t&quot;);
&#125;
count++;
if(count%7==0) System.out.println();
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- LocalDate;LocalTime;LocalDateTime（多用）</span><br><span class="line"></span><br><span class="line">- &gt;~~~java</span><br><span class="line"> &gt;//初始化</span><br><span class="line"> &gt;//now()方法,现在时刻</span><br><span class="line"> &gt;LocalDate localDate= LocalDate.now();</span><br><span class="line"> &gt;System.out.println(localDate);</span><br><span class="line"> &gt;LocalTime localTime=LocalTime.now();</span><br><span class="line"> &gt;System.out.println(localTime);</span><br><span class="line"> &gt;LocalDateTime localDateTime=LocalDateTime.now();</span><br><span class="line"> &gt;System.out.println(localDateTime);</span><br><span class="line"> &gt;//of（）方法，设计时间</span><br><span class="line"> &gt;LocalDate of=LocalDate.of(2024,11,3);</span><br><span class="line"> &gt;LocalTime of1=localTime.of(18,22,11);</span><br><span class="line"> &gt;//LocalDateTime使用频率最高</span><br><span class="line"> &gt;//get方法</span><br><span class="line"> &gt;System.out.println(localDateTime.getYear());</span><br><span class="line"> &gt;System.out.println(localDateTime.getMonth());//月的英文</span><br><span class="line"> &gt;System.out.println(localDateTime.getDayOfMonth());//月的值</span><br><span class="line"> &gt;System.out.println(localDateTime.getMonthValue());</span><br><span class="line"> &gt;System.out.println(localDateTime.getHour());</span><br><span class="line"> &gt;//.....</span><br><span class="line"> &gt;//不叫set方法，叫with方法，不在自身的基础上改变</span><br><span class="line"> &gt;LocalDateTime localDateTime1=localDateTime.withMonth(8);</span><br><span class="line"> &gt;System.out.println(localDateTime);</span><br><span class="line"> &gt;System.out.println(localDateTime1);</span><br><span class="line"> &gt;//.plusMonth（n）加n个月  .minusMonth（n） 减n个月</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</blockquote>
</li>
<li><p>DateTimeFormatter    <code>ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;);  </code>常用</p>
</li>
<li><blockquote>
<pre><code class="Java">//格式化类
//自定义的格式化  ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;);  常用
DateTimeFormatter dateTimeFormatter=DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;);
//LocalDateTime  ----&gt;String
 LocalDateTime now=LocalDateTime.now();
 System.out.println(now);//2024-11-03T19:09:07.842778100
String format=DateTimeFormatter.format(now);
System.out.println(format);//2024-11-03 07:10:05
 //String----&gt;LocalTimeDate
 TemporalAccessor parse1=dateTimeFormatter.parse(&quot;2024-11-03 07:10:05&quot;);
System.out.println(parse1);

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">### 11.3.Math类</span><br><span class="line"></span><br><span class="line">- 1.使用``Math类``的时候无需导包，直接使用即可</span><br><span class="line"></span><br><span class="line">`package java.lang;`</span><br><span class="line"></span><br><span class="line"> 2.` Math类`没有子类，不能被其它类继承</span><br><span class="line"></span><br><span class="line"> ~~~java</span><br><span class="line"> public final class Math&#123;&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</blockquote>
</li>
</ul>
<p>3.里面的属性全部被final修饰，方法也是被final修饰的。</p>
<p>4.外界不可以创建对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Math</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Math</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造器私有化</p>
<p>5.Math类中的所有属性，方法都被static修饰，不用创建对象去调用（也不能），直接通过<code> 类名.属性名  类名.方法名</code>去调用。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用属性，方法</span></span><br><span class="line">Math.PI;<span class="comment">//Π圆周率</span></span><br><span class="line">Math.random();<span class="comment">//[0.0,1.0)随机数</span></span><br><span class="line">Math.obs(-<span class="number">80</span>);<span class="comment">//80绝对值</span></span><br><span class="line">Math.ceil(<span class="number">9.1</span>);<span class="comment">//10.0向上取值</span></span><br><span class="line">Math.floor(<span class="number">9.9</span>);<span class="comment">//9向下取值</span></span><br><span class="line">Math.round(<span class="number">3.5</span>);<span class="comment">//4四舍五入</span></span><br><span class="line">Math.max(<span class="number">3</span>,<span class="number">6</span>);<span class="comment">//6取最大</span></span><br><span class="line">Math.min(<span class="number">3</span>,<span class="number">6</span>)<span class="comment">//3取最小</span></span><br></pre></td></tr></table></figure>

<h3 id="11-4-String类"><a href="#11-4-String类" class="headerlink" title="11.4.String类"></a>11.4.String类</h3><ul>
<li><ol>
<li><code>String类</code>直接使用无需导包</li>
</ol>
<blockquote>
<p>package java.lang;</p>
</blockquote>
<ol start="2">
<li>无法继承，不能有子类</li>
</ol>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="3">
<li>Strng底层是一个char类型的数组</li>
</ol>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="4">
<li>常用方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;asdasdad&quot;;</span><br><span class="line">String str1=&quot;asdasd&quot;;</span><br><span class="line">System.out.println(str.length());//返回数组的长度</span><br><span class="line">str.isEmpty();//判断是否为空，返回Boolean</span><br><span class="line">System.out.println(str.chaAt(1))//获取索引对应的字符</span><br><span class="line">System.out.println(&quot;asdasdad&quot;.equals(str));//比较字符串是否一致，返回Boolean；注意：str1.equals(&quot;sdadad&quot;);如果传入引用str1为空；会报空指针异常</span><br><span class="line">//String类实现了Compareable接口，所以String中一定要对这个方法进行重写；</span><br><span class="line">System.out.println(str.compareTo(str1));</span><br><span class="line">System.out.println(str.subString(3,6));//截取【3，6）部分</span><br><span class="line">str.replace(&#x27;a&#x27;,&#x27;u&#x27;);//把a替换为u</span><br><span class="line">String str2=&quot;a,v,b,s,d,f&quot;;</span><br><span class="line">String[] strs=str2.split(&quot;,&quot;);</span><br><span class="line">System.out.println(strs[0]);//a</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;compareTo的逻辑：s8.compareTo(s9);</p>
<p><img src="/java.assets/image-20241104182403532.png" alt="image-20241104182403532"></p>
</li>
</ul>
<h3 id="11-5-StringBuilder和StringBuffer常用方法如下："><a href="#11-5-StringBuilder和StringBuffer常用方法如下：" class="headerlink" title="11.5.StringBuilder和StringBuffer常用方法如下："></a>11.5.<code>StringBuilder</code>和<code>StringBuffer</code>常用方法如下：</h3><p><strong>一、append () 方法</strong></p>
<ol>
<li><strong>功能</strong>：<ul>
<li>用于在字符串末尾添加内容，可以是字符串、字符、整数、浮点数等各种数据类型。</li>
<li>例如，<code>StringBuilder sb = new StringBuilder(); sb.append(&quot;Hello&quot;);</code>，此时<code>sb</code>的内容变为 “Hello”。如果继续执行<code>sb.append(123);</code>，则<code>sb</code>变为 “Hello123”。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li>当需要动态地构建一个字符串时非常有用。比如在生成日志信息时，可以逐步将不同的信息片段添加到一个<code>StringBuilder</code>或<code>StringBuffer</code>对象中。</li>
<li>例如，在一个程序中记录用户的操作日志，可以使用<code>StringBuilder</code>来拼接用户的操作信息、时间戳等内容。</li>
</ul>
</li>
</ol>
<p><strong>二、insert () 方法</strong></p>
<ol>
<li><strong>功能</strong>：<ul>
<li>在指定位置插入内容。可以插入字符串、字符、整数、浮点数等各种数据类型。</li>
<li>例如，<code>StringBuilder sb = new StringBuilder(&quot;Hello&quot;); sb.insert(2, &quot;World&quot;);</code>，此时<code>sb</code>的内容变为 “HeWorldllo”。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li>当需要在特定位置插入内容时使用。比如在编辑文本时，如果需要在特定位置插入一些补充信息，就可以使用这个方法。</li>
<li>例如，在一个文本编辑器中，用户可以在已有的文本中选择一个位置插入新的字符或字符串。</li>
</ul>
</li>
</ol>
<p><strong>三、delete () 方法</strong></p>
<ol>
<li><strong>功能</strong>：<ul>
<li>删除指定范围内的字符。可以指定起始索引和结束索引来确定要删除的字符范围。</li>
<li>例如，<code>StringBuilder sb = new StringBuilder(&quot;Hello World&quot;); sb.delete(5, 10);</code>，此时<code>sb</code>的内容变为 “Hello”，因为删除了从索引 5 到索引 10（不包括 10）的字符。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li>当需要删除部分字符串内容时使用。比如在处理用户输入的错误信息时，可以删除特定的错误部分。</li>
<li>例如，在一个表单验证程序中，如果用户输入了错误的格式，可以使用<code>StringBuilder</code>或<code>StringBuffer</code>来删除错误的部分，并插入正确的格式提示。</li>
</ul>
</li>
</ol>
<p><strong>四、reverse () 方法</strong></p>
<ol>
<li><strong>功能</strong>：<ul>
<li>将字符串反转。例如，“Hello” 反转后变为 “olleH”。</li>
<li>例如，<code>StringBuilder sb = new StringBuilder(&quot;Hello&quot;); sb.reverse();</code>，此时<code>sb</code>的内容变为 “olleH”。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li>在需要对字符串进行反转操作时使用。比如在某些加密算法中，可能需要对字符串进行反转处理。</li>
<li>例如，在一个简单的加密程序中，可以将用户输入的字符串反转后再进行其他加密操作。</li>
</ul>
</li>
</ol>
<p><strong>五、toString () 方法</strong></p>
<ol>
<li><strong>功能</strong>：<ul>
<li>将<code>StringBuilder</code>或<code>StringBuffer</code>对象转换为<code>String</code>类型。</li>
<li>例如，<code>StringBuilder sb = new StringBuilder(&quot;Hello&quot;); String str = sb.toString();</code>，此时<code>str</code>的内容为 “Hello”。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li>当需要将<code>StringBuilder</code>或<code>StringBuffer</code>对象作为字符串使用时，比如将其传递给需要<code>String</code>类型参数的方法。</li>
<li>例如，在一个打印输出的方法中，需要将<code>StringBuilder</code>对象转换为<code>String</code>类型才能进行打印。</li>
</ul>
</li>
</ol>
<ul>
<li>注意:<code>StringBuilder</code>是非线程安全的，在单线程环境下，它通常比<code>StringBuffer</code>效率更高</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb=new StringBuilder();//空构造器；但是实际上对数组进行了初始化，长度为16；</span><br><span class="line">StringBuilder sb=new StringBuilder(4);//有参构造器，长度为4；</span><br><span class="line">StringBuilder sb=new StringBuilder(&quot;dads&quot;);//有参构造器；字符串初始化为&quot;dads&quot;;长度为4+16；  实际操作为：super(str.length()+16);append(str)//str为传入的参数</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="11-6-System"><a href="#11-6-System" class="headerlink" title="11.6.System"></a>11.6.System</h3><h3 id="11-7-Runtime"><a href="#11-7-Runtime" class="headerlink" title="11.7.Runtime"></a>11.7.Runtime</h3><h2 id="12-IO流"><a href="#12-IO流" class="headerlink" title="12.IO流"></a>12.IO流</h2><ul>
<li><p>File类：封装文件&#x2F;目录的各种信息，对文件&#x2F;目录进行操作，但是我们不可以获取到文件&#x2F;目录中的内容。</p>
</li>
<li><p>I&#x2F;O流：Input&#x2F;Output的缩写，用于对设备之间的数据传输</p>
<p><img src="/java.assets/image-20241112190146403.png"></p>
</li>
</ul>
<p>try-catch捕获异常，finally最后关闭流</p>
<p><img src="/java.assets/image-20241127200033060.png" alt="image-20241127200033060"></p>
<ul>
<li>FileReader,FileWriter完成文本复制(字符-文本类)一个一个</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">File f1=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\temporymemory\\user.txt&quot;</span>);</span><br><span class="line">File f2=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\temporymemory\\message.txt&quot;</span>);</span><br><span class="line">FileReader fr=<span class="keyword">new</span> <span class="title class_">FileReader</span>(f1);</span><br><span class="line">FileWriter fw=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(f2);</span><br><span class="line"><span class="comment">//一个字符一个字符进行读写，返回-1表示文件结尾</span></span><br><span class="line"><span class="type">int</span> n=fr.read();</span><br><span class="line"><span class="keyword">while</span>(n!=-<span class="number">1</span>)&#123;</span><br><span class="line">fw.write(n);</span><br><span class="line">n=fr.read();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用缓冲字符数组</span></span><br><span class="line"><span class="type">char</span>[] ch=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> len=ch;</span><br><span class="line"><span class="keyword">while</span>(len!=-<span class="number">1</span>)&#123;<span class="comment">//String s=new String(ch,0,len);</span></span><br><span class="line">fr.write(ch,<span class="number">0</span>,len);<span class="comment">//fr.write(s);</span></span><br><span class="line">len=fr.read(ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭流；先用的后关</span></span><br><span class="line">fw.close();</span><br><span class="line">fr.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</blockquote>
<ul>
<li>FileInputStream,FileOutputStream完成非文本复制（字节-图片类）</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">File f1=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line">File f2=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path2&quot;</span>);</span><br><span class="line">FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f1);</span><br><span class="line">FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f2);</span><br><span class="line"><span class="comment">//文件是Utf-8存储，英文占一个字节，中文占三个字节</span></span><br><span class="line"><span class="type">int</span> n=fis.read();</span><br><span class="line"><span class="keyword">while</span>(n!=-<span class="number">1</span>)&#123;</span><br><span class="line">fos.write(n);</span><br><span class="line">n=fis.read();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用缓存数组</span></span><br><span class="line"><span class="type">byte</span>[] b=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">8</span>]；</span><br><span class="line"><span class="type">int</span> len=fis.read(b);</span><br><span class="line"><span class="keyword">while</span>(len！=-<span class="number">1</span>)&#123;</span><br><span class="line">fos.write(b,<span class="number">0</span>,len);</span><br><span class="line">len=fis.read(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭流，先用后关</span></span><br><span class="line">fos.close();</span><br><span class="line">fin.close();</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>BufferedInputStream,BufferedOutputStream（缓冲字节处理流）</p>
</li>
<li><p>作用：可以提高字节流的读写性能</p>
</li>
<li><blockquote>
<p>通过缓冲池减少系统调用的次数</p>
<p>原理：缓冲字节流自带了8kb的缓冲池；缓冲字节输出流也自带了8kb的缓冲池</p>
</blockquote>
</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//功能加强，在FileInputStream和FileOutputStream外面套一个管BufferedInputStream和BufferedOutputStream</span></span><br><span class="line">&gt;BufferedInputStream bis=<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">&gt;BufferedOutputStream bos=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line">&gt;<span class="type">byte</span>[] b=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">8</span>];</span><br><span class="line">&gt;<span class="type">int</span> len=bis.read(b);</span><br><span class="line">&gt;<span class="keyword">while</span>(len!=-<span class="number">1</span>)&#123;</span><br><span class="line">&gt;bos.write(b,<span class="number">0</span>,len);</span><br><span class="line">&gt;len=bis.read(b);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//关闭流；先开后关</span></span><br><span class="line">&gt;bos.close();</span><br><span class="line">&gt;bis.close();</span><br><span class="line">&gt;fos.close();</span><br><span class="line">&gt;fis.close();</span><br></pre></td></tr></table></figure>




</blockquote>
<ul>
<li>BufferedReader,BufferedWriter完成文本复制（缓冲字符处理流）一行一行</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">File f1=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line">File f2=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path2&quot;</span>);</span><br><span class="line">BufferedReader fr=BufferedReader(<span class="keyword">new</span> <span class="title class_">FlieReader</span>(f1));<span class="comment">//参数是FileReader</span></span><br><span class="line">BufferedWriter fw=bufferedWriter(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(f2));<span class="comment">//参数是FileWriter</span></span><br><span class="line"><span class="comment">//BufferedWriter fw=bufferedWriter(new FileWriter(f2,true))//追加模式写</span></span><br><span class="line"><span class="comment">//一行一行的读，写</span></span><br><span class="line">String str;</span><br><span class="line"><span class="keyword">while</span>((str=fr.readerline())!=<span class="literal">null</span>)<span class="comment">//读取</span></span><br><span class="line">&#123;</span><br><span class="line"> fw.write(str);<span class="comment">//此时写在缓冲区</span></span><br><span class="line"> fw.newline();<span class="comment">//换行</span></span><br><span class="line">&#125;</span><br><span class="line">fw.flush();<span class="comment">//写入磁盘</span></span><br><span class="line">fw.close();</span><br><span class="line">fr.close();</span><br></pre></td></tr></table></figure>

<p>案例：<img src="/java.assets/image-20241127202555955.png" alt="image-20241127202555955"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedTset</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>( BufferedReader br=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;path&quot;</span>));</span><br><span class="line">              BufferedWriter bw=<span class="keyword">new</span> <span class="title class_">bufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FlieWriter</span>(<span class="string">&quot;path1&quot;</span>));</span><br><span class="line">             )<span class="comment">//资源放在try-catch块中，自动刷新关闭释放</span></span><br><span class="line">            &#123;</span><br><span class="line">                List&lt;String&gt; data=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                String line;<span class="comment">//读出加入到List容器</span></span><br><span class="line">                <span class="keyword">while</span>((line=br.readline())!=<span class="literal">null</span>) data.add(line);</span><br><span class="line">            &#125;</span><br><span class="line">        Collection.sort(data);<span class="comment">//排序</span></span><br><span class="line">        System.out.println(adta);</span><br><span class="line">        <span class="comment">//写入</span></span><br><span class="line">        <span class="keyword">for</span>(String s:data)&#123;</span><br><span class="line">            bw.Writer(s);</span><br><span class="line">            bw.newLine();<span class="comment">//换行</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>原始流、缓冲流的性能分析</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="13-集合-容器"><a href="#13-集合-容器" class="headerlink" title="13.集合(容器)"></a>13.集合(容器)</h2><ul>
<li>基本体系</li>
<li><img src="/java.assets/image-20241104155653318.png" alt="image-20241104155653318"></li>
</ul>
<h3 id="13-1-Collection接口-List可以添加重复元素，set不能"><a href="#13-1-Collection接口-List可以添加重复元素，set不能" class="headerlink" title="13.1.Collection接口(List可以添加重复元素，set不能)"></a>13.1.Collection接口(List可以添加重复元素，set不能)</h3><ul>
<li><blockquote>
<ul>
<li><p>常用方法</p>
</li>
<li><pre><code class="java">//增加：add(E e)  addAll(collection&lt;?extends E&gt;c)
//删除:  clear()  remove(Object o)
//修改:  
//查看: iterator()  size()
//判断: contains(Object o)  equals(Object 0) isEmpty()              
 //创建对象
        //接口不能实例化，可以引用实现类
        Collection col=new ArrayList();
        //集合有个特点：只能存放引用数据类型，不能是基本数据类型
col.add(18);//Integer类自动转换为引用数据类型
        col.add(12);
        col.add(&quot;asdasdas&quot;);
        System.out.println(col);//[18, 12]
          List col1  =Arrays.asList(new Integer[]&#123;18,12&#125;);
        col.addAll(col1);//将另一个集合添加到自己
System.out.println(col);
col.clear();//清空
System.out.println(col);
System.out.println(col.size());//元素个数
System.out.println(col.isEmpty());//是否为空
        col.add(col1);//将col1，作为一个元素加入
        System.out.println(col);//[[18, 12]]
        col.add(19);
        System.out.println(col);
        System.out.println(col.equals(col1));//比较两个集合是否一样
        System.out.println(col.contains(col1));//判断是否集合中包含传入的集合
        System.out.println(col.remove(col1));//删除传入的元素，成功返回true
        System.out.println(col);
        col.add(12);
        col.add(18);
        System.out.println(col);
        System.out.println(col.removeAll(col1));//删除该集合中所包含的传入集合的元素，成功返回true
        System.out.println(col);
//对集合遍历，查看元素
        Integer[] i=new Integer[]&#123;11,12,13,14,15&#125;;
        col.addAll(Arrays.asList(i));
        System.out.println(col);
//for (int j=0;j&lt;col.size();j++)&#123;//普通foe循环
//    col.
//&#125; 无通过索引找元素的方法
        //增强for循环
        col.add(&quot;abc&quot;);
        for(Object L:col)&#123;//只能用Object接收，集合中包含不同的元素
            System.out.println(L);
        &#125;
//通过迭代器iterator对集合进行遍历
        System.out.println(col.iterator());
        Iterator iterator=col.iterator();
        while (iterator.hasNext())&#123;//通过haxNext()放啊来判断是否下一个元素；如果有返回true
            System.out.println(iterator.next());//next()方法将元素获取到；并且将指针下移



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 通过迭代器iterator对集合进行遍历；haxNext()放啊来判断是否下一个元素；如果有返回true；next()方法将元素获取到；并且将指针下移</span><br><span class="line"></span><br><span class="line">- 注意：增强for循环是一种语法糖（一种简化的语法）；它简化了遍历集合或数组的代码，但底层的实现还是依赖于迭代器或者类似的机制。</span><br><span class="line"></span><br><span class="line">### 13.2.List接口（extends Collection）</span><br><span class="line"></span><br><span class="line">- &gt;- 常用方法</span><br><span class="line"></span><br><span class="line"> &gt;- ~~~Java</span><br><span class="line"> //增：add(int index,E element)  </span><br><span class="line">    //删：remove(int index)  remove(Object o)</span><br><span class="line">    //改:set(int index,E element) </span><br><span class="line">    //查：get(int index)</span><br><span class="line">    //判断：与Collection一致</span><br><span class="line">                                                 </span><br><span class="line">         //增：add(int index,E element)</span><br><span class="line">    //删：remove(int index)  remove(Object o)</span><br><span class="line">    //改:set(int index,E element)</span><br><span class="line">    //查：get(int index)</span><br><span class="line">    //判断：</span><br><span class="line">    List list=new ArrayList();//接口引用实现类</span><br><span class="line">    list.add(12);//element</span><br><span class="line">    list.add(17);</span><br><span class="line">    list.add(13);</span><br><span class="line">    Integer[] i=&#123;1,2,3,4,5,6&#125;;</span><br><span class="line">    list.addAll(Arrays.asList(i));</span><br><span class="line">    System.out.println(list);//[12, 17, 13, 1, 2, 3, 4, 5, 6]</span><br><span class="line">    list.add(0,66);//在索引为0处添加66</span><br><span class="line">    System.out.println(list);//[66, 12, 17, 13, 1, 2, 3, 4, 5, 6]</span><br><span class="line">    list.set(0,77);//把索引为0的元素改为77</span><br><span class="line">    System.out.println(list);//[77, 12, 17, 13, 1, 2, 3, 4, 5, 6]</span><br><span class="line">    list.remove(2);//在集合在存入的是Integer数据类型时，删除的是对应索引的元素</span><br><span class="line">    System.out.println(list);//[77, 12, 13, 1, 2, 3, 4, 5, 6]</span><br><span class="line">    list.add(2,&quot;asdasd&quot;);</span><br><span class="line">    list.remove(&quot;asdasd&quot;);//其它数据类型直接删除对应元素，而非对应索引的元素</span><br><span class="line">    System.out.println(list);//[77, 12, 13, 1, 2, 3, 4, 5, 6]</span><br><span class="line">    Object o=list.get(0);//返回传入索引的对应元素</span><br><span class="line">    System.out.println(o);//77</span><br><span class="line">    //遍历</span><br><span class="line">         //普通for循环</span><br><span class="line">         for(int j=0;j&lt; list.size();j++)&#123;</span><br><span class="line">             System.out.println(list.get(j));</span><br><span class="line">         &#125;</span><br><span class="line">         //强制for循环</span><br><span class="line">         for(Object obj:list) System.out.println(obj);</span><br><span class="line">         //迭代器Iterator</span><br><span class="line">         Iterator iterator=list.iterator();</span><br><span class="line">         while (iterator.hasNext())System.out.println(iterator.next());</span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>与Collection相比多了通过索引增加和删除以及查看；如此一来就能通过普通for循环遍历</p>
</li>
<li><p>扩展方法都和索引相关</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="13-3-ArrayList实现类（动态数组）"><a href="#13-3-ArrayList实现类（动态数组）" class="headerlink" title="13.3.ArrayList实现类（动态数组）"></a>13.3.ArrayList实现类（动态数组）</h3><ul>
<li><blockquote>
<ul>
<li>常用方法与List相近</li>
<li>第一次扩容到十，第二次扩容到1.5倍</li>
</ul>
</blockquote>
</li>
</ul>
<ol>
<li><strong>ArrayList 概述</strong><ul>
<li>ArrayList 是 Java 集合框架中的一个重要类，它位于<code>java.util</code>包中。它实现了<code>List</code>接口，这意味着它具有<code>List</code>接口所定义的所有方法，例如可以通过索引访问元素、可以包含重复元素等特点。</li>
<li>ArrayList 本质上是一个动态大小的数组。它提供了方便的方法来添加、删除和访问元素，并且会自动调整大小以适应存储元素的数量变化。与普通数组相比，ArrayList 更加灵活，因为不需要在创建时指定固定的大小。</li>
</ul>
</li>
<li><strong>创建 ArrayList 对象</strong><ul>
<li>可以使用以下方式创建一个空的 ArrayList：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>



<ul>
<li>这里创建了一个可以存储<code>String</code>类型元素的 ArrayList。<code>&lt;String&gt;</code>是 Java 泛型的语法，用于指定列表中元素的类型。如果不使用泛型，ArrayList 可以存储任何类型的对象，但这样容易导致类型安全问题。例如，以下代码会在编译时产生警告：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">listWithoutGeneric</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">listWithoutGeneric.add(<span class="string">&quot;String&quot;</span>);</span><br><span class="line">listWithoutGeneric.add(<span class="number">123</span>);  <span class="comment">// 可以添加不同类型的元素，可能导致问题</span></span><br></pre></td></tr></table></figure>



<ol>
<li>添加元素到 ArrayList<ul>
<li>使用<code>add</code>方法可以将元素添加到 ArrayList 中。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">stringList.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure>



<ul>
<li>还可以在指定位置添加元素。例如，将一个元素插入到索引为 1 的位置：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringList.add(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br></pre></td></tr></table></figure>



<ul>
<li>此时，<code>stringList</code>的内容为<code>[&quot;Hello&quot;, &quot;Java&quot;, &quot;World&quot;]</code>。需要注意的是，如果指定的索引超出了当前列表的范围（例如，索引大于列表的大小），会抛出<code>IndexOutOfBoundsException</code>异常。</li>
</ul>
<ol>
<li>访问 ArrayList 中的元素<ul>
<li>可以通过索引来访问 ArrayList 中的元素，就像访问数组元素一样。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> stringList.get(<span class="number">0</span>);  <span class="comment">// 获取索引为0的元素，这里是&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>如果使用了非法的索引（例如，负数或大于等于列表大小的数），会抛出<code>IndexOutOfBoundsException</code>异常。</li>
</ul>
<ol>
<li>修改 ArrayList 中的元素<ul>
<li>通过索引和<code>set</code>方法可以修改 ArrayList 中的元素。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringList.set(<span class="number">0</span>, <span class="string">&quot;Hi&quot;</span>);</span><br></pre></td></tr></table></figure>



<ul>
<li>此时，<code>stringList</code>的第一个元素被修改为<code>Hi</code>。同样，使用非法的索引会导致<code>IndexOutOfBoundsException</code>异常。</li>
</ul>
<ol>
<li>删除 ArrayList 中的元素<ul>
<li>可以使用<code>remove</code>方法来删除元素。如果知道元素的索引，可以这样删除：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringList.remove(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<ul>
<li>这会删除索引为 1 的元素。如果知道元素本身的值，也可以删除：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> stringList.remove(<span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure>



<ul>
<li><code>result</code>的值为<code>true</code>表示元素被成功删除，<code>false</code>表示列表中不存在该元素。</li>
</ul>
<ol>
<li>遍历 ArrayList<ul>
<li>使用 for 循环遍历<ul>
<li>通过索引来遍历 ArrayList，这种方式类似于遍历数组。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringList.size(); i++) &#123;</span><br><span class="line">    System.out.println(stringList.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>使用增强 for 循环遍历<ul>
<li>这种方式更简洁，不需要使用索引。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String str : stringList) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>使用迭代器遍历</li>
<li><img src="/java.assets/image-20241222155322256.png" alt="image-20241222155322256"><ul>
<li>Iterator 是一个接口，用于遍历集合中的元素。</li>
<li>haxNext()方法来判断是否下一个元素；如果有返回true；next()方法将元素获取到；并且将指针下移</li>
<li>迭代器遍历完毕，指针不会复位，可以获取一个新的迭代器对象进行再次遍历</li>
<li>循环中只能用一次next（）</li>
<li>迭代器遍历时，不能使用集合的方法进行增删操作</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = stringList.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li><strong>ArrayList 的容量和大小</strong><ul>
<li>ArrayList 有一个容量（<code>capacity</code>）的概念，它表示底层数组的大小。当添加元素导致元素数量超过当前容量时，ArrayList 会自动扩容。例如，初始容量可能是 10，当添加第 11 个元素时，ArrayList 会创建一个新的、更大的数组，并将原来的元素复制到新数组中。</li>
<li>可以使用<code>size</code>方法来获取 ArrayList 中实际元素的数量。例如，<code>stringList.size()</code>返回<code>stringList</code>中元素的个数。</li>
</ul>
</li>
<li><strong>与其他集合的比较和转换</strong><ul>
<li>与<code>LinkedList</code>相比，ArrayList 在随机访问（通过索引访问元素）方面性能更好，因为它内部是基于数组实现的；而 LinkedList 在插入和删除操作（特别是在列表中间进行操作）时性能更好，因为它是基于链表实现的。</li>
<li>ArrayList 可以方便地与其他集合进行转换。例如，将 ArrayList 转换为数组：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] array = stringList.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[stringList.size()]);</span><br></pre></td></tr></table></figure>



<ul>
<li>也可以将数组转换为 ArrayList，例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] anotherArray = &#123;<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>&#125;;</span><br><span class="line">ArrayList&lt;String&gt; newList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(anotherArray));</span><br></pre></td></tr></table></figure>



<h3 id="13-4-LinkedList"><a href="#13-4-LinkedList" class="headerlink" title="13.4.LinkedList"></a>13.4.LinkedList</h3><ul>
<li>LinkedList底层是基于双向链表存储数据的</li>
</ul>
<blockquote>
<ul>
<li>无论查询哪个数据都要从头开始找或者从尾部开始</li>
<li>增删相对快</li>
<li>对首尾元素进行增删改查速度快</li>
<li>占用内存多，使用场景少</li>
</ul>
</blockquote>
<p><img src="/java.assets/image-20241221192020851.png" alt="image-20241221192020851"></p>
<ul>
<li>总结：查询多用ArrayList,增删多用LinkedList</li>
<li>LinkedList用的少</li>
</ul>
<h3 id="13-5-Set"><a href="#13-5-Set" class="headerlink" title="13.5.Set"></a>13.5.Set</h3><ul>
<li>无序（添加顺序和获取出的数据顺序不一致）</li>
<li>不重复</li>
<li>无索引</li>
</ul>
<blockquote>
<ul>
<li>HashSet:无序、不重复、无索引</li>
<li>LinkedHashSet:有序、不重复、无索引</li>
<li>TreeSet:排序（比较器和排序接口）、不重复、无索引</li>
</ul>
</blockquote>
<ul>
<li><p>注意set接口用到的常用方法，基本上就是Collection提供的，自己几乎没有额外新增的一些常用功能</p>
</li>
<li><p>HashSet集合的底层原理</p>
</li>
<li><blockquote>
<p>哈希值</p>
<ul>
<li><p>Java中所有对象都有一个哈希值，都可以调用Object提供的hashCode方法，返回对象自己的哈希值</p>
</li>
<li><pre><code class="Java">public int hashCode():返回对象的哈希码值
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 同一个对象调用该方法返回的哈希值是相同的</span><br><span class="line"></span><br><span class="line">- 不同的对象，他们的哈希值大概率不一样。int(-21亿多到21亿多，当对象个数超过可能会出现哈希碰撞，但是几乎不可能)</span><br><span class="line"></span><br><span class="line">基于哈希表实现</span><br><span class="line"></span><br><span class="line">- JDK8之前的哈希表：数组+链表</span><br><span class="line"></span><br><span class="line">- ~~~Java</span><br><span class="line">  Set&lt;String&gt; set=new HashSet&lt;&gt;();</span><br><span class="line">  set.add(&quot;数据1&quot;);//第一次加数据，创建一个默认长度为16的数组，默认加载因子为0.75，使用元素的哈希值对数组长度做运算计算出应该存入的位置</span><br><span class="line">  //后续加入数据先判断该位置是否为null，如果是null则直接存入，如果不是null，表示有元素，则调用equals方法比较，相等不存，不相等则存入数据</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>JDK开始，当链表长度超过8，且数组长度超过64时，自动将链表转成红黑树</p>
</li>
<li><p>红黑树</p>
</li>
<li><blockquote>
<ul>
<li>自平衡的二叉排序树（左右子树的高度差不超过一的排序树（左小于右））</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ol>
<li><strong>什么是 Java 泛型</strong><ul>
<li>Java 泛型是 JDK 5.0 引入的一个重要特性，它提供了一种在编译时期检查类型安全的机制。简单来说，泛型允许你在定义类、接口和方法时使用类型参数，这样这些类型就可以在使用时再确定。</li>
<li>例如，在没有泛型之前，如果你有一个存储整数的列表，你可能会定义一个<code>ArrayList</code>，然后将整数添加进去。但是如果不小心添加了一个字符串，在运行时才会发现错误。而泛型可以让你在编译时就避免这种类型不匹配的错误。</li>
<li>泛型的主要目的是提高代码的复用性和类型安全性。</li>
</ul>
</li>
<li><strong>泛型的语法</strong><ul>
<li>定义泛型类<ul>
<li>以一个简单的<code>Box</code>类为例，它可以用来存储任意类型的对象。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>这里的<code>&lt;T&gt;</code>就是定义了一个类型参数<code>T</code>，<code>T</code>可以是任何引用类型（在 Java 中，基本类型不能直接作为泛型类型参数，但可以使用它们对应的包装类型，如<code>Integer</code>对应<code>int</code>）。在<code>Box</code>类中，有一个私有成员变量<code>t</code>的类型是<code>T</code>，还有两个方法<code>set</code>和<code>get</code>来设置和获取这个变量。</li>
<li>定义泛型接口<ul>
<li>例如，定义一个<code>Generator</code>接口，用于生成某种类型的对象。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">generate</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>类型参数<code>T</code>用于指定生成对象的类型，实现这个接口的类需要提供<code>generate</code>方法的具体实现，并且返回类型是<code>T</code>。</li>
<li>定义泛型方法<ul>
<li>泛型方法可以在普通类或泛型类中定义</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Util</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getMiddle</span><span class="params">(T... a)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>这里<code>&lt;T&gt;</code>定义了一个泛型方法<code>getMiddle</code>，它可以接受任意数量的<code>T</code>类型的参数（<code>T... a</code>是可变参数的语法），并返回中间位置的元素。</li>
</ul>
<ol>
<li>泛型的使用场景<ul>
<li>集合框架中的应用<ul>
<li>在 Java 的集合框架中，泛型被广泛使用。例如<code>ArrayList</code>、<code>HashMap</code>等。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">stringList.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="comment">// 编译器会检查类型，下面这行代码会报错，因为不能添加整数</span></span><br><span class="line"><span class="comment">// stringList.add(123);</span></span><br></pre></td></tr></table></figure>



<ul>
<li>这样就确保了<code>ArrayList</code>中只能存储<code>String</code>类型的元素，提高了代码的类型安全性。</li>
<li>自定义数据结构和算法<ul>
<li>当你实现自己的数据结构，如链表、栈、队列等，或者实现一些通用的算法，如排序、查找等，泛型可以让你的代码更加通用。例如，实现一个简单的链表节点类。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">    T data;</span><br><span class="line">    Node&lt;T&gt; next;</span><br><span class="line">    Node(T data) &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>这个<code>Node</code>类可以用来构建存储不同类型数据的链表。</li>
</ul>
<ol>
<li><strong>类型擦除</strong><ul>
<li>Java 中的泛型是通过类型擦除来实现的。这意味着在编译后的字节码中，泛型类型信息会被擦除。例如，对于<code>Box&lt;Integer&gt;</code>和<code>Box&lt;String&gt;</code>，在字节码层面，它们都会被转换为<code>Box</code>（原始类型）。</li>
<li>编译器会在编译时进行类型检查，插入必要的类型转换代码。但是在运行时，通过反射等方式获取的类型信息是擦除后的类型。这也导致了一些限制，比如不能使用<code>new T()</code>（因为在运行时<code>T</code>的具体类型已经被擦除了），但可以通过传递一个工厂对象或者使用反射等方式来解决这个问题。</li>
</ul>
</li>
<li><strong>通配符</strong><ul>
<li>泛型通配符用于在某些情况下增加泛型的灵活性。</li>
<li>无界通配符<ul>
<li><code>&lt;?&gt; </code>是无界通配符，表示可以匹配任何类型。例如，有一个方法用于打印集合中的元素。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(ArrayList&lt;?&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object element : list) &#123;</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>这个方法可以接受任何类型的<code>ArrayList</code>，但是在方法内部，只能将元素当作<code>Object</code>来处理，因为不知道具体的类型。</li>
<li>上界通配符<ul>
<li><code>&lt;? extends T&gt;</code>是上界通配符，表示匹配<code>T</code>或者<code>T</code>的子类。例如，假设有一个<code>Animal</code>类和它的子类<code>Dog</code>和<code>Cat</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printAnimalList</span><span class="params">(ArrayList&lt;? extends Animal&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Animal animal : list) &#123;</span><br><span class="line">        System.out.println(animal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>这个方法可以接受<code>ArrayList&lt;Animal&gt;</code>、<code>ArrayList&lt;Dog&gt;</code>或者<code>ArrayList&lt;Cat&gt;</code>等，只要元素类型是<code>Animal</code>或者它的子类就行。</li>
<li>下界通配符<ul>
<li><code>&lt;? super T&gt;</code>是下界通配符，表示匹配<code>T</code>或者<code>T</code>的父类。例如，有一个方法用于向集合中添加元素。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addToAnimalList</span><span class="params">(ArrayList&lt;? <span class="built_in">super</span> Dog&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    list.add(dog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>这个方法可以接受<code>ArrayList&lt;Animal&gt;</code>或者<code>ArrayList&lt;Object&gt;</code>等，只要元素类型是<code>Dog</code>或者它的超类就行，这样就可以向集合中添加<code>Dog</code>类型的元素。</li>
</ul>
<h2 id="14-多线程"><a href="#14-多线程" class="headerlink" title="14.多线程"></a>14.多线程</h2><h3 id="14-1-创建多线程"><a href="#14-1-创建多线程" class="headerlink" title="14.1.创建多线程"></a>14.1.创建多线程</h3><ul>
<li>方式一：继承Thread类来实现</li>
</ul>
<blockquote>
<ul>
<li>定义一个子类继承Thread类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">&gt;<span class="comment">//重写Thread类的run方法</span></span><br><span class="line">&gt;<span class="meta">@Override</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">&gt;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;子线程输出&quot;</span>+i);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;<span class="comment">//main方法默认也是一条线程，程序的主线程</span></span><br><span class="line">&gt;Thread t1=<span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">&gt;<span class="comment">//调用start方法启动线程</span></span><br><span class="line">&gt;t1.start();</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;主线程输出：&quot;</span>+i);</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意：</p>
<ol>
<li><p>直接调用run方法会当成普通方法执行，此时相当于还是单线程执行</p>
</li>
<li><p>只调用start方法才是启动一个新的线程执行</p>
</li>
<li><p>不要把主线任务放在启动子线程之前，这样主线程一直是先跑完的，相当于单线程的效果</p>
</li>
</ol>
<ul>
<li>方式二：实现Runnable接口</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Myrunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">&gt;<span class="meta">@Override</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">&gt;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;子线程输出&quot;</span>+i);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">&gt;<span class="comment">//创建线程任务类对象代表一个线程任务</span></span><br><span class="line">&gt;Runnable r=<span class="keyword">new</span> <span class="title class_">Myrunnable</span>();</span><br><span class="line">&gt;<span class="comment">//把线程任务对象交给一个线程对象来处理</span></span><br><span class="line">&gt;Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">&gt;<span class="comment">//启动线程</span></span><br><span class="line">&gt;t1.start();</span><br><span class="line">        </span><br><span class="line">&gt;<span class="comment">//匿名内部写法</span></span><br><span class="line">   <span class="comment">//声明一个接口对象</span></span><br><span class="line">   <span class="comment">//声明一个匿名子类（无声明）内部类,并且接口回调</span></span><br><span class="line"> Runnable r1= <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;子线程输出：&quot;</span>+i);</span><br><span class="line">       &#125;           </span><br><span class="line">   &#125;;</span><br><span class="line">      Thread t2=<span class="keyword">new</span> <span class="title class_">Thread</span>(r1);</span><br><span class="line">      t2.start();</span><br><span class="line">   <span class="comment">//直接用Thread接匿名</span></span><br><span class="line">     Thread t3=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;子线程输出：&quot;</span>+i);</span><br><span class="line">       &#125;).start();</span><br><span class="line">        </span><br><span class="line">   <span class="comment">//Lambda</span></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;子线程输出：&quot;</span>+i);</span><br><span class="line">            &#125;).start();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;主线程输出：&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优缺点：</li>
<li>优点：任务类只是实现接口，可以继承其它类，实现其它接口，扩展性强。</li>
<li>缺点：需要一个Runnable对象</li>
</ul>
</blockquote>
<ul>
<li>方式三：实现Callable接口、Futuretask类（重点）</li>
<li>前两种线程创建方式都存在一个问题</li>
<li>假如线程执行完毕后有一些数据需要返回，他们重写的run方法均不能直接返回结果。</li>
</ul>
<blockquote>
<ol>
<li>定义一个类实现Callable接口，重写call方法，封装要做的事情，和要返回的数据。</li>
<li>把Callable类型的对象封装成FutureTask（线程任务对象)。</li>
<li>把线程任务对象交给Thread对象</li>
<li>调用Thread对象的start方法启动线程</li>
<li>线程执行完毕后，通过Futuretask对象的get()方法来获取线程任务执行的结果。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">Callable&lt;String&gt; c1=<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//把Callable对象封装成FutureTask（线程任务对象)</span></span><br><span class="line"><span class="comment">//FutureTask继承于Runnable</span></span><br><span class="line">FutureTask&lt;String&gt; f1=<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(c1);<span class="comment">//public FutureTask(Callable&lt;V&gt; callable)</span></span><br><span class="line">    Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(f1);</span><br><span class="line">    t1.start();</span><br><span class="line">    </span><br><span class="line">    Callable&lt;String&gt; c2=<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">50</span>);</span><br><span class="line">    FutureTask&lt;String&gt; f2=<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(c2);</span><br><span class="line">    Thread t2=<span class="keyword">new</span> <span class="title class_">Thread</span>(f2);</span><br><span class="line">    t2.start();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取线程的结果</span></span><br><span class="line">    <span class="keyword">try</span>&#123;<span class="comment">//如果主线程发现一个线程还没有执行完，会让出CPU，等第一个线程执行完毕，才会往下执行！</span></span><br><span class="line">        System.out.println(f1.get());</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;<span class="comment">//如果主线程发现第二个线程还没有执行完，会让出CPU，等第二个线程执行完毕，才会往下执行！</span></span><br><span class="line">        System.out.println(f2.get());</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个实现类来实现Callable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyCallable</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.n=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现call方法，定义线程执行体</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">sum+=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;子线程计算的结果是：&quot;</span>+sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="14-2-常用方法"><a href="#14-2-常用方法" class="headerlink" title="14.2.常用方法"></a>14.2.常用方法</h3><ul>
<li><p>搞清楚线程的常用方法</p>
</li>
<li><pre><code class="java">public static void main(String[]args)&#123;
Thread t1=new Mythread(&quot;一号线程&quot;);
    //为线程设置名字public void setName(String name)
//t1.setName(&quot;一号线程&quot;);   //启动之前 
t1.start();
System.out.println(t1.getName());//public String getName()获取线程的名字默认是Thread-索引
Thread t1=new Mythread(&quot;二号线程&quot;);
//t2.setName(&quot;二号线程&quot;);    
t2.start();
System.out.println(t2.getName());
//获取当前线程public static Thread currentThread();
    //哪个线程调用这个代码，这个代码就拿到哪个线程
    Thread m=Thread.currentThread();//主线程
    m.setName(&quot;主线程&quot;);
    System.out.println(m.getName());//main
    
    
&#125;

class Mythread extends Thread&#123;
//重写Thread的run方法
@Override
public void run()&#123;
for(int i=0;i&lt;5;i++)&#123;
System.out.println(Thread.currentThread.getName()+&quot;子线程输出&quot;+i);
&#125;  
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  &gt; public void setName(String name)为线程设置名字为线程设置名字,需要在线程开启前</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; public void start()启动线程</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; public String getName()获取线程的名字默认是Thread-索引</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; public static Thread currentThread();获取当前线程，哪个线程调用这个代码，这个代码就拿到哪个线程</span><br><span class="line"></span><br><span class="line">- 常用构造器</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">public Thread(String name)//初始化时传入线程的名字</span><br><span class="line">public Thread(Runnable target)//封装Runnable对象，（传入任务）对象</span><br><span class="line">public Thread(Runnable target,String name)//传入任务对象和线程的名字</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>线程休眠</p>
</li>
</ul>
<p>让**<code>当前执行的线程</code>**进入休眠状态</p>
<p>public static void sleep(long times)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);<span class="comment">//1000ms=1s</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;<span class="comment">//线程被中断抛出InterruptedException</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>线程插队</li>
</ul>
<p>让调用这个方法的线程先执行完毕</p>
<p>public final void join()..</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">MyThread t1=<span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程输出：&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> extend Thread&#123;</span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;子线程输出：&quot;</span>+i);</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            t1.join();<span class="comment">//当i为1时，子线程插队;子线程执行完毕再执行主线程。</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="14-3-线程安全"><a href="#14-3-线程安全" class="headerlink" title="14.3.线程安全"></a>14.3.线程安全</h3><ul>
<li>多个线程，同时操作同一个共享资源时，可能会出现业务安全问题</li>
</ul>
<p>原因：</p>
<ul>
<li><blockquote>
<p>存在多个线程同时执行</p>
<p>同时访问一个共享资源</p>
<p>存在修改共享资源</p>
</blockquote>
<ul>
<li>模拟两个账户同时取钱</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String cardId;<span class="comment">//卡号</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//余额</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span>&#123;</span><br><span class="line">    <span class="comment">//拿到当前谁在取钱</span></span><br><span class="line">    String name=Thread.currentThread().getName();</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.money&gt;=money)&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;取钱成功，取了&quot;</span>+money+<span class="string">&quot;元，余额为：&quot;</span>(<span class="built_in">this</span>.money-money));</span><br><span class="line">        <span class="built_in">this</span>.money-=money;<span class="comment">//更新余额放最后，更大概率模拟出来两个人都取到钱的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> System.out.println(<span class="string">&quot;余额不足！&quot;</span>);</span><br><span class="line">&#125;    </span><br><span class="line">    <span class="comment">//。。。构造器以及getter、setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"><span class="comment">//初始化账户</span></span><br><span class="line">Account acc=<span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;ICBC_0910&quot;</span>,<span class="number">100000</span>);</span><br><span class="line"><span class="comment">//创建两个线程同时取钱</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">drawThread</span>(<span class="string">&quot;小明&quot;</span>,acc).start();   </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">drawThread</span>(<span class="string">&quot;小红&quot;</span>,acc).start(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">drawThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="keyword">private</span> Account acc;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">drawThread</span><span class="params">(String name,Account acc)</span>&#123;</span><br><span class="line"><span class="built_in">super</span>(name);</span><br><span class="line"><span class="built_in">this</span>.acc=acc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//取钱</span></span><br><span class="line">acc.drawMoney(<span class="number">100000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-4-线程同步"><a href="#14-4-线程同步" class="headerlink" title="14.4.线程同步"></a>14.4.线程同步</h3><ul>
<li>加锁：每次只允许一个线程加锁，加锁后才能进入访问，访问完毕自动解锁，然后其它线程才能进入并且加锁</li>
</ul>
<blockquote>
<ol>
<li>同步代码块</li>
</ol>
<p>作用：把访问的共享资源的核心代码给上锁，以此保证线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">&gt;<span class="comment">//访问共享资源的核心代码</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>原理：每次只允许一个线程加锁后进入，执行完毕后自动解锁，其它线程才可以进来执行。</p>
<p>注意：对于当前同时执行的线程来说，同步锁必须是同一把（同一个对象），否则会出bug。</p>
<ul>
<li><blockquote>
<p>建议使用共享资源作为锁对象，对于实例方法建议使用this作为锁对象。</p>
<p>对于静态方法建议使用字节码（类名.class）对象作为锁对象。</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li>同步方法</li>
</ol>
<p>作用：把访问的资源核心方法给上锁，以此保证线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;修饰符 <span class="keyword">synchronized</span> 方法名（参数列表）</span><br></pre></td></tr></table></figure>

<p>对于实例方法默认使用this作为锁对象。</p>
<p>对于静态方法默认使用字节码（类名.class）对象作为锁对象</p>
<p>优点：范围更大，可读性好</p>
<p>缺点：性能缺少</p>
<ol start="3">
<li><code>lock锁</code></li>
</ol>
<p>作用：可以创建出锁对象进行加锁和解锁，更灵活，更方便，更强大。</p>
<p>Lock是接口，不能直接实例化，可以采用它的实现类ReentrantLock来构建Lock锁对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">&gt;<span class="keyword">private</span> String cardId;<span class="comment">//卡号</span></span><br><span class="line">&gt;<span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//余额</span></span><br><span class="line">&gt;<span class="keyword">private</span> <span class="keyword">final</span> Lock lk=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();<span class="comment">//final保护锁对象</span></span><br><span class="line">   </span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span>&#123;</span><br><span class="line">   <span class="comment">//拿到当前谁在取钱</span></span><br><span class="line">   String name=Thread.currentThread().getName();</span><br><span class="line">   <span class="comment">//上锁</span></span><br><span class="line">   lk.lock();</span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.money&gt;=money)&#123;</span><br><span class="line">       System.out.println(name+<span class="string">&quot;取钱成功，取了&quot;</span>+money+<span class="string">&quot;元，余额为：&quot;</span>(<span class="built_in">this</span>.money-money));</span><br><span class="line">       <span class="built_in">this</span>.money-=money;<span class="comment">//更新余额放最后，更大概率模拟出来两个人都取到钱的情况</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> System.out.println(<span class="string">&quot;余额不足！&quot;</span>);</span><br><span class="line">&gt;&#125; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span>&#123;</span><br><span class="line">       lk.unlock();<span class="comment">//解锁，防止出现异常无法解锁</span></span><br><span class="line">   &#125;</span><br><span class="line">     </span><br><span class="line">   <span class="comment">//。。。构造器以及getter、setter</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="14-5-线程池"><a href="#14-5-线程池" class="headerlink" title="14.5.线程池"></a>14.5.线程池</h3><ul>
<li>线程池是一个可以<code>复用线程</code>的技术</li>
</ul>
<blockquote>
<ul>
<li>创建线程池</li>
</ul>
<p>代表线程池的接口：ExecutorService</p>
<ul>
<li>方式一：使用ExecutorService的实现类ThreadPoolExecutor</li>
</ul>
<p><img src="/java.assets/image-20241128182621673.png"></p>
</blockquote>
<p>最大线程数的配置：</p>
<p>如果是CPU密集型任务：电脑的逻辑处理器数量+1</p>
<p>IO密集型任务：电脑的逻辑处理器数量*2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程池对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"><span class="comment">//1、使用线程池的实现类ThreadPoolExecutor</span></span><br><span class="line">ExecutorService pool=<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>,<span class="number">5</span>,<span class="number">10</span>,TimeUnit.SECONDS,<span class="keyword">new</span> <span class="title class_">ArryBlockingQueue</span>&lt;&gt;(<span class="number">3</span>),Executors.defaultThreadFactory(),<span class="keyword">new</span> <span class="title class_">ThreadPoolAbortPolicy</span>());<span class="comment">//拒绝策略为抛异常处理</span></span><br><span class="line"><span class="comment">//2、处理Runnable任务和Callable任务,看会不会复用线程</span></span><br><span class="line"><span class="comment">//Runnable任务</span></span><br><span class="line">Runnable target=<span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="comment">//提交任务pool.execute(任务对象)，任务可以复用，创建线程，自动启动线程处理该任务。</span></span><br><span class="line">pool.execute(target);<span class="comment">//提交第一个任务</span></span><br><span class="line">pool.execute(target);<span class="comment">//提交第二个</span></span><br><span class="line">pool.execute(target);<span class="comment">//提交第三个</span></span><br><span class="line"><span class="comment">//pool.execute(target);//复用线程</span></span><br><span class="line"><span class="comment">//pool.execute(target);//复用线程</span></span><br><span class="line">pool.execute(target);<span class="comment">//无法复用，放入任务队列</span></span><br><span class="line">pool.execute(target);</span><br><span class="line">pool.execute(target);</span><br><span class="line">pool.execute(target);<span class="comment">//任务队列满，到了创建临时线程时机</span></span><br><span class="line">pool.execute(target);</span><br><span class="line">pool.execute(target);<span class="comment">//临时线程满了，到了任务拒绝时机</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//Callable任务</span></span><br><span class="line">Future&lt;String&gt; f1=pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>));<span class="comment">//多态，用Future接口来接FutureTask对象</span></span><br><span class="line">Future&lt;String&gt; f1=pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>));  </span><br><span class="line">Future&lt;String&gt; f1=pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">300</span>));  </span><br><span class="line">Future&lt;String&gt; f1=pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">400</span>));  </span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    System.out.println(f1.get());</span><br><span class="line">    System.out.println(f2.get());</span><br><span class="line">    System.out.println(f3.get());</span><br><span class="line">    System.out.println(f4.get()); </span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、关闭线程池，（*一般不关闭线程池）</span></span><br><span class="line">pool.shutdown();<span class="comment">//等所有任务执行完毕后再关闭线程池</span></span><br><span class="line"><span class="comment">//pool.shutdownNow();//立即关闭，不管任务是否执行完毕</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="meta">@OVerride</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">System.out.println(Thred.currentThread().getName()+<span class="string">&quot;输出：&quot;</span>+i);</span><br><span class="line"><span class="comment">//让线程无法复原模拟临时线程的创建时机</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mycallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCallable</span><span class="params">(<span class="type">int</span> n)</span>&#123;<span class="built_in">this</span>.n=n;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=;i&lt;=n;i++)sum+=i;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">&quot;计算1-&quot;</span>+n+<span class="string">&quot;的和是：&quot;</span>+sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：</li>
<li>临时线程的创建时机：</li>
</ul>
<blockquote>
<ul>
<li>核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程</li>
</ul>
</blockquote>
<ul>
<li>拒绝新任务的时机：</li>
</ul>
<blockquote>
<ul>
<li>核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始拒绝任务</li>
</ul>
</blockquote>
<blockquote>
<p>任务拒绝策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPOlicy()<span class="comment">//丢弃任务并且抛出异常</span></span><br><span class="line">ThreadPoolExecutor.DiscardPolicy()<span class="comment">//直接丢弃（不推荐）</span></span><br><span class="line">ThreadPOOlExecutor.DiscardOldestPolicy()<span class="comment">//丢弃任务队列中等待最久的任务，然后把当前任务加入队列</span></span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy()<span class="comment">//由主线程负责调用任务的run()方法从而绕过线程池直接执行</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>方式二：使用Executors(线程池的工具类)调用方法返回不同特点的线程池对象</li>
</ul>
<p><img src="/java.assets/image-20241202172933438.png" alt="image-20241202172933438"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过线程池工具类Executors,调用其静态方法直接的到线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">ExecutorService pool=Executors.newFixedThreadPool(<span class="number">3</span>);<span class="comment">//无临时线程</span></span><br><span class="line">Future&lt;String&gt; f1=pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>));<span class="comment">//多态，用Future接口来接FutureTask对象</span></span><br><span class="line">Future&lt;String&gt; f1=pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>));  </span><br><span class="line">Future&lt;String&gt; f1=pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">300</span>));  </span><br><span class="line">Future&lt;String&gt; f1=pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">400</span>));  </span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    System.out.println(f1.get());</span><br><span class="line">    System.out.println(f2.get());</span><br><span class="line">    System.out.println(f3.get());</span><br><span class="line">    System.out.println(f4.get()); </span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：</li>
</ul>
<blockquote>
<ul>
<li>这些方法的底层都是通过线程池的实现类ThreadPoolExecutor创建的线程池对象</li>
<li>尽量使用ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</li>
<li><ol>
<li>FixedThreadPool和SingThreadPool:允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，导致OOM（内存溢出）</li>
</ol>
</li>
</ul>
<ol start="2">
<li>CachedThreadPool和ScheduledThreadPool:允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程,导致OOM（内存溢出）</li>
</ol>
</blockquote>
<h3 id="14-6-并发和并行"><a href="#14-6-并发和并行" class="headerlink" title="14.6.并发和并行"></a>14.6.并发和并行</h3><ul>
<li><p>进程：正在运行的程序（软件）就是一个独立的进程。</p>
<ul>
<li>线程是属于进程的，一个进程中可以同时运行很多个线程</li>
<li>进程中的多个线程其实是并发和并行执行的（取决于CPU的核数，单核只能并发）</li>
</ul>
</li>
<li><p>并发：进程中的线程是由CPU负责调度执行的，但CPU能同时处理线程的数量有限，为了保证全部线程都能往前执行，CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。</p>
</li>
<li><p>并行：在同一个时刻上，同时有多个线程在被CPU调度执行。</p>
</li>
<li><p><code>多线程是并发和并行同时</code>。</p>
</li>
<li><p>红包雨游戏，某企业100名员工，工号1到100，发出两百个红包，其中小红包在【1-30】元之间，总占比为80%，大红包【31-100】元，总占比为20%<br>模拟100个员工抢红包，输出哪个员工抢到哪个红包的过程，活动结束时提示活动结束<br>结束后对100名员工按照抢到的红包金额进行排序，并输出。。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Multi_Thread_test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红包雨游戏，某企业100名员工，工号1到100，发出两百个红包，其中小红包在【1-30】元之间，总占比为80%，大红包【31-100】元，总占比为20%</span></span><br><span class="line"><span class="comment">//模拟100个员工抢红包，输出哪个员工抢到哪个红包的过程，活动结束时提示活动结束</span></span><br><span class="line"><span class="comment">//结束后对100名员工按照抢到的红包金额进行排序，并输出。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line"><span class="comment">//100个员工相当于100个线程来竞争200个红包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//2、定义线程类，创建100个线程，竞争同一个集合</span></span><br><span class="line">    List&lt;Integer&gt;redpacket=getRedPacket();</span><br><span class="line">    List&lt;Peoplegetredpacket&gt;Threads=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">Peoplegetredpacket t=<span class="keyword">new</span> <span class="title class_">Peoplegetredpacket</span>(redpacket,<span class="string">&quot;员工&quot;</span>+i);</span><br><span class="line">Threads.add(t);</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、等待所有线程执行完毕，才进入主线程</span></span><br><span class="line">    <span class="keyword">for</span>(Thread t:Threads)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">t.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//4、对抢到的红包进行排序，并输出</span></span><br><span class="line">Collections.sort(Threads,(t1,t2)-&gt;t2.getTotalmoney() - t1.getTotalmoney());</span><br><span class="line">System.out.println(<span class="string">&quot;员工按抢到的红包金额排序：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Peoplegetredpacket t:Threads)&#123;</span><br><span class="line">System.out.println(t.getName()+<span class="string">&quot;抢到红包总额：&quot;</span>+t.getTotalmoney());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1、准备两百个随机的红包返回，放到List集合中去返回</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">getRedPacket</span><span class="params">()</span>&#123;</span><br><span class="line">        Random random=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="comment">//模拟两百个红包,随机产生200个红包，小红包在1-30之间，大红包31-100，小红包占80%，大红包占20%</span></span><br><span class="line">        List&lt;Integer&gt;redpacket=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">160</span>;i++)redpacket.add(random.nextInt(<span class="number">30</span>)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">40</span>;i++)redpacket.add(random.nextInt(<span class="number">70</span>)+<span class="number">31</span>);</span><br><span class="line">        <span class="keyword">return</span> redpacket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Multi_Thread_test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Peoplegetredpacket</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">   List&lt;Integer&gt; redpacket;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> totalmoney;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Peoplegetredpacket</span><span class="params">(List&lt;Integer&gt; redpacket,String name)</span>&#123;</span><br><span class="line">       <span class="built_in">super</span>(name);</span><br><span class="line">       <span class="built_in">this</span>.redpacket=redpacket;</span><br><span class="line">       totalmoney=<span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="comment">//随机获取一个红包</span></span><br><span class="line">           <span class="keyword">synchronized</span> (redpacket) &#123;</span><br><span class="line">               <span class="keyword">if</span>(redpacket.size()==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">               <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) Math.random() * redpacket.size();</span><br><span class="line">               <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> redpacket.remove(index);</span><br><span class="line">               totalmoney += money;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">&quot;抢到红包：&quot;</span> + money);</span><br><span class="line">               <span class="keyword">if</span> (redpacket.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;活动结束！&quot;</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">500</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTotalmoney</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> totalmoney;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>















































<h2 id="15-网络处理"><a href="#15-网络处理" class="headerlink" title="15.网络处理"></a>15.网络处理</h2><ul>
<li>基本的通信架构</li>
</ul>
<blockquote>
<ul>
<li>CS架构（Client客户端&#x2F;Server服务端）</li>
<li>BS架构(Browser浏览器&#x2F;Server服务器)</li>
</ul>
</blockquote>
<p>域名-》DNS解析-》ip地址-》与服务器通信</p>
<p>公网IP:是可以连接到互联网的IP地址</p>
<p>内网IP:也叫局域网IP,是只能组织机构内部使用的IP地址；例如：192.168.开头的就是常见的局域网地址，范围为192.168.0.0-192.168.255.255</p>
<p>本机IP:127.0.0.1、localhost</p>
<p>ipconfig:查看本机的网络信息</p>
<p>ping:检查网络是否联通</p>
<h4 id="15-1-InetAddress"><a href="#15-1-InetAddress" class="headerlink" title="15.1.InetAddress"></a>15.1.InetAddress</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InetAddress <span class="title function_">getLocalHost</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException<span class="comment">//获取本机Ip</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getHostName</span><span class="params">()</span><span class="comment">//获取该IP的主机名</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getHostAddress</span><span class="params">(String host)</span>  <span class="keyword">throws</span> UnknownHostException<span class="comment">//根据ip地址或者域名，返回一个inetAddress对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReachable</span><span class="params">(<span class="type">int</span> timeout)</span><span class="keyword">throws</span> IOException<span class="comment">//判断主机在指定毫秒内与该ip对应的主机是否能连通</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InetAddress <span class="title function_">getByName</span><span class="params">(<span class="string">&quot;域名/ip地址&quot;</span>)</span>    </span><br></pre></td></tr></table></figure>

<ul>
<li>获取本机ip对象和对方ip对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;<span class="comment">//获取本机ip</span></span><br><span class="line">InetAddress ip1=InetAddress.getLocalHost();</span><br><span class="line">System.out.println(ip1.getHostName());</span><br><span class="line">System.out.println(ip1.getHostAddress());</span><br><span class="line"><span class="comment">//获取对方ip对象</span></span><br><span class="line">InetAddress ip2=InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">System.out.println(ip2.getHostName());</span><br><span class="line">System.out.println(ip2.getHostAddress());</span><br><span class="line"><span class="comment">//判断本机与对方主机是否互通</span></span><br><span class="line">System.out.println(ip2.isReachable(<span class="number">5000</span>));<span class="comment">//五秒内是否可以互通</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>端口</li>
</ul>
<p><img src="/java.assets%5Cimage-20241202202113494.png" alt="image-20241202202113494"></p>
<ul>
<li>传输层的协议</li>
</ul>
<p>UDP协议：无连接不可靠，用户数据报协议，只管发出去（适用于语言、视频）</p>
<p>TCP协议：面向连接，可靠，要保证在不可靠的信道上实现可靠的通信（网页、文件下载、支付）</p>
<h4 id="15-2-UDP通信"><a href="#15-2-UDP通信" class="headerlink" title="15.2.UDP通信"></a>15.2.UDP通信</h4><ul>
<li>特点：无连接不可靠</li>
<li>DatagramSocket(int port),DatagramPacket(byte[] buf,int length,&#x2F;&#x2F;address,port)</li>
</ul>
<p><img src="/java.assets/image-20241212082603810.png" alt="image-20241212082603810"></p>
<ul>
<li>完成UDP通信：实现一发一收</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPclientDemo1</span>  <span class="comment">//客户端</span></span><br><span class="line">&#123;<span class="comment">//1.创建发送端对象  </span></span><br><span class="line">System.out.println(<span class="string">&quot;客户端启动&quot;</span>)    </span><br><span class="line">DatagramSocket socket=<span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();<span class="comment">//默认分配端口，也可以指定端口</span></span><br><span class="line"><span class="comment">//2.创建数据包对象封装要发送的数据</span></span><br><span class="line"><span class="comment">//参数1：发送的数据，参数2：发送的数据长度，参数3：目的端的IP地址，参数4：服务端的程序端口号</span></span><br><span class="line"><span class="type">byte</span>[] bytes=<span class="string">&quot;asddsdasd&quot;</span> .getBytes();  </span><br><span class="line">DatagramPacket packet=<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length,InerAddress.getLocalHost,<span class="number">8000</span>);</span><br><span class="line"><span class="comment">//3.让发送端对象发送数据包的数据</span></span><br><span class="line">socket.send(packet);</span><br><span class="line">socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPServerDemo2</span>&#123;<span class="comment">//服务端</span></span><br><span class="line"><span class="comment">//1.创建接收端对象，指定端口号</span></span><br><span class="line">System.out.println(<span class="string">&quot;服务端启动&quot;</span>)</span><br><span class="line">DatagramSocket socket=<span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8000</span>);</span><br><span class="line"><span class="comment">//2.创建一个数据包负责接收数据</span></span><br><span class="line"><span class="type">byte</span>[] buf=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];<span class="comment">//一个包最大64kb</span></span><br><span class="line">DatagramPacket packet=<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf,buf.length);</span><br><span class="line"><span class="comment">//3.接收数据，将数据封装到数据包对象的字节数组中</span></span><br><span class="line">socket.recive(packet);</span><br><span class="line"><span class="comment">//4.看数据是否收到</span></span><br><span class="line"><span class="type">int</span> len=packet.getlength();<span class="comment">//获取收到的数据包长度</span></span><br><span class="line">String data=<span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,len);</span><br><span class="line">System.out.println(<span class="string">&quot;服务端收到了：&quot;</span>+data);</span><br><span class="line"><span class="comment">//5.获取对方的ip地址以及端口号</span></span><br><span class="line">String ip=packet.getInetAddress().getHostAddress();</span><br><span class="line"><span class="type">int</span> port=packet.getPort();</span><br><span class="line">System.out.println(<span class="string">&quot;对方ip:&quot;</span>+ip+<span class="string">&quot;对方端口：&quot;</span>+port);</span><br><span class="line">socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>多发多收</li>
<li><ul>
<li>客户端和服务端使用死循环</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPclientDemo1</span>  <span class="comment">//客户端</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"><span class="comment">//1.创建发送端对象  </span></span><br><span class="line">System.out.println(<span class="string">&quot;客户端启动&quot;</span>)    </span><br><span class="line">DatagramSocket socket=<span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();<span class="comment">//默认分配端口，也可以指定端口</span></span><br><span class="line"><span class="comment">//2.创建数据包对象封装要发送的数据</span></span><br><span class="line"><span class="comment">//参数1：发送的数据，参数2：发送的数据长度，参数3：目的端的IP地址，参数4：服务端的程序端口号</span></span><br><span class="line">Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">String msg=sc.nextLine();</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;exit&quot;</span>.equals(msg))&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;==客户端退出==&quot;</span>)；</span><br><span class="line">socket.close();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">byte</span>[] bytes=msg.getBytes();  </span><br><span class="line">DatagramPacket packet=<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length,InerAddress.getLocalHost,<span class="number">8000</span>);</span><br><span class="line"><span class="comment">//3.让发送端对象发送数据包的数据</span></span><br><span class="line">socket.send(packet);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPServerDemo2</span>&#123;<span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"><span class="comment">//1.创建接收端对象，指定端口号</span></span><br><span class="line">System.out.println(<span class="string">&quot;服务端启动&quot;</span>)</span><br><span class="line">DatagramSocket socket=<span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8000</span>);</span><br><span class="line"><span class="comment">//2.创建一个数据包负责接收数据</span></span><br><span class="line"><span class="type">byte</span>[] buf=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];<span class="comment">//一个包最大64kb</span></span><br><span class="line">DatagramPacket packet=<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf,buf.length);</span><br><span class="line"><span class="comment">//3.接收数据，将数据封装到数据包对象的字节数组中</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">socket.recive(packet);<span class="comment">//等待式接收数据</span></span><br><span class="line"><span class="comment">//4.看数据是否收到</span></span><br><span class="line"><span class="type">int</span> len=packet.getlength();<span class="comment">//获取收到的数据包长度</span></span><br><span class="line">String data=<span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,len);</span><br><span class="line">System.out.println(<span class="string">&quot;服务端收到了：&quot;</span>+data);</span><br><span class="line"><span class="comment">//5.获取对方的ip地址以及端口号</span></span><br><span class="line">String ip=packet.getIAddress().getHostAddress();</span><br><span class="line"><span class="type">int</span> port=packet.getPort();</span><br><span class="line">System.out.println(<span class="string">&quot;对方ip:&quot;</span>+ip+<span class="string">&quot;对方端口：&quot;</span>+port);</span><br><span class="line">System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="15-3-TCP通信"><a href="#15-3-TCP通信" class="headerlink" title="15.3.TCP通信"></a>15.3.TCP通信</h4><ul>
<li>特点：面向连接，可靠通信</li>
<li>“三次握手”</li>
</ul>
<blockquote>
<p>一发一收</p>
</blockquote>
<p><img src="/java.assets/image-20241212092517979.png" alt="image-20241212092517979"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCpclientDemo1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"><span class="comment">//1.创建客户端Socket对象，请求与服务器的连接</span></span><br><span class="line">        Socket socket=<span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9999</span>);</span><br><span class="line"><span class="comment">//2.使用socket对象调用getOutputString()方法得到字节输出流</span></span><br><span class="line">        OutputStream os=socket.getOutputStream();</span><br><span class="line"><span class="comment">//3.使用字节输出流完成数据的发送</span></span><br><span class="line">        DataOutputStream dos=<span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line">        dos.writeInt(<span class="number">1</span>);</span><br><span class="line">        dos.writeUTF(<span class="string">&quot;嘎嘎嘎！&quot;</span>);</span><br><span class="line"><span class="comment">//4.释放资源：关闭socket管道</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/java.assets/image-20241212093923345.png" alt="image-20241212093923345"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="comment">//实现一发一收</span></span><br><span class="line">        <span class="comment">//1.创建ServerSocket对象，指定端口号</span></span><br><span class="line">        ServerSocket ss=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2.调用accept方法，阻塞等待客户端连接，一旦有客户端连接会返回一个Socket对象</span></span><br><span class="line">        Socket socket=ss.accept();</span><br><span class="line">        <span class="comment">//3.获取输入流，读取客户端发送的消息</span></span><br><span class="line">        IntputStream is=socket.getIntputStream();</span><br><span class="line">        <span class="comment">//4.把字节输入流包装成特殊数据输入流</span></span><br><span class="line">        DataInputStream dis=<span class="keyword">new</span> <span class="title class_">DataIntputStream</span>(is);</span><br><span class="line">        <span class="comment">//5.读取数据</span></span><br><span class="line">        <span class="type">int</span> id=dis.readInt();</span><br><span class="line">        String msg=dis.readUTF();</span><br><span class="line">        System.out.println(<span class="string">&quot;id&quot;</span>+id+<span class="string">&quot;,收到的客户端msg:&quot;</span>+msg);</span><br><span class="line">        <span class="comment">//6.获取客户端的ip和端口</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取客户端的ip地址：&quot;</span>+socket.getInetAddress().getHostAddress());</span><br><span class="line">        System.out.println(<span class="string">&quot;获取客户端的端口号：&quot;</span>+socket.getPort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<blockquote>
<p>多发多收</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCpclientDemo1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"><span class="comment">//1.创建客户端Socket对象，请求与服务器的连接</span></span><br><span class="line">        Socket socket=<span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9999</span>);</span><br><span class="line"><span class="comment">//2.使用socket对象调用getOutputString()方法得到字节输出流</span></span><br><span class="line">        OutputStream os=socket.getOutputStream();</span><br><span class="line"><span class="comment">//3.使用字节输出流完成数据的发送</span></span><br><span class="line">        DataOutputStream dos=<span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line">       Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        whlie(<span class="literal">true</span>)&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;请说：&quot;</span>);  </span><br><span class="line">          String msg=sc.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;exit&quot;</span>.equals(msg))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;退出成功！&quot;</span>);</span><br><span class="line">                dos.close();<span class="comment">//关闭输出管道</span></span><br><span class="line">                socket.close();<span class="comment">//关闭socket</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dos.writeUTF(msg);<span class="comment">//发送数据</span></span><br><span class="line">            dos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="comment">//实现一发一收</span></span><br><span class="line">        <span class="comment">//1.创建ServerSocket对象，指定端口号</span></span><br><span class="line">        ServerSocket ss=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2.调用accept方法，阻塞等待客户端连接，一旦有客户端连接会返回一个Socket对象</span></span><br><span class="line">        Socket socket=ss.accept();</span><br><span class="line">        <span class="comment">//3.获取输入流，读取客户端发送的消息</span></span><br><span class="line">        IntputStream is=socket.getIntputStream();</span><br><span class="line">        <span class="comment">//4.把字节输入流包装成特殊数据输入流</span></span><br><span class="line">        DataInputStream dis=<span class="keyword">new</span> <span class="title class_">DataIntputStream</span>(is);</span><br><span class="line">        <span class="comment">//5.读取数据</span></span><br><span class="line">       <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            String msg=dis.readUTF();<span class="comment">//等待客户端发送消息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;收到的客户端msg:&quot;</span>+msg);</span><br><span class="line">        <span class="comment">//6.获取客户端的ip和端口</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取客户端的ip地址：&quot;</span>+socket.getInetAddress().getHostAddress());</span><br><span class="line">        System.out.println(<span class="string">&quot;获取客户端的端口号：&quot;</span>+socket.getPort());</span><br><span class="line">           System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="15-4-多个客户端同时通信"><a href="#15-4-多个客户端同时通信" class="headerlink" title="15.4.多个客户端同时通信"></a>15.4.多个客户端同时通信</h4><ul>
<li><p>对客户端进行改造</p>
</li>
<li><p>主线程接收客户端连接</p>
</li>
<li><p>子线程处理消息</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="comment">//实现一发一收</span></span><br><span class="line">        <span class="comment">//1.创建ServerSocket对象，指定端口号</span></span><br><span class="line">        ServerSocket ss=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2.调用accept方法，阻塞等待客户端连接，一旦有客户端连接会返回一个Socket对象</span></span><br><span class="line">        <span class="keyword">while</span>(ture)&#123;</span><br><span class="line">              Socket socket=ss.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;一个客户端上线了：&quot;</span>socket.getInetAddress().getHostAddress())</span><br><span class="line">            <span class="comment">//把客户端管道交给一个子线程来处理</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServerReader</span>(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReader</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReader</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket=socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="comment">//读取该管道的消息</span></span><br><span class="line">        InputStream is=socket.getInputStream();</span><br><span class="line">        DataIuputStream dis=<span class="keyword">new</span> <span class="title class_">DataIntputStream</span>(is);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            String msg=dis.readUTF();</span><br><span class="line">             System.out.println(<span class="string">&quot;收到的客户端msg:&quot;</span>+msg);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取客户端的ip地址：&quot;</span>+socket.getInetAddress().getHostAddress());</span><br><span class="line">        System.out.println(<span class="string">&quot;获取客户端的端口号：&quot;</span>+socket.getPort());</span><br><span class="line">           System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;一个客户端下线了：&quot;</span>socket.getInetAddress.getHostAddress());</span><br><span class="line">        &#125; </span><br><span class="line">       &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="15-5-B-S架构，使用线程池"><a href="#15-5-B-S架构，使用线程池" class="headerlink" title="15.5.B&#x2F;S架构，使用线程池"></a>15.5.B&#x2F;S架构，使用线程池</h4><h3 id=""><a href="#" class="headerlink" title=""></a></h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/java.html" data-id="cm5aqnt6f000aqcda925x9npx" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    

  
    
  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 hlx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>