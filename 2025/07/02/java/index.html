

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="xing">
  <meta name="keywords" content="">
  
    <meta name="description" content="java（有c&#x2F;c++基础）1.初识java1.1.java的体系结构 javaSE :标准版，个人计算机上的应用（重点） JavaEE：企业版，服务器端的应用（重点） JavaME：微型版，定位在消费性产品  1.2.Java的特性与优势 Java就是c++语法的简化版，相当于将c++的一些内容去除；比如：头文件，指针运算，结构，联合，操作符重载，虚基类等等。同时，语法基于C语言。 高">
<meta property="og:type" content="article">
<meta property="og:title" content="xing的个人博客">
<meta property="og:url" content="http://example.com/2025/07/02/java/index.html">
<meta property="og:site_name" content="xing的个人博客">
<meta property="og:description" content="java（有c&#x2F;c++基础）1.初识java1.1.java的体系结构 javaSE :标准版，个人计算机上的应用（重点） JavaEE：企业版，服务器端的应用（重点） JavaME：微型版，定位在消费性产品  1.2.Java的特性与优势 Java就是c++语法的简化版，相当于将c++的一些内容去除；比如：头文件，指针运算，结构，联合，操作符重载，虚基类等等。同时，语法基于C语言。 高">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/.com//image-20241015175105864.png">
<meta property="og:image" content="http://example.com/.com//image-20241015175622423.png">
<meta property="og:image" content="http://example.com/.com//image-20241015175759664.png">
<meta property="og:image" content="http://example.com/.com//image-20241023144932770.png">
<meta property="og:image" content="http://example.com/.com//image-20241023150558249.png">
<meta property="og:image" content="http://example.com/.com//image-20250222173943751.png">
<meta property="og:image" content="http://example.com/.com//image-20241103174048966.png">
<meta property="og:image" content="http://example.com/.com//image-20241104182403532.png">
<meta property="og:image" content="http://example.com/.com//image-20241112190146403.png">
<meta property="og:image" content="http://example.com/.com//image-20241127200033060.png">
<meta property="og:image" content="http://example.com/.com//image-20241127202555955.png">
<meta property="og:image" content="http://example.com/.com//image-20241104155653318.png">
<meta property="og:image" content="http://example.com/.com//image-20241222155322256.png">
<meta property="og:image" content="http://example.com/.com//image-20241221192020851.png">
<meta property="og:image" content="http://example.com/.com//image-20250222235931156.png">
<meta property="og:image" content="http://example.com/.com//image-20250221233439364.png">
<meta property="og:image" content="http://example.com/.com//image-20250305213411493.png">
<meta property="og:image" content="http://example.com/.com//image-20241128182621673.png">
<meta property="og:image" content="http://example.com/.com//image-20241202172933438.png">
<meta property="og:image" content="http://example.com/.com//java.assets%5Cimage-20241202202113494.png">
<meta property="og:image" content="http://example.com/.com//image-20241212082603810.png">
<meta property="og:image" content="http://example.com/.com//image-20250421165851026.png">
<meta property="og:image" content="http://example.com/.com//image-20241212092517979.png">
<meta property="og:image" content="http://example.com/.com//image-20241212093923345.png">
<meta property="og:image" content="http://example.com/.com//image-20250227155911896.png">
<meta property="og:image" content="http://example.com/.com//image-20250227161039549.png">
<meta property="og:image" content="http://example.com/.com//image-20250227161841918.png">
<meta property="og:image" content="http://example.com/.com//image-20250331142402456.png">
<meta property="og:image" content="http://example.com/.com//image-20250331142631910.png">
<meta property="og:image" content="http://example.com/.com//image-20250331143300867.png">
<meta property="og:image" content="http://example.com/.com//image-20250331143819924.png">
<meta property="og:image" content="http://example.com/.com//image-20250331143959390.png">
<meta property="og:image" content="http://example.com/.com//image-20250331144028471.png">
<meta property="og:image" content="http://example.com/.com//image-20250331144158882.png">
<meta property="og:image" content="http://example.com/.com//image-20250331144633543.png">
<meta property="og:image" content="http://example.com/.com//image-20250331145005267.png">
<meta property="og:image" content="http://example.com/.com//image-20250331145622188.png">
<meta property="og:image" content="http://example.com/.com//image-20250421172401690.png">
<meta property="article:published_time" content="2025-07-01T17:11:58.301Z">
<meta property="article:modified_time" content="2025-06-24T02:25:01.957Z">
<meta property="article:author" content="xing">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/.com//image-20241015175105864.png">
  
  
  
  <title>xing的个人博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>xing的个人博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text=""></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-07-02 01:11" pubdate>
          2025年7月2日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          48k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          404 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header"></h1>
            
            
              <div class="markdown-body">
                
                <h1 id="java（有c-c-基础）"><a href="#java（有c-c-基础）" class="headerlink" title="java（有c&#x2F;c++基础）"></a>java（有c&#x2F;c++基础）</h1><h2 id="1-初识java"><a href="#1-初识java" class="headerlink" title="1.初识java"></a>1.初识java</h2><h3 id="1-1-java的体系结构"><a href="#1-1-java的体系结构" class="headerlink" title="1.1.java的体系结构"></a>1.1.java的体系结构</h3><ul>
<li>javaSE :标准版，个人计算机上的应用（重点）</li>
<li>JavaEE：企业版，服务器端的应用（重点）</li>
<li>JavaME：微型版，定位在消费性产品</li>
</ul>
<h3 id="1-2-Java的特性与优势"><a href="#1-2-Java的特性与优势" class="headerlink" title="1.2.Java的特性与优势"></a>1.2.Java的特性与优势</h3><ul>
<li>Java就是c++语法的简化版，相当于将c++的一些内容去除；比如：头文件，指针运算，结构，联合，操作符重载，虚基类等等。同时，语法基于C语言。</li>
<li>高性能：通过虚拟机优化提升速度</li>
<li>分布式</li>
<li>多线程</li>
<li>健壮性</li>
</ul>
<h3 id="1-3-核心机制"><a href="#1-3-核心机制" class="headerlink" title="1.3.核心机制"></a>1.3.核心机制</h3><ul>
<li><p>垃圾收集机制</p>
</li>
<li><p>跨平台原理</p>
</li>
</ul>
<p>Java的跨平台原理</p>
<p><img src="/.com//image-20241015175105864.png" srcset="/img/loading.gif" lazyload alt="image-20241015175105864"></p>
<p>C语言的跨平台原理</p>
<p><img src="/.com//image-20241015175622423.png" srcset="/img/loading.gif" lazyload alt="image-20241015175622423"></p>
<p>比较：</p>
<p><img src="/.com//image-20241015175759664.png" srcset="/img/loading.gif" lazyload alt="image-20241015175759664"></p>
<h3 id="1-4-常用的DOS命令"><a href="#1-4-常用的DOS命令" class="headerlink" title="1.4.常用的DOS命令"></a>1.4.常用的DOS命令</h3><blockquote>
<p>win+r+cmd</p>
</blockquote>
<p>打开控制台</p>
<ol>
<li>切换盘符：c:  ,   d:    ,  e:   不用区分大小写</li>
<li>显示详细信息：dir   相当于Linux中的ls</li>
<li>改变当前目录：  cd   和Linux中的一样</li>
<li>.  当前目录   和  ..  上级目录  ：和Linux里一样</li>
<li>清屏cls</li>
<li>上下箭头切换历史命令</li>
<li>tab键补齐</li>
<li>创建目录和删除目录：md 和rd 后面加文件   对应Linux中的mkdir和rm</li>
<li>copy复制文件：和Linux中的cp一样</li>
</ol>
<h3 id="1-5-快捷总结"><a href="#1-5-快捷总结" class="headerlink" title="1.5.快捷总结"></a>1.5.快捷总结</h3><p>CTRL+ALT+L：自动对齐</p>
<p>CTRL+ALT+T:对代码块进行包围操作（异常、同步锁）</p>
<p>CTRL+H:查看类的层级关系</p>
<p>Ctrl+Alt+←：回到光标前面一次的位置，→同理</p>
<p>SHIFT+F6:同时修改变量</p>
<h2 id="2-数据类型——常量、变量、输入输出"><a href="#2-数据类型——常量、变量、输入输出" class="headerlink" title="2.数据类型——常量、变量、输入输出"></a>2.数据类型——常量、变量、输入输出</h2><h3 id="2-1-常量、变量"><a href="#2-1-常量、变量" class="headerlink" title="2.1.常量、变量"></a>2.1.常量、变量</h3><ul>
<li>字面常量</li>
</ul>
<blockquote>
<p>整型常量、字符常量、逻辑常量、字符串常量</p>
</blockquote>
<p>null常量：可以赋值给任何类型的变量。</p>
<ul>
<li>变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">pubilc <span class="hljs-keyword">class</span> <span class="hljs-title class_">value</span>()&#123;<br>    pubilc <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">byte</span> mybyte=<span class="hljs-number">120</span>;<span class="hljs-comment">//  byte变量（-127，128）一个字节</span><br>        <span class="hljs-type">short</span> myshort=<span class="hljs-number">120</span>;<span class="hljs-comment">// short变量 两个字节</span><br>        <span class="hljs-type">int</span> myint=<span class="hljs-number">120</span>; <span class="hljs-comment">//int变量 4个字节</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">mylong</span> <span class="hljs-operator">=</span><span class="hljs-number">12123L</span>;<span class="hljs-comment">// long变量 8个字节  最后加上L来标识</span><br>        <span class="hljs-type">float</span> myfloat=<span class="hljs-number">3.14f</span>;<span class="hljs-comment">//float变量 4个字节  最后加上f来标识</span><br>        <span class="hljs-type">double</span> mydouble=<span class="hljs-number">3.1415926</span>;<span class="hljs-comment">// double变量 8个字节</span><br>        <span class="hljs-type">char</span> mychar=<span class="hljs-string">&#x27;A&#x27;</span>; <span class="hljs-comment">//char变量 2个字节</span><br>        <span class="hljs-type">boolean</span> myboolean=ture;<span class="hljs-comment">//false 布尔变量理论上只要一位，Java中占一个字节</span><br>        <span class="hljs-type">int</span>[] myarray=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<span class="hljs-comment">//int数组型变量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;myarray.length;i++)&#123;<span class="hljs-comment">//赋值</span><br>            myarray[i]=i+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> element :myarray)&#123;<br>            System.out.println(element+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<span class="hljs-comment">//输出</span><br>        <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Season</span>&#123;<span class="hljs-comment">//枚举型变量</span><br>            spring,summer,autumn,winter<br>        &#125;<br>        <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>字符常量<code>final</code></li>
</ul>
<p>和c++中的const性质类似，被final修饰的字符变量变成常量不可修改</p>
<p>在Java中final可以用来修饰类和方法</p>
<p><code>被final修饰的类不能被继承</code></p>
<p><code>被final修饰的方法不能被子类重写。</code></p>
<p><code>final修饰引用类型地址值不能改变</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">final</span> num=<span class="hljs-number">10</span>;<br>num=<span class="hljs-number">5</span><span class="hljs-comment">//无法改变</span><br><span class="hljs-keyword">final</span> Dog d=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>d=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<span class="hljs-comment">//---&gt;地址值不能改</span><br><span class="hljs-comment">//d对象的属性依然可以改变</span><br></code></pre></td></tr></table></figure>

<h3 id="2-2-类型转换"><a href="#2-2-类型转换" class="headerlink" title="2.2. 类型转换"></a>2.2. 类型转换</h3><h4 id="2-2-1隐式转换"><a href="#2-2-1隐式转换" class="headerlink" title="2.2.1隐式转换"></a>2.2.1隐式转换</h4><ul>
<li><strong>字节数从小到大</strong>：byte-&gt;short-&gt;char-&gt;int-&gt;long-&gt;float-&gt;double</li>
</ul>
<p>long比float字节多所以转换可能存在丢失</p>
<ul>
<li><strong>字符类型与整数类型</strong>：<code>char可以自动转换为int</code>,因为char在Java中是2字节的无符号整数，其本质上可以看成是一种特殊的整数类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">byte</span> b=<span class="hljs-number">120</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span>b;<span class="hljs-comment">//byte 自动转换为int</span><br><br><span class="hljs-type">char</span> ch=<span class="hljs-string">&#x27;A&#x27;</span>;<br><span class="hljs-type">int</span> code=ch;<span class="hljs-comment">//char自动转换为int，得到字符‘A’的码值</span><br></code></pre></td></tr></table></figure>

<h4 id="2-2-2强制转换（显式转换）"><a href="#2-2-2强制转换（显式转换）" class="headerlink" title="2.2.2强制转换（显式转换）"></a>2.2.2强制转换（显式转换）</h4><ul>
<li>当需要将大的数据类型转换为小的数据类型时，需要进行强制类型转换。可能会导致数据精度的损失。</li>
<li>targetType v&#x3D;(tergetType)value</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">double</span> d=<span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> j=(<span class="hljs-type">int</span>)d;<span class="hljs-comment">//得到3，小数部分被截断</span><br><span class="hljs-type">long</span> l=<span class="hljs-number">121892364819236412793L</span>;<br><span class="hljs-type">int</span> k=(<span class="hljs-type">int</span>)l; <span class="hljs-comment">//长整型强制转换为整型，可能出现数据溢出</span><br></code></pre></td></tr></table></figure>



<h4 id="2-2-3特殊的类型转换"><a href="#2-2-3特殊的类型转换" class="headerlink" title="2.2.3特殊的类型转换"></a>2.2.3特殊的类型转换</h4><p>字符串与基本数据结构的转换</p>
<ul>
<li><p>基本数据类型转字符串</p>
<ul>
<li>可以使用连接操作（<code>+</code>） 或相应的字符串转换方法。</li>
<li>使用<code>String.valueOf()</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用+连接操作</span><br><span class="hljs-type">int</span> num=<span class="hljs-number">456</span>;<br>String str1=<span class="hljs-string">&quot;&quot;</span>+num;<br><br><span class="hljs-comment">//使用String.valueOf()方法：</span><br><span class="hljs-type">int</span> num2=<span class="hljs-number">456</span>;<br>String str2=String.valueOf(num2);<br></code></pre></td></tr></table></figure>
</li>
<li><p>字符串转基本数据类型</p>
<ul>
<li>使用相应的包装类的parsexxx()方法（xxx表示具体的数据类型，如Integer.parseInt()、Double.parseDouble()等）。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String str3=<span class="hljs-string">&quot;123356&quot;</span>;<br><span class="hljs-type">int</span> num3=Integer.parseInt(str3);<br></code></pre></td></tr></table></figure>

<p>如果字符串的内容不符合数字格式，会抛出NumberFormatException异常。</p>
<h3 id="2-3-Scanner基础用法"><a href="#2-3-Scanner基础用法" class="headerlink" title="2.3.Scanner基础用法"></a>2.3.<code>Scanner</code>基础用法</h3><ul>
<li>读取基本数据类型</li>
</ul>
<blockquote>
<p>nextInt()-读取整数</p>
<p>nextDouble()-读取双精度浮点数</p>
<p>nextBoolean()-读取布尔值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br>Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">int</span> age=sc.nextInt();<span class="hljs-comment">//键盘录入年龄</span><br><span class="hljs-type">double</span> hign=sc.nextDouble();<span class="hljs-comment">//键盘录入身高</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>读取字符串&#x2F;字符</li>
</ul>
<blockquote>
<p>next()-读取下一个单词</p>
<p>nextLine()-读取一行字符串</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java">Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>String word=sc.next();<span class="hljs-comment">//读取一个单词</span><br>String str=sc.nextLine();<span class="hljs-comment">//读取一行</span><br><span class="hljs-type">char</span> ch=word.charAt();<span class="hljs-comment">//读取一个字符</span><br></code></pre></td></tr></table></figure>



<ul>
<li>其它方法</li>
</ul>
<blockquote>
<p>hasNext()-判断是否还有下一个输入项</p>
<p>hasNextInt、hasNextDouble等等</p>
</blockquote>
<h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3.运算符"></a>3.运算符</h2><h3 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1.算术运算符"></a>3.1.算术运算符</h3><ol>
<li><strong>基本算术运算符</strong><ul>
<li>加法（+）<ul>
<li>用于计算两个数值的和。例如：<code>int a = 3 + 5;</code>，结果<code>a</code>为 8。</li>
<li>当用于字符串时，它起到连接字符串的作用，如<code>String s1 = &quot;Hello&quot; + &quot;World&quot;;</code>，结果<code>s1</code>为<code>&quot;HelloWorld&quot;</code>。</li>
</ul>
</li>
<li>减法（-）<ul>
<li>用于计算两个数值的差。例如：<code>int b = 7 - 4;</code>，结果<code>b</code>为 3。</li>
</ul>
</li>
<li>乘法（*）<ul>
<li>用于计算两个数值的乘积。例如：<code>int c = 2 * 6;</code>，结果<code>c</code>为 12。</li>
</ul>
</li>
<li>除法（&#x2F;）<ul>
<li>当用于整数时，它执行整除操作。例如：<code>int d = 10 / 3;</code>，结果<code>d</code>为 3。</li>
<li>当用于浮点数时，执行常规的除法运算，得到带有小数的结果，如<code>double e = 10.0 / 3.0;</code>，结果<code>e</code>约为 3.3333。</li>
</ul>
</li>
<li>取余（%）<ul>
<li>用于计算两个数相除的余数。例如：<code>int f = 10 % 3;</code>，结果<code>f</code>为 1。</li>
</ul>
</li>
</ul>
</li>
<li><strong>自增（++）和自减（–）运算符</strong><ul>
<li>自增（++）<ul>
<li>分为前置自增和后置自增。</li>
<li>前置自增（<code>++i</code>）：先将变量的值加 1，然后再使用变量的值。例如：</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> ++i;<br><span class="hljs-comment">// 此时i的值为4，j的值也为4</span><br></code></pre></td></tr></table></figure>



<ul>
<li>后置自增（<code>i++</code>）：先使用变量的值，然后再将变量的值加 1。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> m++;<br><span class="hljs-comment">// 此时m的值为4，n的值为3</span><br></code></pre></td></tr></table></figure>



<ul>
<li>自减（–）<ul>
<li>与自增类似，分为前置自减和后置自减。</li>
<li>前置自减（<code>--k</code>）：先将变量的值减 1，然后再使用变量的值。</li>
<li>后置自减（<code>k--</code>）：先使用变量的值，然后再将变量的值减 1。</li>
</ul>
</li>
</ul>
<h3 id="3-2-关系运算符"><a href="#3-2-关系运算符" class="headerlink" title="3.2.关系运算符"></a>3.2.关系运算符</h3><ol>
<li>比较大小关系<ul>
<li>等于（&#x3D;&#x3D;）<ul>
<li>用于判断两个值是否相等。例如：<code>boolean b1 = (3 == 3);</code>，结果<code>b1</code>为<code>true</code>；<code>boolean b2 = (3 == 4);</code>，结果<code>b2</code>为<code>false</code>。</li>
</ul>
</li>
<li>不等于（!&#x3D;）<ul>
<li>用于判断两个值是否不相等。例如：<code>boolean c1 = (3!= 4);</code>，结果<code>c1</code>为<code>true</code>。</li>
</ul>
</li>
<li>大于（&gt;）<ul>
<li>用于判断左边的值是否大于右边的值。例如：<code>boolean d1 = (5 &gt; 3);</code>，结果<code>d1</code>为<code>true</code>。</li>
</ul>
</li>
<li>小于（&lt;）<ul>
<li>用于判断左边的值是否小于右边的值。例如：<code>boolean e1 = (2 &lt; 3);</code>，结果<code>e1</code>为<code>true</code>。</li>
</ul>
</li>
<li>大于等于（&gt;&#x3D;）<ul>
<li>用于判断左边的值是否大于等于右边的值。例如：<code>boolean f1 = (3 &gt;= 3);</code>，结果<code>f1</code>为<code>true</code>。</li>
</ul>
</li>
<li>小于等于（&lt;&#x3D;）<ul>
<li>用于判断左边的值是否小于等于右边的值。例如：<code>boolean g1 = (2 &lt;= 3);</code>，结果<code>g1</code>为<code>true</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-3-逻辑运算符"><a href="#3-3-逻辑运算符" class="headerlink" title="3.3.逻辑运算符"></a>3.3.逻辑运算符</h3><ol>
<li>逻辑与（&amp;&amp;）和逻辑或（||）<ul>
<li>逻辑与（&amp;&amp;）<ul>
<li>当且仅当两个操作数都为<code>true</code>时，结果才为<code>true</code>。例如：<code>boolean a = (3 &gt; 2) &amp;&amp; (4 &lt; 5);</code>，结果<code>a</code>为<code>true</code>；<code>boolean b = (3 &gt; 2) &amp;&amp; (4 &gt; 5);</code>，结果<code>b</code>为<code>false</code>。</li>
<li>逻辑与具有短路特性，即当第一个操作数为<code>false</code>时，不会再计算第二个操作数。</li>
</ul>
</li>
<li>逻辑或（||）<ul>
<li>只要两个操作数中有一个为<code>true</code>，结果就为<code>true</code>。例如：<code>boolean c = (3 &gt; 2) || (4 &gt; 5);</code>，结果<code>c</code>为<code>true</code>；<code>boolean d = (3 &lt; 2) || (4 &lt; 5);</code>，结果<code>d</code>为<code>true</code>；<code>boolean e = (3 &lt; 2) || (4 &gt; 5);</code>，结果<code>e</code>为<code>false</code>。</li>
<li>逻辑或也具有短路特性，即当第一个操作数为<code>true</code>时，不会再计算第二个操作数。</li>
</ul>
</li>
</ul>
</li>
<li>逻辑非（!）<ul>
<li>用于对操作数取反。例如：<code>boolean f =!(3 &gt; 2);</code>，结果<code>f</code>为<code>false</code>。</li>
</ul>
</li>
</ol>
<h3 id="3-4-位运算符"><a href="#3-4-位运算符" class="headerlink" title="3.4.位运算符"></a>3.4.位运算符</h3><ol>
<li><p>按位与（&amp;）、按位或（|）、按位异或（^）和取反（~）</p>
<ul>
<li><p>按位与（&amp;）</p>
<ul>
<li>对两个操作数的每一位进行与操作。例如：<code>int a = 5 &amp; 3;</code>，5 的二进制是<code>101</code>，3 的二进制是<code>011</code>，按位与后得到<code>001</code>，即<code>a</code>为 1。</li>
</ul>
</li>
<li><p>按位或（|）</p>
<ul>
<li>对两个操作数的每一位进行或操作。例如：<code>int b = 5 | 3;</code>，得到<code>111</code>，即<code>b</code>为 7。</li>
</ul>
</li>
<li><p>按位异或（^）</p>
<ul>
<li>对两个操作数的每一位进行异或操作。相同为 0，不同为 1。例如：<code>int c = 5 ^ 3;</code>，得到<code>110</code>，即<code>c</code>为 6。</li>
</ul>
</li>
<li><p>取反（~）</p>
<ul>
<li>对操作数的每一位进行取反操作。例如：<code>int d = ~5;</code>，5 的二进制是<code>00000101</code>，取反后得到<code>11111010</code>，即<code>d</code>为 - 6（在有符号二进制表示中）。</li>
</ul>
<p>计算机中负数使用补码表示：</p>
<p>6：00000000 00000000 00000000 00000110</p>
<p>取反：11111111 11111111 11111111 11111001</p>
<p>加1：11111111 11111111 11111111 11111010    —–》-6</p>
</li>
</ul>
</li>
<li><p>左移（&lt;&lt;）、右移（&gt;&gt;）和无符号右移（&gt;&gt;&gt;）</p>
<ul>
<li>左移（&lt;&lt;）<ul>
<li>将操作数的二进制位向左移动指定的位数，右边补 0。例如：<code>int e = 2 &lt;&lt; 1;</code>，2 的二进制是<code>00000010</code>，左移 1 位后得到<code>00000100</code>，即<code>e</code>为 4。</li>
</ul>
</li>
<li>右移（&gt;&gt;）<ul>
<li>将操作数的二进制位向右移动指定的位数，左边补符号位。例如：<code>int f = 4 &gt;&gt; 1;</code>，4 的二进制是<code>00000100</code>，右移 1 位后得到<code>00000010</code>，即<code>f</code>为 2。</li>
</ul>
</li>
<li>无符号右移（&gt;&gt;&gt;）<ul>
<li>将操作数的二进制位向右移动指定的位数，左边补 0。例如：<code>int g = -4 &gt;&gt;&gt; 1;</code>，-4 的二进制是<code>11111100</code>，无符号右移 1 位后得到<code>01111110</code>，即<code>g</code>为 126。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-5-赋值运算符"><a href="#3-5-赋值运算符" class="headerlink" title="3.5.赋值运算符"></a>3.5.赋值运算符</h3><ol>
<li>基本赋值运算符（&#x3D;）和复合赋值运算符<ul>
<li>基本赋值运算符（&#x3D;）<ul>
<li>用于将一个值赋给一个变量。例如：<code>int x = 5;</code>，将 5 赋给变量<code>x</code>。</li>
</ul>
</li>
<li>复合赋值运算符<ul>
<li>包括<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>等。例如：<code>int y = 3; y += 2;</code>等价于<code>y = y + 2;</code>，结果<code>y</code>为 5。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-6-条件运算符（-）-三元运算符"><a href="#3-6-条件运算符（-）-三元运算符" class="headerlink" title="3.6.条件运算符（?:）&#x2F;三元运算符"></a>3.6.条件运算符（?:）&#x2F;三元运算符</h3><ol>
<li>语法和示例<ul>
<li>语法为<code>condition? expression1 : expression2</code>。当<code>condition</code>为<code>true</code>时，返回<code>expression1</code>的值；当<code>condition</code>为<code>false</code>时，返回<code>expression2</code>的值。例如：<code>int a = (3 &gt; 2)? 5 : 10;</code>，结果<code>a</code>为 5。</li>
</ul>
</li>
</ol>
<h2 id="4-随机数"><a href="#4-随机数" class="headerlink" title="4.随机数"></a>4.随机数</h2><h3 id="4-1-Math-random-方法"><a href="#4-1-Math-random-方法" class="headerlink" title="4.1.Math.random()方法"></a>4.1.<code>Math.random()</code>方法</h3><ol>
<li>基本原理<ul>
<li><code>Math.random()</code>是<code>java.lang.Math</code>类中的一个静态方法，它会返回一个大于等于 0.0 且小于 1.0 的双精度随机浮点数。</li>
<li>每次调用<code>Math.random()</code>都会生成一个新的随机数。它的实现基于伪随机数生成器（Pseudo - Random Number Generator，简称 PRNG），在内部会维护一个种子值，通过特定的算法根据种子值生成随机数序列。</li>
</ul>
</li>
<li>使用方法<ul>
<li>例如，要生成一个 0 到 9 之间的随机整数，可以使用以下代码：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">randomNumber</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(Math.random() * <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>



<ul>
<li>这里首先<code>Math.random()</code>生成一个 0 到 1 之间的浮点数，然后乘以 10 得到一个 0 到 10 之间（不包含 10）的浮点数，最后通过强制类型转换<code>(int)</code>将其转换为整数，得到 0 到 9 之间的随机整数。</li>
<li>如果要生成一个指定范围内的随机整数，例如<code>min</code>到<code>max</code>（包含<code>min</code>和<code>max</code>），可以使用以下公式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">randomInRange</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(Math.random() * (max - min + <span class="hljs-number">1</span>)) + min;<br></code></pre></td></tr></table></figure>



<h3 id="4-2-java-util-Random类"><a href="#4-2-java-util-Random类" class="headerlink" title="4.2.java.util.Random类"></a>4.2.<code>java.util.Random</code>类</h3><ol>
<li>创建对象<ul>
<li>可以通过<code>new</code>关键字创建<code>Random</code>类的实例，例如：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-comment">// 使用random对象生成随机数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li><code>Random</code>类也有一个可以传入种子值的构造函数，例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">seededRandom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">12345</span>);<br></code></pre></td></tr></table></figure>



<ul>
<li>当使用相同的种子值创建<code>Random</code>对象时，它们会生成相同的随机数序列，这在需要重现随机数序列的场景中很有用。</li>
</ul>
<ol>
<li>常用方法<ul>
<li><code>nextInt()</code>方法<ul>
<li>该方法有两种形式：<ul>
<li>无参数形式：<code>nextInt()</code>会返回一个随机的整数，其范围是整个整数范围（负无穷到正无穷，但实际上受限于<code>int</code>类型的范围）。例如：</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">randomInt</span> <span class="hljs-operator">=</span> random.nextInt();<br></code></pre></td></tr></table></figure>



<ul>
<li>有参数形式：<code>nextInt(int n)</code>会返回一个大于等于 0 且小于<code>n</code>的随机整数。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">randomInRange</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-number">10</span>); <span class="hljs-comment">// 生成0到9之间的随机整数</span><br></code></pre></td></tr></table></figure>



<ul>
<li><code>nextDouble()</code>方法<ul>
<li>它返回一个大于等于 0.0 且小于 1.0 的随机双精度浮点数，与<code>Math.random()</code>类似，但使用<code>Random</code>类可以更方便地结合其他随机数生成方法使用。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-type">double</span> <span class="hljs-variable">randomDouble</span> <span class="hljs-operator">=</span> random.nextDouble();<br></code></pre></td></tr></table></figure>



<ul>
<li><code>nextBoolean()</code>方法<ul>
<li>用于生成一个随机的布尔值（<code>true</code>或<code>false</code>）。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-type">boolean</span> <span class="hljs-variable">randomBoolean</span> <span class="hljs-operator">=</span> random.nextBoolean();<br></code></pre></td></tr></table></figure>



<h3 id="4-3-java-security-SecureRandom类"><a href="#4-3-java-security-SecureRandom类" class="headerlink" title="4.3. java.security.SecureRandom类"></a>4.3. <code>java.security.SecureRandom</code>类</h3><ol>
<li>安全性特点<ul>
<li><code>SecureRandom</code>类用于生成安全的随机数，适用于加密、安全协议等对随机数质量要求较高的场景。它基于更复杂的随机源（如操作系统的随机事件）来生成随机数，相比<code>Math.random()</code>和<code>Random</code>类，具有更高的随机性和不可预测性。</li>
</ul>
</li>
<li>使用方法<ul>
<li>与<code>Random</code>类类似，也可以通过<code>new</code>关键字创建<code>SecureRandom</code>类的实例，例如：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.security.SecureRandom;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecureRandomExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SecureRandom</span> <span class="hljs-variable">secureRandom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecureRandom</span>();<br>        <span class="hljs-comment">// 使用secureRandom对象生成安全随机数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li><pre><code class="hljs">SecureRandom
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>  类也有一些方法用于生成不同类型的随机数，例如：<br><br>  - `nextInt()`方法<br>    - 与`Random`类的`nextInt`方法类似，例如：<br><br>```java<br>         SecureRandom secureRandom = <span class="hljs-keyword">new</span> SecureRandom()<span class="hljs-comment">;</span><br>         int secureRandomInt = secureRandom.nextInt(<span class="hljs-number">10</span>)<span class="hljs-comment">; // 生成0到9之间的安全随机整数</span><br></code></pre></td></tr></table></figure>

</code></pre>
</li>
<li><p><code>nextBytes(byte[] bytes)</code>方法</p>
<ul>
<li>用于填充一个字节数组，使其包含随机字节数据。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] randomBytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">16</span>];<br><span class="hljs-type">SecureRandom</span> <span class="hljs-variable">secureRandom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecureRandom</span>();<br>secureRandom.nextBytes(randomBytes);<br></code></pre></td></tr></table></figure>



<ul>
<li>这种生成随机字节数组的功能在加密算法（如生成密钥、初始化向量等）中非常有用。</li>
</ul>
<h2 id="5-流程控制（复习）"><a href="#5-流程控制（复习）" class="headerlink" title="5.流程控制（复习）"></a>5.流程控制（复习）</h2><h3 id="5-1-分支的嵌套使用"><a href="#5-1-分支的嵌套使用" class="headerlink" title="5.1.分支的嵌套使用"></a>5.1.分支的嵌套使用</h3><p>会员积分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String [] args)</span>&#123;<br><span class="hljs-comment">//会员积分</span><br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.print(<span class="hljs-string">&quot;请输入会员积分：&quot;</span>);<br><span class="hljs-comment">//int score=sc.nextInt();//输入浮点型、负数、字符会报错，使用hasNextInt()来防止错误输入</span><br>        <span class="hljs-keyword">if</span>(sc.hasNextDouble()) &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> sc.nextDouble();<br>            <span class="hljs-keyword">if</span>(score&gt;=<span class="hljs-number">8000</span>) System.out.println(<span class="hljs-string">&quot;会员六折&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(score&gt;=<span class="hljs-number">4000</span>) System.out.println(<span class="hljs-string">&quot;会员七折&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(score&gt;=<span class="hljs-number">2000</span>) System.out.println(<span class="hljs-string">&quot;会员八折&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(score&gt;=<span class="hljs-number">0</span>) System.out.println(<span class="hljs-string">&quot;会员九折&quot;</span>);<br>            <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;无折扣&quot;</span>);<br>            <br>        &#125;<br>        <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;输入错误&quot;</span>);<br><span class="hljs-comment">//**if判断失败进入下一个else；**</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>小朋友搬桌子：年龄大于7，可以搬</p>
<p>大于5岁，性别是男，可以搬</p>
<p>否则不可搬</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入年龄：&quot;</span>);<br>        <span class="hljs-type">int</span> age=sc.nextInt();<br>        <span class="hljs-keyword">if</span>(age&gt;=<span class="hljs-number">7</span>) System.out.println(<span class="hljs-string">&quot;可以搬&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(age&gt;=<span class="hljs-number">5</span>)&#123;<br>    System.out.println(<span class="hljs-string">&quot;请输入性别&quot;</span>);<br>            String sex=sc.next();<br>            <span class="hljs-type">char</span> s=sex.charAt(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(s==<span class="hljs-string">&#x27;男&#x27;</span>)System.out.println(<span class="hljs-string">&quot;可以搬&quot;</span>);<br>            <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;不能搬&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;不能搬&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//String类的charAt(n);方法用于获得字符串的单个字符</span><br></code></pre></td></tr></table></figure>

<p>根据学生分数判断等级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入学生成绩：&quot;</span>);<br>        <span class="hljs-keyword">if</span>(sc.hasNextInt())&#123;<br>            <span class="hljs-type">int</span> score=sc.nextInt();<br>            <span class="hljs-keyword">switch</span>(score/<span class="hljs-number">10</span>)&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>: <span class="hljs-comment">//System.out.println(&quot;A&quot;);break;</span><br>                <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: System.out.println(<span class="hljs-string">&quot;A&quot;</span>);<span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: System.out.println(<span class="hljs-string">&quot;B&quot;</span>);<span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: System.out.println(<span class="hljs-string">&quot;C&quot;</span>);<span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: System.out.println(<span class="hljs-string">&quot;D&quot;</span>);<span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:  System.out.println(<span class="hljs-string">&quot;E&quot;</span>);<span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-comment">// System.out.println(&quot;E&quot;);break;</span><br>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-comment">// System.out.println(&quot;E&quot;);break;</span><br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">// System.out.println(&quot;E&quot;);break;</span><br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">// System.out.println(&quot;E&quot;);break;</span><br>                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">// System.out.println(&quot;E&quot;);break;</span><br><br>                    defalut: System.out.println(<span class="hljs-string">&quot;无效成绩&quot;</span>);<br>            &#125;<br><br><br>        &#125;<span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;输入错误&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//case下的操作一样可以省略</span><br>模板：<br><span class="hljs-keyword">switch</span>(表达式)&#123;<br>    <span class="hljs-keyword">case</span> 值:操作;<span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 值:操作;<span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 值:操作;<span class="hljs-keyword">break</span>;<br>    ....<br>        defalut: 操作;<br>&#125;    <br></code></pre></td></tr></table></figure>



<h3 id="5-2循环"><a href="#5-2循环" class="headerlink" title="5.2循环"></a>5.2循环</h3><h4 id="5-2-1for"><a href="#5-2-1for" class="headerlink" title="5.2.1for"></a>5.2.1for</h4><ol>
<li>基本语法<ul>
<li>基本形式为<code>for(初始化表达式; 布尔表达式; 更新表达式) &#123;循环体&#125;</code>。</li>
<li>例如：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>这里初始化表达式<code>int i = 0</code>定义并初始化循环变量，布尔表达式<code>i &lt; 5</code>用于判断循环是否继续，更新表达式<code>i++</code>在每次循环后更新循环变量。</li>
</ul>
<ol start="2">
<li>增强 for 循环（foreach）</li>
</ol>
<ul>
<li>语法为<code>for(元素类型 元素变量 : 数组或集合) &#123;循环体&#125;</code>。</li>
<li>用于遍历数组或集合。例如，遍历数组：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> number : numbers) &#123;<br>    System.out.println(number);<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>这里<code>number</code>依次代表数组<code>numbers</code>中的每个元素。</li>
<li>遍历集合（以<code>ArrayList</code>为例）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br>ArrayList&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>names.add(<span class="hljs-string">&quot;Alice&quot;</span>);<br>names.add(<span class="hljs-string">&quot;Bob&quot;</span>);<br>names.add(<span class="hljs-string">&quot;Charlie&quot;</span>);<br><span class="hljs-keyword">for</span>(String name : names) &#123;<br>    System.out.println(name);<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="5-2-2-while-循环"><a href="#5-2-2-while-循环" class="headerlink" title="5.2.2.while 循环"></a>5.2.2.while 循环</h4><ol>
<li>基本语法<ul>
<li>语法为<code>while(布尔表达式) &#123;循环体&#125;</code>。</li>
<li>例如：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(j &lt; <span class="hljs-number">3</span>) &#123;<br>    System.out.println(j);<br>    j++;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>只要布尔表达式<code>j &lt; 3</code>为真，循环体就会执行，并且在循环体中通过<code>j++</code>更新循环变量。</li>
</ul>
<ol start="2">
<li>do - while 循环</li>
</ol>
<ul>
<li>语法为<code>do &#123;循环体&#125; while(布尔表达式);</code>。</li>
<li>与 while 循环不同的是，do - while 循环先执行一次循环体，再判断布尔表达式。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span> &#123;<br>    System.out.println(k);<br>    k++;<br>&#125; <span class="hljs-keyword">while</span>(k &lt; <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>



<ul>
<li>这里即使布尔表达式一开始不成立，循环体也会执行一次。</li>
</ul>
<h4 id="5-2-3-循环控制语句"><a href="#5-2-3-循环控制语句" class="headerlink" title="5.2.3.循环控制语句"></a>5.2.3.循环控制语句</h4><ol>
<li>break 语句<ul>
<li>用于跳出当前循环。</li>
<li>在 for 循环中的应用：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">5</span>) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>当<code>i</code>等于 5 时，执行<code>break</code>，循环立即结束，只会输出 0 到 4。</li>
<li>在 while 循环中的应用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span>(m == <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    System.out.println(m);<br>    m++;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>这里通过<code>while(true)</code>创建一个无限循环，但当<code>m</code>等于 3 时，<code>break</code>语句<code>跳出循环</code>。</li>
</ul>
<ol start="2">
<li>continue 语句</li>
</ol>
<ul>
<li>用于<code>跳过当前循环的剩余语句，直接进入下一次循环</code>。</li>
<li>在 for 循环中的应用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; n &lt; <span class="hljs-number">5</span>; n++) &#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    System.out.println(n);<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>当<code>n</code>等于 2 时，执行<code>continue</code>，跳过本次循环中<code>System.out.println(n);</code>这一语句，直接进入下一次循环，会输出 0、1、3、4。</li>
<li>在 while 循环中的应用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(p &lt; <span class="hljs-number">5</span>) &#123;<br>    p++;<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    System.out.println(p);<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>当<code>p</code>等于 3 时，执行<code>continue</code>，跳过本次循环的输出语句，会输出 1、2、4、5。</li>
</ul>
<ol start="3">
<li>return</li>
</ol>
<ul>
<li><code>直接结束程序</code></li>
</ul>
<h4 id="5-2-4-多重循环嵌套"><a href="#5-2-4-多重循环嵌套" class="headerlink" title="5.2.4.多重循环嵌套"></a>5.2.4.多重循环嵌套</h4><ol>
<li>乘法口诀</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<br>            <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">do</span>&#123;<br>                System.out.print(j+<span class="hljs-string">&quot;*&quot;</span>+i+<span class="hljs-string">&quot;=&quot;</span>+i*j+<span class="hljs-string">&quot;\t&quot;</span>);<br>                j++;<br>            &#125;<span class="hljs-keyword">while</span> (j&lt;=i);<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ol start="2">
<li>百钱买百鸡</li>
</ol>
<p>公鸡5文钱一只，母鸡3文钱一只，小鸡3只一文钱，用100文钱买一百只鸡，其中公鸡，母鸡，小鸡都必须要有，问公鸡，母鸡，小鸡要买多少只刚好凑足100文钱。</p>
<p>公鸡：x,</p>
<p>母鸡：y,</p>
<p>小鸡：z</p>
<p>x+y+z&#x3D;100;</p>
<p>5x+3y+z&#x2F;3&#x3D;100;</p>
<p><code>暴力</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;=<span class="hljs-number">100</span>;x++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=<span class="hljs-number">1</span>;y&lt;=<span class="hljs-number">100</span>;y++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> z=<span class="hljs-number">1</span>;z&lt;=<span class="hljs-number">100</span>;z++)&#123;<br><span class="hljs-keyword">if</span>((x+y+z==<span class="hljs-number">100</span>)&amp;&amp;(<span class="hljs-number">5</span>*x+<span class="hljs-number">3</span>*y+z/<span class="hljs-number">3</span>==<span class="hljs-number">100</span>)&amp;&amp;(z%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>))<br>System.out.println(x+<span class="hljs-string">&quot;\t&quot;</span>+y+<span class="hljs-string">&quot;\t&quot;</span>+z+<span class="hljs-string">&quot;\t&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><code>优化</code></p>
<p>循环的最的值考虑最多能买多少只；把z的循环去除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;=<span class="hljs-number">19</span>;x++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=<span class="hljs-number">1</span>;y&lt;=<span class="hljs-number">31</span>;y++)&#123;<br><span class="hljs-type">int</span> z=<span class="hljs-number">100</span>-x-y;<br><span class="hljs-keyword">if</span>((<span class="hljs-number">5</span>*x+<span class="hljs-number">3</span>*y+z/<span class="hljs-number">3</span>==<span class="hljs-number">100</span>)&amp;&amp;(z%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>))<br>System.out.println(x+<span class="hljs-string">&quot;\t&quot;</span>+y+<span class="hljs-string">&quot;\t&quot;</span>+z+<span class="hljs-string">&quot;\t&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>







<h2 id="6-方法、数组"><a href="#6-方法、数组" class="headerlink" title="6.方法、数组"></a>6.方法、数组</h2><h3 id="6-1-方法"><a href="#6-1-方法" class="headerlink" title="6.1.方法"></a>6.1.方法</h3><ul>
<li>和c\c++中的函数性质一样</li>
</ul>
<ol>
<li>面试题：两个数是否交换成功</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b=<span class="hljs-number">20</span>;<br>System.out.println(<span class="hljs-string">&quot;输出交换前的两个数：&quot;</span>+a+<span class="hljs-string">&quot;---&quot;</span>+b);<br>changeNum(a,b);<br>System.out.println(<span class="hljs-string">&quot;输出交换后的两个数：&quot;</span>+a+<span class="hljs-string">&quot;---&quot;</span>+b);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num1,<span class="hljs-type">int</span> num2)</span>&#123;<br><span class="hljs-type">int</span> t;<br>t=num1;<br>num1=num2;<br>num2=t;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>答案：不一样，<code>Java中一切都是值传递</code>，交换的只是形参。</p>
</blockquote>
<ol start="2">
<li><code>方法重载Overload</code></li>
</ol>
<p>定义：</p>
<ul>
<li>在同一个类中，方法签名（Method Signature）不同,即方法名相同，形参列表不同，构成了方法的重载</li>
<li>方法的重载只和方法的<code>形参列表</code>和<code>方法名</code>有关，与<code>修饰符</code>，<code>返回值类型</code>无关</li>
</ul>
<ol start="3">
<li><code>方法重写Override</code></li>
</ol>
<p>定义：</p>
<ul>
<li>在子类中对于父类方法的重写，方法签名（Method Signature）相同，即修饰符，返回值类型，方法名，形参列表都相同，构成了方法的重写。</li>
</ul>
<ol start="4">
<li><code>静态绑定和动态绑定</code></li>
</ol>
<ul>
<li>静态绑定（编译时绑定）：</li>
<li><ul>
<li>编译代码时就确定调用的方法</li>
<li>常见于重载的方法，private，static，final修饰的方法以及构造方法默认静态绑定</li>
</ul>
</li>
<li>动态绑定（运行时绑定）：</li>
<li><ul>
<li>运行中才能确定调用的是哪个方法</li>
<li>常见于重写的方法，private，static，final修饰的方法以及构造方法以外的方法。</li>
</ul>
</li>
</ul>
<h3 id="6-2-数组"><a href="#6-2-数组" class="headerlink" title="6.2.数组"></a>6.2.数组</h3><ul>
<li><code>java中的数组以对象形象存储在堆区，对象的引用存储在栈区。</code></li>
</ul>
<h4 id="6-2-1数组的初始化以及常用操作"><a href="#6-2-1数组的初始化以及常用操作" class="headerlink" title="6.2.1数组的初始化以及常用操作"></a>6.2.1数组的初始化以及常用操作</h4><ol>
<li>声明数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr;<br><span class="hljs-type">int</span> arr2[];<br><span class="hljs-type">int</span>[] arr3=<span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>如果数组只声明，没有后续操作相当于没定义。</p>
<p>在反编译代码中没有相应操作</p>
<p>辨别：数组赋值为null和什么都没有赋值 不一样</p>
</blockquote>
<ol start="2">
<li>创建</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">arr =<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<span class="hljs-comment">//给数组开辟了一个长度为4的空间</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>编译期声明和创建会被合为一句话</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>[] arr=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">4</span>];<br><span class="hljs-comment">//java;java中的数组是对象，在创建时会自动初始化为默认值；Java有自动垃圾回收机制（Garbage Collection，GC），程序员不需要显示的释放内存。有严格的边界检查机制，越界访问时会抛出异常</span><br><br><span class="hljs-type">int</span>* arr=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">4</span>]; <br><span class="hljs-keyword">delete</span>[] arr;<br><span class="hljs-comment">//c++ new会调用相应的构造函数来初始化对象；使用完后需要程序员使用delete[]来释放内存。没有数组边界检查机制，越界访问会使程序崩溃或产生未定义行为</span><br><br><span class="hljs-type">int</span> n=<span class="hljs-number">4</span>;<br><span class="hljs-type">int</span>* arr=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(n*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-built_in">free</span>(arr);<br><span class="hljs-comment">//malloc分配的内存是未初始化的，使用之前需要自行初始化。使用后需要程序员使用free（）来释放内存。没有数组边界检查机制，越界访问会使程序崩溃或产生未定义行为</span><br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>在c&#x2F;c++&#x2F;java中分配的内存都在堆区</p>
</blockquote>
<ol start="3">
<li>使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">arr[<span class="hljs-number">0</span>]=<span class="hljs-number">12</span>;<br>arr[<span class="hljs-number">1</span>]=<span class="hljs-number">47</span>;<br>...<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(arr[<span class="hljs-number">2</span>]);<br>System.out.println(arr[<span class="hljs-number">0</span>]+<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>通过数组一个属性来获取  length 长度</p>
</blockquote>
<p><code> arr.length</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;数组的长度使：&quot;</span>+arr.length);<br></code></pre></td></tr></table></figure>

<ol start="5">
<li><p>数组的三种初始化</p>
<ul>
<li>静态初始化&#x2F;&#x2F;直接赋值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr=&#123;<span class="hljs-number">12</span>,<span class="hljs-number">23</span>,<span class="hljs-number">45</span>&#125;;<br><span class="hljs-type">int</span>[] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">12</span>,<span class="hljs-number">23</span>,<span class="hljs-number">45</span>&#125;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ol>
<li><pre><code class="java">int[] arr=new int[3]&#123;12,23,45&#125;;---》;错误
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><br><span class="hljs-attribute">2</span>. ~~~Java<br>   <span class="hljs-attribute">int</span>[] arr;<br>   <span class="hljs-attribute">arr</span>=&#123;<span class="hljs-number">12</span>,<span class="hljs-number">23</span>,<span class="hljs-number">34</span>&#125;;---&gt;错误<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</blockquote>
<ul>
<li>动态初始化&#x2F;&#x2F;定义和赋值分开</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr;<br>arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<span class="hljs-comment">//int[] arr=new int[3];</span><br>arr[<span class="hljs-number">0</span>]=<span class="hljs-number">12</span>;<br>arr[<span class="hljs-number">1</span>]=<span class="hljs-number">23</span>;<br>arr[<span class="hljs-number">2</span>]=<span class="hljs-number">45</span>;<br></code></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>默认初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span>[] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<span class="hljs-comment">//每个里面都是0</span><br>Boolean[] b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>[<span class="hljs-number">3</span>];<span class="hljs-comment">//每个里面都是false</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code> 最值问题</code>&#x2F;&#x2F;选择排序&#x2F;&#x2F;冒泡排序&#x2F;&#x2F;<code> 数组的复制</code></p>
</li>
</ol>
<ul>
<li><p>给定一个数组求数组的最大值并且排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span>[] arr=&#123;<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">125</span>,<span class="hljs-number">9</span>,<span class="hljs-number">45</span>&#125;;<br>        <span class="hljs-type">int</span> maxNum=arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span>[] arr1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>        <span class="hljs-type">int</span>[] arr2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>        System.arraycopy(arr,<span class="hljs-number">0</span>,arr1,<span class="hljs-number">0</span>,arr.length);<br>        System.arraycopy(arr,<span class="hljs-number">0</span>,arr2,<span class="hljs-number">0</span>,arr.length);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:arr)<span class="hljs-comment">//找出最大值</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(x&gt;maxNum)<br>                maxNum=x;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;最大值：&quot;</span>+maxNum);<br><br>        <span class="hljs-type">int</span> temp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr1.length-<span class="hljs-number">1</span>;i++)<span class="hljs-comment">//冒泡排序，从大到小</span><br>        &#123;<span class="hljs-comment">//遍历数组，比当前大就互换</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;arr1.length;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(arr1[i]&lt;arr1[j]) &#123;<br>                    temp=arr1[i];<br>                    arr1[i]=arr1[j];<br>                    arr1[j]=temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.printf(<span class="hljs-string">&quot;从大到小：&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:arr1)<br>            System.out.print(x+<span class="hljs-string">&quot;\t&quot;</span>);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr2.length-<span class="hljs-number">1</span>;i++)&#123;<span class="hljs-comment">//从小到大；</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;arr2.length;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(arr2[i]&gt;arr2[j])&#123;<br>                    temp=arr2[i];<br>                    arr2[i]=arr2[j];<br>                    arr2[j]=temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.printf(<span class="hljs-string">&quot;\n从小到大：&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y:arr2)<br>            System.out.print(y+<span class="hljs-string">&quot;\t&quot;</span>);<br>        System.out.printf(<span class="hljs-string">&quot;\n原数组：&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> z:arr)<br>            System.out.print(z+<span class="hljs-string">&quot;\t&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//冒泡排序</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length-<span class="hljs-number">1</span>;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;arr.length-<span class="hljs-number">1</span>-i;j++)&#123;<br><span class="hljs-type">int</span> temp;<br><span class="hljs-keyword">if</span>(arr[j]&gt;arr[j+<span class="hljs-number">1</span>])&#123;<br>temp=arr[j+<span class="hljs-number">1</span>];<br>arr[j+<span class="hljs-number">1</span>]=arr[j];<br>arr[j]=temp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><img src="/.com//image-20241023144932770.png" srcset="/img/loading.gif" lazyload alt="image-20241023144932770"></p>
</li>
</ul>
<blockquote>
<p>注意点：-</p>
<ul>
<li>选择排序的边界问题</li>
<li>选择排序- 第一个先和后面所有的比，完全确定第一个，再第二个和后面所有的比较，依次往后走一个开始。</li>
</ul>
<blockquote>
<p>两个指针参数i，j,一个【0，length-1）；一个【1，length）</p>
</blockquote>
<p>注：j&#x3D;(i+1)</p>
<p><img src="/.com//image-20241023150558249.png" srcset="/img/loading.gif" lazyload alt="image-20241023150558249"></p>
<ul>
<li><p>冒泡排序的边界问题</p>
</li>
<li><p>从第一个开始每次相邻两个比较，比较一轮可以确定最后一个，依次往后每次从头开始。</p>
<p><img src="/.com//image-20250222173943751.png" srcset="/img/loading.gif" lazyload alt="image-20250222173943751"></p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>复制数组的方式</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span>[] arr1=arr;<br><span class="hljs-type">int</span>[] arr2=arr;<span class="hljs-comment">//这种复制方式只是让arr1和arr2指向了与arr相同的数组对象</span><br></code></pre></td></tr></table></figure>

<p>这种方式属于<code> arr对象的引用</code>，在Java中数组是对象</p>
<p>想要不改变原数组并且独立的对数组进行不同排序应该使用<code> System.arraycopy(sourceArray,sourcepos,destinationArray,destinationpos,length)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br><span class="hljs-type">int</span>[] arr2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>System.arraycopy(arr,<span class="hljs-number">0</span>,arr1,<span class="hljs-number">0</span>,length);<br>System.arraycopy(arr,<span class="hljs-number">0</span>,arr1,<span class="hljs-number">0</span>,length);<br></code></pre></td></tr></table></figure>

<p>System.arraycopy是一个本地方法，直接在内存层面进行数据复制，效率比普通的循环遍历复制效率高</p>
</blockquote>
</blockquote>
<h4 id="6-2-2数组-详述-main方法"><a href="#6-2-2数组-详述-main方法" class="headerlink" title="6.2.2数组_详述 main方法"></a>6.2.2数组_详述<code> main</code>方法</h4><ol>
<li>main方法：程序的入口，在同一个类中，如果有多个方法，那么虚拟机就会识别main方法，从这个方法作为程序的入口</li>
<li>main方法格式严格要求：</li>
</ol>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>public static —&gt;修饰符  &#x2F;&#x2F;面对对象的知识</p>
<p>void —&gt;代表方法没有返回值</p>
<p>String[] args —&gt;形参—》不确定因素</p>
</blockquote>
<ol start="3">
<li>问题：程序中是否可以有其它的方法也叫main方法？</li>
</ol>
<blockquote>
<p>可以，构成了函数的重载</p>
<ul>
<li><p>在 Java 中，一个类中只能有一个<code>public static void main(String[] args)</code>方法作为程序的入口点。</p>
</li>
<li><p>如果在一个类中定义了多个<code>main</code>方法，并且其中只有一个是<code>public static void main(String[] args)</code>这种形式，那么只有这个符合规定的<code>main</code>方法会被 Java 虚拟机（JVM）识别并作为程序启动的入口。</p>
</li>
<li><p><code> c/c++</code>中只能有一个<code> main</code>函数作为程序的入口，如果有多个链接器不知道哪个才是程序的入口。</p>
</li>
</ul>
</blockquote>
<ol start="4">
<li>String[] args实参到底是什么</li>
</ol>
<blockquote>
<p>可以手动传入实参，参数是String[],实参是 new String[0]  </p>
<p>默认情况下，虚拟机在调用main方法的时候就是传入了一个长度为0的数组</p>
</blockquote>
<h4 id="6-2-3数组-可变参数"><a href="#6-2-3数组-可变参数" class="headerlink" title="6.2.3数组__可变参数"></a>6.2.3数组__<code>可变参数</code></h4><ol>
<li>可变参数：作用提供了一个方法，参数的个数是可变的(jdk1.5之后的版本)</li>
</ol>
<blockquote>
<p>解决了部分方法重载的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    method01(<span class="hljs-number">10</span>);<br>    method01();<br>    method01(<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>);<br>    method01(<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>,<span class="hljs-number">60</span>,<span class="hljs-number">70</span>);<br>    method01(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>&#125;);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meyhod01</span><span class="hljs-params">(<span class="hljs-type">int</span>...num)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;---1&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<ol start="2">
<li>对于参数的处理</li>
</ol>
<blockquote>
<p>方法的内部对可变参数的处理跟数组是一样（内部隐式创建一个数组来存储这些参数）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method01</span><span class="hljs-params">(<span class="hljs-type">int</span>...num)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;---1&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:num)&#123;<br>System.out.println(i+<span class="hljs-string">&quot;\t&quot;</span>);<br>&#125;<br>System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>依次输出参数</p>
</blockquote>
<ol start="3">
<li>在可变参数的基础上再加一个参数</li>
</ol>
<blockquote>
<ul>
<li><p>可变参数一定要放在最后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method01</span><span class="hljs-params">(<span class="hljs-type">int</span> num2,<span class="hljs-type">int</span>...num)</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<ol start="4">
<li>可变参数不建议使用</li>
</ol>
<h2 id="7-面对对象"><a href="#7-面对对象" class="headerlink" title="7.面对对象"></a>7.面对对象</h2><blockquote>
<ul>
<li><p>万事万物皆对象</p>
</li>
<li><p>对象：具体的事物，实体</p>
</li>
<li><p>类：对对象向上抽取的部分，形成类，类是抽象的，一个模板</p>
</li>
<li><blockquote>
<p> 权限修饰符：private（本身类中）&lt;defalut(默认)同一个包&lt;protect（类中，子类中）&lt;public（全都可以）</p>
<p>java中私有属性不能被直接继承</p>
</blockquote>
</li>
<li><p>先有父类再有子类—》继承；先有子类再有父类—-》泛化</p>
</li>
<li><p>类是一个引用变量指向堆中的实例</p>
</li>
</ul>
</blockquote>
<h3 id="7-1、面向对象编程的基本概念"><a href="#7-1、面向对象编程的基本概念" class="headerlink" title="7.1、面向对象编程的基本概念"></a><strong>7.1、面向对象编程的基本概念</strong></h3><h4 id="7-1-1-类（Class）—》引用数据类型"><a href="#7-1-1-类（Class）—》引用数据类型" class="headerlink" title="7.1.1.类（Class）—》引用数据类型"></a>7.1.1.类（Class）—》引用数据类型</h4><ul>
<li>类是 Java 中面向对象编程的核心概念之一。它是一种模板或蓝图，用于定义对象的属性和行为。例如，我们可以定义一个<code>Car</code>类：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-comment">// 成员变量（属性）</span><br>    <span class="hljs-keyword">private</span> String color;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> speed;<br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(String color, <span class="hljs-type">int</span> speed)</span> &#123;<br>        <span class="hljs-built_in">this</span>.color = color;<br>        <span class="hljs-built_in">this</span>.speed = speed;<br>    &#125;<br>    <span class="hljs-comment">// 成员方法（行为）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The &quot;</span> + color + <span class="hljs-string">&quot; car is driving at &quot;</span> + speed + <span class="hljs-string">&quot; mph.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>在这个<code>Car</code>类中，<code>color</code>和<code>speed</code>是属性，<code>drive</code>是行为，而构造方法用于创建<code>Car</code>类的对象。</li>
</ul>
<h4 id="7-1-2-对象（Object）"><a href="#7-1-2-对象（Object）" class="headerlink" title="7.1.2.对象（Object）"></a>7.1.2.对象（Object）</h4><ul>
<li>对象是类的实例。通过使用类的构造方法，我们可以创建对象。例如，使用上面定义的<code>Car</code>类创建对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">myCar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-number">60</span>);<br>        myCar.drive();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>这里<code>myCar</code>就是<code>Car</code>类的一个对象，它具有<code>Car</code>类定义的属性和行为。</li>
</ul>
<h4 id="7-1-3-封装（Encapsulation）"><a href="#7-1-3-封装（Encapsulation）" class="headerlink" title="7.1.3.封装（Encapsulation）"></a>7.1.3.封装（Encapsulation）</h4><ul>
<li>封装是将数据（属性）和操作数据的方法（行为）捆绑在一起，并对数据的访问进行限制。在 Java 中，通常使用<code>private</code>关键字来限制属性的直接访问，然后通过公共的方法（getter 和 setter 方法）来访问和修改属性。例如，在<code>Car</code>类中：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-keyword">private</span> String color;<br>    <span class="hljs-comment">// 获取颜色的getter方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> color;<br>    &#125;<br>    <span class="hljs-comment">// 设置颜色的setter方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColor</span><span class="hljs-params">(String color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li><p>这样可以隐藏内部数据的实现细节，提高代码的安全性和可维护性。</p>
</li>
<li><blockquote>
<p>高内聚：类的内部数据操作细节自己完成，不允许外部干涉；</p>
<ul>
<li>低耦合：仅对外部暴露少量的方法用于使用</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="7-1-4-继承（Inheritance）"><a href="#7-1-4-继承（Inheritance）" class="headerlink" title="7.1.4.继承（Inheritance）"></a>7.1.4.继承（Inheritance）</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-type">Java</span>：<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>  <span class="hljs-keyword">extends</span>   <span class="hljs-title">A</span> </span>&#123;&#125;<br><span class="hljs-meta">@override</span><br>public void method（）&#123;&#125;<br><br>c++：<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-title">：public</span> <span class="hljs-title">A</span></span>&#123;&#125;<br>void method() <span class="hljs-keyword">override</span> &#123;&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>java中：</code></p>
<ul>
<li>继承允许一个类（子类）继承另一个类（父类）的属性和行为。子类可以在父类的基础上添加新的属性和行为，或者重写父类的方法。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> wheels;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Vehicle</span><span class="hljs-params">(<span class="hljs-type">int</span> wheels)</span> &#123;<br>        <span class="hljs-built_in">this</span>.wheels = wheels;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The vehicle is moving.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-keyword">private</span> String brand;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(<span class="hljs-type">int</span> wheels, String brand)</span> &#123;<br>        <span class="hljs-built_in">super</span>(wheels);<br>        <span class="hljs-built_in">this</span>.brand = brand;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The car is moving.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>这里<code>Car</code>类继承自<code>Vehicle</code>类，它继承了<code>wheels</code>属性和<code>move</code>方法，并且可以添加自己的<code>brand</code>属性和重写<code>move</code>方法。</li>
</ul>
<p><code>protected</code>常用于在继承关系中，允许子类访问和扩展父类的部分功能。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentClass</span> &#123;<br>       <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> protectedVar;<br>       <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">protectedMethod</span><span class="hljs-params">()</span> &#123;<br>           protectedVar = <span class="hljs-number">20</span>;<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">package</span> anotherpackage;<br>   <span class="hljs-keyword">import</span> mypackage.ParentClass;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ParentClass</span> &#123;<br>       <span class="hljs-keyword">void</span> <span class="hljs-title function_">accessProtected</span><span class="hljs-params">()</span> &#123;<br>           <span class="hljs-comment">// 可以访问父类的protectedVar和protectedMethod</span><br>           protectedVar = <span class="hljs-number">30</span>;<br>           protectedMethod();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<blockquote>
<p><code> c++中：</code></p>
<ul>
<li>C++ 支持类的继承。例如，定义一个<code>Square</code>类继承自<code>Rectangle</code>类：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Rectangle &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Square</span>(<span class="hljs-type">int</span> side) : <span class="hljs-built_in">Rectangle</span>(side, side) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<ul>
<li>这里<code>Square</code>类继承了<code>Rectangle</code>类的属性和方法，并且在构造函数中通过调用父类的构造函数来初始化对象。</li>
<li>还可以重写父类的方法，例如重写<code>area</code>方法（如果有特殊需求）：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Rectangle &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Square</span>(<span class="hljs-type">int</span> side) : <span class="hljs-built_in">Rectangle</span>(side, side) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">getLength</span>();<br>        <span class="hljs-keyword">return</span> l * l;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="7-1-5-多态（Polymorphism）"><a href="#7-1-5-多态（Polymorphism）" class="headerlink" title="7.1.5.多态（Polymorphism）"></a>7.1.5.多态（Polymorphism）</h4><blockquote>
<p><code>java中：</code></p>
<ul>
<li>多态有两种主要形式：方法重载（Overloading）和方法重写（Overriding）。</li>
<li>方法重载是指在一个类中定义多个方法名相同但参数列表不同的方法。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>方法重写是指子类重写父类中定义的方法，如上面<code>Car</code>类重写<code>Vehicle</code>类的<code>move</code>方法。多态性使得程序可以根据对象的实际类型来调用相应的方法，增强了代码的灵活性和可扩展性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">animal</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shut</span><span class="hljs-params">()</span>&#123;&#125;;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">animal</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shut</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">animal</span>&#123;<br><span class="hljs-meta">@Override</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shut</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">girl</span> &#123;<br><span class="hljs-meta">@Override</span>    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">(class animal)</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>girl pp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">girl</span>();<br>cat c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">cat</span>();<br>dog d=<span class="hljs-keyword">new</span> <span class="hljs-title class_">dog</span>();<br>animal an=c;<br>pp.play(c);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>


</blockquote>
<blockquote>
<p><code> c++中：</code></p>
<ul>
<li>函数重载是 C++ 实现多态的一种方式。例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MathUtils</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<ul>
<li>另一种多态是通过虚函数实现的动态多态。定义一个基类<code>Shape</code>和派生类<code>Circle</code>和<code>Rectangle</code>：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> radius;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Circle</span>(<span class="hljs-type">int</span> r) : <span class="hljs-built_in">radius</span>(r) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span> * radius * radius;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-type">int</span> width;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rectangle</span>(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> w) : <span class="hljs-built_in">length</span>(l), <span class="hljs-built_in">width</span>(w) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> length * width;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<ul>
<li>这里<code>Shape</code>类中的<code>area</code>函数是虚函数，派生类<code>Circle</code>和<code>Rectangle</code>重写了<code>area</code>函数。当通过基类指针或引用调用<code>area</code>函数时，会根据对象的实际类型调用相应的函数，实现动态多态。</li>
</ul>
</blockquote>
<h4 id="7-1-6-局部变量和成员变量"><a href="#7-1-6-局部变量和成员变量" class="headerlink" title="7.1.6.局部变量和成员变量"></a>7.1.6.局部变量和成员变量</h4><ul>
<li>局部变量：方法体（函数）中定义的变量，类外定义的变量，需要手动初始化</li>
<li>成员变量：类中定义且方法体外的变量，可以由类的构造函数自动初始化</li>
<li>static静态成员变量：类中定义且方法体外的变量，可供类的所以实例使用</li>
</ul>
<h4 id="7-1-7-c-和Java中的静态成员变量之间的区别："><a href="#7-1-7-c-和Java中的静态成员变量之间的区别：" class="headerlink" title="7.1.7.c++和Java中的静态成员变量之间的区别："></a>7.1.7.c++和Java中的静态成员变量之间的区别：</h4><blockquote>
<p>在静态的方法里不能访问非静态的属性；在非静态的方法里都可以访问。</p>
</blockquote>
<h5 id="7-1-7-1-定义方式"><a href="#7-1-7-1-定义方式" class="headerlink" title="7.1.7.1.定义方式"></a>7.1.7.1.定义方式</h5><blockquote>
<ol>
<li>C++<ul>
<li>在 C++ 中，类的静态成员变量需要先在类中声明，然后在类外进行定义和初始化。例如：</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVar;<br>&#125;;<br><span class="hljs-type">int</span> MyClass::staticVar = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>



<ul>
<li>这里先在<code>MyClass</code>类中声明了<code>staticVar</code>这个静态成员变量，然后在类外通过<code>int MyClass::staticVar = 0;</code>进行定义和初始化。</li>
</ul>
<ol start="2">
<li>Java</li>
</ol>
<ul>
<li>在 Java 中，可以在声明静态成员变量时直接初始化，或者通过静态代码块初始化。例如：</li>
<li>直接初始化：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyJavaClass</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">staticVar</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>通过静态代码块初始化：&#x2F;&#x2F;在类加载的时候直接执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyJavaClass</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> staticVar;<br>    <span class="hljs-keyword">static</span> &#123;<br>        staticVar = <span class="hljs-number">20</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

</blockquote>
<h5 id="7-1-7-2内存分配和生命周期"><a href="#7-1-7-2内存分配和生命周期" class="headerlink" title="7.1.7.2内存分配和生命周期"></a>7.1.7.2内存分配和生命周期</h5><blockquote>
<ol>
<li>C++</li>
</ol>
<ul>
<li>静态成员变量在程序启动时分配内存，在整个程序运行期间都存在。它在内存中的存储位置与全局变量类似，在数据段。当类的第一个对象被创建之前，静态成员变量就已经存在了。</li>
<li>例如，当有多个<code>MyClass</code>对象时，它们共享同一个静态成员变量<code>staticVar</code>的存储空间。无论创建多少个<code>MyClass</code>对象，<code>staticVar</code>在内存中只有一份。</li>
</ul>
<ol start="2">
<li>Java</li>
</ol>
<ul>
<li>在 Java 中，静态成员变量在类加载时被分配内存。当类加载器将类加载到 JVM（Java Virtual Machine）中时，静态成员变量就会被初始化并占用内存空间。</li>
<li>其生命周期从类加载开始，直到类被卸载。只要类存在于 JVM 中，静态成员变量就一直存在。例如，对于<code>MyJavaClass</code>类，一旦<code>MyJavaClass</code>被加载，其静态变量<code>staticVar</code>就会存在，与是否创建<code>MyJavaClass</code>的对象无关。</li>
</ul>
</blockquote>
<h5 id="7-1-7-3访问方式"><a href="#7-1-7-3访问方式" class="headerlink" title="7.1.7.3访问方式"></a>7.1.7.3访问方式</h5><blockquote>
<p><code> 类名.静态变量/方法</code></p>
</blockquote>
<blockquote>
<ol>
<li>C++</li>
</ol>
<ul>
<li>在 C++ 中，可以通过类名直接访问静态成员变量，也可以通过类的对象来访问。例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MyClass obj;<br><span class="hljs-comment">// 通过类名访问</span><br>std::cout &lt;&lt; MyClass::staticVar &lt;&lt; std::endl;<br><span class="hljs-comment">// 通过对象访问</span><br>std::cout &lt;&lt; obj.staticVar &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>



<ul>
<li>不过，通过类名访问是更符合规范的方式。</li>
</ul>
<ol>
<li>Java</li>
</ol>
<ul>
<li>在 Java 中，同样可以通过类名直接访问静态成员变量。通过对象访问静态成员变量在语法上是允许的，但不被推荐，因为这容易让人误解静态成员变量与对象相关。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyJavaClass</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">staticVar</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 通过类名访问</span><br>        System.out.println(MyJavaClass.staticVar);<br>    &#125;<br>        <span class="hljs-type">MyJavaClass</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyJavaClass</span>();<br>        <span class="hljs-comment">// 通过对象访问（不推荐）</span><br>        System.out.println(obj.staticVar);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



</blockquote>
<h5 id="7-1-7-4继承中的表现"><a href="#7-1-7-4继承中的表现" class="headerlink" title="7.1.7.4继承中的表现"></a>7.1.7.4继承中的表现</h5><blockquote>
<ol>
<li>C++</li>
</ol>
<ul>
<li>在 C++ 中，子类可以继承父类的静态成员变量。如果子类重新定义了父类的同名静态成员变量，那么子类的静态成员变量会隐藏父类的同名静态成员变量。</li>
<li>例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVar;<br>&#125;;<br><span class="hljs-type">int</span> Parent::staticVar = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> : <span class="hljs-keyword">public</span> Parent &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVar;<br>&#125;;<br><span class="hljs-type">int</span> Child::staticVar = <span class="hljs-number">2</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 访问父类的静态成员变量</span><br>    std::cout &lt;&lt; Parent::staticVar &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 访问子类的静态成员变量</span><br>    std::cout &lt;&lt; Child::staticVar &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>在这个例子中，<code>Child</code>类中的<code>staticVar</code>隐藏了<code>Parent</code>类中的<code>staticVar</code>。</li>
</ul>
<ol>
<li>Java</li>
</ol>
<ul>
<li>在 Java 中，子类也可以继承父类的静态成员变量。但是，由于静态成员变量属于类本身，所以通过子类访问父类的静态成员变量时，不存在多态性。</li>
<li>例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentClass</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">staticVar</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ParentClass</span> &#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 通过父类访问静态成员变量</span><br>        System.out.println(ParentClass.staticVar);<br>        <span class="hljs-comment">// 通过子类访问静态成员变量</span><br>        System.out.println(ChildClass.staticVar);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li><p>这里<code>ChildClass</code>继承了<code>ParentClass</code>的静态成员变量<code>staticVar</code>，通过<code>ChildClass</code>和<code>ParentClass</code>访问到的是同一个变量。</p>
</li>
<li><p><strong>子类无法重写父类的静态方法：</strong></p>
</li>
<li><p><strong>重写（Override）</strong>：重写是针对实例方法而言的，它是实现多态性的一种方式。当子类重写父类的实例方法时，通过父类引用指向子类对象，调用该方法时会执行子类重写后的方法。重写遵循 “运行时绑定”，即根据实际对象的类型来决定调用哪个方法。</p>
</li>
<li><p><strong>隐藏（Hide）</strong>：对于静态方法，由于静态方法属于类本身，而不属于类的实例，子类可以定义与父类相同名称、参数列表和返回类型的静态方法，这被称为静态方法的隐藏。静态方法的调用遵循 “编译时绑定”，即根据引用变量的类型来决定调用哪个方法</p>
</li>
</ul>
</blockquote>
<h3 id="7-2-static代码块"><a href="#7-2-static代码块" class="headerlink" title="7.2.static代码块"></a>7.2.static代码块</h3><ul>
<li><p>代码块执行顺序：</p>
</li>
<li><blockquote>
<p>静态块:在类加载的时候执行一次，用于一些全局性的初始化操作</p>
<ul>
<li>构造块</li>
<li>构造器</li>
<li>普通块</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><span class="hljs-comment">//属性</span><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> sa;<br>    <span class="hljs-comment">//方法</span><br>    <span class="hljs-comment">//代码块</span><br>    <span class="hljs-comment">//构造器</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<span class="hljs-comment">//构造块</span><br>        <span class="hljs-built_in">this</span>.a=a;<br>    &#125;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.a);<span class="hljs-comment">//普通块</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(sa);<br>    &#125;<br>    <span class="hljs-comment">//静态块</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        sa=<span class="hljs-number">10</span>;<br>        System.out.println(sa);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-3-导包import"><a href="#7-3-导包import" class="headerlink" title="7.3.导包import"></a>7.3.导包import</h3><h4 id="7-3-1在-Java-中的包（package）和导入（import）"><a href="#7-3-1在-Java-中的包（package）和导入（import）" class="headerlink" title="7.3.1在 Java 中的包（package）和导入（import）"></a>7.3.1在 Java 中的包（package）和导入（import）</h4><blockquote>
<ul>
<li>包的创建：名字小写，中间用点隔开，不能用系统的关键字，对应目录路径</li>
<li>在Java中的导包没有包含和被包含的关系</li>
</ul>
</blockquote>
<ol>
<li>包（package）的概念与作用<ul>
<li>概念<ul>
<li>包是 Java 中用于组织类和接口的一种机制。它类似于文件系统中的文件夹，将相关的类和接口分组在一起。例如，<code>java.util</code>就是一个包，它包含了许多实用工具类，如<code>ArrayList</code>、<code>HashMap</code>等。</li>
</ul>
</li>
<li>作用<ul>
<li><strong>解决命名冲突</strong>：在大型项目中，不同的开发人员可能会创建同名的类。通过将类放在不同的包中，可以避免这种命名冲突。例如，公司 A 和公司 B 可能都有一个名为<code>Employee</code>的类，但如果公司 A 将其类放在<code>com.companyA</code>包中，公司 B 将其类放在<code>com.companyB</code>包中，就不会产生冲突。</li>
<li><strong>管理代码结构</strong>：有助于更好地组织和管理代码。例如，与图形相关的类可以放在<code>com.graphics</code>包中，与数据库操作相关的类可以放在<code>com.database</code>包中，使项目的代码结构更加清晰。</li>
</ul>
</li>
</ul>
</li>
<li>包的定义与使用<ul>
<li>定义包<ul>
<li>在 Java 源文件的开头使用<code>package</code>关键字来定义包。例如：</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.myproject;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-comment">// 类的内容</span><br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>上述代码将<code>MyClass</code>类放在了<code>com.example.myproject</code>包中。源文件所在的目录结构应该与包名的层次结构相对应，即上述类文件应该放在<code>com/example/myproject</code>目录下（在实际的文件系统中，目录用<code>/</code>分隔）。</li>
<li>访问包中的类<ul>
<li>要在其他类中访问另一个包中的类，有以下几种方式：</li>
<li><strong>使用全限定名</strong>：例如，如果要在<code>com.anotherpackage</code>包中的类中使用<code>com.example.myproject.MyClass</code>，可以这样写：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.anotherpackage;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnotherClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        com.example.myproject.<span class="hljs-type">MyClass</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">com</span>.example.myproject.MyClass();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>这种方式比较繁琐，但在没有导入包的情况下是可行的。</li>
</ul>
<ol start="3">
<li>导入（import）语句</li>
</ol>
<ul>
<li>作用<ul>
<li>为了避免每次使用其他包中的类时都要写全限定名，Java 提供了<code>import</code>语句来导入包中的类。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.anotherpackage;<br><span class="hljs-keyword">import</span> com.example.myproject.MyClass;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnotherClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>通过<code>import</code>语句，就可以直接使用<code>MyClass</code>类名，而不需要写全限定名。</li>
<li>通配符导入（*）<ul>
<li>除了导入单个类，还可以使用通配符<code>*</code>来导入一个包中的所有类。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>这将导入<code>java.util</code>包中的所有类。不过需要注意的是，这种导入方式并不会提高程序的运行效率，只是在编写代码时更加方便，但可能会导致命名冲突（如果导入的多个包中有同名类），所以在实际使用中要谨慎。</p>
</li>
<li><p>静态导入：<code> static</code>搭配通配符可以导入类中的所有的静态内容</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.*;<br></code></pre></td></tr></table></figure>

<ul>
<li>在静态导入以后同一个类中有相同的方法时会优先走自己定义的方法。</li>
</ul>
<h4 id="7-3-2-在-C-中的命名空间（namespace）类似概念"><a href="#7-3-2-在-C-中的命名空间（namespace）类似概念" class="headerlink" title="7.3.2.在 C++ 中的命名空间（namespace）类似概念"></a>7.3.2.在 C++ 中的命名空间（namespace）类似概念</h4><ol>
<li>命名空间（namespace）的概念与作用<ul>
<li>概念<ul>
<li>命名空间是 C++ 中用于避免命名冲突的一种机制。它将相关的类型、函数、变量等封装在一个命名空间内。例如：</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> mynamespace &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>        <span class="hljs-comment">// 类的内容</span><br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 函数内容</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>作用<ul>
<li>与 Java 中的包类似，主要用于解决命名冲突问题。在 C++ 库和大型项目中，不同的模块可能会定义相同名字的函数或类型，通过命名空间可以将它们区分开来。例如，<code>std</code>是 C++ 标准库的命名空间，其中包含了<code>cout</code>、<code>vector</code>等众多标准类型和函数。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>命名空间的使用</li>
</ol>
<ul>
<li>访问命名空间中的成员<ul>
<li>有以下几种方式访问命名空间中的成员：</li>
<li><strong>使用全限定名（::）</strong>：例如：</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    mynamespace::MyClass obj;<br>    mynamespace::<span class="hljs-built_in">myFunction</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>这种方式每次都要写出命名空间名和作用域解析运算符<code>::</code>，比较麻烦。</li>
<li><strong>使用<code>using</code>声明</strong>：例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> mynamespace::MyClass;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    mynamespace::<span class="hljs-built_in">myFunction</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>通过<code>using</code>声明，可以在当前作用域内直接使用<code>MyClass</code>，而不需要写出命名空间名，但对于<code>myFunction</code>，如果要使用，还是需要写出命名空间名，除非也对<code>myFunction</code>进行<code>using</code>声明。</li>
<li><strong>使用<code>using namespace</code>指令（不推荐在头文件中使用）</strong>：例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> mynamespace;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    <span class="hljs-built_in">myFunction</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>这种方式将命名空间中的所有成员都引入到当前作用域，使用起来最方便，但可能会导致命名冲突。如果在头文件中使用<code>using namespace</code>指令，可能会在包含该头文件的多个源文件中产生意外的命名冲突，所以在头文件中一般不建议使用这种方式。</li>
</ul>
<h3 id="7-4-super修饰符"><a href="#7-4-super修饰符" class="headerlink" title="7.4.super修饰符"></a>7.4.super修饰符</h3><h4 id="7-4-1调用父类的构造方法"><a href="#7-4-1调用父类的构造方法" class="headerlink" title="7.4.1调用父类的构造方法"></a>7.4.1调用父类的构造方法</h4><ul>
<li>当子类的构造方法需要调用父类的构造方法时，可以使用super（).</li>
<li>如果父类有默认构造方法（无参构造方法），在子类构造方法中不写super（）时，编译器会自动添加一个super（）调用。</li>
<li>例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Parent</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;parent constructor&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Child</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//编译器会自动添加super（）</span><br>System.out.println(<span class="hljs-string">&quot;Child constructor&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>但如果父类没有默认构造方法，子类构造方法必须显示的调用父类的某个构造方法，此时就要有super（参数列表）。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Parent</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Parent constructor with value:&quot;</span>+value);<br><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Child</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">super</span>(<span class="hljs-number">10</span>);<br>System.out.println(<span class="hljs-string">&quot;Child constructor&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="7-4-2访问父类的成员（方法和变量）"><a href="#7-4-2访问父类的成员（方法和变量）" class="headerlink" title="7.4.2访问父类的成员（方法和变量）"></a>7.4.2访问父类的成员（方法和变量）</h4><ul>
<li><p>访问父类的方法</p>
<ul>
<li>当子类重写了父类的方法以后，如果子类想要调用父类被重写的方法，可以用<code> super.方法名（参数列表）。</code>例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>System.outprintln(<span class="hljs-string">&quot;Parent print method&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Child print method&quot;</span>);<br><span class="hljs-built_in">super</span>.print();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>




</li>
<li><p>在<code>Child</code>类的<code>print</code>方法中，先执行了自己的打印语句，然后通过<code>super.print()</code>调用了父类的<code>print</code>方法。</p>
</li>
</ul>
<h4 id="7-4-3访问父类的变量"><a href="#7-4-3访问父类的变量" class="headerlink" title="7.4.3访问父类的变量"></a>7.4.3访问父类的变量</h4><ul>
<li>类似地，当子类和父类有同名变量时，在子类中可以用<code>super.变量名</code>来访问父类的变量。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showValues</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Child value: &quot;</span> + <span class="hljs-built_in">this</span>.value);<br>        System.out.println(<span class="hljs-string">&quot;Parent value: &quot;</span> + <span class="hljs-built_in">super</span>.value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="7-5-Object类"><a href="#7-5-Object类" class="headerlink" title="7.5 Object类"></a>7.5 Object类</h3><ol>
<li>概述<ul>
<li>在 Java 中，<code>Object</code>类是所有类的根类。这意味着，所有的 Java 类都直接或间接地继承自<code>Object</code>类。它位于<code>java.lang</code>包中，无需显式导入。</li>
</ul>
</li>
<li>主要方法<ul>
<li><code>equals(Object obj)</code>方法<ul>
<li>该方法用于比较两个对象是否相等。在<code>Object</code>类中，<code>equals</code>方法默认的实现是比较两个对象的引用是否相同，即<code>==</code>操作。例如：</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">     <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>             <span class="hljs-type">Object</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>             <span class="hljs-type">Object</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>             System.out.println(obj1==obj2);<span class="hljs-comment">//一定是false，比较的是地址值</span><br>             System.out.println(obj1.equals(obj2)); <span class="hljs-comment">// 通常返回false，因为是不同对象的引用，比较的也是地址值</span><br>         &#125;<br>     &#125;<br>源码：<span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>&#123;<span class="hljs-comment">//比较地址</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>==obj;<br>&#125;<br><br>通常重写为比较两个类的属性是否相同<br>   <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>&#123;<br>    <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> xxx)&#123;<span class="hljs-comment">//判断obj是否是xxx的实例</span><br>        <span class="hljs-comment">//将obj转为同类型</span><br>    <span class="hljs-type">XXX</span> <span class="hljs-variable">other</span> <span class="hljs-operator">=</span>(XXX)obj;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.getXXX()==other.getXXX()&amp;&amp;...)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125;<br>   <br>&#125; <br></code></pre></td></tr></table></figure>



<ul>
<li>很多类会重写<code>equals</code>方法来实现基于对象内容的比较。例如，<code>String</code>类重写了<code>equals</code>方法，用于比较字符串的内容：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>System.out.println(str1.equals(str2)); <span class="hljs-comment">// 返回true，因为内容相同</span><br></code></pre></td></tr></table></figure>



<ul>
<li><code>hashCode()</code>方法<ul>
<li><code>hashCode</code>方法返回对象的哈希码值。哈希码在哈希表等数据结构中用于快速查找。在<code>Object</code>类中，<code>hashCode</code>方法返回的是对象的内部地址的某种转换值（通常与内存地址相关）。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>System.out.println(obj.hashCode());<br></code></pre></td></tr></table></figure>



<ul>
<li>当重写<code>equals</code>方法时，通常也需要重写<code>hashCode</code>方法，以保证相等的对象具有相同的哈希码。例如，在自定义类中：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClass</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass()!= o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">myClass</span> <span class="hljs-operator">=</span> (MyClass) o;<br>        <span class="hljs-keyword">return</span> value == myClass.value;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li><code>toString()</code>方法<ul>
<li><code>toString</code>方法返回对象的字符串表示。在<code>Object</code>类中，<code>toString</code>方法返回的是对象的类名加上哈希码的十六进制表示。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">     <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>     System.out.println(obj.toString());<br><span class="hljs-comment">//原理</span><br>getClass().getName()+<span class="hljs-string">&#x27;@&#x27;</span>+Integer.toHexString(hashCode())<span class="hljs-comment">//</span><br>    全限定路径：包名+类名的完整表示<br></code></pre></td></tr></table></figure>



<ul>
<li>很多类会重写<code>toString</code>方法来提供更有意义的字符串表示。例如，<code>Date</code>类重写了<code>toString</code>方法来返回日期的字符串形式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>System.out.println(date.toString());<br></code></pre></td></tr></table></figure>

<ul>
<li><p>可以在类中重写为介绍类的信息的方法。</p>
</li>
<li><p><code>getClass()</code>方法</p>
<ul>
<li>该方法返回对象的运行时类。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>System.out.println(obj.getClass()); <span class="hljs-comment">// 输出java.util.ArrayList</span><br></code></pre></td></tr></table></figure>

<ul>
<li>instanceof和（classA.getClass()&#x3D;&#x3D;classB.class）区别</li>
</ul>
<blockquote>
<p>instanceof是Java中的二元运算符，考虑继承和实现，左边为null时，返回false</p>
<p>A.getClass()&#x3D;&#x3D;B.class,通过比较Class对象来判断是非是同一个类的实例，不考虑实现和继承，左边为null时，报空指针异常。</p>
</blockquote>
<ul>
<li>这个方法在反射等机制中非常有用，可以用来获取对象所属的类的相关信息，如类名、方法、字段等。</li>
<li><code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>方法<ul>
<li>这些方法用于线程间的协作，实现线程的等待和唤醒机制。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Thread 1 is waiting&quot;</span>);<br>                    lock.wait();<br>                    System.out.println(<span class="hljs-string">&quot;Thread 1 is awakened&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Thread 2 is notifying&quot;</span>);<br>                lock.notify();<br>            &#125;<br>        &#125;);<br>        thread1.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>在这个例子中，<code>thread1</code>等待，<code>thread2</code>唤醒<code>thread1</code>。</li>
</ul>
<h3 id="7-6-向上（下）转型"><a href="#7-6-向上（下）转型" class="headerlink" title="7.6.向上（下）转型"></a>7.6.向上（下）转型</h3><ul>
<li>在 Java 中，向上转型（upcasting）和向下转型（downcasting）是与多态相关的重要概念。</li>
</ul>
<h4 id="7-6-1-向上转型"><a href="#7-6-1-向上转型" class="headerlink" title="7.6.1.向上转型"></a>7.6.1.向上转型</h4><blockquote>
<ul>
<li>定义和作用</li>
<li>向上转型是指将一个子类对象赋值给一个父类类型的引用。这是自动进行的，不需要显式的类型转换。 作用：实现多态性，使代码更加灵活和可维护。通过父类引用可以调用子类重写的方法，从而实现不同的行为。</li>
</ul>
</blockquote>
<p> 示例:</p>
<p> 考虑以下代码： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;      <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;             <br>System.out.println(<span class="hljs-string">&quot;Animal makes a sound&quot;</span>);  <br>&#125; <br>&#125;     <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123; <br><span class="hljs-meta">@Override</span>         <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;             <br>System.out.println(<span class="hljs-string">&quot;Meow&quot;</span>); <br>&#125;    <br>&#125; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;     <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;             <br><span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();             <br>animal.makeSound(); <span class="hljs-comment">// 输出 &quot;Meow&quot;    </span><br>&#125;   <br>&#125; <br></code></pre></td></tr></table></figure>

<ul>
<li>在这个例子中，将 Cat 类的对象赋值给 Animal 类型的变量 animal，这就是向上转型。此时，通过 animal 引用调用 makeSound() 方法，实际上调用的是 Cat 类中重写的方法。</li>
</ul>
<h4 id="7-6-2向下转型"><a href="#7-6-2向下转型" class="headerlink" title="7.6.2向下转型"></a>7.6.2向下转型</h4><blockquote>
<p>定义和作用:父类的引用类型无法调用子类特殊的方法得通过向下转型，变成子类引用后才能调用子类得特殊方法</p>
<ul>
<li>向下转型是指将一个父类对象的引用强制转换为一个子类类型的引用。这是显式的类型转换，需要小心进行，因为如果转换不正确可能会导致 ClassCastException。 作用：当需要访问子类特有的方法或属性时，可以进行向下转型。</li>
</ul>
</blockquote>
<p>示例 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;         <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;        <br>System.out.println(<span class="hljs-string">&quot;Animal makes a sound&quot;</span>);<br>&#125;     &#125;     <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;       <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scratch</span><span class="hljs-params">()</span> &#123;             <br>System.out.println(<span class="hljs-string">&quot;Cat is scratching&quot;</span>);         &#125;     <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;             <br><span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();             <br><span class="hljs-keyword">if</span> (animal <span class="hljs-keyword">instanceof</span> Cat) &#123;            <br><span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> (Cat) animal;               <br>cat.scratch(); <span class="hljs-comment">// 输出 &quot;Cat is scratching&quot;             </span><br>&#125;        <br>&#125;    <br>&#125; <br></code></pre></td></tr></table></figure>

<ul>
<li>在这个例子中，首先进行向上转型，将 Cat 对象赋值给 Animal 引用。然后，通过 instanceof 运算符检查 animal 是否是 Cat 类型的实例，如果是，进行向下转型，将 animal 强制转换为 Cat 类型的变量 cat，这样就可以调用 Cat 类特有的 scratch() 方法。 总之，向上转型和向下转型在 Java 编程中是非常有用的技术，但需要谨慎使用，特别是在进行向下转型时，要确保转换的正确性，以避免运行时错误。</li>
<li><code>编译看左边，运行看右边</code>：编译的时候如果用向上转型（父类对象指向子类的实例）调用方法必须是父类中有的，不然编译出错，运行的时候根据右边具体子类对应的重写的方法来执行。</li>
</ul>
<h2 id="8-抽象类-方法和内部类"><a href="#8-抽象类-方法和内部类" class="headerlink" title="8.抽象类_方法和内部类"></a>8.抽象类_方法和内部类</h2><h3 id="8-1-抽象类"><a href="#8-1-抽象类" class="headerlink" title="8.1.抽象类"></a><strong>8.1.抽象类</strong></h3><p>在 Java 中，抽象类和抽象方法是实现抽象概念和多态性的重要工具。</p>
<ol>
<li>定义和特点<ul>
<li>抽象类是使用 <code>abstract</code> 关键字修饰的类。它可以包含抽象方法和非抽象方法，也可以包含成员变量和构造方法。</li>
<li>抽象类不能被实例化，即<code>不能使用 new</code>关键字创建抽象类的对象。它的存在主要是为了被其他类继承，提供一个通用的模板或框架。</li>
</ul>
</li>
<li>作用<ul>
<li>抽象类可以作为其他类的基类，定义一些通用的属性和方法，供子类继承和实现。它可以强制子类实现某些特定的方法，确保代码的一致性和可维护性。</li>
<li>抽象类可以包含抽象方法，这些方法只有方法签名，没有具体的实现。子类必须实现这些抽象方法，否则子类也必须声明为抽象类。</li>
</ul>
</li>
</ol>
<p><strong>二、抽象方法</strong></p>
<ol>
<li>定义和特点<ul>
<li>抽象方法是使用 <code>abstract</code> 关键字修饰的方法，只有方法签名，没有方法体。例如：<code>public abstract void doSomething();</code>。</li>
<li>抽象方法必须在抽象类中声明。如果一个类包含抽象方法，那么这个类必须声明为抽象类。</li>
</ul>
</li>
<li>作用<ul>
<li>抽象方法定义了一种行为规范，子类必须实现这些方法来提供具体的行为。这使得代码更加灵活和可扩展，不同的子类可以根据自己的需求实现不同的行为。</li>
</ul>
</li>
</ol>
<p><strong>三、示例</strong></p>
<p>以下是一个使用抽象类和抽象方法的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-comment">// 成员变量</span><br>    <span class="hljs-keyword">private</span> String color;<br><br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Shape</span><span class="hljs-params">(String color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-comment">// 抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getArea</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 非抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printColor</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Color: &quot;</span> + color);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> radius;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(String color, <span class="hljs-type">double</span> radius)</span> &#123;<br>        <span class="hljs-built_in">super</span>(color);<br>        <span class="hljs-built_in">this</span>.radius = radius;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getArea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.PI * radius * radius;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> width;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> height;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Rectangle</span><span class="hljs-params">(String color, <span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height)</span> &#123;<br>        <span class="hljs-built_in">super</span>(color);<br>        <span class="hljs-built_in">this</span>.width = width;<br>        <span class="hljs-built_in">this</span>.height = height;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getArea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> width * height;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">circle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-string">&quot;Red&quot;</span>, <span class="hljs-number">5.0</span>);<br>        <span class="hljs-type">Shape</span> <span class="hljs-variable">rectangle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-string">&quot;Blue&quot;</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">6.0</span>);<br><br>        circle.printColor();<br>        System.out.println(<span class="hljs-string">&quot;Circle area: &quot;</span> + circle.getArea());<br><br>        rectangle.printColor();<br>        System.out.println(<span class="hljs-string">&quot;Rectangle area: &quot;</span> + rectangle.getArea());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>在这个示例中，<code>Shape</code> 是一个抽象类，它定义了一个抽象方法 <code>getArea()</code> 和一个非抽象方法 <code>printColor()</code>。<code>Circle</code> 和 <code>Rectangle</code> 类继承自 <code>Shape</code> 类，并实现了 <code>getArea()</code> 方法。通过这种方式，不同的形状类可以根据自己的特点实现计算面积的方法，同时共享通用的属性和方法。</p>
<p>总之，抽象类和抽象方法在 Java 编程中提供了一种强大的方式来实现代码的复用、多态性和可维护性。它们可以帮助开发者更好地组织和设计代码，提高代码的质量和可读性。</p>
<h3 id="8-2-内部类"><a href="#8-2-内部类" class="headerlink" title="8.2.内部类"></a>8.2.内部类</h3><p>在 Java 中，内部类是定义在另一个类内部的类。它可以访问外部类的成员，包括私有成员，并且可以实现更好的封装和代码组织。</p>
<p><strong>一、内部类的类型</strong></p>
<ol>
<li>成员内部类<ul>
<li>定义在外部类的成员位置，就像外部类的成员变量和成员方法一样。它可以访问外部类的所有成员，包括私有成员。</li>
<li>示例：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">outerVariable</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printOuterVariable</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Outer variable: &quot;</span> + outerVariable);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ol start="2">
<li>局部内部类</li>
</ol>
<ul>
<li>定义在外部类的方法内部，只能在该方法内部使用。局部内部类可以访问外部类的成员以及方法中的局部变量，但局部变量必须是 final 或 effectively final 的。</li>
<li>示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">outerMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">localVariable</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalInnerClass</span> &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLocalVariable</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Local variable: &quot;</span> + localVariable);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">LocalInnerClass</span> <span class="hljs-variable">localInner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalInnerClass</span>();<br>        localInner.printLocalVariable();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ol start="3">
<li>匿名内部类</li>
</ol>
<ul>
<li>没有名字的内部类，通常用于创建接口或抽象类的实现，或者继承一个类并重写其中的方法。它通常在需要一次性使用一个类的情况下使用。</li>
<li>示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">outerMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MyInterface</span> <span class="hljs-variable">myInterface</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterface</span>() &#123;<br><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Doing something.&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>        myInterface.doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>二、内部类的优点</strong></p>
<ol>
<li>实现更好的封装<ul>
<li>内部类可以隐藏在外部类内部，对外界不可见，只有外部类可以访问它。这有助于提高代码的安全性和可维护性。</li>
</ul>
</li>
<li>访问外部类的成员<ul>
<li>内部类可以访问外部类的所有成员，包括私有成员。这使得在某些情况下实现特定的功能更加方便。</li>
</ul>
</li>
<li>代码组织和可读性<ul>
<li>内部类可以将相关的代码放在一起，使代码结构更清晰，提高可读性。</li>
</ul>
</li>
</ol>
<p><strong>三、内部类的注意事项</strong></p>
<ol>
<li>命名冲突<ul>
<li>内部类的名称不能与外部类或其他内部类的名称相同，否则会导致编译错误。</li>
</ul>
</li>
<li>访问权限<ul>
<li>内部类的访问权限受到外部类的限制。如果外部类是私有的，内部类也只能在外部类内部访问。</li>
</ul>
</li>
<li>内存管理<ul>
<li>内部类的对象会持有外部类对象的引用，这可能会导致内存泄漏问题。在使用内部类时，要注意及时释放资源，避免内存泄漏。</li>
</ul>
</li>
</ol>
<p>总之，内部类是 Java 中一种强大的特性，它可以帮助开发者实现更好的封装、代码组织和可读性。在使用内部类时，要注意命名冲突、访问权限和内存管理等问题，以确保代码的正确性和性能。</p>
<h3 id="8-3-简单工厂设计模式"><a href="#8-3-简单工厂设计模式" class="headerlink" title="8.3.简单工厂设计模式"></a>8.3.简单工厂设计模式</h3><ul>
<li><p>不仅可以使用父类的形参，还可以使用父类左方法的返回值类型，真是返回的对象可以是该类的任意一个子类对象。</p>
</li>
<li><p>简单工厂模式的实现，它是解决大量对象创建问题的一个解决方案，将创建和使用分开，公厂负责创建，使用者直接调用即可，简单工厂模式的基本要求是（<code> 定义一个创建对象的类并且通过静态方法来实现创建</code>）</p>
<blockquote>
<ul>
<li>定义一个static方法，通过类名直接实现</li>
<li>返回值类型是父类类型，返回的可以是其任意子类类型</li>
<li>传入一个字符串类型的参数，工厂根据参数创建对应的子类产品</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<span class="hljs-comment">//抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shut</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<span class="hljs-comment">//子类猫</span><br><span class="hljs-meta">@Override</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shut</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;喵喵喵&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<span class="hljs-comment">//子类狗</span><br><span class="hljs-meta">@Overrride</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shut</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;汪汪汪&quot;</span>);<br>&#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PetStore</span>&#123;<span class="hljs-comment">//宠物店  单例模式</span><br><span class="hljs-comment">//私有构造函数</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">PetStore</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-comment">//</span><br><span class="hljs-comment">//方法提供动物</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Animal <span class="hljs-title function_">getanimal</span><span class="hljs-params">(String petname)</span>&#123;<br>Animal an=<span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;猫&quot;</span>.equals(petname)) an=<span class="hljs-keyword">new</span> <span class="hljs-title class_">cat</span>();<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;狗&quot;</span>.equals(petname)) an=<span class="hljs-keyword">new</span> <span class="hljs-title class_">dog</span>();<br>    <span class="hljs-keyword">return</span> an;<br>&#125;<span class="hljs-comment">//petname.equals(&quot;猫&quot;)  当petname为空时会报空指针异常</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">girl</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">(Animal an)</span>&#123;<br>        an.shut();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>        girl g=<span class="hljs-keyword">new</span> <span class="hljs-title class_">girl</span>();<br>        Animal an=PetStore.getanimal(<span class="hljs-string">&quot;狗&quot;</span>);<br>        g.play(an);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-接口"><a href="#9-接口" class="headerlink" title="9.接口"></a>9.接口</h2><h3 id="9-1-接口的基本概念"><a href="#9-1-接口的基本概念" class="headerlink" title="9.1.接口的基本概念"></a>9.1.接口的基本概念</h3><ol>
<li>类是类，接口是接口，属于同一层次的概念。</li>
<li>接口中没有构造器。接口声明使用 <code>interface</code>关键字。</li>
<li>在 JDK 1.8 之前，接口主要有两部分：<ul>
<li>常量：固定修饰符为 <code>public static final</code>，可不写系统默认补全。</li>
<li>抽象方法：固定修饰符为 <code>public abstract</code>。</li>
</ul>
</li>
</ol>
<h3 id="9-2-类和接口的关系"><a href="#9-2-类和接口的关系" class="headerlink" title="9.2.类和接口的关系"></a>9.2.类和接口的关系</h3><ol>
<li>实现关系：类通过 <code>implements</code>关键字实现接口。</li>
<li>一旦实现一个接口，实现类必须重写接口的全部抽象方法。如果没有全部重写，可以把类变成抽象类。</li>
<li>Java 只有单继承，但可以多实现（类只能有一个直接父类，但可以实现多个接口），一般先继承再实现。</li>
<li>接口不能创建对象，但接口可以指向实现类，如 <code>test_interface t = new Student();</code>。</li>
</ol>
<h3 id="9-3-接口的常量访问"><a href="#9-3-接口的常量访问" class="headerlink" title="9.3.接口的常量访问"></a>9.3.接口的常量访问</h3><ol>
<li>接口.常量，如 <code>test_interface.Num</code>。</li>
<li>通过实现接口的类来访问，接口中的属性都是静态常量，可直接通过类名.常量（如 <code>Student.num</code>）或通过实例（如 <code>s.Num</code>）。</li>
</ol>
<h3 id="9-4-接口的作用"><a href="#9-4-接口的作用" class="headerlink" title="9.4.接口的作用"></a>9.4.接口的作用</h3><ol>
<li>接口定义规则与类不同，实现类负责实现接口定义的规则即可。</li>
<li>用类继承侧重属性的本质，用接口实现不追寻本质，只是实现特定功能（如 -able）。例如手机和照相机不同根无法继承，但手机可拍照，可通过接口实现拍照功能。</li>
</ol>
<h3 id="9-5-增加多态的应用场合"><a href="#9-5-增加多态的应用场合" class="headerlink" title="9.5.增加多态的应用场合"></a>9.5.增加多态的应用场合</h3><ol>
<li>父类当作方法的形参，传入具体的子类对象。</li>
<li>父类当作方法的返回值，返回的是具体的子类对象。</li>
<li>接口当作方法的形参，传入具体的实现类的对象。</li>
<li>接口当作方法的返回值，返回的是具体的实现类的对象。</li>
</ol>
<h3 id="9-6-接口和抽象类的区别"><a href="#9-6-接口和抽象类的区别" class="headerlink" title="9.6.接口和抽象类的区别"></a>9.6.接口和抽象类的区别</h3><ol>
<li>JDK 1.8 之后，接口新增非抽象方法：<ul>
<li>被 <code>public default</code>修饰的非抽象方法，加上 <code>default</code>后不能被重写，其它修饰符可默认不加。</li>
<li>静态方法。</li>
</ul>
</li>
<li>在接口中加入非抽象方法的原因：如果接口中只能定义抽象方法，修改接口内容对实现类影响太大，加入非抽象方法可供某些实现类调用。</li>
</ol>
<h3 id="9-7-示例代码"><a href="#9-7-示例代码" class="headerlink" title="9.7.示例代码"></a>9.7.示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">test_interface</span> &#123;<br>    <span class="hljs-comment">//常量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">Num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>;<br>    <span class="hljs-comment">//非抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">c</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;---&gt;method c非抽象方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//静态方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">d</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;---&gt;static方法&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">test_interface</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;------默认抽象方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;---num:&quot;</span> + num);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testc_d</span><span class="hljs-params">()</span> &#123;<br>        c(); <span class="hljs-comment">//可以</span><br>        <span class="hljs-comment">// super.c();不可以</span><br>        test_interface.<span class="hljs-built_in">super</span>.c(); <span class="hljs-comment">//可以</span><br>        test_interface.d(); <span class="hljs-comment">//调用静态方法</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">test_interface</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        s.a();<br>        s.b(test_interface.Num);<br>        System.out.println(Student.Num);<br>        System.out.println(s.Num);<br>        s.testc_d();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="9-8-接口与Lambda表达式"><a href="#9-8-接口与Lambda表达式" class="headerlink" title="9.8.接口与Lambda表达式"></a>9.8.接口与Lambda表达式</h3><ul>
<li><p>Lambda表达式就是一个只写参数列表和方法体的匿名方法（参数列表和方法体之间的符号是-&gt;)</p>
</li>
<li><pre><code class="java">(a,b)-&gt;&#123;
return a+b;
&#125;
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br>- java中的Lambda表达式主要用于在给单接口变量（接口中有且只有一个<span class="hljs-keyword">abstract</span>方法）赋值，让代码更简洁。<br><br>- ~~~java<br>  <span class="hljs-keyword">interface</span> <span class="hljs-title">ShowMessage</span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span>(<span class="hljs-params">String s</span>)</span>;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">test</span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String args[]</span>)</span>&#123;<br>  ShowMessage sm;<span class="hljs-comment">//声明接口变量</span><br>  sm= (s)-&gt;&#123;     <span class="hljs-comment">//接口变量中存放Lambda表达式的值,把一整个Lambda表达式看作右值，所以结尾加&#x27;;&#x27;</span><br>  System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;tvtvtv&quot;</span>);<br>  System.<span class="hljs-keyword">out</span>.println(s);<br>  System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;tvtvtv&quot;</span>);<br>  &#125;;<br>  sm.print(<span class="hljs-string">&quot;长城牌电视机&quot;</span>)<span class="hljs-comment">//接口回调Lambda表达式实现的接口方法</span><br>  <br>  &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

</code></pre>
</li>
<li><p>函数式接口</p>
</li>
<li><pre><code class="java">// 定义一个函数式接口
@FunctionalInterface
interface Calculator &#123;
    int calculate(int a, int b);
&#125;

public class LambdaExample &#123;
    public static void main(String[] args) &#123;
        // 使用 Lambda 表达式实现 Calculator 接口
        Calculator addition = (a, b) -&gt; a + b;
        Calculator subtraction = (a, b) -&gt; a - b;

        int result1 = addition.calculate(5, 3);
        int result2 = subtraction.calculate(5, 3);

        System.out.println(&quot;5 + 3 = &quot; + result1);
        System.out.println(&quot;5 - 3 = &quot; + result2);
    &#125;
&#125;
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs d"><br>- 代码解释：<br><br>  - <span class="hljs-string">`Calculator`</span> 接口是一个函数式接口，使用 <span class="hljs-string">`@FunctionalInterface`</span> 注解进行标注，它只包含一个抽象方法 <span class="hljs-string">`calculate()`</span>。<br>  - 在 <span class="hljs-string">`main`</span> 方法中，使用 Lambda 表达式分别实现了加法和减法操作。<span class="hljs-string">`(a, b) -&gt; a + b`</span> 表示一个接收两个整数参数并返回它们之和的函数，<span class="hljs-string">`(a, b) -&gt; a - b`</span> 表示一个接收两个整数参数并返回它们之差的函数。<br>  - 调用 <span class="hljs-string">`calculate()`</span> 方法并传入相应的参数，将结果存储在变量中并打印输出。<br><br>  <br><br>  通过上述示例，你可以看到 Java 中接口和 Lambda 表达式的基本用法和它们之间的关联，Lambda 表达式为实现函数式接口提供了一种简洁、灵活的方式。<br><br><br><br>## <span class="hljs-number">10.</span>异常（Exception）处理<br><br>### <span class="hljs-number">10.1</span>捕获异常<br><br>- <span class="hljs-number">1.</span>基于<span class="hljs-keyword">if</span>-<span class="hljs-keyword">else</span>处理异常缺点太多，所以Java中专门出了一个异常处理机制：<br><br>- &gt; 异常三连：<span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span>-<span class="hljs-keyword">finally</span><br><br>- <span class="hljs-number">2.</span>异常出现了以后怎么看：<br><br>- 第一行提示异常的类型，最后一行提示异常出现的位置<br><br>- ![image-<span class="hljs-number">20241102161403029</span>](java.assets/image-<span class="hljs-number">20241102161403029.</span>png)<br><br>- <span class="hljs-number">3.</span>捕获异常： <span class="hljs-string">` try-catch`</span><br><br>- &gt; ~~~Java<br>  &gt; <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> test&#123;<br>  &gt; <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[]args)&#123;<br>  &gt; <span class="hljs-comment">//录入两个数求商</span><br>  &gt; <span class="hljs-keyword">try</span>&#123;<br>  &gt; Scanner sc=<span class="hljs-keyword">new</span> Scanner(System.<span class="hljs-keyword">in</span>);<br>  &gt; System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;请输入第一个数:&quot;</span>);<br>  &gt; <span class="hljs-keyword">int</span> num1=sc.nextInt();<br>  &gt; System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;请输入第二个数：&quot;</span>);<br>  &gt; <span class="hljs-keyword">int</span> num2=sc.nextInt();<br>  &gt; System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;商：&quot;</span>+num1/num2);<br>  &gt; &#125;<br>  &gt; <span class="hljs-keyword">catch</span>(Exception ex)&#123;<span class="hljs-comment">//Exception是所有异常的父类</span><br>  &gt; System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;对不起，程序出现异常！&quot;</span>)；<br>  &gt; &#125;<br>  &gt;     System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;------enjoy(o.o)&quot;</span>);<br>  &gt; &#125;<br>  &gt; &#125;<br></code></pre></td></tr></table></figure>
&gt;
&gt; &gt; 原理：把可能会出现的异常放入try代码块中，然后将异常封装成对象，被catch后面的（）中的异常对象接受，接受以后执行catch后面的&#123;&#125;里面的代码。
&gt; &gt;
&gt; &gt; - 1. try中没有异常，catch中代码不执行
&gt; &gt;   2. try中有异常，catch进行捕获：
&gt; &gt;
&gt; &gt;   如果异常匹配，走catch中的代码块
&gt; &gt;
&gt; &gt;   如果异常不匹配，不走catch中的代码，异常中断
&gt; &gt;
&gt; &gt;   注意：（1）try中如果出现异常，然后用catch捕获成功的话，那么try中后续的代码是不会执行的
&gt; &gt;
&gt; &gt;   （2）如果catch捕获异常成功，那么try-catch后面的代码该执行还是继续执行无影响
</code></pre>
</li>
</ul>
<h3 id="10-2-异常处理"><a href="#10-2-异常处理" class="headerlink" title="10.2.异常处理"></a>10.2.异常处理</h3><ul>
<li><p>打印异常信息：</p>
<blockquote>
<p>调用toString方法，显示异常的类名（全限定路径）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(ex);<br>System.out.println(ex.toString());<br></code></pre></td></tr></table></figure>

<p>显示异常描述信息对应的字符串,如果没有就显示null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(ex.getMessage());<br></code></pre></td></tr></table></figure>

<p>显示异常的堆栈信息：将异常的信息在控制台打印而不中断程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ex.printStackTrace();<br></code></pre></td></tr></table></figure>

<p>抛出异常，程序中断（异常两次）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> ex;<br></code></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h3 id="10-3finally"><a href="#10-3finally" class="headerlink" title="10.3finally"></a>10.3finally</h3><ul>
<li>（1）什么情况下，try-catch后面的代码不执行？</li>
</ul>
<ol>
<li>throw抛出异常的情况</li>
<li>异常捕获失败（与捕获的异常类型不相容，直接中断）</li>
<li>在try中遇到return</li>
</ol>
<ul>
<li>（2）如何将try-catch后面的代码必须执行？</li>
</ul>
<blockquote>
<p>只要将必须执行的代码放入finally中，那么这代码无论如何一定执行</p>
</blockquote>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-comment">//录入两个数求商</span><br><span class="hljs-keyword">try</span>&#123;<br>Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(<span class="hljs-string">&quot;请输入第一个数:&quot;</span>);<br><span class="hljs-type">int</span> num1=sc.nextInt();<br>System.out.println(<span class="hljs-string">&quot;请输入第二个数：&quot;</span>);<br><span class="hljs-type">int</span> num2=sc.nextInt();<br>System.out.println(<span class="hljs-string">&quot;商：&quot;</span>+num1/num2);<br>    <span class="hljs-comment">//System.exit(0);//终止当前的虚拟器执行</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">catch</span>(Exception ex)&#123;<span class="hljs-comment">//Exception是所有异常的父类</span><br><span class="hljs-comment">//throw ex;</span><br>&#125;<br><span class="hljs-keyword">finally</span>&#123;<span class="hljs-comment">//一定执行</span><br>System.out.println(<span class="hljs-string">&quot;----enjoy(o.o)&quot;</span>);<br>&#125;<br>    <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>（3）先执行finally再执行return</p>
</li>
<li><p>（4）什么代码会放在finally中？</p>
</li>
<li><blockquote>
<p>关闭数据库资源、关闭IO流资源、关闭socket资源。</p>
<p>如果把资源放<code>try(&quot;资源&quot;)&#123;&#125;</code>，如此会自动释放。不需要在finally中手动释放。</p>
</blockquote>
</li>
<li><p>（5）finally代码块不执行的情况：</p>
</li>
<li><blockquote>
<pre><code class="Java">System.exit(0);//终止当前的虚拟器执行
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs haxe">   <br> -   (<span class="hljs-number">6</span>)带有close的语法糖<span class="hljs-keyword">try</span>(IO流对象)&#123;&#125;     自动关闭文件流，不需要使用finally代码块<br><br> - &gt; ~~~java<br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedTset</span></span>&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args)&#123;<br>     <span class="hljs-keyword">try</span>( BufferedReader br=<span class="hljs-keyword">new</span> <span class="hljs-type">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">FileReader</span>(<span class="hljs-string">&quot;path&quot;</span>));<br>           BufferedWriter bw=<span class="hljs-keyword">new</span> <span class="hljs-type">bufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">FlieWriter</span>(<span class="hljs-string">&quot;path1&quot;</span>));<br>          )<span class="hljs-comment">//资源放在try-catch块中，自动刷新关闭释放</span><br>         &#123;<br>             List&lt;<span class="hljs-keyword">String</span>&gt; data=<span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>             <span class="hljs-keyword">String</span> line;<span class="hljs-comment">//读出加入到List容器</span><br>             <span class="hljs-keyword">while</span>((line=br.readline())!=<span class="hljs-literal">null</span>) data.add(line);<br>         &#125;<br>     Collection.sort(data);<span class="hljs-comment">//排序</span><br>     System.out.println(adta);<br>     <span class="hljs-comment">//写入</span><br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">String</span> s:<span class="hljs-type">data</span>)&#123;<br>         bw.Writer(s);<br>         bw.<span class="hljs-keyword">new</span><span class="hljs-type">Line</span>;<span class="hljs-comment">//换行</span><br>     &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>         e.printStackTrace();<br>     &#125;<br><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</code></pre>
</blockquote>
</li>
</ul>
<h3 id="10-4-多重catch"><a href="#10-4-多重catch" class="headerlink" title="10.4.多重catch"></a>10.4.多重catch</h3><ul>
<li><p>（1）try中出现异常以后，将异常类型跟catch后面的类型依次匹配，执行第一个与异常类型匹配的catch语句，后面的catch语句就会被忽略</p>
</li>
<li><p>（2）将特殊异常放前面；（先写子类异常再写父类异常）</p>
</li>
<li><p>（3）在jdk1.7以后，异常处理方式：可以并列用|符号连接：</p>
</li>
<li><pre><code class="java">public static Integer getInteger(String nm,Integer val)&#123;
String v=null;
try&#123;
v=System.getProperty(nm);
&#125;catch(IllegalArgumentException|NullPointerException e)&#123;

&#125;if(v!=null)&#123;
try&#123;
return Integer.decode(v);
&#125;catch(NumberFormatException e)&#123;&#125;
&#125;
return val;
&#125;

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs php"><br><span class="hljs-comment">### 10.5.异常分类</span><br><br>- &gt; Object类--》<span class="hljs-built_in">Throwable</span>类--》<br>  &gt;<br>  &gt; &gt; <span class="hljs-built_in">Error</span>(错误)、<span class="hljs-built_in">Exception</span>(异常)     <span class="hljs-comment">//Error错误不用关注，一般靠程序本身无法解决</span><br>  &gt;<br>  &gt; &gt; <span class="hljs-built_in">Exception</span>---》检查异常、运行时异常<br><br>  注意：程序中语法错、逻辑错误都不属于上面的error、<span class="hljs-built_in">Exception</span><br><br><span class="hljs-number">1</span>. 运行时异常（免检异常unchecked exception）<span class="hljs-built_in">Error</span>和<span class="hljs-built_in">RuntimeException</span><br><br>- 写代码的时候，不用特意对异常进行处理，在程序运行以后系统自动检测，然后报出异常<br><br><span class="hljs-number">2</span>. 检查异常(必检异常checked exception)<br><br>- 写代码的时候，就要对代码进行异常处理：throws向外抛或者<span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span>捕获异常<br><br>常见的必检异常：（继承自<span class="hljs-built_in">Exception</span>)<br><br>&gt;SQLException、IOException、ClassnotFindexception、InterruptException<br><br>常见的免检异常：(继承自<span class="hljs-built_in">RuntimeException</span>)<br><br>&gt;NullPointerException（空指针）、ArrthmaticException、ClassCastException（类转换）、<span class="hljs-title function_ invoke__">IndexOutOfBandException</span>(越界)<br><br><br><br>&gt; ALT+enter用idea生成<span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span><br>&gt;<br>&gt; CTRL+ALT+T生成<span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span><br><br><span class="hljs-number">1</span>. <span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span>嵌套<br><span class="hljs-number">2</span>. 多重<span class="hljs-keyword">catch</span><br><span class="hljs-number">3</span>. throws<br><br>- **<span class="hljs-keyword">throw</span>和throws**的区别<br><br>  &gt;~~~java<br>  &gt;package com.fortest1;<br>  &gt;import java.util.Scanner;<br>  &gt;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test01</span> </span>&#123;<br>  &gt;<span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_ invoke__">main</span>(String[] args) throws <span class="hljs-built_in">Exception</span> <span class="hljs-comment">//把异常抛给方法名</span><br>  &gt;&#123;<br>  &gt;   Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>  &gt;   System.out.<span class="hljs-title function_ invoke__">println</span>(<span class="hljs-string">&quot;请输入第一个数:&quot;</span>);<br>  &gt;   <span class="hljs-keyword">int</span> num1=sc.<span class="hljs-title function_ invoke__">nextInt</span>();<br>  &gt;   System.out.<span class="hljs-title function_ invoke__">println</span>(<span class="hljs-string">&quot;请输入第二个数：&quot;</span>);<br>  &gt;   <span class="hljs-keyword">int</span> num2=sc.<span class="hljs-title function_ invoke__">nextInt</span>();<br>  &gt;<span class="hljs-keyword">if</span>(num2==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//除数为0，制造异常</span><br>  &gt;<span class="hljs-comment">//制造运行时异常：</span><br>  &gt;<span class="hljs-comment">//throw new RuntimeException();</span><br>  &gt;<span class="hljs-comment">//制造检查异常</span><br>  &gt;<span class="hljs-comment">/*  try &#123;</span><br><span class="hljs-comment">  &gt;   throw new Exception();</span><br><span class="hljs-comment">  &gt;&#125; catch (Exception e) &#123;</span><br><span class="hljs-comment">  &gt;   e.printStackTrace();</span><br><span class="hljs-comment">  &gt;&#125;</span><br><span class="hljs-comment">  &gt;*/</span><br>  &gt;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>();<br>  &gt;&#125;<br>  &gt;<span class="hljs-keyword">else</span> System.out.<span class="hljs-title function_ invoke__">println</span>(<span class="hljs-string">&quot;商：&quot;</span>+num1/num2);<br>  &gt;   &#125;<br>  &gt;&#125;<br></code></pre></td></tr></table></figure>
&gt;
&gt;&gt; 1. 位置不同：throw：在方法内部；throws:方法的声明处，谁调用谁处理或者继续往外抛出
&gt;&gt; 2. 内容不同：throw+异常对象（检查异常、运行时异常）；throws+异常的类型（可以多个类型，用&quot;,&quot;拼接）
&gt;&gt; 3. 作用不同：throw:异常出现的源头，制造异常；throws：在方法的声明处，告诉方法的调用者，这个方法中可能存在异常，要么自己处理要么在继续向外抛出异常
</code></pre>
</li>
</ul>
<h3 id="10-6-异常-重载和重写以及自定义异常"><a href="#10-6-异常-重载和重写以及自定义异常" class="headerlink" title="10.6.异常_重载和重写以及自定义异常"></a>10.6.异常_重载和重写以及自定义异常</h3><h4 id="10-6-1异常重载和重写"><a href="#10-6-1异常重载和重写" class="headerlink" title="10.6.1异常重载和重写"></a>10.6.1异常重载和重写</h4><ul>
<li>重载：方法名相同，形参列表不同(与异常无关)</li>
</ul>
<blockquote>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception</span>&#123;<br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span><span class="hljs-keyword">throws</span> ArithmeticException</span>&#123;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>重写：子类继承；接口实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception&#123;<br>System.out.println(<span class="hljs-string">&quot;父类方法&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> exdents Person&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> RunTimeException&#123;<br>System.out.println(<span class="hljs-string">&quot;子类方法&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><blockquote>
<p>子类的异常范围&lt;&#x3D;父类的异常；即子类的异常不能是父类异常的父类</p>
</blockquote>
</li>
</ul>
<h4 id="10-6-2自定义异常"><a href="#10-6-2自定义异常" class="headerlink" title="10.6.2自定义异常"></a>10.6.2自定义异常</h4><ul>
<li><p>创建一个类：</p>
</li>
<li><blockquote>
<p>该类可以继承自运行时异常RuntimeException为免检异常</p>
<p>也可以继承检查异常Exception为必检异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java">&gt;<span class="hljs-keyword">package</span> com.fortest1;<br><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> extends <span class="hljs-comment">//Exception RuntimeException </span><br>&gt;&#123;<br>&gt;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">790745766939L</span>;<br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-title function_">MyException</span><span class="hljs-params">()</span>&#123;&#125;<br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-title function_">MyException</span><span class="hljs-params">(String msg)</span>&#123;<br> <span class="hljs-built_in">super</span>(msg);<br>&gt;&#125;<br>&gt;&#125;<br><br></code></pre></td></tr></table></figure>

<p>通过throw new MyException(“sdasdsad”);抛出异常不强调额外处理，也可以用try-catch捕获</p>
<p>如果继承的是检查异常需要捕获异常或者throws向上抛出</p>
</blockquote>
</li>
<li><p><strong>搞清楚五个关键词</strong>：try-catch-finally-throw-throws</p>
</li>
</ul>
<h3 id="10-7-断言"><a href="#10-7-断言" class="headerlink" title="10.7.断言"></a>10.7.断言</h3><ul>
<li><p>断言语句在调试代码阶段非常有用，断言语句一般用于程序不准备通过捕获异常来处理的错误，例如：当发生某个错误时要求程序必须立即停止执行。</p>
</li>
<li><p>语法结构：</p>
</li>
<li><pre><code class="hljs">assert number&gt;10;//number&gt;10的值为true，程序继续执行，否则程序立即结束执行
assert booleanExpression;//true继续执行，否则程序立即结束执行
assert booleanExpression:messageExcept;//booleanExpression为true继续执行，为false，停止执行，并且输出messageExcept表达式的值
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><br>  <br><br><span class="hljs-comment">## 11.常用类</span><br><br><span class="hljs-comment">### 11.1.包装类</span><br><br>- （<span class="hljs-number">1</span>）什么是包装类？<br><br>- &gt; 将基本数据类型对应进行了一个封装，产生了一个新的类，---》**包装类**<br>  &gt;<br>  &gt; 基本数据类型：boolean<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span>-&gt;</span>byte<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span>-&gt;</span>char<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">2</span>)</span>-&gt;</span>short<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">2</span>)</span>-&gt;</span>int<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">4</span>)</span>-&gt;</span>long<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">8</span>L)</span>-&gt;</span>float<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">4f</span>)</span>-&gt;</span>double(<span class="hljs-number">8</span>)<br>  &gt;<br>  &gt; 包装类---&gt;引用数据类型<br><br>  &gt;（<span class="hljs-number">2</span>）对应关系：<br>  &gt;<br>  &gt;基本数据类型                包装类     继承关系<br>  &gt;<br>  &gt;byte                               Byte    ---》<span class="hljs-built_in">Number</span>--》<span class="hljs-built_in">Object</span>    <br>  &gt;<br>  &gt;short                             Short   ---》<span class="hljs-built_in">Number</span>--》<span class="hljs-built_in">Object</span><br>  &gt;<br>  &gt;int                                  Integer  ---》<span class="hljs-built_in">Number</span>--》<span class="hljs-built_in">Object</span><br>  &gt;<br>  &gt;long                               Long     ---》<span class="hljs-built_in">Number</span>--》<span class="hljs-built_in">Object</span><br>  &gt;<br>  &gt;float                               Float    ---》<span class="hljs-built_in">Number</span>--》<span class="hljs-built_in">Object</span><br>  &gt;<br>  &gt;double                           Double   ---》<span class="hljs-built_in">Number</span>--》<span class="hljs-built_in">Object</span><br>  &gt;<br>  &gt;char                               Character    ---》<span class="hljs-built_in">Object</span><br>  &gt;<br>  &gt;boolean                         <span class="hljs-built_in">Boolean</span>    ---》<span class="hljs-built_in">Object</span><br><br>- （<span class="hljs-number">3</span>）已经有数据类型了为什么要使用包装类？<br><br>&gt; 把基本数据类型封装成包装类便于引用数据类型操作<br><br>- **类Integer**<br><br>- &gt; <span class="hljs-number">1.</span> 直接使用无需导包  Java.Lang下<br>  &gt; <span class="hljs-number">2.</span> 类的继承关系   ---&gt;<span class="hljs-built_in">Number</span>---&gt;<span class="hljs-built_in">Object</span><br>  &gt; <span class="hljs-number">3.</span> 实现接口：  Serializable,Comparable&lt;Integer&gt;<br>  &gt; <span class="hljs-number">4.</span> 这个类被final修饰不能被继承：<br>  &gt;<br>  &gt; &gt; ~~~java<br>  &gt; &gt; public final <span class="hljs-keyword">class</span> <span class="hljs-title class_">Integer</span> <br>  &gt; &gt; <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Number</span><br>  &gt; &gt; implements Comparable&lt;Integer&gt;<br></code></pre></td></tr></table></figure>
&gt;
&gt; 5. 对int类型进行包装
&gt; 6. 属性：共有静态字符常量通过类名调用public static final
&gt;
&gt; &gt; <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">System.out.println(Integer.MAX_VALUE);<span class="hljs-comment">//int的最大值</span><br>System.out.println(Integer.MIN_VALUE);<span class="hljs-comment">//int的最小值</span><br></code></pre></td></tr></table></figure>
&gt; &gt;
&gt; &gt; 注意：最大值+1=最小值；最小值-1=最大值
&gt;
&gt; 7. 构造方法：(无空参)
&gt;
&gt; &gt; <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">12</span>);<span class="hljs-comment">//12--&gt;private final value</span><br>Integer i2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-string">&quot;12&quot;</span>);<span class="hljs-comment">//转为12--&gt;private final value</span><br>Integer i3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-string">&quot;abc&quot;</span>);<span class="hljs-comment">//NumFormatException异常</span><br></code></pre></td></tr></table></figure>
&gt;
&gt; 8. 包装类的自动类型转化
&gt;
&gt; &gt; <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i=<span class="hljs-number">12</span>;<span class="hljs-comment">//Integer---&gt;int通过Integer.ValeuOf()</span><br>Integer i2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">12</span>);<br><span class="hljs-type">int</span> num=i2;<span class="hljs-comment">//int---&gt;Integer 通过Integer.intValue()</span><br></code></pre></td></tr></table></figure>
&gt;
&gt; 9. 常用方法：
&gt;
&gt; &gt;i1.compareTo(i2) ;  //返回-1，0，1   
&gt; &gt;
&gt; &gt;i1.equals（i2）;   //返回true，false
&gt; &gt;
&gt; &gt;int num = Integer.parseInt(&quot;123&quot;);//将字符串转化为int
&gt; &gt;
&gt; &gt;int value = i1.intValue(); //返回Integer对象的int值
&gt; &gt;
&gt; &gt;String str=i1.toString();//以字符串方式返回Integer的值
</code></pre>
</li>
</ul>
<h3 id="11-2-日期相关"><a href="#11-2-日期相关" class="headerlink" title="11.2.日期相关"></a>11.2.日期相关</h3><ul>
<li><p>Java.util.Date</p>
</li>
<li><blockquote>
<pre><code class="java">//Date类的使用  java.util.Date
Date d=new Date();  //初始化一个Date对象
    //获取当前时间
    System.out.println(d);
System.out.println(d.toString());
//返回自1970年1月1日00.00.00GMT以来的毫秒数
    System.out.println(d.getTime());
    System.out.println(System.currentTimeMillis());
//System.currentTimeMillis()更方便直接静态调用无需创建对象
//public static native long currentTimeMillis();本地方法没有方法体
//该时间差的作用：用于衡量一些算法的时间：
    long startTime=System.currentTimeMillis();
    for(int i=0;i&lt;10000;i++)
    &#123;
        System.out.print(i);
    &#125;
    System.out.println();
    long endTime=System.currentTimeMillis();
    System.out.println(endTime-startTime);
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>- java.<span class="hljs-keyword">sql</span>.Date(只包含日期，与数据库交互)<br><br>- &gt; ~~~~java<br>//java.<span class="hljs-keyword">sql</span>.Date   需要传入long型参数 <span class="hljs-number">1970</span>年<span class="hljs-number">1</span>月<span class="hljs-number">1</span>日<span class="hljs-number">00.00</span><span class="hljs-number">.00</span>到所要表示的时间的毫秒数<br>    <span class="hljs-type">Date</span> d=<span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>(<span class="hljs-keyword">System</span>.currentTimeMillis());<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(d);<br>//区别：<span class="hljs-keyword">sql</span>.Date只返回年月日；util.Date包括时分秒<br>    //联系：<span class="hljs-keyword">sql</span>.Date(子) exdents util.Date（父）<br>    //相互转换：//向上转型：子类对象赋值给父类的引用   //父类的引用类型无法调用子类特殊的方法得通过向下转型，变成子类引用后才能调用子类得特殊方法<br>                   java.util.Date date_fa=<span class="hljs-built_in">new</span> java.<span class="hljs-keyword">sql</span>.Date(<span class="hljs-keyword">System</span>.currentTimeMillis());<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(date_fa.getTime());<br>//向下转型：<br>    java.util.Date date_fa1=<span class="hljs-built_in">new</span> java.<span class="hljs-keyword">sql</span>.Date(<span class="hljs-keyword">System</span>.currentTimeMillis());<br><span class="hljs-keyword">if</span>(date_fa1 instanceof java.<span class="hljs-keyword">sql</span>.Date)&#123;<br>    <span class="hljs-type">Date</span> date_son1=(<span class="hljs-type">Date</span>) date_fa1;<br>&#125;<br><br>~~~~<br><br>- SimpleDateFormat（少用）<br><br> - &gt; String<span class="hljs-comment">---&gt;java.util.Date类型转换</span><br><br>&gt; String<span class="hljs-comment">---&gt;java.sql.Date</span><br>&gt;<br>&gt; java.<span class="hljs-keyword">sql</span>.Date<span class="hljs-comment">---&gt;java.util.Date</span><br>&gt;<br>&gt; ~~~java<br>&gt; <span class="hljs-type">Date</span> date3=<span class="hljs-type">Date</span>.valueOf(&quot;2024-11-03&quot;);<br>&gt;     java.util.Date date_3= (java.util.Date) date3;<br>&gt;     <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(date_3.toString());<br></code></pre></td></tr></table></figure>

- 缺点：字符串只能是年-月-日；
- 引入DateFormat(抽象类)无法初始化，SimpleDateFormat作为子类可以初始化

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"> <span class="hljs-comment">//日期转换</span><br>    <span class="hljs-comment">//String---&gt;Date</span><br>    <span class="hljs-comment">//SimpleDateFormat extends DateFormat(抽象类)</span><br>    DateFormat df=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<span class="hljs-comment">//自己定义的日期格式年y,月M,日d,时H(24)/h(12),分m,秒s,毫秒S</span><br><span class="hljs-comment">//定义好了格式化标准</span><br>    <span class="hljs-keyword">try</span> &#123;<br>       Date date= df.parse(<span class="hljs-string">&quot;2024-11-03 17:25:55&quot;</span>);<br>        System.out.println(date);<br>    &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br><span class="hljs-comment">//Date---&gt;String</span><br>   String df_now= df.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>System.out.println(df_now);<br></code></pre></td></tr></table></figure>

- parse（接受字符串返回Date），format（接受Date返回字符串）
</code></pre>
</blockquote>
</li>
<li><p>日历Calendar(抽象类)(少用)</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Calendar是一个抽象类，不可以直接创建对象</span><br><span class="hljs-comment">//GregorianCalendar()子类extends Calendar</span><br>Calendar cal=<span class="hljs-keyword">new</span> <span class="hljs-title class_">GregorianCalendar</span>();<br>Calendar cal2=Calendar.getInstance();<br>System.out.println(cal2);<br><span class="hljs-comment">//常用的方法  get方法；传入Calendar中定义的常量</span><br>   System.out.println(cal2.get(Calendar.YEAR));<span class="hljs-comment">//年</span><br>    System.out.println(cal2.get(Calendar.MONTH));<span class="hljs-comment">//月</span><br>    System.out.println(cal2.get(Calendar.DATE));<span class="hljs-comment">//日</span><br>    System.out.println(cal2.get(Calendar.DAY_OF_WEEK));<span class="hljs-comment">//按国外星期日第一天</span><br>    System.out.println(cal2.getActualMaximum(Calendar.DATE));<span class="hljs-comment">//获取最大</span><br>    System.out.println(cal2.getActualMinimum(Calendar.DATE));<span class="hljs-comment">//获取最小</span><br> <span class="hljs-comment">//set方法：可以改变Calendar的内容</span><br> cal2.set(Calendar.YEAR,<span class="hljs-number">2025</span>);<br>cal2.set(Calendar.DATE,<span class="hljs-number">6</span>);<br><span class="hljs-comment">//setTime方法：</span><br> java.sql.Date date=java.sql.Date.valueOf(<span class="hljs-string">&quot;2026-11-03&quot;</span>);<br>cal2.setTime(date);<br><br></code></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>完成需求:</p>
</li>
<li><p><img src="/.com//image-20241103174048966.png" srcset="/img/loading.gif" lazyload alt="image-20241103174048966"></p>
</li>
<li><blockquote>
<pre><code class="java"> //String--》Calendar
//录入日期的字符串
    Scanner sc=new Scanner(System.in);
    System.out.println(&quot;请输入你要查看的日期：（提示：请按照年-月-日的格式）&quot;);
String strDate=sc.next();
//String --&gt;Calendar
//1.String--&gt;Date
    java.sql.Date date=java.sql.Date.valueOf(strDate);
//2.Date--&gt;Caendar
    Calendar cal=Calendar.getInstance();
cal.setTime(date);
//
    System.out.println(&quot;日\t一\t二\t三\t四\t五\t六&quot;);
//获取本月的最大天数
int maxDay=cal.getActualMaximum(Calendar.DATE);
//获取当前日期的日
    int now_Day=cal.get(Calendar.DATE);
    //将当前日期中的日调为本月的1号,在看1号是星期几
    cal.set(Calendar.DATE,1);
   int num= cal.get(Calendar.DAY_OF_WEEK);
int count=0;
for(int i=1;i&lt;=num-1;i++)&#123;
    System.out.print(&quot;\t&quot;);
    count++;
&#125;
for(int i=1 ;i&lt;=maxDay;i++)&#123;
    if (i==now_Day)&#123;
    System.out.print(i+&quot;*&quot;+&quot;\t&quot;);
&#125;
else &#123;
    System.out.print(i+&quot;\t&quot;);
&#125;
count++;
if(count%7==0) System.out.println();
&#125;
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>- LocalDate;LocalTime;LocalDateTime（多用）<br><br>- &gt;~~~java<br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">//初始化</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">//now()方法,现在时刻</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">LocalDate localDate= LocalDate.now();</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">System.out.println(localDate);</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">LocalTime localTime=LocalTime.now();</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">System.out.println(localTime);</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">LocalDateTime localDateTime=LocalDateTime.now();</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">System.out.println(localDateTime);</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">//of（）方法，设计时间</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">LocalDate of=LocalDate.of(2024,11,3);</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">LocalTime of1=localTime.of(18,22,11);</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">//LocalDateTime使用频率最高</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">//get方法</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">System.out.println(localDateTime.getYear());</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">System.out.println(localDateTime.getMonth());//月的英文</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">System.out.println(localDateTime.getDayOfMonth());//月的值</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">System.out.println(localDateTime.getMonthValue());</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">System.out.println(localDateTime.getHour());</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">//.....</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">//不叫<span class="hljs-built_in">set</span>方法，叫with方法，不在自身的基础上改变</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">LocalDateTime localDateTime1=localDateTime.withMonth(8);</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">System.out.println(localDateTime);</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">System.out.println(localDateTime1);</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">//.plusMonth（n）加n个月  .minusMonth（n） 减n个月</span><br><span class="hljs-meta prompt_"> &gt;</span><span class="language-bash">//.plusDay(n) 加n天      .minusDay(n) 减n天</span><br><br></code></pre></td></tr></table></figure>
</code></pre>
</blockquote>
</li>
<li><p>DateTimeFormatter    <code>ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;);  </code>常用</p>
</li>
<li><blockquote>
<pre><code class="Java">//格式化类
//自定义的格式化  ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;);  常用
DateTimeFormatter dateTimeFormatter=DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;);
//LocalDateTime  ----&gt;String
 LocalDateTime now=LocalDateTime.now();
 System.out.println(now);//2024-11-03T19:09:07.842778100
String format=DateTimeFormatter.format(now);
System.out.println(format);//2024-11-03 07:10:05
 //String----&gt;LocalTimeDate
 TemporalAccessor parse1=dateTimeFormatter.parse(&quot;2024-11-03 07:10:05&quot;);
System.out.println(parse1);

<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ruby"> <br> <br><br><span class="hljs-comment">### 11.3.Math类</span><br><br>- <span class="hljs-number">1</span>.使用<span class="hljs-string">``</span><span class="hljs-title class_">Math</span>类<span class="hljs-string">``</span>的时候无需导包，直接使用即可<br><br><span class="hljs-string">`package java.lang;`</span><br><br> <span class="hljs-number">2</span>.<span class="hljs-string">` Math类`</span>没有子类，不能被其它类继承<br><br> ~~~java<br> <span class="hljs-keyword">public</span> final <span class="hljs-keyword">class</span> <span class="hljs-title class_">Math</span>&#123;&#125;<br></code></pre></td></tr></table></figure>
</code></pre>
</blockquote>
</li>
</ul>
<p>3.里面的属性全部被final修饰，方法也是被final修饰的。</p>
<p>4.外界不可以创建对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Math</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Math</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>构造器私有化</p>
<p>5.Math类中的所有属性，方法都被static修饰，不用创建对象去调用（也不能），直接通过<code> 类名.属性名  类名.方法名</code>去调用。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//常用属性，方法</span><br>Math.PI;<span class="hljs-comment">//Π圆周率</span><br>Math.random();<span class="hljs-comment">//[0.0,1.0)随机数</span><br>Math.obs(-<span class="hljs-number">80</span>);<span class="hljs-comment">//80绝对值</span><br>Math.ceil(<span class="hljs-number">9.1</span>);<span class="hljs-comment">//10.0向上取值</span><br>Math.floor(<span class="hljs-number">9.9</span>);<span class="hljs-comment">//9向下取值</span><br>Math.round(<span class="hljs-number">3.5</span>);<span class="hljs-comment">//4四舍五入</span><br>Math.max(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//6取最大</span><br>Math.min(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>)<span class="hljs-comment">//3取最小</span><br></code></pre></td></tr></table></figure>

<h3 id="11-4-String类"><a href="#11-4-String类" class="headerlink" title="11.4.String类"></a>11.4.String类</h3><ul>
<li><ol>
<li><code>String类</code>直接使用无需导包</li>
</ol>
<blockquote>
<p>package java.lang;</p>
</blockquote>
<ol start="2">
<li>无法继承，不能有子类</li>
</ol>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span>;<br></code></pre></td></tr></table></figure>
</blockquote>
<ol start="3">
<li>Strng底层是一个char类型的数组</li>
</ol>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br></code></pre></td></tr></table></figure>
</blockquote>
<ol start="4">
<li>常用方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">String str=<span class="hljs-string">&quot;asdasdad&quot;</span>;<br>String str1=<span class="hljs-string">&quot;asdasd&quot;</span>;<br>System.out.println(str.length());<span class="hljs-comment">//返回数组的长度</span><br>str.isEmpty();<span class="hljs-comment">//判断是否为空，返回Boolean</span><br>System.out.println(str.chaAt(<span class="hljs-number">1</span>))<span class="hljs-comment">//获取索引对应的字符</span><br>System.out.println(<span class="hljs-string">&quot;asdasdad&quot;</span>.equals(str));<span class="hljs-comment">//比较字符串是否一致，返回Boolean；注意：str1.equals(&quot;sdadad&quot;);如果传入引用str1为空；会报空指针异常</span><br><span class="hljs-comment">//String类实现了Compareable接口，所以String中一定要对这个方法进行重写；</span><br>System.out.println(str.compareTo(str1));<br>System.out.println(str.subString(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>));<span class="hljs-comment">//截取【3，6）部分</span><br>str.replace(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>);<span class="hljs-comment">//把a替换为u</span><br><span class="hljs-comment">//split</span><br>String str2=<span class="hljs-string">&quot;a,v,b,s,d,f&quot;</span>;<br>String[] strs=str2.split(<span class="hljs-string">&quot;,&quot;</span>);<br>System.out.println(strs[<span class="hljs-number">0</span>]);<span class="hljs-comment">//a</span><br><span class="hljs-comment">//lastIndexOf</span><br>string url=<span class="hljs-string">&quot;asdasdasdas.asda.png&quot;</span>;<br>String extension=url.subString(url.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br><br></code></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;compareTo的逻辑：s8.compareTo(s9);</p>
<p><img src="/.com//image-20241104182403532.png" srcset="/img/loading.gif" lazyload alt="image-20241104182403532"></p>
<h4 id="为什么new一个String会创建两个对象？"><a href="#为什么new一个String会创建两个对象？" class="headerlink" title="为什么new一个String会创建两个对象？"></a>为什么new一个String会创建两个对象？</h4><ul>
<li><p>在 Java 中，使用 <code>new String(&quot;xxx&quot;)</code> 这种方式创建字符串对象时，通常会创建两个对象，下面详细解释其原因。</p>
<h5 id="1-字符串常量池"><a href="#1-字符串常量池" class="headerlink" title="1. 字符串常量池"></a>1. 字符串常量池</h5><p>在 Java 里，为了节省内存和提高性能，字符串常量池（String Pool）被引入。字符串常量池是 Java 堆内存中的一个特殊区域，用于存储字符串常量。当你在代码中使用双引号直接声明一个字符串时，例如 <code>String s = &quot;hello&quot;;</code>，Java 首先会检查字符串常量池中是否已经存在值为 <code>&quot;hello&quot;</code> 的字符串对象。如果存在，就直接返回该对象的引用；如果不存在，就会在字符串常量池中创建一个新的字符串对象，并返回其引用。</p>
<h5 id="2-new-String-xxx-创建对象的过程"><a href="#2-new-String-xxx-创建对象的过程" class="headerlink" title="2. new String(&quot;xxx&quot;) 创建对象的过程"></a>2. <code>new String(&quot;xxx&quot;)</code> 创建对象的过程</h5><p>当使用 <code>new String(&quot;xxx&quot;)</code> 这种方式创建字符串对象时，会经历以下两个步骤，从而创建两个对象：</p>
<ul>
<li><strong>第一步：在字符串常量池中创建对象</strong>：当 Java 遇到双引号括起来的字符串字面量 <code>&quot;xxx&quot;</code> 时，会先检查字符串常量池中是否已经存在值为 <code>&quot;xxx&quot;</code> 的字符串对象。如果不存在，就在字符串常量池中创建一个新的字符串对象来存储 <code>&quot;xxx&quot;</code>。</li>
<li><strong>第二步：在堆内存中创建对象</strong>：<code>new</code> 关键字会在 Java 堆内存中创建一个新的 <code>String</code> 对象，这个对象会复制字符串常量池中 <code>&quot;xxx&quot;</code> 的值。最终返回的是堆内存中这个新创建的 <code>String</code> 对象的引用。</li>
</ul>
<h5 id="3-示例代码及解释"><a href="#3-示例代码及解释" class="headerlink" title="3. 示例代码及解释"></a>3. 示例代码及解释</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringCreationExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 在字符串常量池中创建 &quot;hello&quot; 对象</span><br>        <span class="hljs-comment">// 同时在堆内存中创建一个新的 String 对象，复制常量池 &quot;hello&quot; 的值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>); <br>        <span class="hljs-comment">// 检查字符串常量池中是否已有 &quot;hello&quot;，已有则直接返回引用</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>; <br>        String s3=s1.intern();<br>        System.out.println(s1 == s2); <span class="hljs-comment">// 输出 false，因为 s1 和 s2 引用的是不同的对象</span><br>        System.out.println(s1.equals(s2)); <span class="hljs-comment">// 输出 true，因为它们的值相同</span><br>        System.out.println(s2 == s3);<span class="hljs-comment">// 输出 true，因为 s2 和 s3 都引用字符串常量池中的对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="intern-方法"><a href="#intern-方法" class="headerlink" title="intern() 方法"></a><code>intern()</code> 方法</h4><p><code>intern()</code> 方法用于手动将字符串对象添加到字符串常量池中。当调用一个字符串对象的 <code>intern()</code> 方法时，JVM 会检查字符串常量池中是否已经存在与该对象值相等的字符串对象。</p>
<ul>
<li>如果存在，返回字符串常量池中该对象的引用。</li>
<li>如果不存在，将该对象的引用添加到字符串常量池中，并返回该引用。</li>
</ul>
<p>在上述代码中：</p>
<ul>
<li><code>String s1 = new String(&quot;hello&quot;);</code> 会在字符串常量池中创建一个 <code>&quot;hello&quot;</code> 对象，同时在堆内存中创建一个新的 <code>String</code> 对象，<code>s1</code> 引用的是堆内存中的对象。</li>
<li><code>String s2 = &quot;hello&quot;;</code> 会检查字符串常量池中是否已经存在 <code>&quot;hello&quot;</code> 对象，由于前面已经创建，所以 <code>s2</code> 直接引用字符串常量池中的 <code>&quot;hello&quot;</code> 对象。</li>
<li><code>s1 == s2</code> 比较的是两个引用是否指向同一个对象，由于 <code>s1</code> 和 <code>s2</code> 分别指向堆内存和字符串常量池中的不同对象，所以结果为 <code>false</code>。</li>
<li><code>s1.equals(s2)</code> 比较的是两个字符串的值是否相等，由于它们的值都是 <code>&quot;hello&quot;</code>，所以结果为 <code>true</code>。</li>
<li><code>s2 == s3</code>比较的是两个引用是否指向同一个对象,由于s2 和 s3 都引用字符串常量池中的对象，所以结果为true。</li>
</ul>
<h5 id="4-特殊情况"><a href="#4-特殊情况" class="headerlink" title="4. 特殊情况"></a>4. 特殊情况</h5><p>如果字符串常量池中已经存在对应值的字符串对象，那么使用 <code>new String(&quot;xxx&quot;)</code> 只会在堆内存中创建一个新的 <code>String</code> 对象，而不会在字符串常量池中再次创建。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>; <br><span class="hljs-comment">// 此时字符串常量池中已有 &quot;hello&quot;，只会在堆内存创建新对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>); <br></code></pre></td></tr></table></figure>



<p>综上所述，一般情况下 <code>new String(&quot;xxx&quot;)</code> 会创建两个对象，一个在字符串常量池中，一个在堆内存中。</p>
</li>
</ul>
</li>
</ul>
<h3 id="11-5-StringBuilder和StringBuffer常用方法如下："><a href="#11-5-StringBuilder和StringBuffer常用方法如下：" class="headerlink" title="11.5.StringBuilder和StringBuffer常用方法如下："></a>11.5.<code>StringBuilder</code>和<code>StringBuffer</code>常用方法如下：</h3><p><strong>一、append () 方法</strong></p>
<ol>
<li><strong>功能</strong>：<ul>
<li>用于在字符串末尾添加内容，可以是字符串、字符、整数、浮点数等各种数据类型。</li>
<li>例如，<code>StringBuilder sb = new StringBuilder(); sb.append(&quot;Hello&quot;);</code>，此时<code>sb</code>的内容变为 “Hello”。如果继续执行<code>sb.append(123);</code>，则<code>sb</code>变为 “Hello123”。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li>当需要动态地构建一个字符串时非常有用。比如在生成日志信息时，可以逐步将不同的信息片段添加到一个<code>StringBuilder</code>或<code>StringBuffer</code>对象中。</li>
<li>例如，在一个程序中记录用户的操作日志，可以使用<code>StringBuilder</code>来拼接用户的操作信息、时间戳等内容。</li>
</ul>
</li>
</ol>
<p><strong>二、insert () 方法</strong></p>
<ol>
<li><strong>功能</strong>：<ul>
<li>在指定位置插入内容。可以插入字符串、字符、整数、浮点数等各种数据类型。</li>
<li>例如，<code>StringBuilder sb = new StringBuilder(&quot;Hello&quot;); sb.insert(2, &quot;orld&quot;);</code>，此时<code>sb</code>的内容变为 “HeWorldllo”。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li>当需要在特定位置插入内容时使用。比如在编辑文本时，如果需要在特定位置插入一些补充信息，就可以使用这个方法。</li>
<li>例如，在一个文本编辑器中，用户可以在已有的文本中选择一个位置插入新的字符或字符串。</li>
</ul>
</li>
</ol>
<p><strong>三、delete () 方法</strong></p>
<ol>
<li><strong>功能</strong>：<ul>
<li>删除指定范围内的字符。可以指定起始索引和结束索引来确定要删除的字符范围。</li>
<li>例如，<code>StringBuilder sb = new StringBuilder(&quot;Hello World&quot;); sb.delete(5, 10);</code>，此时<code>sb</code>的内容变为 “Hello”，因为删除了从索引 5 到索引 10（不包括 10）的字符。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li>当需要删除部分字符串内容时使用。比如在处理用户输入的错误信息时，可以删除特定的错误部分。</li>
<li>例如，在一个表单验证程序中，如果用户输入了错误的格式，可以使用<code>StringBuilder</code>或<code>StringBuffer</code>来删除错误的部分，并插入正确的格式提示。</li>
</ul>
</li>
</ol>
<p><strong>四、reverse () 方法</strong></p>
<ol>
<li><strong>功能</strong>：<ul>
<li>将字符串反转。例如，“Hello” 反转后变为 “olleH”。</li>
<li>例如，<code>StringBuilder sb = new StringBuilder(&quot;Hello&quot;); sb.reverse();</code>，此时<code>sb</code>的内容变为 “olleH”。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li>在需要对字符串进行反转操作时使用。比如在某些加密算法中，可能需要对字符串进行反转处理。</li>
<li>例如，在一个简单的加密程序中，可以将用户输入的字符串反转后再进行其他加密操作。</li>
</ul>
</li>
</ol>
<p><strong>五、toString () 方法</strong></p>
<ol>
<li><strong>功能</strong>：<ul>
<li>将<code>StringBuilder</code>或<code>StringBuffer</code>对象转换为<code>String</code>类型。</li>
<li>例如，<code>StringBuilder sb = new StringBuilder(&quot;Hello&quot;); String str = sb.toString();</code>，此时<code>str</code>的内容为 “Hello”。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li>当需要将<code>StringBuilder</code>或<code>StringBuffer</code>对象作为字符串使用时，比如将其传递给需要<code>String</code>类型参数的方法。</li>
<li>例如，在一个打印输出的方法中，需要将<code>StringBuilder</code>对象转换为<code>String</code>类型才能进行打印。</li>
</ul>
</li>
</ol>
<ul>
<li>注意:<code>StringBuilder</code>是非线程安全的，在单线程环境下，它通常比<code>StringBuffer</code>效率更高</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-type">StringBuilder</span>();<span class="hljs-comment">//空构造器；但是实际上对数组进行了初始化，长度为16；</span><br>StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-type">StringBuilder</span>(<span class="hljs-number">4</span>);<span class="hljs-comment">//有参构造器，长度为4；</span><br>StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-type">StringBuilder</span>(<span class="hljs-string">&quot;dads&quot;</span>);<span class="hljs-comment">//有参构造器；字符串初始化为&quot;dads&quot;;长度为4+16；  实际操作为：super(str.length()+16);append(str)//str为传入的参数</span><br><br></code></pre></td></tr></table></figure>



<h3 id="11-6-System"><a href="#11-6-System" class="headerlink" title="11.6.System"></a>11.6.System</h3><h3 id="11-7-Runtime"><a href="#11-7-Runtime" class="headerlink" title="11.7.Runtime"></a>11.7.Runtime</h3><h3 id="11-8-Arrays类的使用"><a href="#11-8-Arrays类的使用" class="headerlink" title="11.8 Arrays类的使用"></a>11.8<code> Arrays类</code>的使用</h3><blockquote>
<p><code> import java.util.Arrays;</code></p>
</blockquote>
<ol>
<li><code>toString</code>方法</li>
</ol>
<blockquote>
<ul>
<li>数组转化为字符串，返回字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr =<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">24</span>,<span class="hljs-number">25</span>,<span class="hljs-number">26</span>,<span class="hljs-number">27</span>&#125;;<br>        String str=Arrays.toString(arr);<br>        System.out.println(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>结果：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">24</span>,<span class="hljs-number">25</span>,<span class="hljs-number">26</span>,<span class="hljs-number">27</span>]<br></code></pre></td></tr></table></figure>
</blockquote>
<ol start="2">
<li><code> binarySearch二分法查找</code></li>
</ol>
<blockquote>
<ul>
<li>找出指定<code> 有序</code>数组的指定元素对应的索引，返回int</li>
<li>binarysearch(arr,value);</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr =<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">24</span>,<span class="hljs-number">25</span>,<span class="hljs-number">26</span>,<span class="hljs-number">27</span>&#125;;<br>        <span class="hljs-type">int</span> index=Arrays.binarySearch(arr,<span class="hljs-number">26</span>);<br>        System.out.println(index);<br>        <span class="hljs-comment">//String str=Arrays.toString(arr);</span><br>        <span class="hljs-comment">//System.out.println(str);</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>注意：</p>
<blockquote>
<p><code> binarysearch</code>只能对有序数组进行查找，无序数组使用前应该进行<code>sort</code>排序</p>
</blockquote>
</li>
</ul>
</blockquote>
<ol start="3">
<li><code> sort排序</code></li>
</ol>
<blockquote>
<ul>
<li>对指定数组进行升序排序（从小到大）</li>
<li>sort(arr)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr =<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">22</span>,<span class="hljs-number">21</span>,<span class="hljs-number">26</span>,<span class="hljs-number">20</span>,<span class="hljs-number">29</span>,<span class="hljs-number">27</span>&#125;;<br>        Arrays.sort(arr);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:arr)<br>            System.out.print(x+<span class="hljs-string">&quot;\t&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-number">20</span>	<span class="hljs-number">21</span>	<span class="hljs-number">22</span>	<span class="hljs-number">26</span>	<span class="hljs-number">27</span>	<span class="hljs-number">29</span><br></code></pre></td></tr></table></figure>
</blockquote>
<ol start="4">
<li><code> copyOf复制</code>&#x2F;<code> copyOfRange区间复制</code></li>
</ol>
<blockquote>
<ul>
<li>将老数组按新的长度进行复制得到一个新数组</li>
<li>copyOf(arr,newlength)</li>
<li>copyOfRange(arr,pos1,pos2)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr =<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">22</span>,<span class="hljs-number">21</span>,<span class="hljs-number">26</span>,<span class="hljs-number">20</span>,<span class="hljs-number">29</span>,<span class="hljs-number">27</span>&#125;;<br>        <span class="hljs-type">int</span>[] arr1=Arrays.copyOf(arr,<span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:arr1)<br>            System.out.print(x+<span class="hljs-string">&quot;\t&quot;</span>);<br>        System.out.println();<br>        <span class="hljs-type">int</span>[] arr2=Arrays.copyOfRange(arr,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y:arr2)<br>        System.out.print(y+<span class="hljs-string">&quot;\t&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-number">22</span>	<span class="hljs-number">21</span>	<span class="hljs-number">26</span>	<span class="hljs-number">20</span>	<br><span class="hljs-number">26</span>	<span class="hljs-number">20</span>	<span class="hljs-number">29</span>	<br></code></pre></td></tr></table></figure>

<ul>
<li><p>注意：</p>
<blockquote>
<p>copyOfRange(arr,pos1,pos2),复制的区间为索引[pos1,pos2);</p>
<p>pos1取，pos2不取</p>
<p>和随机数一样左包含右不包含</p>
</blockquote>
</li>
</ul>
</blockquote>
<ol start="5">
<li><code> equals比较</code></li>
</ol>
<blockquote>
<ul>
<li>比较两个数组的值是否一样</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr1=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br><span class="hljs-type">int</span>[] arr2=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>System.out.println(Arrays.equals(arr1,arr2));<span class="hljs-comment">//true</span><br>System.out.println(arr1==arr2);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure>

<ul>
<li><pre><code class="Java">System.out.println(arr1==arr2);//比较的是两个数组的地址
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><br><br><span class="hljs-number">6</span>. 填充（`fill`）<br><br>- `Arrays.fill(int[] a, int val)`用于将数组`a`中的所有元素填充为`val`。<br><br>```java<br>       import java.util.Arrays<span class="hljs-comment">;</span><br><br>       public class Main &#123;<br>           public static void main(String[] args) &#123;<br>               int[] arr = <span class="hljs-keyword">new</span> int[<span class="hljs-number">5</span>]<span class="hljs-comment">;</span><br>               Arrays.fill(arr, <span class="hljs-number">10</span>)<span class="hljs-comment">;</span><br><span class="hljs-title">               for (int num :</span> arr) &#123;<br>                   System.out.print(num + <span class="hljs-string">&quot; &quot;</span>)<span class="hljs-comment">;</span><br>               &#125;<br>           &#125;<br>       &#125;<br>```<br><br>上述代码会将长度为 <span class="hljs-number">5</span> 的数组`arr`的所有元素填充为 <span class="hljs-number">10</span><br><br><br><br><span class="hljs-number">7</span>. 转换为List集合（`asList()`）<br><br>&gt;- `Arrays.asList()` 可以将一个数组或者多个参数转换成一个 `List` 集合。<br><br>&gt;~~~java<br>&gt;List&lt;String&gt; list=Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>,&#x27;b&#x27;,&#x27;c&#x27;)<span class="hljs-comment">;//将多个参数转化为List</span><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>上述代码通过 <code>Arrays.asList</code> 把三个字符串元素转换为了一个 <code>List</code> 集合。</p>
<p>不过需要注意：</p>
<ul>
<li><strong>不支持基本数据类型数组</strong>：<code>Arrays.asList</code> 只能接受 <code>Object</code> 类型的参数或者数组。如果传入基本数据类型数组，它会把数组当作一个 <code>Object</code> 类型元素，导致返回的 <code>List</code> 只有一个元素，即原始数组本身。</li>
<li><strong>返回的 <code>List</code> 具有固定大小</strong>：<code>Arrays.asList</code> 返回的 <code>List</code> 是 <code>Arrays</code> 类的一个内部类，它持有对原始数组的引用，大小固定，不支持调用 <code>add</code>、<code>remove</code>、<code>clear</code> 等修改集合大小的方法，否则会抛出 <code>UnsupportedOperationException</code> 异常 。但对该 <code>List</code> 的修改会反映到原始数组上，反之亦然。</li>
</ul>
</blockquote>
<ol start="8">
<li>转换为stream流</li>
</ol>
<blockquote>
<ul>
<li><code>Arrays.stream</code> 是 <code>java.util.Arrays</code> 类中的一个静态方法，它接受一个数组作为参数，并将该数组转换为一个 <code>Stream</code> 对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;Arrays.stream(Str.split(<span class="hljs-string">&quot;,&quot;</span>))<br></code></pre></td></tr></table></figure>

<p>这里将分割后的字符串数组转换为一个 <code>Stream&lt;String&gt;</code> 对象，方便后续的流操作。</p>
</blockquote>
<h3 id="11-9-Collections-类"><a href="#11-9-Collections-类" class="headerlink" title="11.9.Collections 类"></a>11.9.<code>Collections</code> 类</h3><p><code>Collections</code> 类位于 <code>java.util</code> 包下，提供了大量用于操作集合（如 <code>List</code>、<code>Set</code>、<code>Map</code> 等）的静态方法。</p>
<h4 id="常用方法分类及示例"><a href="#常用方法分类及示例" class="headerlink" title="常用方法分类及示例"></a>常用方法分类及示例</h4><h5 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h5><ul>
<li>**<code>sort(List&lt;T&gt; list)</code>**：对 <code>List</code> 集合中的元素进行自然排序，要求元素实现 <code>Comparable</code> 接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SortExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-number">3</span>);<br>        list.add(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-number">2</span>);<br>        Collections.sort(list);<br>        System.out.println(list); <span class="hljs-comment">// 输出: [1, 2, 3]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>**<code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>**：使用指定的比较器对 <code>List</code> 集合中的元素进行排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;, age=&quot;</span> + age + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SortWithComparatorExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Person&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">20</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">18</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">22</span>));<br><br>        Collections.sort(list, Comparator.comparingInt(Person::getAge));<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="查找和替换操作"><a href="#查找和替换操作" class="headerlink" title="查找和替换操作"></a>查找和替换操作</h5><ul>
<li>**<code>max(Collection&lt;? extends T&gt; coll)</code>**：返回集合中的最大元素，元素需实现 <code>Comparable</code> 接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-number">3</span>);<br>        list.add(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Collections.max(list);<br>        System.out.println(max); <span class="hljs-comment">// 输出: 3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>**<code>replaceAll(List&lt;T&gt; list, T oldVal, T newVal)</code>**：将 <code>List</code> 集合中所有指定的旧值替换为新值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReplaceAllExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-number">2</span>);<br>        list.add(<span class="hljs-number">1</span>);<br>        Collections.replaceAll(list, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>        System.out.println(list); <span class="hljs-comment">// 输出: [3, 2, 3]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h5><ul>
<li>**<code>synchronizedList(List&lt;T&gt; list)</code>**：返回指定列表的同步（线程安全的）列表。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedListExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; synList = Collections.synchronizedList(list);<br>        <span class="hljs-comment">// 在多线程环境下可以安全使用 synList</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="12-IO流"><a href="#12-IO流" class="headerlink" title="12.IO流"></a>12.IO流</h2><ul>
<li><p>File类：封装文件&#x2F;目录的各种信息，对文件&#x2F;目录进行操作，但是我们不可以获取到文件&#x2F;目录中的内容。</p>
</li>
<li><p>I&#x2F;O流：Input&#x2F;Output的缩写，用于对设备之间的数据传输</p>
<p><img src="/.com//image-20241112190146403.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<p>try-catch捕获异常，finally最后关闭流</p>
<p><img src="/.com//image-20241127200033060.png" srcset="/img/loading.gif" lazyload alt="image-20241127200033060"></p>
<ul>
<li>FileReader,FileWriter完成文本复制(字符-文本类)一个一个</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">File f1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:\\temporymemory\\user.txt&quot;</span>);<br>File f2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:\\temporymemory\\message.txt&quot;</span>);<br>FileReader fr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(f1);<br>FileWriter fw=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(f2);<br><span class="hljs-comment">//一个字符一个字符进行读写，返回-1表示文件结尾</span><br><span class="hljs-type">int</span> n=fr.read();<br><span class="hljs-keyword">while</span>(n!=-<span class="hljs-number">1</span>)&#123;<br>fw.write(n);<br>n=fr.read();<br>&#125;<br><span class="hljs-comment">//利用缓冲字符数组</span><br><span class="hljs-type">char</span>[] ch=<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> len=ch;<br><span class="hljs-keyword">while</span>(len!=-<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//String s=new String(ch,0,len);</span><br>fr.write(ch,<span class="hljs-number">0</span>,len);<span class="hljs-comment">//fr.write(s);</span><br>len=fr.read(ch);<br>&#125;<br><span class="hljs-comment">//关闭流；先用的后关</span><br>fw.close();<br>fr.close();<br><br></code></pre></td></tr></table></figure>


</blockquote>
<ul>
<li>FileInputStream,FileOutputStream完成非文本复制（字节-图片类）</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">File f1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;path&quot;</span>);<br>File f2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;path2&quot;</span>);<br>FileInputStream fis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(f1);<br>FileOutputStream fos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(f2);<br><span class="hljs-comment">//文件是Utf-8存储，英文占一个字节，中文占三个字节</span><br><span class="hljs-type">int</span> n=fis.read();<br><span class="hljs-keyword">while</span>(n!=-<span class="hljs-number">1</span>)&#123;<br>fos.write(n);<br>n=fis.read();<br>&#125;<br><span class="hljs-comment">//利用缓存数组</span><br><span class="hljs-type">byte</span>[] b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">8</span>]；<br><span class="hljs-type">int</span> len=fis.read(b);<br><span class="hljs-keyword">while</span>(len！=-<span class="hljs-number">1</span>)&#123;<br>fos.write(b,<span class="hljs-number">0</span>,len);<br>len=fis.read(b);<br>&#125;<br><br><span class="hljs-comment">//关闭流，先用后关</span><br>fos.close();<br>fin.close();<br></code></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>BufferedInputStream,BufferedOutputStream（缓冲字节处理流）</p>
</li>
<li><p>作用：可以提高字节流的读写性能</p>
</li>
<li><blockquote>
<p>通过缓冲池减少系统调用的次数</p>
<p>原理：缓冲字节流自带了8kb的缓冲池；缓冲字节输出流也自带了8kb的缓冲池</p>
</blockquote>
</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">//功能加强，在FileInputStream和FileOutputStream外面套一个管BufferedInputStream和BufferedOutputStream</span><br>&gt;BufferedInputStream bis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis);<br>&gt;BufferedOutputStream bos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fos);<br>&gt;<span class="hljs-type">byte</span>[] b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">8</span>];<br>&gt;<span class="hljs-type">int</span> len=bis.read(b);<br>&gt;<span class="hljs-keyword">while</span>(len!=-<span class="hljs-number">1</span>)&#123;<br>&gt;bos.write(b,<span class="hljs-number">0</span>,len);<br>&gt;len=bis.read(b);<br>&gt;&#125;<br>&gt;<span class="hljs-comment">//关闭流；先开后关</span><br>&gt;bos.close();<br>&gt;bis.close();<br>&gt;fos.close();<br>&gt;fis.close();<br></code></pre></td></tr></table></figure>




</blockquote>
<ul>
<li>BufferedReader,BufferedWriter完成文本复制（缓冲字符处理流）一行一行</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">File f1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;path&quot;</span>);<br>File f2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;path2&quot;</span>);<br>BufferedReader fr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlieReader</span>(f1));<span class="hljs-comment">//参数是FileReader</span><br>BufferedWriter fw=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(f2));<span class="hljs-comment">//参数是FileWriter</span><br><span class="hljs-comment">//BufferedWriter fw=bufferedWriter(new FileWriter(f2,true))//追加模式写</span><br><span class="hljs-comment">//一行一行的读，写</span><br>String str;<br><span class="hljs-keyword">while</span>((str=fr.readerline())!=<span class="hljs-literal">null</span>)<span class="hljs-comment">//读取</span><br>&#123;<br> fw.write(str);<span class="hljs-comment">//此时写在缓冲区</span><br> fw.newline();<span class="hljs-comment">//换行</span><br>&#125;<br>fw.flush();<span class="hljs-comment">//写入磁盘</span><br>fw.close();<br>fr.close();<br></code></pre></td></tr></table></figure>

<p>案例：<img src="/.com//image-20241127202555955.png" srcset="/img/loading.gif" lazyload alt="image-20241127202555955"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedTset</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">try</span>( BufferedReader br=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;path&quot;</span>));<br>              BufferedWriter bw=<span class="hljs-keyword">new</span> <span class="hljs-title class_">bufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlieWriter</span>(<span class="hljs-string">&quot;path1&quot;</span>));<br>             )<span class="hljs-comment">//资源放在try-catch块中，自动刷新关闭释放</span><br>            &#123;<br>                List&lt;String&gt; data=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                String line;<span class="hljs-comment">//读出加入到List容器</span><br>                <span class="hljs-keyword">while</span>((line=br.readline())!=<span class="hljs-literal">null</span>) data.add(line);<br>            &#125;<br>        Collection.sort(data);<span class="hljs-comment">//排序</span><br>        System.out.println(adta);<br>        <span class="hljs-comment">//写入</span><br>        <span class="hljs-keyword">for</span>(String s:data)&#123;<br>            bw.Writer(s);<br>            bw.newLine();<span class="hljs-comment">//换行</span><br>        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>原始流、缓冲流的性能分析</li>
</ul>
<blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br></code></pre></td></tr></table></figure>


</blockquote>
<ul>
<li><p>将文件转成字节数组</p>
</li>
<li><p>序列化和反序列化IO</p>
</li>
</ul>
<h2 id="13-集合-容器"><a href="#13-集合-容器" class="headerlink" title="13.集合(容器)"></a>13.集合(容器)</h2><ul>
<li>基本体系</li>
<li><img src="/.com//image-20241104155653318.png" srcset="/img/loading.gif" lazyload alt="image-20241104155653318"></li>
</ul>
<h3 id="13-1-Collection接口-List可以添加重复元素，Set不能"><a href="#13-1-Collection接口-List可以添加重复元素，Set不能" class="headerlink" title="13.1.Collection接口(List可以添加重复元素，Set不能)"></a>13.1.Collection接口(List可以添加重复元素，Set不能)</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><code>Collection</code> 是 Java 集合框架中的一个接口，它是所有单列集合类的根接口，定义了集合的基本操作方法，如添加元素、删除元素、判断集合是否为空等。它派生了许多子接口，如 <code>List</code>、<code>Set</code> 和 <code>Queue</code> 等，这些子接口又有各自的具体实现类。</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><p><code>add(E e)</code>：向集合中添加一个元素。</p>
</li>
<li><p><code>remove(Object o)</code>：从集合中移除指定的元素。</p>
</li>
<li><p><code>contains(Object o)</code>：判断集合中是否包含指定的元素。</p>
</li>
<li><p><code>size()</code>：返回集合中元素的数量。</p>
</li>
<li><p><code>isEmpty()</code>：判断集合是否为空。</p>
</li>
<li><p>集合有个特点：只能存放引用数据类型，不能是基本数据类型</p>
</li>
<li><p>遍历集合</p>
</li>
</ul>
<blockquote>
<ul>
<li><pre><code class="java">//对集合遍历，查看元素
        Integer[] i=new Integer[]&#123;11,12,13,14,15&#125;;
        col.addAll(Arrays.asList(i));
        System.out.println(col);
//for (int j=0;j&lt;col.size();j++)&#123;//普通for循环
//    col.
//&#125; 无通过索引找元素的方法
        //增强for循环
        col.add(&quot;abc&quot;);
        for(Object L:col)&#123;//只能用Object接收，集合中包含不同的元素
            System.out.println(L);
        &#125;
//通过迭代器iterator对集合进行遍历
        System.out.println(col.iterator());
        Iterator iterator=col.iterator();
        while (iterator.hasNext())&#123;//通过haxNext()放啊来判断是否下一个元素；如果有返回true
            System.out.println(iterator.next());//next()方法将元素获取到；并且将指针下移
        &#125;
    
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">  <br>- 通过迭代器iterator对集合进行遍历；haxNext()放啊来判断是否下一个元素；如果有返回<span class="hljs-keyword">true</span>；next()方法将元素获取到；并且将指针下移<br><br>- 注意：增强<span class="hljs-keyword">for</span>循环是一种语法糖（一种简化的语法）；它简化了遍历集合或数组的代码，但底层的实现还是依赖于迭代器或者类似的机制。<br><br>### <span class="hljs-number">13.2</span>.List接口<br><br>- 元素可重复<br>- 有序，有索引<br><br>- &gt;- 常用方法<br><br> &gt;- ~~~Java<br>  //增：<span class="hljs-keyword">add</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>,E element)  <br>   //删：remove(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>)  remove(<span class="hljs-keyword">Object</span> o)<br>   //改:<span class="hljs-keyword">set</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>,E element) <br>   //查：<span class="hljs-keyword">get</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>)<br>   //判断：与Collection一致<br>                                                                      <br>        //增：<span class="hljs-keyword">add</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>,E element)<br>   //删：remove(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>)  remove(<span class="hljs-keyword">Object</span> o)<br>   //改:<span class="hljs-keyword">set</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>,E element)<br>   //查：<span class="hljs-keyword">get</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>)<br>   //判断：<br>   List list=<span class="hljs-built_in">new</span> ArrayList();//接口引用实现类<br>   list.<span class="hljs-keyword">add</span>(<span class="hljs-number">12</span>);//element<br>   list.<span class="hljs-keyword">add</span>(<span class="hljs-number">17</span>);<br>   list.<span class="hljs-keyword">add</span>(<span class="hljs-number">13</span>);<br>   <span class="hljs-type">Integer</span>[] i=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>   list.addAll(Arrays.asList(i));<br>   <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(list);//[<span class="hljs-number">12</span>, <span class="hljs-number">17</span>, <span class="hljs-number">13</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>   list.<span class="hljs-keyword">add</span>(<span class="hljs-number">0</span>,<span class="hljs-number">66</span>);//在索引为<span class="hljs-number">0</span>处添加<span class="hljs-number">66</span><br>   <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(list);//[<span class="hljs-number">66</span>, <span class="hljs-number">12</span>, <span class="hljs-number">17</span>, <span class="hljs-number">13</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>   list.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span>,<span class="hljs-number">77</span>);//把索引为<span class="hljs-number">0</span>的元素改为<span class="hljs-number">77</span><br>   <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(list);//[<span class="hljs-number">77</span>, <span class="hljs-number">12</span>, <span class="hljs-number">17</span>, <span class="hljs-number">13</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>   list.remove(<span class="hljs-number">2</span>);//在集合在存入的是<span class="hljs-type">Integer</span>数据类型时，删除的是对应索引的元素<br>   <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(list);//[<span class="hljs-number">77</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>   list.<span class="hljs-keyword">add</span>(<span class="hljs-number">2</span>,&quot;asdasd&quot;);<br>   list.remove(&quot;asdasd&quot;);//其它数据类型直接删除对应元素，而非对应索引的元素<br>   <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(list);//[<span class="hljs-number">77</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>   <span class="hljs-keyword">Object</span> o=list.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);//返回传入索引的对应元素<br>   <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(o);//<span class="hljs-number">77</span><br>   //遍历<br>        //普通<span class="hljs-keyword">for</span>循环<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt; list.size();j++)&#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(list.<span class="hljs-keyword">get</span>(j));<br>        &#125;<br>        //强制<span class="hljs-keyword">for</span>循环<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">Object</span> obj:list) <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(obj);<br>        //迭代器Iterator<br>        Iterator iterator=list.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext())<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(iterator.next());<br><br><br>~~~Java<br> &gt;- 与Collection相比多了通过索引增加和删除以及查看；如此一来就能通过普通<span class="hljs-keyword">for</span>循环遍历<br> &gt;- 扩展方法都和索引相关<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</blockquote>
<ul>
<li><p><img src="/.com//image-20241222155322256.png" srcset="/img/loading.gif" lazyload alt="image-20241222155322256"></p>
<ul>
<li><p><strong><code>void remove()          删除集合中调用next()返回的对象</code></strong></p>
</li>
<li><p>Iterator 是一个接口，用于遍历集合中的元素。</p>
</li>
<li><p>haxNext()方法来判断是否下一个元素；如果有返回true；next()方法将元素获取到；并且将指针下移</p>
</li>
<li><p>迭代器遍历完毕，指针不会复位，可以获取一个新的迭代器对象进行再次遍历</p>
</li>
<li><p>循环中只能用一次next（），因为hasNext()只能保证下一个元素存在，下下个元素无法确定。</p>
</li>
<li><p>迭代器遍历时，不能使用集合的方法进行增删操作，迭代器在遍历集合时，会维护一个内部的状态来跟踪集合的结构。如果在迭代过程中使用集合的方法（如 <code>add()</code>、<code>remove()</code> 等）对集合进行增删操作，会破坏迭代器的内部状态，导致迭代器无法正确跟踪集合的元素，从而可能抛出 <code>ConcurrentModificationException</code> 异常。</p>
</li>
<li><p><strong><code>Iterator Iterable  ListIterator  区别</code></strong></p>
</li>
<li><p>早期只有Iterator接口，提供对集合进行遍历的方法，在jdk1.8后，引入Iterable接口，在Iterable接口代码中也提供了Iterator接口，实现该接口的集合依然可以使用迭代器遍历，此外还提供forEach()方法支持增强for循环，底层依然使用迭代器进行遍历。</p>
</li>
<li><p>ListIterator存在与List集合中，通过调用方法可以返回<strong>起始下标</strong>为 <code>index</code>的迭代器，大多数方法与 Iterator 中定义的含义相同，但是比 Iterator 强大的地方是可以在<strong>任意一个下标位置</strong>返回该迭代器，且可以实现<strong>双向遍历</strong>。</p>
</li>
<li><pre><code class="Java">List&lt;Integer&gt; list=new ArrayList&lt;&gt;();
ListIterator&lt;Integer&gt; listInter1=list.listIterator();//返回索引为0的迭代器
ListIterator&lt;Integer&gt; listInter2=list.listIterator(5);//返回索引为5的迭代器
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp">  <br>- ~~~java<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ListIterator</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-title">extends</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; &#123;<br>      <span class="hljs-function">boolean <span class="hljs-title">hasNext</span>()</span>;<br>      <span class="hljs-function">E <span class="hljs-title">next</span>()</span>;<br>      <span class="hljs-function">boolean <span class="hljs-title">hasPrevious</span>()</span>;<br>      <span class="hljs-function">E <span class="hljs-title">previous</span>()</span>;<br>      <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">nextIndex</span>()</span>;<br>      <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">previousIndex</span>()</span>;<br>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span>()</span>;<br>      <span class="hljs-comment">// 替换当前下标的元素,即访问过的最后一个元素</span><br>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span>(<span class="hljs-params">E e</span>)</span>;<br>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span>(<span class="hljs-params">E e</span>)</span>;<br>  &#125;<br>  <br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="1-ArrayList实现类"><a href="#1-ArrayList实现类" class="headerlink" title="1.ArrayList实现类"></a>1.ArrayList实现类</h4><ul>
<li><blockquote>
<ul>
<li>动态数组（<code>Object[] elementData</code>）</li>
<li>常用方法与List相近</li>
<li>第一次扩容到十（使用无参构造器没有指定大小的情况下），第二次扩容到1.5倍</li>
</ul>
</blockquote>
</li>
</ul>
<ol>
<li><strong>ArrayList 概述</strong><ul>
<li>ArrayList 是 Java 集合框架中的一个重要类，它位于<code>java.util</code>包中。它实现了<code>List</code>接口，这意味着它具有<code>List</code>接口所定义的所有方法，例如可以通过索引访问元素、可以包含重复元素等特点。</li>
<li>ArrayList 本质上是一个动态大小的数组。它提供了方便的方法来添加、删除和访问元素，并且会自动调整大小以适应存储元素的数量变化。与普通数组相比，ArrayList 更加灵活，因为不需要在创建时指定固定的大小。</li>
</ul>
</li>
<li><strong>创建 ArrayList 对象</strong><ul>
<li>可以使用以下方式创建一个空的 ArrayList：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>



<ul>
<li>这里创建了一个可以存储<code>String</code>类型元素的 ArrayList。<code>&lt;String&gt;</code>是 Java 泛型的语法，用于指定列表中元素的类型。如果不使用泛型，ArrayList 可以存储任何类型的对象，但这样容易导致类型安全问题。例如，以下代码会在编译时产生警告：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ArrayList</span> <span class="hljs-variable">listWithoutGeneric</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>listWithoutGeneric.add(<span class="hljs-string">&quot;String&quot;</span>);<br>listWithoutGeneric.add(<span class="hljs-number">123</span>);  <span class="hljs-comment">// 可以添加不同类型的元素，可能导致问题</span><br></code></pre></td></tr></table></figure>



<ol>
<li>添加元素到 ArrayList<ul>
<li>使用<code>add</code>方法可以将元素添加到 ArrayList 中。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; stringList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>stringList.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>stringList.add(<span class="hljs-string">&quot;World&quot;</span>);<br></code></pre></td></tr></table></figure>



<ul>
<li>还可以在指定位置添加元素。例如，将一个元素插入到索引为 1 的位置：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stringList.add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Java&quot;</span>);<br></code></pre></td></tr></table></figure>



<ul>
<li>此时，<code>stringList</code>的内容为<code>[&quot;Hello&quot;, &quot;Java&quot;, &quot;World&quot;]</code>。需要注意的是，如果指定的索引超出了当前列表的范围（例如，索引大于列表的大小），会抛出<code>IndexOutOfBoundsException</code>异常。</li>
</ul>
<ol>
<li>访问 ArrayList 中的元素<ul>
<li>可以通过索引来访问 ArrayList 中的元素，就像访问数组元素一样。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> stringList.get(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 获取索引为0的元素，这里是&quot;Hello&quot;</span><br></code></pre></td></tr></table></figure>



<ul>
<li>如果使用了非法的索引（例如，负数或大于等于列表大小的数），会抛出<code>IndexOutOfBoundsException</code>异常。</li>
</ul>
<ol>
<li>修改 ArrayList 中的元素<ul>
<li>通过索引和<code>set</code>方法可以修改 ArrayList 中的元素。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stringList.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;Hi&quot;</span>);<br></code></pre></td></tr></table></figure>



<ul>
<li>此时，<code>stringList</code>的第一个元素被修改为<code>Hi</code>。同样，使用非法的索引会导致<code>IndexOutOfBoundsException</code>异常。</li>
</ul>
<ol>
<li>删除 ArrayList 中的元素<ul>
<li>可以使用<code>remove</code>方法来删除元素。如果知道元素的索引，可以这样删除：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stringList.remove(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>



<ul>
<li>这会删除索引为 1 的元素。如果知道元素本身的值，也可以删除：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> stringList.remove(<span class="hljs-string">&quot;World&quot;</span>);<br></code></pre></td></tr></table></figure>



<ul>
<li><code>result</code>的值为<code>true</code>表示元素被成功删除，<code>false</code>表示列表中不存在该元素。</li>
</ul>
<ol>
<li>遍历 ArrayList<ul>
<li>使用 for 循环遍历<ul>
<li>通过索引来遍历 ArrayList，这种方式类似于遍历数组。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stringList.size(); i++) &#123;<br>    System.out.println(stringList.get(i));<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>使用增强 for 循环遍历<ul>
<li>这种方式更简洁，不需要使用索引。底层也是使用迭代器遍历，是一个语法糖，方便简洁的使用。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String str : stringList) &#123;<br>    System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li><p>使用迭代器遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;String&gt; iterator = stringList.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>    System.out.println(iterator.next());<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><strong>ArrayList 的容量和大小</strong><ul>
<li>ArrayList 有一个容量（<code>capacity</code>）的概念，它表示底层数组的大小。当添加元素导致元素数量超过当前容量时，ArrayList 会自动扩容。例如，初始容量可能是 10，当添加第 11 个元素时，ArrayList 会创建一个新的、更大的数组，并将原来的元素复制到新数组中。</li>
<li>可以使用<code>size</code>方法来获取 ArrayList 中实际元素的数量。例如，<code>stringList.size()</code>返回<code>stringList</code>中元素的个数。</li>
</ul>
</li>
<li><strong>与其他集合的比较和转换</strong><ul>
<li>与<code>LinkedList</code>相比，ArrayList 在随机访问（通过索引访问元素）方面性能更好，因为它内部是基于数组实现的；而 LinkedList 在插入和删除操作（特别是在列表中间进行操作）时性能更好，因为它是基于链表实现的。</li>
<li>ArrayList 可以方便地与其他集合进行转换。例如，将 ArrayList 转换为数组：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] array = stringList.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[stringList.size()]);<br></code></pre></td></tr></table></figure>



<ul>
<li>也可以将数组转换为 ArrayList，例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] anotherArray = &#123;<span class="hljs-string">&quot;One&quot;</span>, <span class="hljs-string">&quot;Two&quot;</span>, <span class="hljs-string">&quot;Three&quot;</span>&#125;;<br>ArrayList&lt;String&gt; newList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(anotherArray));<br></code></pre></td></tr></table></figure>

<ul>
<li><p>部分核心源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArrayList</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> Object[] elementData;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyArrayList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[DEFAULT_CAPACITY];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);<br>        elementData[size++] = e;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>) &#123;<br>            grow(minCapacity);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>) &#123;<br>            newCapacity = minCapacity;<br>        &#125;<br>        elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        rangeCheck(index);<br>        <span class="hljs-keyword">return</span> (E) elementData[index];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheck</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;Index: &quot;</span> + index + <span class="hljs-string">&quot;, Size: &quot;</span> + size);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2.LinkedList"></a>2.LinkedList</h4><ul>
<li>LinkedList底层是基于双向链表存储数据的</li>
</ul>
<blockquote>
<ul>
<li>双向链表（<code>Node&lt;E&gt; </code>值，前驱结点，后继结点）</li>
<li>无论查询哪个数据都要从头开始找或者从尾部开始</li>
<li>增删相对快</li>
<li>对首尾元素进行增删改查速度快</li>
<li>占用内存多，使用场景少</li>
<li>同时实现了Deque接口，具有双端队列的特性</li>
</ul>
</blockquote>
<p><img src="/.com//image-20241221192020851.png" srcset="/img/loading.gif" lazyload alt="image-20241221192020851"></p>
<ul>
<li><p>总结：</p>
</li>
<li><p>优势：LinkedList 底层没有<code>扩容机制</code>，使用<code>双向链表</code>存储元素，所以插入和删除元素效率较高，适用于频繁操作元素的场景</p>
</li>
<li><p>劣势：LinkedList 不具备<code>随机访问</code>的特点，查找某个元素只能从 <code>head</code> 或 <code>tail</code> 指针一个一个比较，所以<strong>查找中间的元素时效率很低</strong></p>
</li>
<li><p>部分核心源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> Node&lt;E&gt; first;<br>    <span class="hljs-keyword">private</span> Node&lt;E&gt; last;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        E item;<br>        Node&lt;E&gt; next;<br>        Node&lt;E&gt; prev;<br><br>        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>            <span class="hljs-built_in">this</span>.item = element;<br>            <span class="hljs-built_in">this</span>.next = next;<br>            <span class="hljs-built_in">this</span>.prev = prev;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        linkLast(e);<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);<br>        last = newNode;<br>        <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>) &#123;<br>            first = newNode;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l.next = newNode;<br>        &#125;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        checkElementIndex(index);<br>        <span class="hljs-keyword">return</span> node(index).item;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkElementIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isElementIndex(index)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;Index: &quot;</span> + index + <span class="hljs-string">&quot;, Size: &quot;</span> + size);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isElementIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; size;<br>    &#125;<br><br>    Node&lt;E&gt; <span class="hljs-title function_">node</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>            Node&lt;E&gt; x = first;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>                x = x.next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Node&lt;E&gt; x = last;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt; index; i--) &#123;<br>                x = x.prev;<br>            &#125;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-Vector-Stack"><a href="#3-Vector-Stack" class="headerlink" title="3.Vector&#x2F;Stack"></a>3.Vector&#x2F;Stack</h4><ul>
<li><p>Vector 在现在已经是一种过时的集合了，包括继承它的 Stack 集合也如此，它们被淘汰的原因都是因为性能低下。</p>
</li>
<li><p>JDK 1.0 时代，ArrayList 还没诞生，大家都是使用 Vector 集合，但由于 Vector 的每个操作都被 synchronized 关键字修饰，即使在线程安全的情况下，仍然进行无意义的加锁与释放锁，造成额外的性能开销，做了无用功。<br>在 JDK 1.2 时，Collection 家族出现了，它提供了大量高性能、适用於不同场合的集合，而 Vector 也是其中一员，但由于 Vector 在每个方法上都加了锁，由于需要兼容许多老的项目，很难在此基础上优化Vector了，所以渐渐地也就被历史淘汰了。</p>
</li>
</ul>
<p>现在，在线程安全的情况下，不需要选用 Vector 集合，取而代之的是 ArrayList 集合；在并发环境下，出现了 CopyOnWriteArrayList，Vector 完全被弃用了。同样Stack也被弃用了</p>
<h4 id="4-CopyOnWriteArrayList"><a href="#4-CopyOnWriteArrayList" class="headerlink" title="4.CopyOnWriteArrayList"></a>4.CopyOnWriteArrayList</h4><h3 id="13-5-Set接口"><a href="#13-5-Set接口" class="headerlink" title="13.5.Set接口"></a>13.5.Set接口</h3><ul>
<li>无序（添加顺序和获取出的数据顺序不一致）</li>
<li>不重复</li>
<li>无索引</li>
</ul>
<blockquote>
<ul>
<li>HashSet:无序、不重复、无索引、底层利用HashMap（构造函数直接new HashMap）</li>
<li>LinkedHashSet:有序、不重复、无索引、底层利用LinkedHashMap(继承)</li>
<li>TreeSet:排序（比较器和排序接口）、不重复、无索引、底层利用TreeMap</li>
</ul>
</blockquote>
<ul>
<li><p>注意set接口用到的常用方法，基本上就是Collection提供的，自己几乎没有额外新增的一些常用功能</p>
</li>
<li><p>HashSet集合的底层原理</p>
</li>
<li><blockquote>
<p>哈希值</p>
<ul>
<li><p>Java中所有对象都有一个哈希值，都可以调用Object提供的hashCode方法，返回对象自己的哈希值</p>
</li>
<li><pre><code class="Java">public int hashCode():返回对象的哈希码值
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>- 同一个对象调用该方法返回的哈希值是相同的<br><br>- 不同的对象，他们的哈希值大概率不一样。<span class="hljs-type">int</span>(<span class="hljs-number">-21</span>亿多到<span class="hljs-number">21</span>亿多，当对象个数超过可能会出现哈希碰撞，但是几乎不可能)<br><br>基于哈希表HashMap实现<br><br>- JDK8之前的哈希表：数组+链表<br><br>- ~~~Java<br>  <span class="hljs-keyword">Set</span>&lt;String&gt; <span class="hljs-keyword">set</span>=<span class="hljs-built_in">new</span> HashSet&lt;&gt;();<br>  //构造函数直接<span class="hljs-built_in">new</span>一个hashmap<br>  <span class="hljs-keyword">set</span>.<span class="hljs-keyword">add</span>(&quot;数据1&quot;);//第一次加数据，创建一个默认长度为<span class="hljs-number">16</span>的数组，默认加载因子为<span class="hljs-number">0.75</span>，使用元素的哈希值对数组长度做运算计算出应该存入的位置<br>  //后续加入数据先判断该位置是否为<span class="hljs-keyword">null</span>，如果是<span class="hljs-keyword">null</span>则直接存入，如果不是<span class="hljs-keyword">null</span>，表示有元素，则调用equals方法比较，相等不存，不相等则存入数据<br>  //<span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> <span class="hljs-keyword">add</span>(E e) &#123;<br>      <span class="hljs-keyword">return</span> this.map.put(e, PRESENT) == <span class="hljs-keyword">null</span>;<br>  &#125;//我们看到 PRESENT 就是一个静态常量：使用 PRESENT 作为 HashMap 的 <span class="hljs-keyword">value</span> 值，使用HashSet的开发者只需关注于需要插入的 key，屏蔽了 HashMap 的 <span class="hljs-keyword">value</span><br>                                                                    <br></code></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>JDK开始，当链表长度超过8，且数组长度超过64时，自动将链表转成红黑树</p>
</li>
<li><p>红黑树</p>
</li>
<li><blockquote>
<ul>
<li>自平衡的二叉排序树（左右子树的高度差不超过一的排序树（左根右））</li>
<li>根叶黑：根结点和叶子结点视为黑色（叶子结点是树底部的空结点）</li>
<li>不红红：没有连续的红色结点</li>
<li>黑路同：每一条到叶子结点的路径上黑色结点数量相同</li>
<li>高度差不超过两倍</li>
<li>插入删除比平衡二叉搜索树快，查询比平衡二叉搜索树慢</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>HashSet和TreeSet分别如何实现去重的</p>
<ul>
<li>HashSet的去重机制：hashcode()+equals(),底层先通过存入对象，进行运算得到一个hash值，通过hash值得到对应的索引，如果发现table索引所在的位置没有数据，就直接存放，如果有数据，就进行equals比较，如果比较后，不相同就加入，否则不加入。</li>
<li>TreeSet的去重机制：如果你传入了一个Comparator匿名对象，就使用实现的compare去重，如果方法返回0，就认为是重复元素，就不添加，如果你没有传入一个比较器，则以添加的对象实现的Compareable接口的compareTo去重。同理，如果TreeSet在初始化的时候没有传入比较器，那么在后续添加元素是，元素必须是实现了Comparable接口的元素，否则报ClassCastException.</li>
<li><img src="/.com//image-20250222235931156.png" srcset="/img/loading.gif" lazyload alt="image-20250222235931156"></li>
</ul>
</li>
</ul>
<h3 id="13-6-Map接口"><a href="#13-6-Map接口" class="headerlink" title="13.6.Map接口"></a>13.6.Map接口</h3><ul>
<li>Map接口定义了存储的数据结构是键值对&lt;key,value&gt;形式，根据key映射到value，一个key对应一个value</li>
<li>分为两类：<ul>
<li>SortedMap接口：可按自己的规则排序</li>
<li>AbsractMap抽象类：为子类提供模板（通用的API实现）</li>
</ul>
</li>
</ul>
<p><img src="/.com//image-20250221233439364.png" srcset="/img/loading.gif" lazyload alt="image-20250221233439364"></p>
<p>以下是 <code>Map</code> 接口中一些常用的方法：</p>
<ul>
<li><p>添加元素</p>
<ul>
<li><code>V put(K key, V value)</code>：将指定的键值对插入到 <code>Map</code> 中。如果键已经存在，则会覆盖旧值，并返回旧值；如果键不存在，则返回 <code>null</code>。</li>
<li><code>void putAll(Map&lt;? extends K, ? extends V&gt; m)</code>：将指定 <code>Map</code> 中的所有键值对复制到当前 <code>Map</code> 中。</li>
</ul>
</li>
<li><p>获取元素</p>
<ul>
<li><code>V get(Object key)</code>：根据指定的键获取对应的值。如果键不存在，则返回 <code>null</code>。</li>
<li><code>boolean containsKey(Object key)</code>：判断 <code>Map</code> 中是否包含指定的键。</li>
<li><code>boolean containsValue(Object value)</code>：判断 <code>Map</code> 中是否包含指定的值。</li>
</ul>
</li>
<li><p>删除元素</p>
<ul>
<li><code>V remove(Object key)</code>：根据指定的键删除对应的键值对，并返回被删除的值。如果键不存在，则返回 <code>null</code>。</li>
<li><code>void clear()</code>：清空 <code>Map</code> 中的所有键值对。</li>
</ul>
</li>
<li><p>获取大小和判断是否为空</p>
<ul>
<li><code>int size()</code>：返回 <code>Map</code> 中键值对的数量。</li>
<li><code>boolean isEmpty()</code>：判断 <code>Map</code> 是否为空。</li>
</ul>
</li>
<li><p>获取键集、值集和键值对集</p>
<ul>
<li><code>Set&lt;K&gt; keySet()</code>：返回 <code>Map</code> 中所有键组成的 <code>Set</code> 集合。</li>
<li><code>Collection&lt;V&gt; values()</code>：返回 <code>Map</code> 中所有值组成的 <code>Collection</code> 集合。</li>
<li><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code>：返回 <code>Map</code> 中所有键值对组成的 <code>Set</code> 集合，其中 <code>Map.Entry</code> 是一个表示键值对的接口。<code>Map</code> 实现类（如 <code>HashMap</code>）通过创建实现了 <code>Map.Entry</code> 接口的具体类（如 <code>Node</code>）的对象来存储键值对。<code>entrySet()</code> 方法会返回一个包含所有这些 <code>Map.Entry</code> 对象的 <code>Set</code> 集合，从而允许用户遍历 <code>Map</code> 中的所有键值对。</li>
</ul>
</li>
<li><p>对Map进行快速遍历</p>
<blockquote>
<ul>
<li><strong>使用 <code>keySet()</code> 遍历键，再通过键获取值</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">import</span> java.util.HashMap;<br>&gt;<span class="hljs-keyword">import</span> java.util.Map;<br><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapTraversalExample</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>      map.put(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">1</span>);<br>      map.put(<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">2</span>);<br>      <span class="hljs-keyword">for</span> (String key : map.keySet()) &#123;<br>          System.out.println(key + <span class="hljs-string">&quot;: &quot;</span> + map.get(key));<br>      &#125;<br>  &#125;<br>&gt;&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>使用 <code>entrySet()</code> 遍历键值对</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">import</span> java.util.HashMap;<br>&gt;<span class="hljs-keyword">import</span> java.util.Map;<br><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapTraversalExample2</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>      map.put(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">1</span>);<br>      map.put(<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">2</span>);<br>      <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;<br>          System.out.println(entry.getKey() + <span class="hljs-string">&quot;: &quot;</span> + entry.getValue());<br>      &#125;<br>  &#125;<br>&gt;&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>使用 <code>forEach()</code> 方法遍历</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">import</span> java.util.HashMap;<br>&gt;<span class="hljs-keyword">import</span> java.util.Map;<br><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapTraversalExample3</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>      map.put(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">1</span>);<br>      map.put(<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">2</span>);<br>      map.forEach((key, value) -&gt; System.out.println(key + <span class="hljs-string">&quot;: &quot;</span> + value));<br>  &#125;<br>&gt;&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>使用<code>Stream API</code>：Java 8 引入的Stream API也可以用于遍历Map，可以将Map转换为流，然后进行各种操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">import</span> java.util.HashMap;  <span class="hljs-comment">// 导入HashMap类  </span><br>&gt;<span class="hljs-keyword">import</span> java.util.Map;      <span class="hljs-comment">// 导入Map接口  </span><br>&gt;<span class="hljs-keyword">import</span> java.util.stream.Collectors;  <span class="hljs-comment">// 导入Collectors用于结果收集  </span><br><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapTraversalExample</span> &#123;  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>      <span class="hljs-comment">// 创建一个HashMap实例，键为String类型，值为Integer类型  </span><br>      Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();  <br>      <br>      <span class="hljs-comment">// 向HashMap中添加键值对  </span><br>      map.put(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-number">1</span>);  <br>      map.put(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-number">2</span>);  <br>      map.put(<span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-number">3</span>);  <br><br>      <span class="hljs-comment">// 使用Stream API遍历Map并打印所有的键值对  </span><br>      map.entrySet().stream()  <span class="hljs-comment">// 将Map的条目集转换为Stream流  </span><br>        .forEach(entry -&gt; &#123;    <span class="hljs-comment">// 对每个条目执行操作  </span><br>            System.out.println(<span class="hljs-string">&quot;Key: &quot;</span> + entry.getKey() + <span class="hljs-string">&quot;, Value: &quot;</span> + entry.getValue());  <br>        &#125;);  <br><br>      <span class="hljs-comment">// 应用过滤条件，创建一个新Map，包含值大于1的键值对  </span><br>      Map&lt;String, Integer&gt; filteredMap = map.entrySet().stream()  <span class="hljs-comment">// 再次将Map的条目集转换为Stream流  </span><br>                                          .filter(entry -&gt; entry.getValue() &gt; <span class="hljs-number">1</span>)  <span class="hljs-comment">// 过滤出值大于1的条目  </span><br>                                          .collect(Collectors.toMap(            <span class="hljs-comment">// 收集过滤后的条目为新Map  </span><br>                                              Map.Entry::getKey,                 <span class="hljs-comment">// 键为原Map的键  </span><br>                                              Map.Entry::getValue                <span class="hljs-comment">// 值为原Map的值  </span><br>                                          ));  <span class="hljs-comment">//lambda表达式::表示引用，类名：：方法名</span><br>      <span class="hljs-comment">// 打印出过滤后的Map  </span><br>      System.out.println(filteredMap);  <br>  &#125;  <br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h4 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1.HashMap"></a>1.HashMap</h4><ul>
<li><p>JDK1.8以前：数组+链表（头插法）</p>
</li>
<li><p>JDK1.8后：数组+链表&#x2F;红黑树（尾插法，链表≥8且数组≥64时树化以减少搜索时间,链表数量小于6时转回链表）</p>
</li>
<li><p>HashMap不是线程安全的：假设有两个线程 A 和 B 同时对 HashMap 进行操作，并且都触发了扩容。线程 A 先开始扩容，它创建了一个新的数组，并将部分元素复制到新数组中。然后线程 B 也开始扩容，它也创建了一个新的数组。由于线程 A 和线程 B 的执行顺序不确定，可能会导致元素在两个新数组之间来回复制，形成循环链表，从而在后续访问 HashMap 时出现死循环。</p>
</li>
<li><p>通过哈希映射函数计算元素的哈希值来定位</p>
</li>
<li><p>核心参数：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">// 数组默认的初始大小,16</span><br>&gt;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br>&gt;<span class="hljs-comment">// 负载因子，如果你在数组里的元素的个数达到了数组大小 * 负载因子，就会进行数组的扩容</span><br>&gt;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br>&gt;<span class="hljs-comment">// 这个数组就是所谓的map里的核心数据结构的数组，数组的元素就可以看到是Node类型的，天然就可以挂成一个链表，单向链表，Node里面只有一个next指针</span><br>&gt;<span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br>&gt;<span class="hljs-comment">// 这个size代表的是就是当前hashmap中有多少个key-value对，如果这个数量达到了指定大小 * 负载因子，那么就会进行数组的扩容</span><br>&gt;<span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> size;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>      <span class="hljs-keyword">final</span> K key;<br>      V value;<br>      Node&lt;K,V&gt; next;<br>&gt;&#125;<br><br></code></pre></td></tr></table></figure>

<p>这是一个很关键的<code>内部类</code>，他其实是代表了一个key-value对，里面包含了key的hash值，key，value，还有就是可以有一个next的指针，指向下一个Node，也就是指向单向链表中的下一个节点</p>
<p>通过这个next指针，就可以形成一个链表</p>
<p>entryset（）方法就是返回结点集合，由于结点实现了Map.Entry&lt;K,V&gt;接口, 可以多态的使用接口集合来指向结点集合，从而进行遍历，并且该接口Map.Entry&lt;K,V&gt;内有getKey()和getValue()方法，for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) 可以遍历整个HashMap并且能够取键值对。</p>
</blockquote>
</li>
<li><p>Hash计算优化</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>&gt;<span class="hljs-type">int</span> h;<br>&gt;<span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>); <span class="hljs-comment">// 扰动函数</span><br>&gt;&#125;<br></code></pre></td></tr></table></figure>

<p>hash计算把键（key）对应的哈希码值的高16位和低16位进行异或计算得到hash值的低16位，低16位保存了哈希码的高低16位的特征，最后得到的结果去定位数组的index，降低了哈希冲突的概率。</p>
<p>键和值（key和value）都可以为null，但是key为null的键值对只能一个，而value为null的键值对可以为多个</p>
</blockquote>
</li>
</ul>
<h5 id="put操作原理"><a href="#put操作原理" class="headerlink" title="put操作原理"></a>put操作原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key,V value)</span>&#123;<br><span class="hljs-keyword">return</span> putVal(hash(key),key,value,<span class="hljs-literal">false</span>,<span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>        <span class="hljs-comment">// 1.假设，hashmap是空的，通过resize扩容，数组大小就是默认的16，负载因子就是默认的12</span><br>        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            n = (tab = resize()).length;<br>        <span class="hljs-comment">// 2.这是一个寻址算法，用&amp;操作寻址，性能会比用取模高</span><br>        <span class="hljs-comment">// 2.1 n是数组的长度，用数组长度和hash做与运算</span><br>        <span class="hljs-comment">// 2.2在数组长度比较小的时候，高16基本上就废掉了</span><br>        <span class="hljs-comment">// 3.这个数组里的元素是空的</span><br>        <span class="hljs-comment">// 3.1这个分支，他的意思是说tab[i]，i就是hash定位到的数组index，tab[i]如果为空，也就是hash定位到的这个位置是空的，之前没有任何人在这里，此时直接是放一个Node在数组的这个位置即可</span><br>        <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        	<span class="hljs-comment">// 3.2定位到数组了，那就把元素插入到链表或者红黑树里</span><br>            tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 4.hash定位到的数组位置，是已经有了Node了</span><br>            Node&lt;K,V&gt; e; K k;<br>            <span class="hljs-comment">// 5.相同的key（会覆盖旧的value）</span><br>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>                ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                e = p;<br>    	<span class="hljs-comment">// 6.红黑树</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>            <span class="hljs-keyword">else</span> &#123;<br>    	     <span class="hljs-comment">// 7.链表</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                        p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                        <span class="hljs-comment">// 8.如果链表的长度大于等于8的话，链表的总长度达到8的话，那么此时就需要将这个链表转换为一个红黑树的数据结构</span><br>                        <span class="hljs-comment">// 当你遍历到第8个节点，此时binCount是7，同时你挂上了第9个节点，然后就会发现binCount &gt;= 7，达到了临界值，也就是说，当你的链表节点的数量超过8的时候，此时就会将链表转换为红黑树</span><br>                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                            treeifyBin(tab, hash);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// 相同的key（会覆盖旧的value）</span><br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                        <span class="hljs-keyword">break</span>;<br>                    p = e;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 9.相同的key，覆盖旧的value</span><br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>                <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                    e.value = value;<br>                afterNodeAccess(e);<br>                <span class="hljs-keyword">return</span> oldValue;<br>            &#125;<br>        &#125;<br>        ++modCount;<br>        <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>            resize();<br>        afterNodeInsertion(evict);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>put方法的流程：<ul>
<li>判断数组是否为空，空则进行第一次扩容，数组大小扩为16。</li>
<li>根据key计算出hashcode(int hashcode&#x3D;hash(key))</li>
<li>根据hashcode获得数组下标index(int index&#x3D;hashcode&amp;(table.length-1)</li>
<li>得到数组下标后，如果对应位置为空，把结点对象放入对应位置</li>
<li>对应位置不为空，比较hash和key,相同则覆盖，不相同则遍历红黑树或者链表，直到覆盖或者没有相同则直接插入链表首部或者红黑树中，插入前如果链表达到一定长度（8），则转换为红黑树进行插入。</li>
<li>判断如果元素大小超载，则进行数组扩容</li>
</ul>
</li>
<li>如果数组为空，进行第一次扩容数组大小n为16，不为空则进行寻址定位（n-1）&amp;hash得到元素索引，对应位置如果为空，直接插入，如果不为空，比较hash和key,相同则覆盖，不相同则遍历红黑树或者链表，直到覆盖或者没有相同则直接插入链表首部或者红黑树中，插入前如果链表达到一定长度（8），则转换为红黑树进行插入。如果元素大小超载，则进行数组扩容。</li>
<li><code>(n - 1) &amp; hash</code>与取模运算hash%n等价，但是效率高于取模运算，保证数组大小n为2的次幂时，n-1具有特殊形式（011111），则保证了（n-1）%hash结果和取模运算相同。</li>
<li>数组扩容原理：扩容的大小一定是2的n次幂，每次扩容后，重新计算hash,hash值要么停留在之前，要么变为原hash+原大小，有利于分散冲突。</li>
</ul>
<h5 id="get操作代码"><a href="#get操作代码" class="headerlink" title="get操作代码"></a>get操作代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>     Node&lt;K,V&gt; e;<br>     <span class="hljs-comment">// 1.计算key的hash值</span><br>     <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;<br>&#125;<br><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-type">int</span> n; K k;<br>        <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        	<span class="hljs-comment">// 1.先确定数组下标</span><br>            (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>    	<span class="hljs-comment">// 2.如果第一个节点的hash和当前值的hash相等，且值也相等，直接返回</span><br>            <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>                ((k = first.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                <span class="hljs-keyword">return</span> first;<br>            <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 3.如果是红黑树，走红黑树获取节点方法</span><br>                <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>    	     <span class="hljs-comment">// 4.如果是链表，遍历链表比较</span><br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                        <span class="hljs-keyword">return</span> e;<br>                &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li><p>链表转红黑树的实现逻辑</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs processing">  ~~~<br><br>  <br><br>#### <span class="hljs-number">2.</span>LinkedHashMap<br><br>- 继承自<span class="hljs-built_in">HashMap</span><br><br>- LinkedHashMap内部维护了一个双向链表，能保证元素按插入的顺序访问，也能以访问顺序访问，可以用来实现LRU缓存策略。<br><br>- 核心属性<br><br>  ~~~java<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 双向链表头结点,存放旧数据</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">transient</span> LinkedHashMap.<span class="hljs-property">Entry</span>&lt;K,V&gt; head;<br>  <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 双向链表尾结点,存放新数据</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">transient</span> LinkedHashMap.<span class="hljs-property">Entry</span>&lt;K,V&gt; tail;<br>  <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 是否按访问顺序排序，true为按访问顺序，false为按插入顺序</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> accessOrder;<br></code></pre></td></tr></table></figure>
</li>
<li><p>按照插入顺序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedHashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShoppingCartExample</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span>&#123;<br>LinkedHashMap&lt;String,Integer&gt; shoppingCart=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>shoppingCart.put(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-number">3</span>);<br>shoppingCart.put(<span class="hljs-string">&quot;Banana&quot;</span>,<span class="hljs-number">2</span>);<br>shoppingCart.put(<span class="hljs-string">&quot;Orange&quot;</span>,<span class="hljs-number">5</span>);<br><span class="hljs-keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry:shopping.entrySet())&#123;<br>System.put.println(entry.getKey()+<span class="hljs-string">&quot;:&quot;</span>+entry.getValue());<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>按访问顺序排序，并且实现LRU(least recently used 最近最少使用)缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedHashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">// 自定义 LRU 缓存类，继承自 LinkedHashMap</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-comment">// 缓存的最大容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> capacity;<br><br>    <span class="hljs-comment">// 构造函数，初始化缓存容量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-comment">// 调用父类的构造函数</span><br>        <span class="hljs-comment">// 初始容量为 capacity，负载因子为 0.75f，accessOrder 设为 true 表示按访问顺序排序</span><br>        <span class="hljs-built_in">super</span>(capacity, <span class="hljs-number">0.75f</span>, <span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 重写 removeEldestEntry 方法，当缓存大小超过容量时返回 true</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;<br>                <span class="hljs-keyword">return</span> size() &gt; capacity;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个容量为 2 的 LRU 缓存</span><br>        LRUCache&lt;Integer, String&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUCache</span>&lt;&gt;(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">// 向缓存中添加元素</span><br>        cache.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;One&quot;</span>);<br>        cache.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Two&quot;</span>);<br><br>        <span class="hljs-comment">// 访问元素 1，使其成为最近使用的元素</span><br>        System.out.println(cache.get(<span class="hljs-number">1</span>)); <br><br>        <span class="hljs-comment">// 插入元素 3，此时缓存已满，会移除最久未使用的元素（元素 2）</span><br>        cache.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Three&quot;</span>); <br><br>        <span class="hljs-comment">// 尝试获取元素 2，由于已被移除，返回 null</span><br>        System.out.println(cache.get(<span class="hljs-number">2</span>)); <br><br>        <span class="hljs-comment">// 插入元素 4，此时缓存已满，会移除最久未使用的元素（元素 1）</span><br>        cache.put(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;Four&quot;</span>); <br><br>        <span class="hljs-comment">// 尝试获取元素 1，由于已被移除，返回 null</span><br>        System.out.println(cache.get(<span class="hljs-number">1</span>)); <br><br>        <span class="hljs-comment">// 获取元素 3 和 4</span><br>        System.out.println(cache.get(<span class="hljs-number">3</span>)); <br>        System.out.println(cache.get(<span class="hljs-number">4</span>)); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h5><h6 id="基础概念类"><a href="#基础概念类" class="headerlink" title="基础概念类"></a>基础概念类</h6><ul>
<li><p>问题</p>
<p>：LinkedHashMap和HashMap有什么区别？</p>
<ul>
<li><strong>回答</strong>：<code>HashMap</code> 不保证元素的顺序，它根据键的哈希值来存储元素，元素的存储和遍历顺序是无序的。而 <code>LinkedHashMap</code> 是 <code>HashMap</code> 的子类，它维护了一个双向链表，默认按照插入顺序来存储元素，也可以设置为按照访问顺序来存储元素，因此可以保证元素的插入顺序或访问顺序。</li>
</ul>
</li>
<li><p>问题</p>
<p>：LinkedHashMap是如何实现保持插入顺序或访问顺序的？</p>
<ul>
<li><strong>回答</strong>：<code>LinkedHashMap</code> 内部维护了一个双向链表，每个节点除了包含键值对信息外，还包含指向前一个节点和后一个节点的引用。在插入元素时，会将新元素添加到链表的尾部；在访问元素时（如果设置为按访问顺序），会将被访问的元素移动到链表的尾部。通过这种方式，就可以保持元素的插入顺序或访问顺序。</li>
</ul>
</li>
</ul>
<h6 id="源码与原理类"><a href="#源码与原理类" class="headerlink" title="源码与原理类"></a>源码与原理类</h6><ul>
<li><p>问题</p>
<p>：LinkedHashMap的get方法在按访问顺序时做了什么？</p>
<ul>
<li><strong>回答</strong>：当 <code>LinkedHashMap</code> 设置为按访问顺序时，调用 <code>get</code> 方法会将被访问的元素移动到双向链表的尾部。这是通过修改双向链表中节点的前后引用关系来实现的，具体步骤包括先将该节点从当前位置移除，然后将其添加到链表的尾部。</li>
</ul>
</li>
<li><p>问题</p>
<p>： LinkedHashMap的removeEldestEntry方法有什么作用？</p>
<ul>
<li><strong>回答</strong>：<code>removeEldestEntry</code> 方法是一个可重写的方法，用于判断是否需要移除最旧的元素。在插入新元素时，<code>LinkedHashMap</code> 会调用该方法，如果返回 <code>true</code>，则会移除链表头部的元素（即最旧的元素）。在实现 LRU 缓存时，通常会重写该方法，当缓存大小超过容量时返回 <code>true</code>，从而实现自动移除最久未使用的元素。默认情况下返回false不删除元素。</li>
</ul>
</li>
</ul>
<h6 id="应用场景类"><a href="#应用场景类" class="headerlink" title="应用场景类"></a>应用场景类</h6><ul>
<li><p>问题</p>
<p>：在什么情况下你会选择使用LinkedHashMap而不是HashMap</p>
<ul>
<li><strong>回答</strong>：当需要保证元素的插入顺序或访问顺序时，会选择使用 <code>LinkedHashMap</code>。例如，实现一个需要按照用户操作顺序记录数据的日志系统，或者实现 LRU 缓存等场景。而如果不需要考虑元素的顺序，只关注键值对的存储和查找效率，<code>HashMap</code> 是更好的选择。</li>
</ul>
</li>
<li><p>问题</p>
<p>：请设计一个使用LinkedHashMap实现的简单 LRU 缓存。</p>
<ul>
<li><strong>回答</strong>：可以通过继承 <code>LinkedHashMap</code> 并重写 <code>removeEldestEntry</code> 方法来实现。如上述的 <code>LRUCache</code> 类示例，设置 <code>accessOrder</code> 为 <code>true</code> 表示按访问顺序排序，并重写 <code>removeEldestEntry</code> 方法，当缓存大小超过容量时返回 <code>true</code> 以移除最旧的元素。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-HashTable"><a href="#3-HashTable" class="headerlink" title="3.HashTable"></a>3.HashTable</h4><ul>
<li>存储结构是数组+链表</li>
<li>线程安全：所有的方法都加上了synchronized关键字</li>
<li>HashTable 默认长度为 <code>11</code>，负载因子为 <code>0.75F</code>，即元素个数达到数组长度的 75% 时，会进行一次扩容，每次扩容为原来数组长度的 <code>2</code> 倍</li>
</ul>
<h4 id="4-TreeMap"><a href="#4-TreeMap" class="headerlink" title="4.TreeMap"></a>4.TreeMap</h4><ul>
<li><p>TreeMap实现了Map、SortedMap、NavigableMap、Cloneable、Serializble等接口</p>
</li>
<li><p>使用红黑树存储元素，按Key的自然顺序来排序。</p>
</li>
<li><p>不能存储null键，因为要对键进行排序</p>
</li>
<li><p>线程同样不安全，在多线程下使用，需要进行额外处理，例如使用Collections.synchronizedSortedMap方法</p>
</li>
<li><p>构造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.TreeMap;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeMapExample</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-comment">//函数式比较器接口,逆序</span><br>Comparator&lt;String&gt;reverseComparator=(s1,s2)-&gt;s2.comparaTo(s1);<br>TreeMap&lt;String,Integer&gt;treeMap1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<span class="hljs-comment">//默认构造按Key的自然顺序排序</span><br>TreeMap&lt;String,Integer&gt;treeMap2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;(reverseComparator);<span class="hljs-comment">//按传入的比较器</span><br>TreeMap&lt;String,Integer&gt;treeMap3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;((o1,o2)-&gt;String.compare(o2,o1));<span class="hljs-comment">//简化版写法</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>常用方法</p>
<ul>
<li>put(K，V)</li>
<li>get(K)</li>
<li>remove(K)</li>
<li>firstKey()</li>
<li>lastKey()</li>
</ul>
</li>
<li><p>遍历</p>
<ul>
<li><p>使用entrySet()或者keySet()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry:treeMap.entrySet())&#123;<br>System.out.println(entry.getKey()+<span class="hljs-string">&quot;:&quot;</span>+entry.getValue());<br>&#125;<br><br><span class="hljs-keyword">for</span>(String key:treeMap.keySet())&#123;<br>System.out.println(key+<span class="hljs-string">&quot;:&quot;</span>+treeMap.get(key));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 Java 中，<code>Comparable</code>、<code>Comparator</code> 接口以及 <code>compareTo</code> 方法都与对象的比较和排序相关，下面将分别详细介绍它们。</p>
<p><code>Comparable</code> 接口</p>
<ul>
<li><strong>定义</strong>：<code>Comparable</code> 是 Java 中的一个泛型接口，位于 <code>java.lang</code> 包下。它只有一个抽象方法 <code>compareTo</code>，用于定义对象的自然排序规则。一个类实现了 <code>Comparable</code> 接口，就意味着该类的对象可以进行比较和排序。</li>
<li><strong>接口定义</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T o)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>compareTo</code> 方法规则：<ul>
<li>如果当前对象小于指定对象 <code>o</code>，返回一个负整数。</li>
<li>如果当前对象等于指定对象 <code>o</code>，返回 0。</li>
<li>如果当前对象大于指定对象 <code>o</code>，返回一个正整数。</li>
</ul>
</li>
<li><strong>示例代码</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt; &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student other)</span> &#123;<br>        <span class="hljs-comment">// 按年龄升序排序，如果年龄相同则按姓名排序</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ageComparison</span> <span class="hljs-operator">=</span> Integer.compare(<span class="hljs-built_in">this</span>.age, other.age);<br>        <span class="hljs-keyword">if</span> (ageComparison != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> ageComparison;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.compareTo(other.name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;, age=&quot;</span> + age + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以使用 <code>Arrays.sort</code> 或 <code>Collections.sort</code> 对实现了 <code>Comparable</code> 接口的对象数组或列表进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparableExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Student[] students = &#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">20</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">18</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">20</span>)<br>        &#125;;<br>        Arrays.sort(students);<br>        <span class="hljs-keyword">for</span> (Student student : students) &#123;<br>            System.out.println(student);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Comparator</code> 接口</p>
<ul>
<li><strong>定义</strong>：<code>Comparator</code> 是一个函数式接口，位于 <code>java.util</code> 包下。它用于定义一种比较策略，允许在不修改对象类本身的情况下，为对象提供不同的排序规则。<code>Comparator</code> 接口中包含一个抽象方法 <code>compare</code>。</li>
<li><strong>接口定义</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparator</span>&lt;T&gt; &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(T o1, T o2)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>compare</code> 方法规则</p>
<p>：</p>
<ul>
<li>如果 <code>o1</code> 小于 <code>o2</code>，返回一个负整数。</li>
<li>如果 <code>o1</code> 等于 <code>o2</code>，返回 0。</li>
<li>如果 <code>o1</code> 大于 <code>o2</code>，返回一个正整数。</li>
</ul>
</li>
<li><p><strong>示例代码</strong>：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;, age=&quot;</span> + age + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparatorExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Student[] students = &#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">20</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">18</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">20</span>)<br>        &#125;;<br>        <span class="hljs-comment">// 使用 Comparator 按年龄降序排序</span><br>        Arrays.sort(students, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student s1, Student s2)</span> &#123;<br>                <span class="hljs-keyword">return</span> Integer.compare(s2.getAge(), s1.getAge());<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (Student student : students) &#123;<br>            System.out.println(student);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>也可以使用 Lambda 表达式简化 <code>Comparator</code> 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(students, (s1, s2) -&gt; Integer.compare(s2.getAge(), s1.getAge()));<br></code></pre></td></tr></table></figure>

<p><code>compareTo</code> 方法</p>
<ul>
<li><strong>作用</strong>：<code>compareTo</code> 是 <code>Comparable</code> 接口中定义的唯一抽象方法，用于定义对象之间的自然排序规则。当一个类实现了 <code>Comparable</code> 接口，就必须实现 <code>compareTo</code> 方法，这样该类的对象才能进行比较和排序。</li>
<li><strong>使用场景</strong>：通常在需要对对象数组或列表进行默认排序时使用。例如，<code>String</code> 类就实现了 <code>Comparable</code> 接口，其 <code>compareTo</code> 方法按字典顺序比较字符串：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;apple&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;banana&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> str1.compareTo(str2);<br><span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;<br>    System.out.println(str1 + <span class="hljs-string">&quot; 在字典顺序上小于 &quot;</span> + str2);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) &#123;<br>    System.out.println(str1 + <span class="hljs-string">&quot; 等于 &quot;</span> + str2);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    System.out.println(str1 + <span class="hljs-string">&quot; 在字典顺序上大于 &quot;</span> + str2);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>**<code>Comparable</code>**：用于定义对象的自然排序规则，类需要实现该接口并实现 <code>compareTo</code> 方法。</li>
<li>**<code>Comparator</code>**：用于提供额外的比较策略，不修改对象类本身的情况下为对象定义不同的排序规则。</li>
<li>**<code>compareTo</code>**：是 <code>Comparable</code> 接口中的方法，用于定义对象之间的比较逻辑。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><ul>
<li><p>HashMap不是线程安全的，多线程同时put时可能会出现覆盖现象</p>
</li>
<li><p>多线程扩容时，可能产生循环链表。</p>
</li>
<li><p>解决方法：</p>
<ul>
<li><p>手动加锁或者使用读写锁ReentrantReadWriteLock</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span>&#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer,String&gt;map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> Object lock=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key,String Value)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(lock)&#123;<br>            map.put(key,value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用Collections.synchronizedMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>Map&lt;Integer,String&gt;synchronizedMap=Collections.synchronizedMap(map);<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用ConcurrentHashMap</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ConcurrentHashMap&lt;Integer,String&gt;map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>

<h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><ul>
<li><strong>分段锁（JDK 7 及以前）</strong>：<code>ConcurrentHashMap</code> 在 JDK 7 及以前采用分段锁机制。它将整个哈希表分成多个段（Segment extend ReentrantLock），每个段相当于一个小的 <code>HashMap</code>，并且每个段都有自己的锁。不同的线程可以同时访问不同的段，从而提高并发性能。<ul>
<li>将HashMap分段为多个Segment，根据key算出对应Segment的索引index,获取对应位置的锁（segments[index].lock()）,再进行put(segemnts[index].put(key,value))，最后释放锁（segments[index].unlock()）。</li>
</ul>
</li>
<li><strong>CAS + synchronized（JDK 8 及以后）</strong>：JDK 8 及以后的 <code>ConcurrentHashMap</code> 摒弃了分段锁机制，采用 CAS（Compare-And-Swap）和 <code>synchronized</code> 来保证线程安全。在插入元素时，首先使用 CAS 尝试更新节点，如果失败则使用 <code>synchronized</code> 锁住当前桶的头节点，然后进行插入操作。</li>
</ul>
<h3 id="13-7-泛型"><a href="#13-7-泛型" class="headerlink" title="13.7.泛型"></a>13.7.泛型</h3><ol>
<li><strong>什么是 Java 泛型</strong><ul>
<li>Java 泛型是 JDK 5.0 引入的一个重要特性，它提供了一种在编译时期检查类型安全的机制。简单来说，泛型允许你在定义类、接口和方法时使用类型参数，这样这些类型就可以在使用时再确定。</li>
<li>例如，在没有泛型之前，如果你有一个存储整数的列表，你可能会定义一个<code>ArrayList</code>，然后将整数添加进去。但是如果不小心添加了一个字符串，在运行时才会发现错误。而泛型可以让你在编译时就避免这种类型不匹配的错误。</li>
<li>泛型的主要目的是提高代码的复用性和类型安全性。</li>
</ul>
</li>
<li><strong>泛型的语法</strong><ul>
<li>定义泛型类<ul>
<li>以一个简单的<code>Box</code>类为例，它可以用来存储任意类型的对象。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T t;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-built_in">this</span>.t = t;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>这里的<code>&lt;T&gt;</code>就是定义了一个类型参数<code>T</code>，<code>T</code>可以是任何引用类型（在 Java 中，基本类型不能直接作为泛型类型参数，但可以使用它们对应的包装类型，如<code>Integer</code>对应<code>int</code>）。在<code>Box</code>类中，有一个私有成员变量<code>t</code>的类型是<code>T</code>，还有两个方法<code>set</code>和<code>get</code>来设置和获取这个变量。</li>
<li>定义泛型接口<ul>
<li>例如，定义一个<code>Generator</code>接口，用于生成某种类型的对象。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Generator</span>&lt;T&gt; &#123;<br>    T <span class="hljs-title function_">generate</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>类型参数<code>T</code>用于指定生成对象的类型，实现这个接口的类需要提供<code>generate</code>方法的具体实现，并且返回类型是<code>T</code>。</li>
<li>定义泛型方法<ul>
<li>泛型方法可以在普通类或泛型类中定义</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Util</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">getMiddle</span><span class="hljs-params">(T... a)</span> &#123;<br>        <span class="hljs-keyword">return</span> a[a.length / <span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>这里<code>&lt;T&gt;</code>定义了一个泛型方法<code>getMiddle</code>，它可以接受任意数量的<code>T</code>类型的参数（<code>T... a</code>是可变参数的语法），并返回中间位置的元素。</li>
</ul>
<ol>
<li>泛型的使用场景<ul>
<li>集合框架中的应用<ul>
<li>在 Java 的集合框架中，泛型被广泛使用。例如<code>ArrayList</code>、<code>HashMap</code>等。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; stringList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>stringList.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>stringList.add(<span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-comment">// 编译器会检查类型，下面这行代码会报错，因为不能添加整数</span><br><span class="hljs-comment">// stringList.add(123);</span><br></code></pre></td></tr></table></figure>



<ul>
<li>这样就确保了<code>ArrayList</code>中只能存储<code>String</code>类型的元素，提高了代码的类型安全性。</li>
<li>自定义数据结构和算法<ul>
<li>当你实现自己的数据结构，如链表、栈、队列等，或者实现一些通用的算法，如排序、查找等，泛型可以让你的代码更加通用。例如，实现一个简单的链表节点类。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;T&gt; &#123;<br>    T data;<br>    Node&lt;T&gt; next;<br>    Node(T data) &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>        <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>这个<code>Node</code>类可以用来构建存储不同类型数据的链表。</li>
</ul>
<ol>
<li><strong>类型擦除</strong><ul>
<li>Java 中的泛型是通过类型擦除来实现的。这意味着在编译后的字节码中，泛型类型信息会被擦除。例如，对于<code>Box&lt;Integer&gt;</code>和<code>Box&lt;String&gt;</code>，在字节码层面，它们都会被转换为<code>Box</code>（原始类型）。</li>
<li>编译器会在编译时进行类型检查，插入必要的类型转换代码。但是在运行时，通过反射等方式获取的类型信息是擦除后的类型。这也导致了一些限制，比如不能使用<code>new T()</code>（因为在运行时<code>T</code>的具体类型已经被擦除了），但可以通过传递一个工厂对象或者使用反射等方式来解决这个问题。</li>
</ul>
</li>
<li><strong>通配符</strong><ul>
<li>泛型通配符用于在某些情况下增加泛型的灵活性。</li>
<li>无界通配符<ul>
<li><code>&lt;?&gt; </code>是无界通配符，表示可以匹配任何类型。例如，有一个方法用于打印集合中的元素。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(ArrayList&lt;?&gt; list)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Object element : list) &#123;<br>        System.out.println(element);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>这个方法可以接受任何类型的<code>ArrayList</code>，但是在方法内部，只能将元素当作<code>Object</code>来处理，因为不知道具体的类型。</li>
<li>上界通配符<ul>
<li><code>&lt;? extends T&gt;</code>是上界通配符，表示匹配<code>T</code>或者<code>T</code>的子类。例如，假设有一个<code>Animal</code>类和它的子类<code>Dog</code>和<code>Cat</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAnimalList</span><span class="hljs-params">(ArrayList&lt;? extends Animal&gt; list)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Animal animal : list) &#123;<br>        System.out.println(animal);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>这个方法可以接受<code>ArrayList&lt;Animal&gt;</code>、<code>ArrayList&lt;Dog&gt;</code>或者<code>ArrayList&lt;Cat&gt;</code>等，只要元素类型是<code>Animal</code>或者它的子类就行。</li>
<li>下界通配符<ul>
<li><code>&lt;? super T&gt;</code>是下界通配符，表示匹配<code>T</code>或者<code>T</code>的父类。例如，有一个方法用于向集合中添加元素。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addToAnimalList</span><span class="hljs-params">(ArrayList&lt;? <span class="hljs-built_in">super</span> Dog&gt; list)</span> &#123;<br>    <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>    list.add(dog);<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>这个方法可以接受<code>ArrayList&lt;Animal&gt;</code>或者<code>ArrayList&lt;Object&gt;</code>等，只要元素类型是<code>Dog</code>或者它的超类就行，这样就可以向集合中添加<code>Dog</code>类型的元素。</li>
</ul>
<h3 id="13-8-stream流"><a href="#13-8-stream流" class="headerlink" title="13.8.stream流"></a>13.8.stream流</h3><h5 id="1-什么是-Stream-流"><a href="#1-什么是-Stream-流" class="headerlink" title="1. 什么是 Stream 流"></a>1. 什么是 Stream 流</h5><p>Stream 流是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。它并不是一种数据结构，不保存数据，而是对数据进行计算和处理。Stream 流具有以下特点：</p>
<ul>
<li><strong>元素序列</strong>：Stream 流是一系列元素的序列，它可以来自于集合、数组、文件等。</li>
<li><strong>按需计算</strong>：Stream 流的操作是按需计算的，只有在调用终端操作时才会开始执行。</li>
<li><strong>函数式编程</strong>：Stream 流支持函数式编程，通过 Lambda 表达式来定义操作。</li>
<li><strong>不可变</strong>：Stream 流不会修改原始数据源，而是生成一个新的流。</li>
</ul>
<h5 id="2-Stream-流的创建"><a href="#2-Stream-流的创建" class="headerlink" title="2. Stream 流的创建"></a>2. Stream 流的创建</h5><p>可以通过多种方式创建 Stream 流，常见的方式如下：</p>
<h6 id="从集合创建"><a href="#从集合创建" class="headerlink" title="从集合创建"></a>从集合创建</h6><p>集合类（如 <code>List</code>、<code>Set</code> 等）提供了 <code>stream()</code> 和 <code>parallelStream()</code> 方法来创建顺序流和并行流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamCreation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>);<br>        <span class="hljs-comment">// 创建顺序流</span><br>        Stream&lt;String&gt; stream = list.stream();<br>        <span class="hljs-comment">// 创建并行流</span><br>        Stream&lt;String&gt; parallelStream = list.parallelStream();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="从数组创建"><a href="#从数组创建" class="headerlink" title="从数组创建"></a>从数组创建</h6><p>可以使用 <code>Arrays.stream()</code> 方法从数组创建 Stream 流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamFromArray</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        java.util.stream.<span class="hljs-type">IntStream</span> <span class="hljs-variable">intStream</span> <span class="hljs-operator">=</span> Arrays.stream(array);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="使用-Stream-of-方法"><a href="#使用-Stream-of-方法" class="headerlink" title="使用 Stream.of() 方法"></a>使用 <code>Stream.of()</code> 方法</h6><p>可以使用 <code>Stream.of()</code> 方法直接创建 Stream 流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamOf</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="3-Stream-流的操作类型"><a href="#3-Stream-流的操作类型" class="headerlink" title="3. Stream 流的操作类型"></a>3. Stream 流的操作类型</h5><p>Stream 流的操作可以分为中间操作和终端操作。</p>
<h6 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h6><p>中间操作会返回一个新的 Stream 流，多个中间操作可以连接成一个流水线。常见的中间操作有：</p>
<ul>
<li>**<code>filter(Predicate&lt;T&gt; predicate)</code>**：过滤流中的元素，只保留满足条件的元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>        numbers.stream()<br>               .filter(n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>               .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>**<code>map(Function&lt;T, R&gt; mapper)</code>**：将流中的每个元素映射为另一个元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>        numbers.stream()<br>               .map(n -&gt; n * <span class="hljs-number">2</span>)<br>               .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>**<code>sorted()</code>**：对流中的元素进行排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SortedExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>);<br>        numbers.stream()<br>               .sorted()<br>               .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h6><p>终端操作会触发流的执行，并产生一个最终结果。常见的终端操作有：</p>
<ul>
<li>**<code>forEach(Consumer&lt;T&gt; action)</code>**：对流中的每个元素执行指定的操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForEachExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>);<br>        list.stream()<br>            .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>**<code>collect(Collector&lt;T, A, R&gt; collector)</code>**：将流中的元素收集到一个集合中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>        List&lt;Integer&gt; evenNumbers = numbers.stream()<br>                                           .filter(n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>                                           .collect(Collectors.toList());<br>        System.out.println(evenNumbers);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>**<code>count()</code>**：返回流中元素的数量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> numbers.stream()<br>                            .filter(n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>                            .count();<br>        System.out.println(<span class="hljs-string">&quot;Even numbers count: &quot;</span> + count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="4-并行流"><a href="#4-并行流" class="headerlink" title="4. 并行流"></a>4. 并行流</h5><p>并行流是一种可以并行执行的流，它可以充分利用多核处理器的优势，提高处理效率。可以通过 <code>parallelStream()</code> 方法创建并行流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParallelStreamExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> numbers.parallelStream()<br>                          .mapToInt(Integer::intValue)<br>                          .sum();<br>        System.out.println(<span class="hljs-string">&quot;Sum: &quot;</span> + sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>需要注意的是，并行流并不总是比顺序流快，因为并行流的执行需要额外的线程管理和同步开销。在使用并行流时，需要根据具体情况进行性能测试和优化。</p>
<ol start="5">
<li>总结</li>
</ol>
<p>Java 集合框架的 Stream 流提供了一种强大而灵活的方式来处理集合中的元素。通过中间操作和终端操作的组合，可以实现复杂的数据处理逻辑。同时，并行流的使用可以提高处理效率，但需要注意性能问题。掌握 Stream 流的使用可以让代码更加简洁、易读和高效。</p>
<h3 id="13-9-Collections和CollectionUtils"><a href="#13-9-Collections和CollectionUtils" class="headerlink" title="13.9.Collections和CollectionUtils"></a>13.9.Collections和CollectionUtils</h3><h4 id="1-Collections"><a href="#1-Collections" class="headerlink" title="1.Collections"></a>1.<code>Collections</code></h4><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><code>Collections</code> 是 Java 提供的一个工具类，它位于 <code>java.util</code> 包中，包含了一系列用于操作集合的静态方法，这些方法提供了对集合进行排序、查找、填充、同步等功能。</p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><code>sort(List&lt;T&gt; list)</code>：对列表进行自然排序。</li>
<li><code>binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)</code>：在有序列表中使用二分查找算法查找指定元素。</li>
<li><code>reverse(List&lt;?&gt; list)</code>：反转列表中元素的顺序。</li>
<li><code>shuffle(List&lt;?&gt; list)</code>：随机打乱列表中元素的顺序。</li>
<li><code>synchronizedCollection(Collection&lt;T&gt; c)</code>：返回指定集合的同步（线程安全）版本。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionsExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-number">3</span>);<br>        list.add(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-number">4</span>);<br>        <span class="hljs-comment">// 对列表进行排序</span><br>        Collections.sort(list);<br>        System.out.println(<span class="hljs-string">&quot;排序后的列表: &quot;</span> + list);<br>        <span class="hljs-comment">// 反转列表</span><br>        Collections.reverse(list);<br>        System.out.println(<span class="hljs-string">&quot;反转后的列表: &quot;</span> + list);<br>        <span class="hljs-comment">// 随机打乱列表</span><br>        Collections.shuffle(list);<br>        System.out.println(<span class="hljs-string">&quot;打乱后的列表: &quot;</span> + list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-CollectionUtils"><a href="#3-CollectionUtils" class="headerlink" title="3. CollectionUtils"></a>3. <code>CollectionUtils</code></h4><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p><code>CollectionUtils</code> 并不是 Java 标准库中的类，而是 Apache Commons Collections 库提供的一个工具类，它提供了一系列用于操作集合的实用方法，这些方法可以帮助开发者更方便地处理集合，减少代码量。</p>
<h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><code>isEmpty(Collection&lt;?&gt; collection)</code>：判断集合是否为空。</li>
<li><code>isNotEmpty(Collection&lt;?&gt; collection)</code>：判断集合是否不为空。</li>
<li><code>union(Collection&lt;? extends O&gt; a, Collection&lt;? extends O&gt; b)</code>：返回两个集合的并集。</li>
<li><code>intersection(Collection&lt;? extends O&gt; a, Collection&lt;? extends O&gt; b)</code>：返回两个集合的交集。</li>
<li><code>subtract(Collection&lt;? extends O&gt; a, Collection&lt;? extends O&gt; b)</code>：返回两个集合的差集。</li>
</ul>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>首先，你需要在项目中添加 Apache Commons Collections 库的依赖。如果你使用的是 Maven 项目，可以在 <code>pom.xml</code> 中添加以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections4<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.collections4.CollectionUtils;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionUtilsExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list1.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>        list1.add(<span class="hljs-string">&quot;banana&quot;</span>);<br><br>        List&lt;String&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list2.add(<span class="hljs-string">&quot;banana&quot;</span>);<br>        list2.add(<span class="hljs-string">&quot;cherry&quot;</span>);<br><br>        <span class="hljs-comment">// 判断集合是否为空</span><br>        System.out.println(<span class="hljs-string">&quot;list1 是否为空: &quot;</span> + CollectionUtils.isEmpty(list1));<br>        <span class="hljs-comment">// 求两个集合的交集</span><br>        Collection&lt;String&gt; intersection = CollectionUtils.intersection(list1, list2);<br>        System.out.println(<span class="hljs-string">&quot;list1 和 list2 的交集: &quot;</span> + intersection);<br>        <span class="hljs-comment">// 求两个集合的并集</span><br>        Collection&lt;String&gt; union = CollectionUtils.union(list1, list2);<br>        System.out.println(<span class="hljs-string">&quot;list1 和 list2 的并集: &quot;</span> + union);<br>        <span class="hljs-comment">// 求两个集合的差集</span><br>        Collection&lt;String&gt; subtract = CollectionUtils.subtract(list1, list2);<br>        System.out.println(<span class="hljs-string">&quot;list1 减去 list2 的差集: &quot;</span> + subtract);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li><code>Collection</code> 是 Java 集合框架的根接口，定义了集合的基本操作方法。</li>
<li><code>Collections</code> 是 Java 提供的工具类，包含了一系列用于操作集合的静态方法。</li>
<li><code>CollectionUtils</code> 是 Apache Commons Collections 库提供的工具类，提供了更多实用的集合操作方法。</li>
</ul>
<h2 id="14-多线程"><a href="#14-多线程" class="headerlink" title="14.多线程"></a>14.多线程</h2><ul>
<li>java每次运行至少有两个线程，一个是主线程main(),一个是垃圾回收线程</li>
</ul>
<h3 id="14-1-创建多线程"><a href="#14-1-创建多线程" class="headerlink" title="14.1.创建多线程"></a>14.1.创建多线程</h3><ul>
<li>方式一：继承Thread类来实现</li>
</ul>
<blockquote>
<ul>
<li>定义一个子类继承Thread类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>&gt;<span class="hljs-comment">//重写Thread类的run方法</span><br>&gt;<span class="hljs-meta">@Override</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>&gt;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>&gt;System.out.println(<span class="hljs-string">&quot;子线程输出&quot;</span>+i);<br>&gt;&#125;<br>&gt;&#125;<br>&gt;&#125;<br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<span class="hljs-comment">//main方法默认也是一条线程，程序的主线程</span><br>&gt;Thread t1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>&gt;<span class="hljs-comment">//调用start方法启动线程</span><br>&gt;t1.start();<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>       System.out.println(<span class="hljs-string">&quot;主线程输出：&quot;</span>+i);<br>   &#125;<br>&gt;&#125;<br><br></code></pre></td></tr></table></figure>
</blockquote>
<p>注意：</p>
<ol>
<li><p>直接调用run方法会当成普通方法执行，此时相当于还是单线程执行</p>
</li>
<li><p>只调用start方法才是启动一个新的线程执行</p>
</li>
<li><p>不要把主线任务放在启动子线程之前，这样主线程一直是先跑完的，相当于单线程的效果</p>
</li>
</ol>
<ul>
<li>方式二：实现Runnable接口</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myrunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>&gt;<span class="hljs-meta">@Override</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>&gt;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>&gt;System.out.println(<span class="hljs-string">&quot;子线程输出&quot;</span>+i);<br>&gt;&#125;<br>&gt;&#125;<br><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>&gt;<span class="hljs-comment">//创建线程任务类对象代表一个线程任务</span><br>&gt;Runnable r=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Myrunnable</span>();<br>&gt;<span class="hljs-comment">//把线程任务对象交给一个线程对象来处理</span><br>&gt;Thread t1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>&gt;<span class="hljs-comment">//启动线程</span><br>&gt;t1.start();<br>        <br>&gt;<span class="hljs-comment">//匿名内部写法</span><br>   <span class="hljs-comment">//声明一个接口对象</span><br>   <span class="hljs-comment">//声明一个匿名子类（无声明）内部类,并且接口回调</span><br> Runnable r1= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>       System.out.println(<span class="hljs-string">&quot;子线程输出：&quot;</span>+i);<br>       &#125;           <br>   &#125;;<br>      Thread t2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r1);<br>      t2.start();<br>   <span class="hljs-comment">//直接用Thread接匿名</span><br>     Thread t3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>       System.out.println(<span class="hljs-string">&quot;子线程输出：&quot;</span>+i);<br>       &#125;).start();<br>        <br>   <span class="hljs-comment">//Lambda</span><br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>       System.out.println(<span class="hljs-string">&quot;子线程输出：&quot;</span>+i);<br>            &#125;).start();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>       System.out.println(<span class="hljs-string">&quot;主线程输出：&quot;</span>+i);<br>&#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>优缺点：</li>
<li>优点：任务类只是实现接口，可以继承其它类，实现其它接口，扩展性强。</li>
<li>缺点：需要一个Runnable对象</li>
</ul>
</blockquote>
<ul>
<li><p>方式三：实现Callable接口、Futuretask类（重点）</p>
</li>
<li><p>前两种线程创建方式都存在一个问题</p>
</li>
<li><p>假如线程执行完毕后有一些数据需要返回，他们重写的run方法均不能直接返回结果。</p>
</li>
<li><p>Futuretask类实现了Runnalbe接口和Future接口</p>
<ul>
<li>Future接口：对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。<ol>
<li>取消任务：<code>bollean cancel(boolean mayInterruptIfRunning(是否打断正在执行的任务))</code></li>
<li><code>isCancelled()</code>表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li>
<li><code>isDone()</code>表示任务是否已经完成，若任务完成，则返回 true；</li>
<li><code>get()</code> 用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li>
<li><code>get(long timeout, TimeUnit unit)</code> 用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回 <code>null</code>。</li>
</ol>
</li>
</ul>
</li>
<li><p>Callable是单接口，只有一个call方法</p>
</li>
</ul>
<blockquote>
<ol>
<li>定义一个类实现Callable接口，重写call方法，封装要做的事情，和要返回的数据。</li>
<li>把Callable类型的对象封装成FutureTask（线程任务对象)。</li>
<li>把线程任务对象交给Thread对象</li>
<li>调用Thread对象的start方法启动线程</li>
<li>线程执行完毕后，通过Futuretask对象的get()方法来获取线程任务执行的结果。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>Callable&lt;String&gt; c1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">100</span>);<br><span class="hljs-comment">//把Callable对象封装成FutureTask（线程任务对象)</span><br><span class="hljs-comment">//FutureTask继承于Runnable</span><br>FutureTask&lt;String&gt; f1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(c1);<span class="hljs-comment">//public FutureTask(Callable&lt;V&gt; callable)</span><br>    Thread t1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(f1);<br>    t1.start();<br><br>    Callable&lt;String&gt; c2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">50</span>);<br>    FutureTask&lt;String&gt; f2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(c2);<br>    Thread t2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(f2);<br>    t2.start();<br>    <span class="hljs-comment">//实现Callable的对象重写了call(),把该对象传入FutureTask构造器中，FutureTask对象通过.get()拿到call()的返回值。</span><br><br><br><br>    <span class="hljs-comment">//取线程的结果</span><br>    <span class="hljs-keyword">try</span>&#123;<span class="hljs-comment">//如果主线程发现一个线程t1还没有执行完，会让出CPU，等第一个线程执行完毕，才会往下执行！</span><br>        System.out.println(f1.get());<br>    &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">try</span>&#123;<span class="hljs-comment">//如果主线程发现第二个线程t2还没有执行完，会让出CPU，等第二个线程执行完毕，才会往下执行！</span><br>        System.out.println(f2.get());<br>    &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//定义一个实现类来实现Callable接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCallable</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-built_in">this</span>.n=n;<br>&#125;<br><span class="hljs-comment">//实现call方法，定义线程执行体</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>System.out.println(i);<br>sum+=i;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;子线程计算的结果是：&quot;</span>+sum;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>快速简单创建</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">FutureTask&lt;String&gt; futureTask=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;()&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;call&quot;</span>;<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="14-2-常用方法"><a href="#14-2-常用方法" class="headerlink" title="14.2.常用方法"></a>14.2.常用方法</h3><ul>
<li><p>搞清楚线程的常用方法</p>
</li>
<li><pre><code class="java">public static void main(String[]args)&#123;
Thread t1=new Mythread(&quot;一号线程&quot;);
    //为线程设置名字public void setName(String name)
//t1.setName(&quot;一号线程&quot;);   //启动之前 
t1.start();
System.out.println(t1.getName());//public String getName()获取线程的名字默认是Thread-索引
Thread t1=new Mythread(&quot;二号线程&quot;);
//t2.setName(&quot;二号线程&quot;);    
t2.start();
System.out.println(t2.getName());
//获取当前线程public static Thread currentThread();
    //哪个线程调用这个代码，这个代码就拿到哪个线程
    Thread m=Thread.currentThread();//主线程
    m.setName(&quot;主线程&quot;);
    System.out.println(m.getName());//main
    
    
&#125;

class Mythread extends Thread&#123;
//重写Thread的run方法
@Override
public void run()&#123;
for(int i=0;i&lt;5;i++)&#123;
System.out.println(Thread.currentThread.getName()+&quot;子线程输出&quot;+i);
&#125;  
&#125;
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><br>  &gt; <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> setName(<span class="hljs-built_in">String</span> name)为线程设置名字为线程设置名字,需要在线程开启前<br>  &gt;<br>  &gt; <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> start()启动线程<br>  &gt;<br>  &gt; <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> getName()获取线程的名字默认是<span class="hljs-keyword">Thread</span>-索引<br>  &gt;<br>  &gt; <span class="hljs-keyword">public</span> static <span class="hljs-keyword">Thread</span> currentThread();获取当前线程，哪个线程调用这个代码，这个代码就拿到哪个线程<br><br>- 常用构造器<br><br>~~~java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">Thread</span>(<span class="hljs-built_in">String</span> name)<span class="hljs-comment">//初始化时传入线程的名字</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">Thread</span>(Runnable target)<span class="hljs-comment">//封装Runnable对象，（传入任务）对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">Thread</span>(Runnable target,<span class="hljs-built_in">String</span> name)<span class="hljs-comment">//传入任务对象和线程的名字</span><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>线程休眠</p>
</li>
</ul>
<p>让**<code>当前执行的线程</code>**进入休眠状态</p>
<p>public static void sleep(long times)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">10</span>;i++)&#123;<br>System.out.println(i);<br><span class="hljs-keyword">try</span>&#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">//1000ms=1s</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<span class="hljs-comment">//线程被中断抛出InterruptedException</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>案例- 防止CPU占用100%</p>
<p>单核CPU，在运行java死循环程序时，空转浪费cpu</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-keyword">try</span>&#123;<br>Thread.sleep(<span class="hljs-number">50</span>);<br>&#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>sleep</code>与<code>wait</code>的区别：</p>
<blockquote>
<p>sleep()方法，线程不会释放对象锁。而调用wait()方法的时候，线程会放弃对象所，进入等待锁定池，直到针对该对象调用notify()方法后，本线程才进入对象池准备获取对象进入运行状态。</p>
</blockquote>
<ul>
<li>线程插队</li>
</ul>
<p>让调用这个方法的线程先执行完毕</p>
<p>public final void join()..</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>MyThread t1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread2</span>();<br>t1.start();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<br>System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;线程输出：&quot;</span>+i);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> extend Thread&#123;<br><span class="hljs-meta">@Override</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<br>System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;子线程输出：&quot;</span>+i);<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            t1.join();<span class="hljs-comment">//当i为1时，子线程插队;子线程执行完毕再执行主线程。</span><br>        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>       e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>线程让队</li>
</ul>
<p>void yield():将正在执行的线程暂停，允许其它线程执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">YieldDemo</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mian</span><span class="hljs-params">(Strin[]args)</span>&#123;<br>Thread thread1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;-Count&quot;</span>+i);<br><span class="hljs-keyword">if</span>(i==<span class="hljs-number">2</span>)&#123;<br>System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;is yielding...&quot;</span>);<br>Thread.<span class="hljs-keyword">yield</span>();<span class="hljs-comment">//让出时间片</span><br>&#125;<br>&#125;<br>&#125;，<span class="hljs-string">&quot;Thread-1&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; - Count: &quot;</span> + i);<br>&#125;<br>&#125;, <span class="hljs-string">&quot;Thread-2&quot;</span>);<br>thread1.start();<br>thread2.start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>注意事项</li>
</ul>
<ol>
<li><strong>非强制性</strong>：<ul>
<li><code>yield()</code> 只是向调度器发出一个建议，调度器可以选择忽略这个建议。因此，调用 <code>yield()</code> 后，当前线程仍然可能继续运行。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li><code>yield()</code> 通常用于调试或优化线程调度，但在实际生产环境中很少使用，因为它的行为不可预测。</li>
</ul>
</li>
<li><strong>优先级影响</strong>：<ul>
<li><code>yield()</code> 只会让出与当前线程相同优先级的线程运行。如果其他线程的优先级较低，则它们不会被调度。</li>
</ul>
</li>
</ol>
<ul>
<li><p>线程优先级</p>
<p>每个线程执行时都具有一个优先级的属性，优先级高的线程可以获得较多的执行机会，但是线程的优先级依然无法保障线程的执行次数序，优先级高的线程获取CPU资源的概率较大，优先级低的也并非没有机会执行。</p>
<p>每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main()线程具有普通优先级。</p>
<p>Thread 类提供了 setPriority(int newPriority) 和 getPriority() 方法来设置和返回一个指定线程的优先级。优先级的参数是一个整数，范围1到10。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> MIN_PRIORITY|最低优先级|<span class="hljs-number">1</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> NORM_PRIORITY|中等优先级，线程默认优先级|<span class="hljs-number">5</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> MAX_PRIORITY|最高优先级|<span class="hljs-number">10</span><br><span class="hljs-comment">//虽然 Java 提供了 10 个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和 Java 的 10 个优先级别对应。所以我们应该使用 MAX_PRIORITY、MIN_PRIORITY 和 NORM_PRIORITY 三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>中断线程</p>
<p>通过**interrupt()**方法中断其运行状态</p>
<p>interrupt() 方法可以用来中断一个正处于阻塞状态（如 sleep()、wait()、join() 等）的线程，以便让线程尽快结束。具体来说，调用线程的 interrupt() 方法之后，它的中断标志位会被设置为 true（实际上是通过将一个名为中断状态的 volatile 变量设为 true 来实现的），表示该线程已经被中断，但并不会强制终止该线程的执行。</p>
<p>当一个线程处于阻塞状态时，例如在 sleep()、wait()、join() 等方法内部时，如果此时另一个线程调用了该线程的 interrupt() 方法，那么该线程就会被中断，也就是抛出 InterruptedException 异常（如果线程没有处于阻塞状态，则不会有任何影响）。这个 InterruptedException 异常可以被捕获并进行相应的处理，例如跳出循环、释放资源等。因为在 InterruptedException 异常被抛出之前，线程所持有的锁不会被释放，因此需要在 finally 块中处理相关资源的释放。</p>
<p>需要注意的是，interrupt() 方法只是设置了一个中断标志位，并不能强制结束线程的执行。如果我们希望结束线程的执行，需要在相应的业务逻辑中做出响应的处理，比如检查中断标志位，然后主动退出线程的执行。如果不进行相应的处理，线程就会继续执行下去，直到完成所有任务，这可能不是我们期望的结果。</p>
<ul>
<li><p>两阶段终止模式</p>
<ol>
<li><strong>第一阶段：通知线程停止</strong><ul>
<li>主线程向目标线程发送一个停止信号（通常通过设置一个标志位或使用某种通信机制）。</li>
<li>目标线程在接收到停止信号后，会逐步完成当前任务，并释放占用的资源。</li>
</ul>
</li>
<li><strong>第二阶段：等待线程结束</strong><ul>
<li>主线程等待目标线程完全退出。如果目标线程在合理的时间内未能退出，可以采取强制终止或其他措施。</li>
</ul>
</li>
</ol>
</li>
<li><pre><code class="Java">public class demo&#123;
    public static void main(String[]args)&#123;
        TwoPhaseTermination tpt=new TwoPhaseTermination();
        tpt.start();
        Thread.sleep(200);
        tpt.stop();//使线程报中断异常
    &#125;
&#125;
class TwoPhaseTermination&#123;
    private Thread moniter;
    public void start()&#123;
        monitor =new Thread(()-&gt;&#123;
            while(true)&#123;
                if(Thread.currentThred().current.isInerrupted())//未被中断为false
                &#123;
                    System.out.println(&quot;处理后事，如释放资源等等&quot;);
                    break;
                &#125; 
                try&#123;
                    Thread.sleep(1000);
                    System.out.println(&quot;执行监控记录&quot;);
                &#125;catch(InterruptedException e)&#123;
                    e.printStackTrace();
                    //重新设置打断标记
                    Thread.currentThread().Interrupt();
                &#125;
            &#125;
        &#125;);
        monitor.start();
    &#125;
&#125;public class TwoPhaseTerminationExample &#123;

    // 定义一个可终止的任务类
    static class Task implements Runnable &#123;
        private volatile boolean isRunning = true; // 停止标志
//volatile -保证可见性，不同线程之间数据同步可见
        @Override
        public void run() &#123;
            System.out.println(&quot;Task started...&quot;);
            while (isRunning) &#123;
                try &#123;
                    // 模拟任务执行
                    System.out.println(&quot;Task is running...&quot;);
                    Thread.sleep(1000); // 每秒执行一次
                &#125; catch (InterruptedException e) &#123;
                    Thread.currentThread().interrupt(); // 恢复中断状态
                    System.out.println(&quot;Task was interrupted.&quot;);
                    break;
                &#125;
            &#125;

            // 清理操作
            cleanup();
            System.out.println(&quot;Task terminated gracefully.&quot;);
        &#125;

        // 请求停止
        public void requestStop() &#123;
            isRunning = false;
        &#125;

        // 清理资源
        private void cleanup() &#123;
            System.out.println(&quot;Performing cleanup...&quot;);
            // 在这里执行清理逻辑，例如关闭文件、释放锁等
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        Task task = new Task();
        Thread workerThread = new Thread(task);
        workerThread.start();

        // 让任务运行一段时间
        Thread.sleep(5000);

        // 请求任务停止
        System.out.println(&quot;Main thread requests task to stop...&quot;);
        task.requestStop();

        // 等待任务线程退出
        workerThread.join(); // 等待线程完全退出

        System.out.println(&quot;Main thread continues...&quot;);
    &#125;
&#125;
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 守护线程<br><br>  守护线程–也称“服务线程”,他是后台线程，它有一个特性，即为用户线程 提供 公共服务，在没有用户线程可服务时会自动离开。<br><br>  守护线程使用的情况较少，但并非无用，举例来说，JVM 的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。调用线程对象的方法 setDaemon(<span class="hljs-literal">true</span>),则可以将其设置为守护线程<br><br>  守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务<br><br>  通过 setDaemon(<span class="hljs-literal">true</span>) 来设置线程为“守护线程”，将一个用户线程设置为守护线程 的方式是在 线程对象创建 之前 用线程对象的 setDaemon 方法。<br><br>  ~~~java<br>  <span class="hljs-keyword">Thread</span> daemonTread = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Thread</span>()<span class="hljs-comment">;</span><br>  <br>   // 设定 daemonThread 为 守护线程,default <span class="hljs-literal">false</span>(非守护线程)<br>  daemonThread.setDaemon(<span class="hljs-literal">true</span>)<span class="hljs-comment">;</span><br>  <br>  // 验证当前线程是否为守护线程,返回 <span class="hljs-literal">true</span> 则为守护线程<br>  daemonThread.isDaemon()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>(1) thread.setDaemon(true) 必须在 thread.start() 之前设置，否则会抛出出一个 IllegalThreadStateException 异常。你不能把正在运行的常规线程设置为守护线程。<br>(2) 在 Daemon 线程中产生的新线程也是 Daemon 的。<br>(3) 不要认为所有的应用都可以分配给 Daemon 来进行服务，比如读写操作或者计算逻辑。</p>
<p>线程则是 JVM 级别的，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的 生命周期并不会和 Web 应用程序保持同步。也就是说，即使你停止了 Web 应用，这个线程 依旧是活跃的。</p>
</li>
<li><p>ThreadLocal</p>
</li>
</ul>
<p><img src="/.com//image-20250305213411493.png" srcset="/img/loading.gif" lazyload alt="image-20250305213411493"></p>
<h3 id="14-3-线程安全"><a href="#14-3-线程安全" class="headerlink" title="14.3.线程安全"></a>14.3.线程安全</h3><ul>
<li>多个线程，同时操作同一个共享资源时，可能会出现业务安全问题</li>
</ul>
<p>原因：</p>
<ul>
<li><blockquote>
<p>存在多个线程同时执行</p>
<p>同时访问一个共享资源</p>
<p>存在修改共享资源</p>
</blockquote>
<ul>
<li>模拟两个账户同时取钱</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>&#123;<br><span class="hljs-keyword">private</span> String cardId;<span class="hljs-comment">//卡号</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">double</span> money;<span class="hljs-comment">//余额</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span>&#123;<br>    <span class="hljs-comment">//拿到当前谁在取钱</span><br>    String name=Thread.currentThread().getName();<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.money&gt;=money)&#123;<br>        System.out.println(name+<span class="hljs-string">&quot;取钱成功，取了&quot;</span>+money+<span class="hljs-string">&quot;元，余额为：&quot;</span>(<span class="hljs-built_in">this</span>.money-money));<br>        <span class="hljs-built_in">this</span>.money-=money;<span class="hljs-comment">//更新余额放最后，更大概率模拟出来两个人都取到钱的情况</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;余额不足！&quot;</span>);<br>&#125;    <br>    <span class="hljs-comment">//。。。构造器以及getter、setter</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-comment">//初始化账户</span><br>Account acc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>(<span class="hljs-string">&quot;ICBC_0910&quot;</span>,<span class="hljs-number">100000</span>);<br><span class="hljs-comment">//创建两个线程同时取钱</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">drawThread</span>(<span class="hljs-string">&quot;小明&quot;</span>,acc).start();   <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">drawThread</span>(<span class="hljs-string">&quot;小红&quot;</span>,acc).start(); <br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">drawThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><span class="hljs-keyword">private</span> Account acc;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">drawThread</span><span class="hljs-params">(String name,Account acc)</span>&#123;<br><span class="hljs-built_in">super</span>(name);<br><span class="hljs-built_in">this</span>.acc=acc;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//取钱</span><br>acc.drawMoney(<span class="hljs-number">100000</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="14-4-线程同步"><a href="#14-4-线程同步" class="headerlink" title="14.4.线程同步"></a>14.4.线程同步</h3><h4 id="1-简单-同步"><a href="#1-简单-同步" class="headerlink" title="1.简单-同步"></a>1.简单-同步</h4><ul>
<li>加锁：每次只允许一个线程加锁，加锁后才能进入访问，访问完毕自动解锁，然后其它线程才能进入并且加锁</li>
<li><strong>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</strong></li>
<li>对临界区（对共享资源进行读写操作的代码）进行上锁</li>
</ul>
<blockquote>
<ol>
<li>同步代码块</li>
</ol>
<p>作用：把访问的共享资源的核心代码给上锁，以此保证线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">synchronized</span>(同步锁)&#123;<br>&gt;<span class="hljs-comment">//访问共享资源的核心代码</span><br>&gt;&#125;<br></code></pre></td></tr></table></figure>

<p>原理：每次只允许一个线程加锁后进入，执行完毕后自动解锁，其它线程才可以进来执行。</p>
<p>注意：对于当前同时执行的线程来说，同步锁必须是同一把（同一个对象），否则会出bug。</p>
<ul>
<li><blockquote>
<p>建议使用共享资源作为锁对象，对于实例方法建议使用this作为锁对象。<br>对于静态和类中声明的方法建议使用字节码（类名.class）对象作为锁对象。</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li>同步方法</li>
</ol>
<p>作用：把访问的资源核心方法给上锁，以此保证线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;修饰符 <span class="hljs-keyword">synchronized</span> 方法名（参数列表）<br></code></pre></td></tr></table></figure>

<p>对于实例方法默认使用this作为锁对象。</p>
<p>对于静态方法默认使用字节码（类名.class）对象作为锁对象</p>
<p>优点：范围更大，可读性好</p>
<p>缺点：性能缺少</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Method A is running...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Method B is running...&quot;</span>);<br><span class="hljs-comment">//修饰实例方法，锁的是该方法所属对象的实例锁（this）,同一个实例调用才有互斥效果</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethodA</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Static Method A is running...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethodB</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Static Method B is running...&quot;</span>);<br><span class="hljs-comment">//修饰静态方法，锁的是Class对象，同一时间只有一个线程执行其中一个方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodC</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Method C is running...&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodD</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Method D is running...&quot;</span>);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//同步代码块，指定一个对象作为锁，适用于更细粒度的同步控制</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<ol>
<li><strong>优先使用专用锁对象</strong>：<code>private final Object LOCK = new Object()</code>。</li>
<li><strong>静态同步用类锁</strong>：<code>private static final Object LOCK = new Object()</code> 或 <code>synchronized(ClassName.class)</code>。</li>
<li><strong>避免使用公有对象、字符串常量、包装类作为锁</strong>。</li>
<li><strong>锁对象必须是<code>final</code>的</strong>，确保引用不可变。</li>
<li><strong>锁的粒度要合理</strong>：只同步必要的代码块，避免过度同步。</li>
</ol>
<blockquote>
<ol start="3">
<li><code>lock锁</code></li>
</ol>
<p>作用：可以创建出锁对象进行加锁和解锁，更灵活，更方便，更强大。</p>
<p>Lock是接口，不能直接实例化，可以采用它的实现类<code>ReentrantLock</code>来构建Lock锁对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java">&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>&#123;<br>&gt;<span class="hljs-keyword">private</span> String cardId;<span class="hljs-comment">//卡号</span><br>&gt;<span class="hljs-keyword">private</span> <span class="hljs-type">double</span> money;<span class="hljs-comment">//余额</span><br>&gt;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock lk=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<span class="hljs-comment">//final保护锁对象</span><br><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span>&#123;<br>  <span class="hljs-comment">//拿到当前谁在取钱</span><br>  String name=Thread.currentThread().getName();<br>  <span class="hljs-comment">//上锁</span><br>  lk.lock();<br>  <span class="hljs-keyword">try</span>&#123;<br>       <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.money&gt;=money)&#123;<br>      System.out.println(name+<span class="hljs-string">&quot;取钱成功，取了&quot;</span>+money+<span class="hljs-string">&quot;元，余额为：&quot;</span>(<span class="hljs-built_in">this</span>.money-money));<br>      <span class="hljs-built_in">this</span>.money-=money;<span class="hljs-comment">//更新余额放最后，更大概率模拟出来两个人都取到钱的情况</span><br>  &#125;<br>  <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;余额不足！&quot;</span>);<br>&gt;&#125; <br>  &#125;<br>  <span class="hljs-keyword">finally</span>&#123;<br>      lk.unlock();<span class="hljs-comment">//解锁，防止出现异常无法解锁</span><br>  &#125;<br><br>  <span class="hljs-comment">//。。。构造器以及getter、setter</span><br>&gt;&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><code>synchronized</code>详解</p>
</li>
<li><p><code>ReentrantLock</code>详解</p>
</li>
</ul>
<h4 id="2-进阶-volatile关键字"><a href="#2-进阶-volatile关键字" class="headerlink" title="2.进阶-volatile关键字"></a>2.进阶-volatile关键字</h4><ul>
<li>可见性</li>
</ul>
<h4 id="3-进阶-JMM"><a href="#3-进阶-JMM" class="headerlink" title="3.进阶-JMM"></a>3.进阶-JMM</h4><h4 id="4-进阶-悲观锁、乐观锁、CAS"><a href="#4-进阶-悲观锁、乐观锁、CAS" class="headerlink" title="4.进阶-悲观锁、乐观锁、CAS"></a>4.进阶-悲观锁、乐观锁、CAS</h4><h4 id="5-进阶-原子性"><a href="#5-进阶-原子性" class="headerlink" title="5.进阶-原子性"></a>5.进阶-原子性</h4><h4 id="6-进阶-并发工具类concurrent"><a href="#6-进阶-并发工具类concurrent" class="headerlink" title="6.进阶-并发工具类concurrent"></a>6.进阶-并发工具类concurrent</h4><p><code>CountDownLatch</code> 是 <code>java.util.concurrent</code> 包中的同步辅助类 ，用于实现多线程同步。其核心要点如下：</p>
<ul>
<li><strong>原理</strong>：通过一个计数器实现线程间的协调。创建时指定初始计数，代表需要完成的操作数量。执行任务的线程完成任务后，调用 <code>countDown()</code> 方法使计数器减 1 ；等待的线程调用 <code>await()</code> 方法进入阻塞状态，直到计数器递减为 0 时被唤醒继续执行 。</li>
<li>关键方法<ul>
<li><code>countDown()</code>：执行任务的线程调用，将计数器减 1 。</li>
<li><code>await()</code>：使调用线程阻塞，等待计数器变为 0 。也有带超时参数的 <code>await(long timeout, TimeUnit unit)</code> ，在超时或计数器为 0 时返回 。</li>
</ul>
</li>
<li><strong>线程安全</strong>：内部基于 AQS（抽象队列同步器）实现，保证计数操作的原子性和可见性，多线程并发调用相关方法也能正确工作 。</li>
<li><strong>应用场景</strong>：适用于一个或多个线程等待其他多个线程完成任务的场景，如子任务并行计算后主线程汇总结果、Web 应用中等待多个 API 响应聚合、服务启动时等待多个外部服务就绪等 。</li>
<li><strong>局限性</strong>：计数器一旦为 0 无法重置，不能重复使用 ；使用时要确保 <code>countDown()</code> 正确调用，否则可能导致等待线程永久阻塞 。 与 <code>CyclicBarrier</code> 相比，它不可重用且线程行为不同 。</li>
</ul>
<h4 id="7-进阶-AQS原理"><a href="#7-进阶-AQS原理" class="headerlink" title="7.进阶-AQS原理"></a>7.进阶-AQS原理</h4><ul>
<li>全称是AbstractQueuedSynchronizer,是阻塞式锁和相关的同步工具的框架</li>
</ul>
<h5 id="1-AQS-的核心思想"><a href="#1-AQS-的核心思想" class="headerlink" title="1.AQS 的核心思想"></a>1.AQS 的核心思想</h5><p>AQS 的核心思想是通过一个共享的同步状态（state）和一个CLH 队列（双向链表）来协调线程的竞争和等待。</p>
<p>同步状态（state）：表示资源的可用性或锁的状态。线程可以通过原子操作（如 CAS）来修改这个状态。<br>CLH 队列：当多个线程竞争资源时，未能获取资源的线程会被加入到 CLH 队列中，等待资源释放。</p>
<h5 id="2-AQS-的主要组成部分"><a href="#2-AQS-的主要组成部分" class="headerlink" title="2.AQS 的主要组成部分"></a>2.AQS 的主要组成部分</h5><p>(1) 同步状态（state）</p>
<ul>
<li><p>state 是一个volatile变量，用于表示当前的同步状态。<br>线程可以通过以下方法操作 state：</p>
<ul>
<li>getState()：获取当前的同步状态。</li>
<li>setState(int newState)：设置同步状态。</li>
<li>compareAndSetState(int expect, int update)：通过 CAS 操作更新同步状态。</li>
</ul>
</li>
</ul>
<p> (2) CLH 队列</p>
<ul>
<li><p>CLH 队列是一个双向链表，用于管理等待线程。<br> 每个节点（Node）代表一个线程，包含以下信息：</p>
<ul>
<li><p>prev 和 next：指向前后节点的指针。</p>
</li>
<li><p>thread：表示当前节点对应的线程。</p>
</li>
<li><p>waitStatus：表示节点的状态，可能的值包括： 0：初始状态。</p>
</li>
<li><p>SIGNAL (-1)：表示后继节点需要被唤醒。</p>
</li>
<li><p>CANCELLED (1)：表示该节点已被取消。</p>
</li>
<li><p>CONDITION (-2)：表示该节点在条件队列中等待。</p>
</li>
<li><p>PROPAGATE (-3)：表示共享模式下后续节点可以尝试获取资源。</p>
</li>
</ul>
</li>
</ul>
<h5 id="3-AQS-的工作原理"><a href="#3-AQS-的工作原理" class="headerlink" title="3.AQS 的工作原理"></a>3.AQS 的工作原理</h5><p>AQS 的工作流程可以分为以下几个步骤：</p>
<p>(1) 获取同步状态<br>线程尝试获取同步状态（state），具体逻辑由子类实现（例如 tryAcquire 或 tryAcquireShared）。<br>如果获取成功，则线程继续执行。<br>如果获取失败，则线程被加入到 CLH 队列中，并进入等待状态。<br>(2) 加入 CLH 队列<br>当线程无法获取同步状态时，它会被封装为一个 Node 节点并加入到 CLH 队列的尾部。<br>AQS 使用 CAS 操作确保队列操作的线程安全性。<br>(3) 等待与唤醒<br>在 CLH 队列中，线程会阻塞，直到前驱节点释放锁或资源。<br>当前驱节点完成任务后，会唤醒其后继节点，允许后继节点重新尝试获取同步状态。<br>(4) 释放同步状态<br>线程完成任务后，会释放同步状态（state），具体逻辑由子类实现（例如 tryRelease 或 tryReleaseShared）。<br>释放同步状态后，AQS 会唤醒 CLH 队列中的下一个等待线程。</p>
<h5 id="4-AQS-的两种模式"><a href="#4-AQS-的两种模式" class="headerlink" title="4.AQS 的两种模式"></a>4.AQS 的两种模式</h5><p>AQS 支持两种模式来管理同步状态：</p>
<p>(1) 独占模式<br>独占模式表示同一时间只有一个线程可以持有锁。<br>示例：ReentrantLock。<br>关键方法：<br>tryAcquire(int arg)：尝试获取独占锁。<br>tryRelease(int arg)：尝试释放独占锁。<br>(2) 共享模式<br>共享模式允许多个线程同时持有锁。<br>示例：Semaphore、CountDownLatch。<br>关键方法：<br>tryAcquireShared(int arg)：尝试获取共享锁。<br>tryReleaseShared(int arg)：尝试释放共享锁。</p>
<h5 id="5-AQS-的核心方法"><a href="#5-AQS-的核心方法" class="headerlink" title="5.AQS 的核心方法"></a>5.AQS 的核心方法</h5><p>AQS 提供了一些模板方法，子类需要根据具体的同步需求实现这些方法：</p>
<p>(1) 独占模式的核心方法<br>tryAcquire(int arg)：尝试获取独占锁。<br>tryRelease(int arg)：尝试释放独占锁。<br>isHeldExclusively()：判断当前线程是否独占地持有锁。<br>(2) 共享模式的核心方法<br>tryAcquireShared(int arg)：尝试获取共享锁。<br>tryReleaseShared(int arg)：尝试释放共享锁。<br>(3) 其他方法<br>getState()：获取当前的同步状态。<br>setState(int newState)：设置同步状态。<br>compareAndSetState(int expect, int update)：通过 CAS 操作更新同步状态。</p>
<h3 id="14-5-线程池"><a href="#14-5-线程池" class="headerlink" title="14.5.线程池"></a>14.5.线程池</h3><ul>
<li>线程池是一个可以<code>复用线程</code>的技术</li>
</ul>
<blockquote>
<ul>
<li>创建线程池</li>
</ul>
<p>代表线程池的接口：ExecutorService</p>
<ul>
<li>方式一：使用ExecutorService的实现类ThreadPoolExecutor</li>
</ul>
<p><img src="/.com//image-20241128182621673.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<p>最大线程数的配置：</p>
<p>如果是CPU密集型任务：电脑的逻辑处理器数量+1</p>
<p>IO密集型任务：电脑的逻辑处理器数量*2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建线程池对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-comment">//1、使用线程池的实现类ThreadPoolExecutor</span><br>ExecutorService pool=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,TimeUnit.SECONDS,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArryBlockingQueue</span>&lt;&gt;(<span class="hljs-number">3</span>),Executors.defaultThreadFactory(),<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolAbortPolicy</span>());<span class="hljs-comment">//拒绝策略为抛异常处理</span><br><span class="hljs-comment">//2、处理Runnable任务和Callable任务,看会不会复用线程</span><br><span class="hljs-comment">//Runnable任务</span><br>Runnable target=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><span class="hljs-comment">//提交任务pool.execute(任务对象)，任务可以复用，创建线程，自动启动线程处理该任务。</span><br>pool.execute(target);<span class="hljs-comment">//提交第一个任务</span><br>pool.execute(target);<span class="hljs-comment">//提交第二个</span><br>pool.execute(target);<span class="hljs-comment">//提交第三个</span><br><span class="hljs-comment">//pool.execute(target);//复用线程</span><br><span class="hljs-comment">//pool.execute(target);//复用线程</span><br>pool.execute(target);<span class="hljs-comment">//无法复用，放入任务队列</span><br>pool.execute(target);<br>pool.execute(target);<br>pool.execute(target);<span class="hljs-comment">//任务队列满，到了创建临时线程时机</span><br>pool.execute(target);<br>pool.execute(target);<span class="hljs-comment">//临时线程满了，到了任务拒绝时机</span><br><br>    <br><span class="hljs-comment">//Callable任务</span><br>Future&lt;String&gt; f1=pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">100</span>));<span class="hljs-comment">//多态，用Future接口来接FutureTask对象</span><br>Future&lt;String&gt; f1=pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">200</span>));  <br>Future&lt;String&gt; f1=pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">300</span>));  <br>Future&lt;String&gt; f1=pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">400</span>));  <br><span class="hljs-keyword">try</span>&#123;<br>    System.out.println(f1.get());<br>    System.out.println(f2.get());<br>    System.out.println(f3.get());<br>    System.out.println(f4.get()); <br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//3、关闭线程池，（*一般不关闭线程池）</span><br>pool.shutdown();<span class="hljs-comment">//等所有任务执行完毕后再关闭线程池</span><br><span class="hljs-comment">//pool.shutdownNow();//立即关闭，不管任务是否执行完毕</span><br>&#125;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><span class="hljs-meta">@OVerride</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;<br>System.out.println(Thred.currentThread().getName()+<span class="hljs-string">&quot;输出：&quot;</span>+i);<br><span class="hljs-comment">//让线程无法复原模拟临时线程的创建时机</span><br><span class="hljs-keyword">try</span>&#123;<br>Thread.sleep(Integer.MAX_VALUE);<br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mycallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCallable</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<span class="hljs-built_in">this</span>.n=n;&#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=;i&lt;=n;i++)sum+=i;<br>        <span class="hljs-keyword">return</span> Thread.currentThread().getName()+<span class="hljs-string">&quot;计算1-&quot;</span>+n+<span class="hljs-string">&quot;的和是：&quot;</span>+sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>注意：</li>
<li>临时线程的创建时机：</li>
</ul>
<blockquote>
<ul>
<li>核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程</li>
</ul>
</blockquote>
<ul>
<li>拒绝新任务的时机：</li>
</ul>
<blockquote>
<ul>
<li>核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始拒绝任务</li>
</ul>
</blockquote>
<blockquote>
<p>任务拒绝策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadPoolExecutor.AbortPOlicy()<span class="hljs-comment">//丢弃任务并且抛出异常</span><br>ThreadPoolExecutor.DiscardPolicy()<span class="hljs-comment">//直接丢弃（不推荐）</span><br>ThreadPOOlExecutor.DiscardOldestPolicy()<span class="hljs-comment">//丢弃任务队列中等待最久的任务，然后把当前任务加入队列</span><br>ThreadPoolExecutor.CallerRunsPolicy()<span class="hljs-comment">//由主线程负责调用任务的run()方法从而绕过线程池直接执行</span><br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>方式二：使用Executors(线程池的工具类)调用方法返回不同特点的线程池对象</li>
</ul>
<p><img src="/.com//image-20241202172933438.png" srcset="/img/loading.gif" lazyload alt="image-20241202172933438"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过线程池工具类Executors,调用其静态方法直接的到线程池</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>ExecutorService pool=Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<span class="hljs-comment">//无临时线程</span><br>Future&lt;String&gt; f1=pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">100</span>));<span class="hljs-comment">//多态，用Future接口来接FutureTask对象</span><br>Future&lt;String&gt; f1=pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">200</span>));  <br>Future&lt;String&gt; f1=pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">300</span>));  <br>Future&lt;String&gt; f1=pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">400</span>));  <br><span class="hljs-keyword">try</span>&#123;<br>    System.out.println(f1.get());<br>    System.out.println(f2.get());<br>    System.out.println(f3.get());<br>    System.out.println(f4.get()); <br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>注意：</li>
</ul>
<blockquote>
<ul>
<li>这些方法的底层都是通过线程池的实现类ThreadPoolExecutor创建的线程池对象</li>
<li>尽量使用ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</li>
<li><ol>
<li>FixedThreadPool和SingleThreadPool:允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，导致OOM（内存溢出）</li>
</ol>
</li>
</ul>
<ol start="2">
<li>CachedThreadPool和ScheduledThreadPool:允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程,导致OOM（内存溢出）</li>
</ol>
</blockquote>
<h3 id="14-6-并发和并行"><a href="#14-6-并发和并行" class="headerlink" title="14.6.并发和并行"></a>14.6.并发和并行</h3><ul>
<li><p>进程：正在运行的程序（软件）就是一个独立的进程。</p>
<ul>
<li>线程是属于进程的，一个进程中可以同时运行很多个线程</li>
<li>进程中的多个线程其实是并发和并行执行的（取决于CPU的核数，单核只能并发）</li>
</ul>
</li>
<li><p>并发：进程中的线程是由CPU负责调度执行的，但CPU能同时处理线程的数量有限，为了保证全部线程都能往前执行，CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。</p>
</li>
<li><p>并行：在同一个时刻上，同时有多个线程在被CPU调度执行。</p>
</li>
<li><p><code>多线程是并发和并行同时</code>。</p>
</li>
<li><p>红包雨游戏，某企业100名员工，工号1到100，发出两百个红包，其中小红包在【1-30】元之间，总占比为80%，大红包【31-100】元，总占比为20%<br>模拟100个员工抢红包，输出哪个员工抢到哪个红包的过程，活动结束时提示活动结束<br>结束后对100名员工按照抢到的红包金额进行排序，并输出。。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.Multi_Thread_test;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-comment">//红包雨游戏，某企业100名员工，工号1到100，发出两百个红包，其中小红包在【1-30】元之间，总占比为80%，大红包【31-100】元，总占比为20%</span><br><span class="hljs-comment">//模拟100个员工抢红包，输出哪个员工抢到哪个红包的过程，活动结束时提示活动结束</span><br><span class="hljs-comment">//结束后对100名员工按照抢到的红包金额进行排序，并输出。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest</span> &#123;<br><span class="hljs-comment">//100个员工相当于100个线程来竞争200个红包</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//2、定义线程类，创建100个线程，竞争同一个集合</span><br>    List&lt;Integer&gt;redpacket=getRedPacket();<br>    List&lt;Peoplegetredpacket&gt;Threads=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++)&#123;<br>Peoplegetredpacket t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Peoplegetredpacket</span>(redpacket,<span class="hljs-string">&quot;员工&quot;</span>+i);<br>Threads.add(t);<br>t.start();<br>&#125;<br><span class="hljs-comment">//3、等待所有线程执行完毕，才进入主线程</span><br>    <span class="hljs-keyword">for</span>(Thread t:Threads)&#123;<br><span class="hljs-keyword">try</span> &#123;<br>t.join();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>    <span class="hljs-comment">//4、对抢到的红包进行排序，并输出</span><br>Collections.sort(Threads,(t1,t2)-&gt;t2.getTotalmoney() - t1.getTotalmoney());<br>System.out.println(<span class="hljs-string">&quot;员工按抢到的红包金额排序：&quot;</span>);<br><span class="hljs-keyword">for</span>(Peoplegetredpacket t:Threads)&#123;<br>System.out.println(t.getName()+<span class="hljs-string">&quot;抢到红包总额：&quot;</span>+t.getTotalmoney());<br>&#125;<br><br>&#125;<br><span class="hljs-comment">//1、准备两百个随机的红包返回，放到List集合中去返回</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">getRedPacket</span><span class="hljs-params">()</span>&#123;<br>        Random random=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-comment">//模拟两百个红包,随机产生200个红包，小红包在1-30之间，大红包31-100，小红包占80%，大红包占20%</span><br>        List&lt;Integer&gt;redpacket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">160</span>;i++)redpacket.add(random.nextInt(<span class="hljs-number">30</span>)+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">40</span>;i++)redpacket.add(random.nextInt(<span class="hljs-number">70</span>)+<span class="hljs-number">31</span>);<br>        <span class="hljs-keyword">return</span> redpacket;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.Multi_Thread_test;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Peoplegetredpacket</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>   List&lt;Integer&gt; redpacket;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> totalmoney;<br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Peoplegetredpacket</span><span class="hljs-params">(List&lt;Integer&gt; redpacket,String name)</span>&#123;<br>       <span class="hljs-built_in">super</span>(name);<br>       <span class="hljs-built_in">this</span>.redpacket=redpacket;<br>       totalmoney=<span class="hljs-number">0</span>;<br>   &#125;<br>   <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>           <span class="hljs-comment">//随机获取一个红包</span><br>           <span class="hljs-keyword">synchronized</span> (redpacket) &#123;<br>               <span class="hljs-keyword">if</span>(redpacket.size()==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.random() * redpacket.size();<br>               <span class="hljs-type">int</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> redpacket.remove(index);<br>               totalmoney += money;<br>               System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;抢到红包：&quot;</span> + money);<br>               <span class="hljs-keyword">if</span> (redpacket.size() == <span class="hljs-number">0</span>) &#123;<br>                   System.out.println(<span class="hljs-string">&quot;活动结束！&quot;</span>);<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">try</span> &#123;<br>               Thread.sleep(<span class="hljs-number">500</span>);<br>           &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>               e.printStackTrace();<br>           &#125;<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getTotalmoney</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">return</span> totalmoney;<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>





<h2 id="15-网络处理"><a href="#15-网络处理" class="headerlink" title="15.网络处理"></a>15.网络处理</h2><ul>
<li>基本的通信架构</li>
</ul>
<blockquote>
<ul>
<li>CS架构（Client客户端&#x2F;Server服务端）</li>
<li>BS架构(Browser浏览器&#x2F;Server服务器)</li>
</ul>
</blockquote>
<p>域名-》DNS解析-》ip地址-》与服务器通信</p>
<p>公网IP:是可以连接到互联网的IP地址</p>
<p>内网IP:也叫局域网IP,是只能组织机构内部使用的IP地址；例如：192.168.开头的就是常见的局域网地址，范围为192.168.0.0-192.168.255.255</p>
<p>本机IP:127.0.0.1、localhost</p>
<p>ipconfig:查看本机的网络信息</p>
<p>ping:检查网络是否联通</p>
<h4 id="15-1-InetAddress"><a href="#15-1-InetAddress" class="headerlink" title="15.1.InetAddress"></a>15.1.InetAddress</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InetAddress <span class="hljs-title function_">getLocalHost</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> UnknownHostException<span class="hljs-comment">//获取本机Ip</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getHostName</span><span class="hljs-params">()</span><span class="hljs-comment">//获取该IP的主机名</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getHostAddress</span><span class="hljs-params">(String host)</span>  <span class="hljs-keyword">throws</span> UnknownHostException<span class="hljs-comment">//根据ip地址或者域名，返回一个inetAddress对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isReachable</span><span class="hljs-params">(<span class="hljs-type">int</span> timeout)</span><span class="hljs-keyword">throws</span> IOException<span class="hljs-comment">//判断主机在指定毫秒内与该ip对应的主机是否能连通</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InetAddress <span class="hljs-title function_">getByName</span><span class="hljs-params">(<span class="hljs-string">&quot;域名/ip地址&quot;</span>)</span>    <br></code></pre></td></tr></table></figure>

<ul>
<li>获取本机ip对象和对方ip对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<span class="hljs-comment">//获取本机ip</span><br>InetAddress ip1=InetAddress.getLocalHost();<br>System.out.println(ip1.getHostName());<br>System.out.println(ip1.getHostAddress());<br><span class="hljs-comment">//获取对方ip对象</span><br>InetAddress ip2=InetAddress.getByName(<span class="hljs-string">&quot;www.baidu.com&quot;</span>);<br>System.out.println(ip2.getHostName());<br>System.out.println(ip2.getHostAddress());<br><span class="hljs-comment">//判断本机与对方主机是否互通</span><br>System.out.println(ip2.isReachable(<span class="hljs-number">5000</span>));<span class="hljs-comment">//五秒内是否可以互通</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>端口</li>
</ul>
<p><img src="/.com//java.assets%5Cimage-20241202202113494.png" srcset="/img/loading.gif" lazyload alt="image-20241202202113494"></p>
<ul>
<li>传输层的协议</li>
</ul>
<p>UDP协议：无连接不可靠，用户数据报协议，只管发出去（适用于语言、视频）</p>
<p>TCP协议：面向连接，可靠，要保证在不可靠的信道上实现可靠的通信（网页、文件下载、支付）</p>
<h4 id="15-2-UDP通信"><a href="#15-2-UDP通信" class="headerlink" title="15.2.UDP通信"></a>15.2.UDP通信</h4><ul>
<li>特点：无连接不可靠</li>
<li>DatagramSocket(int port),DatagramPacket(byte[] buf,int length,&#x2F;&#x2F;address,port)</li>
</ul>
<p><img src="/.com//image-20241212082603810.png" srcset="/img/loading.gif" lazyload alt="image-20241212082603810"></p>
<ul>
<li>完成UDP通信：实现一发一收</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPclientDemo1</span>  <span class="hljs-comment">//客户端</span><br>&#123;<span class="hljs-comment">//1.创建发送端对象  </span><br>System.out.println(<span class="hljs-string">&quot;客户端启动&quot;</span>)    <br>DatagramSocket socket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();<span class="hljs-comment">//默认分配端口，也可以指定端口</span><br><span class="hljs-comment">//2.创建数据包对象封装要发送的数据</span><br><span class="hljs-comment">//参数1：发送的数据，参数2：发送的数据长度，参数3：目的端的IP地址，参数4：服务端的程序端口号</span><br><span class="hljs-type">byte</span>[] bytes=<span class="hljs-string">&quot;asddsdasd&quot;</span> .getBytes();  <br>DatagramPacket packet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(bytes,bytes.length,InerAddress.getLocalHost,<span class="hljs-number">8000</span>);<br><span class="hljs-comment">//3.让发送端对象发送数据包的数据</span><br>socket.send(packet);<br>socket.close();<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPServerDemo2</span>&#123;<span class="hljs-comment">//服务端</span><br><span class="hljs-comment">//1.创建接收端对象，指定端口号</span><br>System.out.println(<span class="hljs-string">&quot;服务端启动&quot;</span>)<br>DatagramSocket socket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">8000</span>);<br><span class="hljs-comment">//2.创建一个数据包负责接收数据</span><br><span class="hljs-type">byte</span>[] buf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">64</span>];<span class="hljs-comment">//一个包最大64kb</span><br>DatagramPacket packet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buf,buf.length);<br><span class="hljs-comment">//3.接收数据，将数据封装到数据包对象的字节数组中</span><br>socket.recive(packet);<br><span class="hljs-comment">//4.看数据是否收到</span><br><span class="hljs-type">int</span> len=packet.getlength();<span class="hljs-comment">//获取收到的数据包长度</span><br>String data=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf,<span class="hljs-number">0</span>,len);<br>System.out.println(<span class="hljs-string">&quot;服务端收到了：&quot;</span>+data);<br><span class="hljs-comment">//5.获取对方的ip地址以及端口号</span><br>String ip=packet.getInetAddress().getHostAddress();<br><span class="hljs-type">int</span> port=packet.getPort();<br>System.out.println(<span class="hljs-string">&quot;对方ip:&quot;</span>+ip+<span class="hljs-string">&quot;对方端口：&quot;</span>+port);<br>socket.close();<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>多发多收</li>
<li><ul>
<li>客户端和服务端使用死循环</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPclientDemo1</span>  <span class="hljs-comment">//客户端</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-comment">//1.创建发送端对象  </span><br>System.out.println(<span class="hljs-string">&quot;客户端启动&quot;</span>)    <br>DatagramSocket socket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();<span class="hljs-comment">//默认分配端口，也可以指定端口</span><br><span class="hljs-comment">//2.创建数据包对象封装要发送的数据</span><br><span class="hljs-comment">//参数1：发送的数据，参数2：发送的数据长度，参数3：目的端的IP地址，参数4：服务端的程序端口号</span><br>Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>System.out.print(<span class="hljs-string">&quot;请说：&quot;</span>);<br>String msg=sc.nextLine();<br><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;exit&quot;</span>.equals(msg))&#123;<br>System.out.println(<span class="hljs-string">&quot;==客户端退出==&quot;</span>)；<br>socket.close();<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-type">byte</span>[] bytes=msg.getBytes();  <br>DatagramPacket packet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(bytes,bytes.length,InerAddress.getLocalHost,<span class="hljs-number">8000</span>);<br><span class="hljs-comment">//3.让发送端对象发送数据包的数据</span><br>socket.send(packet);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPServerDemo2</span>&#123;<span class="hljs-comment">//服务端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-comment">//1.创建接收端对象，指定端口号</span><br>System.out.println(<span class="hljs-string">&quot;服务端启动&quot;</span>)<br>DatagramSocket socket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">8000</span>);<br><span class="hljs-comment">//2.创建一个数据包负责接收数据</span><br><span class="hljs-type">byte</span>[] buf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">64</span>];<span class="hljs-comment">//一个包最大64kb</span><br>DatagramPacket packet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buf,buf.length);<br><span class="hljs-comment">//3.接收数据，将数据封装到数据包对象的字节数组中</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>socket.recive(packet);<span class="hljs-comment">//等待式接收数据</span><br><span class="hljs-comment">//4.看数据是否收到</span><br><span class="hljs-type">int</span> len=packet.getlength();<span class="hljs-comment">//获取收到的数据包长度</span><br>String data=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf,<span class="hljs-number">0</span>,len);<br>System.out.println(<span class="hljs-string">&quot;服务端收到了：&quot;</span>+data);<br><span class="hljs-comment">//5.获取对方的ip地址以及端口号</span><br>String ip=packet.getIAddress().getHostAddress();<br><span class="hljs-type">int</span> port=packet.getPort();<br>System.out.println(<span class="hljs-string">&quot;对方ip:&quot;</span>+ip+<span class="hljs-string">&quot;对方端口：&quot;</span>+port);<br>System.out.println(<span class="hljs-string">&quot;--------------------------&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="15-3-TCP通信"><a href="#15-3-TCP通信" class="headerlink" title="15.3.TCP通信"></a>15.3.TCP通信</h4><ul>
<li>特点：面向连接，可靠通信</li>
<li>“三次握手” -建立连接</li>
<li>“四次挥手” -断开连接</li>
</ul>
<p><img src="/.com//image-20250421165851026.png" srcset="/img/loading.gif" lazyload alt="image-20250421165851026"></p>
<blockquote>
<p>一发一收</p>
</blockquote>
<p><img src="/.com//image-20241212092517979.png" srcset="/img/loading.gif" lazyload alt="image-20241212092517979"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TCpclientDemo1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-comment">//1.创建客户端Socket对象，请求与服务器的连接</span><br>        Socket socket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">9999</span>);<br><span class="hljs-comment">//2.使用socket对象调用getOutputString()方法得到字节输出流</span><br>        OutputStream os=socket.getOutputStream();<br><span class="hljs-comment">//3.使用字节输出流完成数据的发送</span><br>        DataOutputStream dos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(os);<br>        dos.writeInt(<span class="hljs-number">1</span>);<br>        dos.writeUTF(<span class="hljs-string">&quot;嘎嘎嘎！&quot;</span>);<br><span class="hljs-comment">//4.释放资源：关闭socket管道</span><br>        socket.close();<br>    &#125;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure>

<p><img src="/.com//image-20241212093923345.png" srcset="/img/loading.gif" lazyload alt="image-20241212093923345"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//服务端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo2</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>        <span class="hljs-comment">//实现一发一收</span><br>        <span class="hljs-comment">//1.创建ServerSocket对象，指定端口号</span><br>        ServerSocket ss=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br>        <span class="hljs-comment">//2.调用accept方法，阻塞等待客户端连接，一旦有客户端连接会返回一个Socket对象</span><br>        Socket socket=ss.accept();<br>        <span class="hljs-comment">//3.获取输入流，读取客户端发送的消息</span><br>        IntputStream is=socket.getIntputStream();<br>        <span class="hljs-comment">//4.把字节输入流包装成特殊数据输入流</span><br>        DataInputStream dis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataIntputStream</span>(is);<br>        <span class="hljs-comment">//5.读取数据</span><br>        <span class="hljs-type">int</span> id=dis.readInt();<br>        String msg=dis.readUTF();<br>        System.out.println(<span class="hljs-string">&quot;id&quot;</span>+id+<span class="hljs-string">&quot;,收到的客户端msg:&quot;</span>+msg);<br>        <span class="hljs-comment">//6.获取客户端的ip和端口</span><br>        System.out.println(<span class="hljs-string">&quot;获取客户端的ip地址：&quot;</span>+socket.getInetAddress().getHostAddress());<br>        System.out.println(<span class="hljs-string">&quot;获取客户端的端口号：&quot;</span>+socket.getPort());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>





<blockquote>
<p>多发多收</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TCpclientDemo1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br><span class="hljs-comment">//1.创建客户端Socket对象，请求与服务器的连接</span><br>        Socket socket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">9999</span>);<br><span class="hljs-comment">//2.使用socket对象调用getOutputString()方法得到字节输出流</span><br>        OutputStream os=socket.getOutputStream();<br><span class="hljs-comment">//3.使用字节输出流完成数据的发送</span><br>        DataOutputStream dos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(os);<br>       Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        whlie(<span class="hljs-literal">true</span>)&#123;<br>          System.out.println(<span class="hljs-string">&quot;请说：&quot;</span>);  <br>          String msg=sc.nextLine();<br>            <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;exit&quot;</span>.equals(msg))&#123;<br>                System.out.println(<span class="hljs-string">&quot;退出成功！&quot;</span>);<br>                dos.close();<span class="hljs-comment">//关闭输出管道</span><br>                socket.close();<span class="hljs-comment">//关闭socket</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            dos.writeUTF(msg);<span class="hljs-comment">//发送数据</span><br>            dos.flush();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//服务端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo2</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>        <span class="hljs-comment">//实现一发一收</span><br>        <span class="hljs-comment">//1.创建ServerSocket对象，指定端口号</span><br>        ServerSocket ss=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br>        <span class="hljs-comment">//2.调用accept方法，阻塞等待客户端连接，一旦有客户端连接会返回一个Socket对象</span><br>        Socket socket=ss.accept();<br>        <span class="hljs-comment">//3.获取输入流，读取客户端发送的消息</span><br>        IntputStream is=socket.getIntputStream();<br>        <span class="hljs-comment">//4.把字节输入流包装成特殊数据输入流</span><br>        DataInputStream dis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataIntputStream</span>(is);<br>        <span class="hljs-comment">//5.读取数据</span><br>       <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            String msg=dis.readUTF();<span class="hljs-comment">//等待客户端发送消息</span><br>        System.out.println(<span class="hljs-string">&quot;收到的客户端msg:&quot;</span>+msg);<br>        <span class="hljs-comment">//6.获取客户端的ip和端口</span><br>        System.out.println(<span class="hljs-string">&quot;获取客户端的ip地址：&quot;</span>+socket.getInetAddress().getHostAddress());<br>        System.out.println(<span class="hljs-string">&quot;获取客户端的端口号：&quot;</span>+socket.getPort());<br>           System.out.println(<span class="hljs-string">&quot;------------------&quot;</span>);<br>       &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="15-4-多个客户端同时通信"><a href="#15-4-多个客户端同时通信" class="headerlink" title="15.4.多个客户端同时通信"></a>15.4.多个客户端同时通信</h4><ul>
<li><p>对客户端进行改造</p>
</li>
<li><p>主线程接收客户端连接</p>
</li>
<li><p>子线程处理消息</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//服务端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo2</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[]args)</span>&#123;<br>        <span class="hljs-comment">//实现一发一收</span><br>        <span class="hljs-comment">//1.创建ServerSocket对象，指定端口号</span><br>        ServerSocket ss=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br>        <span class="hljs-comment">//2.调用accept方法，阻塞等待客户端连接，一旦有客户端连接会返回一个Socket对象</span><br>        <span class="hljs-keyword">while</span>(ture)&#123;<br>              Socket socket=ss.accept();<br>            System.out.println(<span class="hljs-string">&quot;一个客户端上线了：&quot;</span>socket.getInetAddress().getHostAddress())<br>            <span class="hljs-comment">//把客户端管道交给一个子线程来处理</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReader</span>(socket).start();<br>        &#125;<br>       &#125;<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerReader</span><span class="hljs-params">(Socket socket)</span>&#123;<br>        <span class="hljs-built_in">this</span>.socket=socket;<br>    &#125;<br>    <span class="hljs-meta">@Override</span> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">try</span>&#123;<br>          <span class="hljs-comment">//读取该管道的消息</span><br>        InputStream is=socket.getInputStream();<br>        DataIuputStream dis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataIntputStream</span>(is);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            String msg=dis.readUTF();<br>             System.out.println(<span class="hljs-string">&quot;收到的客户端msg:&quot;</span>+msg);<br>        System.out.println(<span class="hljs-string">&quot;获取客户端的ip地址：&quot;</span>+socket.getInetAddress().getHostAddress());<br>        System.out.println(<span class="hljs-string">&quot;获取客户端的端口号：&quot;</span>+socket.getPort());<br>           System.out.println(<span class="hljs-string">&quot;------------------&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;一个客户端下线了：&quot;</span>socket.getInetAddress.getHostAddress());<br>        &#125; <br>       &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h4 id="15-5-WebSocket"><a href="#15-5-WebSocket" class="headerlink" title="15.5.WebSocket"></a>15.5.WebSocket</h4><ul>
<li>B&#x2F;S案例-maven引入坐标，注解实现</li>
</ul>
<blockquote>
<p>浏览器端html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs html">&gt;<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>WebSocket Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;send()&quot;</span>&gt;</span>发送消息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;closeWebSocket()&quot;</span>&gt;</span>关闭连接<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-keyword">var</span> websocket = <span class="hljs-literal">null</span>;</span><br><span class="language-javascript">   <span class="hljs-keyword">var</span> clientId = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>().<span class="hljs-title function_">toString</span>(<span class="hljs-number">36</span>).<span class="hljs-title function_">substr</span>(<span class="hljs-number">2</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//判断当前浏览器是否支持WebSocket</span></span><br><span class="language-javascript">   <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;WebSocket&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-comment">//连接WebSocket节点</span></span><br><span class="language-javascript">       websocket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;ws://localhost:8080/ws/&quot;</span>+clientId);</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">   <span class="hljs-keyword">else</span>&#123;</span><br><span class="language-javascript">       <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Not support websocket&#x27;</span>)</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//连接发生错误的回调方法</span></span><br><span class="language-javascript">   websocket.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-title function_">setMessageInnerHTML</span>(<span class="hljs-string">&quot;error&quot;</span>);</span><br><span class="language-javascript">   &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//连接成功建立的回调方法</span></span><br><span class="language-javascript">   websocket.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-title function_">setMessageInnerHTML</span>(<span class="hljs-string">&quot;连接成功&quot;</span>);</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//接收到消息的回调方法</span></span><br><span class="language-javascript">   websocket.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-title function_">setMessageInnerHTML</span>(event.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//连接关闭的回调方法</span></span><br><span class="language-javascript">   websocket.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-title function_">setMessageInnerHTML</span>(<span class="hljs-string">&quot;close&quot;</span>);</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。</span></span><br><span class="language-javascript">   <span class="hljs-variable language_">window</span>.<span class="hljs-property">onbeforeunload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">       websocket.<span class="hljs-title function_">close</span>();</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//将消息显示在网页上</span></span><br><span class="language-javascript">   <span class="hljs-keyword">function</span> <span class="hljs-title function_">setMessageInnerHTML</span>(<span class="hljs-params">innerHTML</span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;message&#x27;</span>).<span class="hljs-property">innerHTML</span> += innerHTML + <span class="hljs-string">&#x27;&lt;br/&gt;&#x27;</span>;</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">//发送消息</span></span><br><span class="language-javascript">   <span class="hljs-keyword">function</span> <span class="hljs-title function_">send</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-keyword">var</span> message = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;text&#x27;</span>).<span class="hljs-property">value</span>;</span><br><span class="language-javascript">       websocket.<span class="hljs-title function_">send</span>(message);</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//关闭连接</span></span><br><span class="language-javascript">   <span class="hljs-keyword">function</span> <span class="hljs-title function_">closeWebSocket</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">       websocket.<span class="hljs-title function_">close</span>();</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<ul>
<li>ws协议</li>
</ul>
</blockquote>
<blockquote>
<p>服务器端</p>
<p>配置类注册WebSocket的Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">/**</span><br><span class="hljs-comment">* WebSocket配置类，用于注册WebSocket的Bean</span><br><span class="hljs-comment">*/</span><br>&gt;<span class="hljs-meta">@Configuration</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketConfiguration</span> &#123;<br><br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-keyword">public</span> ServerEndpointExporter <span class="hljs-title function_">serverEndpointExporter</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerEndpointExporter</span>();<br>   &#125;<br><br>&gt;&#125;<br></code></pre></td></tr></table></figure>

<p>WebSocket服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">/**</span><br><span class="hljs-comment">* WebSocket服务</span><br><span class="hljs-comment">*/</span><br>&gt;<span class="hljs-meta">@Component</span><br>&gt;<span class="hljs-meta">@ServerEndpoint(&quot;/ws/&#123;sid&#125;&quot;)</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketServer</span> &#123;<br><br>   <span class="hljs-comment">//存放会话对象</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Session&gt; sessionMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 连接建立成功调用的方法</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@OnOpen</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onOpen</span><span class="hljs-params">(Session session, <span class="hljs-meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;客户端：&quot;</span> + sid + <span class="hljs-string">&quot;建立连接&quot;</span>);<br>       sessionMap.put(sid, session);<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 收到客户端消息后调用的方法</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> message 客户端发送过来的消息</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@OnMessage</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String message, <span class="hljs-meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;收到来自客户端：&quot;</span> + sid + <span class="hljs-string">&quot;的信息:&quot;</span> + message);<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 连接关闭调用的方法</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> sid</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@OnClose</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClose</span><span class="hljs-params">(<span class="hljs-meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;连接断开:&quot;</span> + sid);<br>       sessionMap.remove(sid);<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 群发</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> message</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendToAllClient</span><span class="hljs-params">(String message)</span> &#123;<br>       Collection&lt;Session&gt; sessions = sessionMap.values();<br>       <span class="hljs-keyword">for</span> (Session session : sessions) &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-comment">//服务器向客户端发送消息</span><br>               session.getBasicRemote().sendText(message);<br>           &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>               e.printStackTrace();<br>           &#125;<br>       &#125;<br>   &#125;<br><br>&gt;&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h2 id="16-JDBC"><a href="#16-JDBC" class="headerlink" title="16.JDBC"></a>16.JDBC</h2><ul>
<li><p>JDBC:java语言操作关系型数据库的一套API</p>
</li>
<li><p>入门程序</p>
<p><img src="/.com//image-20250227155911896.png" srcset="/img/loading.gif" lazyload alt="image-20250227155911896"></p>
</li>
</ul>
<h3 id="1-JDBC-工作原理"><a href="#1-JDBC-工作原理" class="headerlink" title="1. JDBC 工作原理"></a>1. JDBC 工作原理</h3><ul>
<li><strong>加载驱动程序</strong>：Java 程序通过 <code>Class.forName()</code> 方法加载数据库的驱动程序，不同的数据库有不同的驱动类。</li>
<li><strong>建立连接</strong>：使用 <code>DriverManager.getConnection()</code> 方法与数据库建立连接，需要提供数据库的 URL、用户名和密码。</li>
<li><strong>创建语句对象</strong>：通过连接对象创建 <code>Statement</code>、<code>PreparedStatement</code> 或 <code>CallableStatement</code> 对象，用于执行 SQL 语句。</li>
<li><strong>执行 SQL 语句</strong>：使用语句对象执行 SQL 语句，如查询、插入、更新或删除操作。</li>
<li><strong>处理结果集</strong>：如果执行的是查询语句，会返回一个 <code>ResultSet</code> 对象，用于处理查询结果。</li>
<li><strong>关闭资源</strong>：使用完数据库连接、语句对象和结果集后，需要关闭它们以释放资源。</li>
</ul>
<h3 id="2-JDBC-编程步骤及示例（以-MySQL-数据库为例）"><a href="#2-JDBC-编程步骤及示例（以-MySQL-数据库为例）" class="headerlink" title="2. JDBC 编程步骤及示例（以 MySQL 数据库为例）"></a>2. JDBC 编程步骤及示例（以 MySQL 数据库为例）</h3><h4 id="2-1-导入-JDBC-驱动依赖"><a href="#2-1-导入-JDBC-驱动依赖" class="headerlink" title="2.1 导入 JDBC 驱动依赖"></a>2.1 导入 JDBC 驱动依赖</h4><p>如果你使用的是 Maven 项目，可以在 <code>pom.xml</code> 中添加以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.26<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="2-2-编写-Java-代码"><a href="#2-2-编写-Java-代码" class="headerlink" title="2.2 编写 Java 代码"></a>2.2 编写 Java 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.Statement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 数据库连接信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/your_database_name&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;your_username&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;your_password&quot;</span>;<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1. 加载驱动程序</span><br>            Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br><br>            <span class="hljs-comment">// 2. 建立连接</span><br>            connection = DriverManager.getConnection(url, username, password);<br><br>            <span class="hljs-comment">// 3. 创建语句对象</span><br>            statement = connection.createStatement();<br><br>            <span class="hljs-comment">// 4. 执行 SQL 语句</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SELECT * FROM your_table_name&quot;</span>;<br>            resultSet = statement.executeQuery(sql);<br><br>            <span class="hljs-comment">// 5. 处理结果集</span><br>            <span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>                <span class="hljs-comment">// 假设表中有 id 和 name 两列</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> resultSet.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;ID: &quot;</span> + id + <span class="hljs-string">&quot;, Name: &quot;</span> + name);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 6. 关闭资源</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (resultSet != <span class="hljs-literal">null</span>) resultSet.close();<br>                <span class="hljs-keyword">if</span> (statement != <span class="hljs-literal">null</span>) statement.close();<br>                <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) connection.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/.com//image-20250227161039549.png" srcset="/img/loading.gif" lazyload alt="image-20250227161039549"></p>
<h3 id="3-PreparedStatement-的使用"><a href="#3-PreparedStatement-的使用" class="headerlink" title="3. PreparedStatement 的使用"></a>3. <code>PreparedStatement</code> 的使用</h3><p><code>PreparedStatement</code> 是 <code>Statement</code> 的子接口，它可以预编译 SQL 语句，提高执行效率，同时可以防止 SQL 注入攻击。</p>
<ul>
<li>SQL注入：通过控制修改事先定义好的SQL语句，以达到执行代码对服务器进行攻击的方法。</li>
<li><img src="/.com//image-20250227161841918.png" srcset="/img/loading.gif" lazyload alt="image-20250227161841918"></li>
<li><strong>什么是 SQL 预编译？</strong><ul>
<li><strong>定义</strong>：将 SQL 语句模板发送给数据库服务器编译，后续执行时只需传入参数，无需重复编译。</li>
<li><strong>核心思想</strong>：**”一次编译，多次执行”**。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PreparedStatementExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/your_database_name&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;your_username&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;your_password&quot;</span>;<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>            connection = DriverManager.getConnection(url, username, password);<br><br>            <span class="hljs-comment">// 预编译 SQL 语句</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SELECT * FROM your_table_name WHERE id = ?&quot;</span>;<br>            preparedStatement = connection.prepareStatement(sql);<br><br>            <span class="hljs-comment">// 设置参数</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            preparedStatement.setInt(<span class="hljs-number">1</span>, id);<br><br>            <span class="hljs-comment">// 执行查询</span><br>            resultSet = preparedStatement.executeQuery();<br><br>            <span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">resultId</span> <span class="hljs-operator">=</span> resultSet.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;ID: &quot;</span> + resultId + <span class="hljs-string">&quot;, Name: &quot;</span> + name);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (resultSet != <span class="hljs-literal">null</span>) resultSet.close();<br>                <span class="hljs-keyword">if</span> (preparedStatement != <span class="hljs-literal">null</span>) preparedStatement.close();<br>                <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) connection.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-执行更新操作"><a href="#4-执行更新操作" class="headerlink" title="4. 执行更新操作"></a>4. 执行更新操作</h3><p>除了查询操作，JDBC 还可以执行插入、更新和删除等更新操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/your_database_name&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;your_username&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;your_password&quot;</span>;<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>            connection = DriverManager.getConnection(url, username, password);<br><br>            <span class="hljs-comment">// 插入数据</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">insertSql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;INSERT INTO your_table_name (name, age) VALUES (?, ?)&quot;</span>;<br>            preparedStatement = connection.prepareStatement(insertSql);<br>            preparedStatement.setString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;John&quot;</span>);<br>            preparedStatement.setInt(<span class="hljs-number">2</span>, <span class="hljs-number">25</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowsInserted</span> <span class="hljs-operator">=</span> preparedStatement.executeUpdate();<br>            System.out.println(<span class="hljs-string">&quot;插入的行数: &quot;</span> + rowsInserted);<br><br>            <span class="hljs-comment">// 更新数据</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">updateSql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;UPDATE your_table_name SET age = ? WHERE name = ?&quot;</span>;<br>            preparedStatement = connection.prepareStatement(updateSql);<br>            preparedStatement.setInt(<span class="hljs-number">1</span>, <span class="hljs-number">26</span>);<br>            preparedStatement.setString(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;John&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowsUpdated</span> <span class="hljs-operator">=</span> preparedStatement.executeUpdate();<br>            System.out.println(<span class="hljs-string">&quot;更新的行数: &quot;</span> + rowsUpdated);<br><br>            <span class="hljs-comment">// 删除数据</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">deleteSql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;DELETE FROM your_table_name WHERE name = ?&quot;</span>;<br>            preparedStatement = connection.prepareStatement(deleteSql);<br>            preparedStatement.setString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;John&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowsDeleted</span> <span class="hljs-operator">=</span> preparedStatement.executeUpdate();<br>            System.out.println(<span class="hljs-string">&quot;删除的行数: &quot;</span> + rowsDeleted);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (preparedStatement != <span class="hljs-literal">null</span>) preparedStatement.close();<br>                <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) connection.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="17-反射与注解"><a href="#17-反射与注解" class="headerlink" title="17.反射与注解"></a>17.反射与注解</h2><h3 id="1-反射"><a href="#1-反射" class="headerlink" title="1.反射"></a>1.反射</h3><ul>
<li>反射：加载类，并且允许以编程的方式操作类的各种成分（成员变量、方法、构造器等）</li>
</ul>
<p><img src="/.com//image-20250331142402456.png" srcset="/img/loading.gif" lazyload alt="image-20250331142402456"></p>
<blockquote>
<p>先获取Class对象再获取类的构造器方法等等</p>
</blockquote>
<h4 id="1-获取Class对象-字节码类"><a href="#1-获取Class对象-字节码类" class="headerlink" title="1.获取Class对象-字节码类"></a>1.获取Class对象-字节码类</h4><p><img src="/.com//image-20250331142631910.png" srcset="/img/loading.gif" lazyload alt="image-20250331142631910"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方式一</span><br>Class c1=Student.class;<br>System.out.println(c1.getName());<span class="hljs-comment">//全类名(包括包路径)</span><br>System.out.println(c1.getSimpleName());<span class="hljs-comment">//类名Student</span><br><br><span class="hljs-comment">//方式二：</span><br>Class c2=Class.forName(<span class="hljs-string">&quot;全类名&quot;</span>);<br><br><span class="hljs-comment">//方式三：</span><br>Student stu=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>Class c3=stu.getClass()<br></code></pre></td></tr></table></figure>

<h4 id="2-通过Class对象获取构造器"><a href="#2-通过Class对象获取构造器" class="headerlink" title="2.通过Class对象获取构造器"></a>2.通过Class对象获取构造器</h4><p><img src="/.com//image-20250331143300867.png" srcset="/img/loading.gif" lazyload alt="image-20250331143300867"></p>
<p><img src="/.com//image-20250331143819924.png" srcset="/img/loading.gif" lazyload alt="image-20250331143819924"></p>
<h4 id="3-通过Class对象获取类属性"><a href="#3-通过Class对象获取类属性" class="headerlink" title="3.通过Class对象获取类属性"></a>3.通过Class对象获取类属性</h4><p><img src="/.com//image-20250331143959390.png" srcset="/img/loading.gif" lazyload alt="image-20250331143959390"></p>
<h4 id="4-通过Class对象调用类方法"><a href="#4-通过Class对象调用类方法" class="headerlink" title="4.通过Class对象调用类方法"></a>4.通过Class对象调用类方法</h4><p><img src="/.com//image-20250331144028471.png" srcset="/img/loading.gif" lazyload alt="image-20250331144028471"></p>
<p><img src="/.com//image-20250331144158882.png" srcset="/img/loading.gif" lazyload alt="image-20250331144158882"></p>
<h3 id="2-注解"><a href="#2-注解" class="headerlink" title="2.注解"></a>2.注解</h3><ul>
<li>注解是 Java 提供的一种元数据机制，它为程序的元素（类、方法、字段等）添加额外的信息，这些信息不会影响程序的编译和运行，但可以在编译时、运行时被读取和处理。</li>
</ul>
<h4 id="1-内置注解"><a href="#1-内置注解" class="headerlink" title="1.内置注解"></a>1.内置注解</h4><p><img src="/.com//image-20250331144633543.png" srcset="/img/loading.gif" lazyload alt="image-20250331144633543"></p>
<h4 id="2-元注解"><a href="#2-元注解" class="headerlink" title="2.元注解"></a>2.元注解</h4><p><img src="/.com//image-20250331145005267.png" srcset="/img/loading.gif" lazyload alt="image-20250331145005267"></p>
<p><em><strong>@Target(ElementType.XXX)</strong></em>:描述注解的作用范围</p>
<h3 id="ElementType-枚举类型"><a href="#ElementType-枚举类型" class="headerlink" title="ElementType 枚举类型"></a><code>ElementType</code> 枚举类型</h3><p><code>ElementType</code> 枚举类型包含以下常量：</p>
<ul>
<li><code>TYPE</code>：可应用于类、接口（包含注解类型）或者枚举声明。</li>
<li><code>FIELD</code>：可应用于字段声明，包含枚举常量。</li>
<li><code>METHOD</code>：可应用于方法声明。</li>
<li><code>PARAMETER</code>：可应用于参数声明。</li>
<li><code>CONSTRUCTOR</code>：可应用于构造函数声明。</li>
<li><code>LOCAL_VARIABLE</code>：可应用于局部变量声明。</li>
<li><code>ANNOTATION_TYPE</code>：可应用于注解类型声明。</li>
<li><code>PACKAGE</code>：可应用于包声明。</li>
<li><code>TYPE_PARAMETER</code>：可应用于类型参数声明（Java 8 新增）。</li>
<li><code>TYPE_USE</code>：可应用于任何使用类型的地方（Java 8 新增）。</li>
</ul>
<h4 id="3-自定义注解"><a href="#3-自定义注解" class="headerlink" title="3.自定义注解"></a>3.自定义注解</h4><p><img src="/.com//image-20250331145622188.png" srcset="/img/loading.gif" lazyload alt="image-20250331145622188"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testinterface</span>&#123;<br>    <span class="hljs-comment">//定义了参数就必须传入参数或者使用default声明默认值</span><br>    <span class="hljs-meta">@MyAnnotation(name=&quot;xxx&quot;)</span><br>    <span class="hljs-comment">//@MyAnnotation()</span><br>    <span class="hljs-comment">//@MyAnnotation(&quot;xxx&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br><span class="hljs-meta">@Target(&#123;ElementType.Type,ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> MyAnnotation&#123;<br>    <span class="hljs-comment">//注解的参数： 参数类型+参数名()；</span><br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// String name() default &quot;&quot;;</span><br>    <span class="hljs-comment">//String value();</span><br>    <span class="hljs-comment">//如果注解只有一个值，且用value表示的话，可以省略</span><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3.动态代理"></a>3.动态代理</h3><ul>
<li>通过反射创建代理对象</li>
</ul>
<p><img src="/.com//image-20250421172401690.png" srcset="/img/loading.gif" lazyload alt="image-20250421172401690"></p>
<ul>
<li><strong>实现对象的方法而不调用对象</strong><ul>
<li>定义接口-》指定方法</li>
<li>实现接口</li>
<li>创建代理对象</li>
</ul>
</li>
</ul>
<h4 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h4><ul>
<li><strong>原理</strong>：基于 Java 的反射机制，在运行时动态生成代理类，该代理类实现了目标对象所实现的<strong>接口</strong>。</li>
<li><strong>适用场景</strong>：适用于目标对象实现了接口的情况，常用于面向接口编程的场景。</li>
<li><strong>优点</strong>：Java 原生支持，无需额外依赖，性能较高。</li>
<li><strong>缺点</strong>：只能代理实现了接口的类，无法代理普通类。</li>
</ul>
<h4 id="CGLIB-代理"><a href="#CGLIB-代理" class="headerlink" title="CGLIB 代理"></a>CGLIB 代理</h4><ul>
<li><strong>原理</strong>：通过字节码生成库（如 CGLIB）在运行时动态生成目标类的<strong>子类</strong>作为代理类。</li>
<li><strong>适用场景</strong>：适用于目标对象没有实现接口的情况，或者需要对类的所有方法进行代理的场景。</li>
<li><strong>优点</strong>：可以代理普通类，灵活性高。</li>
<li><strong>缺点</strong>：需要额外依赖，创建代理对象的性能相对较低。</li>
</ul>
<h4 id="通过-AopContext-获取代理对象"><a href="#通过-AopContext-获取代理对象" class="headerlink" title="通过 AopContext 获取代理对象"></a>通过 <code>AopContext</code> 获取代理对象</h4><ul>
<li><strong>原理</strong>：在 Spring AOP 框架中，基于已经配置好的 AOP 切面和代理策略生成代理对象，通过 <code>AopContext</code> 工具类获取当前的代理对象。</li>
<li><strong>适用场景</strong>：用于解决 AOP 代理对象内部方法调用无法触发 AOP 增强的问题，通常在 Spring AOP 的复杂业务场景中使用。</li>
<li><strong>优点</strong>：可以让内部方法调用也触发 AOP 增强逻辑。</li>
<li><strong>缺点</strong>：需要开启暴露代理，会带来一定的性能开销。（引入aop依赖，启动类暴露代理）</li>
</ul>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><h4 id="JDK-动态代理示例"><a href="#JDK-动态代理示例" class="headerlink" title="JDK 动态代理示例"></a>JDK 动态代理示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-comment">// 定义接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 实现接口的目标类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;RealSubject: Handling request.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现 InvocationHandler 接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JdkProxyHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JdkProxyHandler</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;Before method call&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>        System.out.println(<span class="hljs-string">&quot;After method call&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdkDynamicProxyDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">RealSubject</span> <span class="hljs-variable">realSubject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSubject</span>();<br>        <span class="hljs-type">JdkProxyHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdkProxyHandler</span>(realSubject);<br>        <span class="hljs-type">Subject</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (Subject) Proxy.newProxyInstance(<br>                RealSubject.class.getClassLoader(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[]&#123;Subject.class&#125;,<br>                handler<br>        );<br>        proxy.request();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="CGLIB-代理示例"><a href="#CGLIB-代理示例" class="headerlink" title="CGLIB 代理示例"></a>CGLIB 代理示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">// 目标类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TargetClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;TargetClass: Doing something.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现 MethodInterceptor 接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;Before method call&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> proxy.invokeSuper(obj, args);<br>        System.out.println(<span class="hljs-string">&quot;After method call&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxyDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        enhancer.setSuperclass(TargetClass.class);<br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CglibProxyInterceptor</span>());<br>        <span class="hljs-type">TargetClass</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (TargetClass) enhancer.create();<br>        proxy.doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="通过-AopContext-获取代理对象示例"><a href="#通过-AopContext-获取代理对象示例" class="headerlink" title="通过 AopContext 获取代理对象示例"></a>通过 <code>AopContext</code> 获取代理对象示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.After;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.springframework.aop.framework.AopContext;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-comment">// 目标服务类</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Method A is called.&quot;</span>);<br>        <span class="hljs-type">MyService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (MyService) AopContext.currentProxy();<br>        proxy.methodB();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Method B is called.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 切面类</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.example.demo.MyService.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-meta">@Before(&quot;pointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Before method execution.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@After(&quot;pointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;After method execution.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 配置类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAspectJAutoProxy(exposeProxy = true)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyService <span class="hljs-title function_">myService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyService</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyAspect <span class="hljs-title function_">myAspect</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyAspect</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AopContextDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);<br>        <span class="hljs-type">MyService</span> <span class="hljs-variable">myService</span> <span class="hljs-operator">=</span> context.getBean(MyService.class);<br>        myService.methodA();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>以上示例代码分别展示了 JDK 动态代理、CGLIB 代理和通过 <code>AopContext</code> 获取代理对象的使用方法，你可以根据实际需求选择合适的代理方式。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div></div>
      <div>http://example.com/2025/07/02/java/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>xing</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年7月2日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/07/02/JVM/" title="">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/07/02/HttpClient/" title="">
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
